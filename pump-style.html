<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Wordle Wars - Skill Based 1v1 Wagers</title>
    <link rel="icon" type="image/png" href="transparent.png">
    
    <!-- Phantom Wallet Adapter -->
    <script src="https://unpkg.com/@solana/wallet-adapter-base@0.9.23/lib/index.iife.js"></script>
    <script src="https://unpkg.com/@solana/wallet-adapter-phantom@0.9.24/lib/index.iife.js"></script>
    <script src="https://unpkg.com/@solana/web3.js@1.87.6/lib/index.iife.js"></script>
    
    <!-- Socket.IO Client -->
    <script src="https://cdn.socket.io/4.7.2/socket.io.min.js"></script>
    
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            background: #1A1A1A;
            color: #FFFFFF;
            min-height: 100vh;
            overflow-x: hidden;
        }

        /* Sidebar */
        .sidebar {
            position: fixed;
            left: 0;
            top: 0;
            width: 250px;
            height: 100vh;
            background: #121212;
            padding: 20px;
            z-index: 1000;
        }

        .logo {
            font-size: 20px;
            font-weight: bold;
            color: #FFFFFF;
            margin-bottom: 40px;
            display: flex;
            align-items: center;
            justify-content: center;
            cursor: pointer;
            transition: transform 0.2s ease;
        }

        .logo:hover {
            transform: scale(1.05);
        }

        /* Completed Games Section */
        .completed-games {
            margin-top: 30px;
        }

        .completed-games-title {
            font-size: 16px;
            font-weight: bold;
            color: #FFFFFF;
            margin-bottom: 15px;
            text-align: center;
        }

        .completed-games-list {
            max-height: 300px;
            overflow-y: auto;
        }

        .game-result {
            background: #2A2A2A;
            border-radius: 8px;
            padding: 10px;
            margin-bottom: 8px;
            font-size: 12px;
            color: #FFFFFF;
            border-left: 3px solid #80FF80;
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .game-result-icon {
            width: 16px;
            height: 16px;
            opacity: 0.7;
        }

        .game-result.winner {
            border-left-color: #80FF80;
        }

        .game-result.loser {
            border-left-color: #FF6B35;
        }

        .game-wallet {
            font-weight: bold;
            color: #80FF80;
        }

        .game-amount {
            font-weight: bold;
            color: #FFD700;
        }

        .no-games {
            text-align: center;
            color: #666;
            font-style: italic;
            padding: 20px;
        }

        .logo-icon {
            width: 24px;
            height: 24px;
            background: #80FF80;
            border-radius: 4px;
            display: flex;
            align-items: center;
            justify-content: center;
            color: #000;
            font-weight: bold;
        }

        .logo-image {
            width: 180px;
            height: 90px;
            object-fit: contain;
        }

        .nav-menu {
            list-style: none;
        }

        .nav-item {
            margin-bottom: 20px;
        }

        .nav-link {
            color: #FFFFFF;
            text-decoration: none;
            font-size: 16px;
            padding: 10px 0;
            display: flex;
            align-items: center;
            gap: 10px;
            transition: color 0.2s ease;
        }

        .nav-link:hover {
            color: #80FF80;
        }

        .nav-link.active {
            color: #80FF80;
        }

        /* Main Content */
        .main-content {
            margin-left: 250px;
            margin-right: 260px;
            min-height: 100vh;
            background: #1A1A1A;
        }

        /* Header */
        .header {
            background: #20232B;
            padding: 20px 40px;
            display: flex;
            justify-content: center;
            align-items: center;
            position: relative;
        }

        .header-title {
            font-size: 28px;
            font-weight: bold;
            color: #FFFFFF;
            text-align: center;
        }

        .header-actions {
            display: flex;
            align-items: center;
            gap: 20px;
            position: absolute;
            right: 40px;
        }

        /* Connected wallets panel */
        .right-panel {
            position: fixed;
            right: 0;
            top: 0;
            width: 260px;
            height: 100vh;
            background: #121212;
            padding: 20px;
            border-left: 1px solid #2A2A2A;
            display: flex;
            flex-direction: column;
            gap: 12px;
        }
        .panel-title {
            font-size: 16px;
            font-weight: bold;
            color: #FFFFFF;
            margin-bottom: 12px;
            text-align: center;
        }
        .wallet-item {
            padding: 8px 10px;
            background: #1A1A1A;
            border: 1px solid #2A2A2A;
            border-radius: 6px;
            margin-bottom: 8px;
            color: #80FF80;
            font-size: 12px;
            word-break: break-all;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }
        .wallet-link {
            color: #FFD700;
            text-decoration: none;
            font-size: 11px;
            margin-left: 8px;
        }
        .wallet-link:hover { text-decoration: underline; }
        /* Connected wallets list area should scroll, search stays pinned */
        #walletsList {
            flex: 1;
            overflow-y: auto;
            padding-right: 6px; /* space for custom scrollbar */
        }
        .wallet-search { margin-top: 0; border-top: 1px solid #2A2A2A; padding-top: 10px; background: #121212; position: sticky; bottom: 0; }
        .wallet-search input { width: 100%; padding: 8px 10px; background:#1A1A1A; border:1px solid #2A2A2A; border-radius:6px; color:#fff; font-size:12px; }
        .wallet-search .hint { color:#888; font-size:11px; margin-top:6px; }
        .wallet-highlight { box-shadow: inset 0 0 0 2px #FFD700; background: #1F1F00; border-radius: 6px; }
        @keyframes walletFlash {
            0% { box-shadow: inset 0 0 0 0px #FFD700; }
            30% { box-shadow: inset 0 0 0 3px #FFD700; }
            100% { box-shadow: inset 0 0 0 2px #FFD700; }
        }
        .wallet-flash { animation: walletFlash 900ms ease-out; }

        /* Dark scrollbar theme */
        #walletsList::-webkit-scrollbar {
            width: 8px;
        }
        #walletsList::-webkit-scrollbar-track {
            background: #121212;
        }
        #walletsList::-webkit-scrollbar-thumb {
            background-color: #1F1F1F;
            border-radius: 6px;
            border: 1px solid #2A2A2A;
        }
        #walletsList::-webkit-scrollbar-thumb:hover {
            background-color: #2A2A2A;
        }
        /* Firefox */
        #walletsList {
            scrollbar-color: #1F1F1F #121212;
            scrollbar-width: thin;
        }

        .wallet-info {
            display: flex;
            flex-direction: column;
            align-items: flex-end;
            font-size: 14px;
        }

        .wallet-address {
            color: #80FF80;
            font-weight: 500;
        }

        .wallet-balance {
            color: #CCCCCC;
        }

        /* Buttons */
        .btn {
            padding: 12px 24px;
            border: none;
            border-radius: 8px;
            font-size: 14px;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.2s ease;
            text-decoration: none;
            display: inline-flex;
            align-items: center;
            gap: 8px;
        }

        .btn-primary {
            background: #80FF80;
            color: #000000;
        }

        .btn-primary:hover {
            background: #70EE70;
            transform: translateY(-1px);
        }

        .btn-secondary {
            background: #2A2A2A;
            color: #FFFFFF;
            border: 1px solid #404040;
        }
        
        .btn-secondary:hover {
            background: #1A1A1A;
        }

        .btn-danger {
            background: #FF4444;
            color: #FFFFFF;
        }

        .btn-danger:hover {
            background: #EE3333;
        }

        /* Content Area */
        .content {
            padding: 40px;
            max-width: 1200px;
            margin: 0 auto;
        }

        /* Game Sections */
        .game-section {
            background: #2A2A2A;
            border-radius: 12px;
            padding: 30px;
            margin-bottom: 30px;
            border: 1px solid #404040;
        }

        .section-title {
            font-size: 24px;
            font-weight: bold;
            margin-bottom: 20px;
            color: #FFFFFF;
        }

        .hidden {
            display: none !important;
        }

        /* Lobby */
        .wager-section {
            display: flex;
            align-items: center;
            gap: 20px;
            margin-bottom: 30px;
            padding: 20px;
            background: #1A1A1A;
            border-radius: 8px;
            border: 1px solid #404040;
        }

        .wager-section label {
            font-weight: 600;
            color: #FFFFFF;
        }

        .wager-section input {
            padding: 12px 16px;
            border: 1px solid #404040;
            border-radius: 8px;
            background: #1A1A1A;
            color: #FFFFFF;
            font-size: 16px;
            width: 120px;
        }

        .wager-section input:focus {
            outline: none;
            border-color: #80FF80;
        }

        .rules-box {
            background: #1A1A1A;
            border: 1px solid #404040;
            border-radius: 8px;
            padding: 20px;
            margin-bottom: 30px;
        }

        .rules-title {
            color: #80FF80;
            font-size: 18px;
            font-weight: bold;
            margin-bottom: 15px;
        }

        .rules-list {
            color: #CCCCCC;
            line-height: 1.6;
            text-align: left;
        }

        .rule-item {
            margin-bottom: 12px;
            padding-left: 20px;
            position: relative;
        }

        .rule-item:before {
            content: "•";
            color: #80FF80;
            font-weight: bold;
            position: absolute;
            left: 0;
        }

        /* Games List */
        .games-list {
            margin-top: 20px;
        }

        .game-item {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 20px;
            background: #1A1A1A;
            border: 1px solid #404040;
            border-radius: 8px;
            margin-bottom: 15px;
            transition: all 0.2s ease;
        }

        .game-item:hover {
            border-color: #80FF80;
            transform: translateY(-2px);
        }

        .game-info {
            display: flex;
            flex-direction: column;
        }

        .game-wager {
            font-weight: bold;
            color: #80FF80;
            font-size: 18px;
        }

        .game-players {
            color: #CCCCCC;
            font-size: 14px;
        }

        .game-creator {
            color: #80FF80;
            font-size: 12px;
            margin-top: 4px;
        }

        /* Game Room */
        .game-header {
            text-align: center;
            margin-bottom: 30px;
        }

        .game-stats {
            display: flex;
            justify-content: space-around;
            margin: 20px 0;
            padding: 20px;
            background: #1A1A1A;
            border-radius: 8px;
            border: 1px solid #404040;
        }

        .stat-item {
            text-align: center;
        }

        .stat-label {
            color: #CCCCCC;
            font-size: 14px;
            margin-bottom: 5px;
        }

        .stat-value {
            color: #80FF80;
            font-size: 18px;
            font-weight: bold;
        }

        .pot-display {
            text-align: center;
            margin: 20px 0;
            padding: 20px;
            background: #1A1A1A;
            border: 2px solid #80FF80;
            border-radius: 8px;
        }

        .pot-amount {
            font-size: 24px;
            font-weight: bold;
            color: #80FF80;
            margin-bottom: 10px;
        }

        .pot-rules {
            color: #CCCCCC;
            font-size: 14px;
        }

        /* Timer */
        .timer-section {
            text-align: center;
            margin: 30px 0;
        }

        .timer-display {
            font-size: 48px;
            font-weight: bold;
            color: #80FF80;
            margin-bottom: 10px;
            font-family: 'Courier New', monospace;
        }

        .timer-warning {
            color: #FF4444 !important;
            animation: pulse 1s infinite;
        }

        @keyframes pulse {
            0% { opacity: 1; }
            50% { opacity: 0.5; }
            100% { opacity: 1; }
        }

        .timer-label {
            color: #CCCCCC;
            font-size: 16px;
            text-transform: uppercase;
            letter-spacing: 1px;
        }

        /* Wordle Grid */
        .wordle-container {
            max-width: 400px;
            margin: 0 auto;
        }

        .wordle-grid {
            display: grid;
            grid-template-rows: repeat(6, 1fr);
            gap: 8px;
            margin: 30px 0;
        }

        .wordle-row {
            display: grid;
            grid-template-columns: repeat(5, 1fr);
            gap: 8px;
        }

        .wordle-cell {
            width: 60px;
            height: 60px;
            border: 2px solid #404040;
            border-radius: 8px;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 24px;
            font-weight: bold;
            background: #1A1A1A;
            color: #FFFFFF;
            transition: all 0.3s ease;
        }

        .wordle-cell.correct {
            background: #80FF80;
            color: #000000;
            border-color: #80FF80;
        }

        .wordle-cell.present {
            background: #FFD700;
            color: #000000;
            border-color: #FFD700;
        }

        .wordle-cell.absent {
            background: #404040;
            color: #FFFFFF;
            border-color: #404040;
        }

        /* Input Section */
        .input-section {
            display: flex;
            gap: 15px;
            margin: 30px 0;
            justify-content: center;
        }

        .word-input {
            padding: 15px 20px;
            border: 2px solid #404040;
            border-radius: 8px;
            background: #1A1A1A;
            color: #FFFFFF;
            font-size: 18px;
            text-align: center;
            text-transform: uppercase;
            letter-spacing: 2px;
            width: 250px;
        }

        .word-input:focus {
            outline: none;
            border-color: #80FF80;
        }

        /* Game Over */
        .result {
            text-align: center;
            padding: 30px;
            border-radius: 12px;
            margin: 30px 0;
        }

        .result.win {
            background: rgba(128, 255, 128, 0.1);
            border: 2px solid #80FF80;
        }

        .result.lose {
            background: rgba(255, 68, 68, 0.1);
            border: 2px solid #FF4444;
        }

        .result h2 {
            font-size: 28px;
            margin-bottom: 15px;
        }

        .result.win h2 {
            color: #80FF80;
        }

        .result.lose h2 {
            color: #FF4444;
        }

        .result-message {
            color: #CCCCCC;
            line-height: 1.6;
            font-size: 16px;
        }


        /* Responsive */
        @media (max-width: 768px) {
            .sidebar {
                width: 200px;
            }
            
            .main-content {
                margin-left: 200px;
            }
            
            .content {
                padding: 20px;
            }
            
            .header {
                padding: 15px 20px;
            }
            
            .wager-section {
                flex-direction: column;
                align-items: stretch;
            }
            
            .game-stats {
                flex-direction: column;
                gap: 15px;
            }
            
            .input-section {
                flex-direction: column;
                align-items: center;
            }
            
            .word-input {
                width: 100%;
                max-width: 300px;
            }
        }
    </style>
</head>
<body>

    <!-- Sidebar -->
    <div class="sidebar">
        <div class="logo" onclick="showScreen('lobby')">
            <img src="logowithtext.png" alt="Wordle Wars" class="logo-image">
        </div>
        
        <!-- Completed Games Section -->
        <div class="completed-games">
            <h3 class="completed-games-title">Recent Games</h3>
            <div class="completed-games-list" id="completedGamesList">
                <div class="no-games">No completed games yet</div>
            </div>
        </div>
    </div>
    
    <!-- Right panel: connected wallets -->
    <div class="right-panel">
        <div class="panel-title">Connected Wallets</div>
        <div id="walletsList"><div class="wallet-item">None</div></div>
        <div class="wallet-search">
            <input type="text" id="walletSearch" placeholder="Paste full wallet address to verify">
        </div>
    </div>

    <!-- Main Content -->
    <div class="main-content">
        <!-- Header -->
        <div class="header">
            <div class="header-title">Skill Based 1v1 Wagers. Winner Takes All.</div>
            <div class="header-actions">
                <div class="wallet-info">
                    <div class="wallet-address" id="walletAddress">Not Connected</div>
                    <div class="wallet-balance" id="walletBalance">0.0000 SOL</div>
                </div>
                <button class="btn btn-primary" id="connectBtn" onclick="connectWallet()">Connect Wallet</button>
                <button class="btn btn-secondary" id="getDevnetSol" onclick="getDevnetSol()" style="display: none;">Get Devnet SOL</button>
                
                <button class="btn btn-secondary" id="disconnectBtn" onclick="disconnectWallet()" style="display: none;">Disconnect</button>
            </div>
        </div>

        <!-- Content -->
        <div class="content">
            <!-- Lobby -->
            <div class="game-section" id="lobby">
                <h2 class="section-title">Game Lobby</h2>
                
                <div class="rules-box">
                    <div class="rules-title">How to Play</div>
                <div class="rules-list">
                    <div class="rule-item">First to guess the 5-letter word wins</div>
                    <div class="rule-item">If you run out of 6 guesses or 5 minutes, you lose</div>
                    <div class="rule-item">Winner takes all!</div>
                    <div class="rule-item">Minimum bet: 0.022 SOL | Maximum bet: 10 SOL</div>
                </div>
                </div>
                
                <div class="wager-section">
                    <label>Wager Amount (SOL):</label>
                    <input type="number" id="wagerAmount" min="0.022" step="0.001" value="0.1">
                    <button class="btn btn-primary" onclick="createGame()">Create Game</button>
                </div>
                
                <!-- Quick forfeit section removed - users go directly to game room -->
                
                <!-- Active game section removed - users go directly to game room -->
                
                
                <div id="lobbyErrorMessage" style="display: none; color: #FF4444; text-align: center; margin-top: 10px; padding: 10px; background: rgba(255, 68, 68, 0.1); border: 1px solid #FF4444; border-radius: 5px;"></div>
                
                <div class="games-list">
                    <h3>Available Games</h3>
                    <div id="gamesList">
                        <p style="color: #CCCCCC; text-align: center; padding: 20px;">No games available. Create one!</p>
                    </div>
                </div>
            </div>

            <!-- Game Room -->
            <div class="game-section hidden" id="gameRoom">
                <div class="game-header">
                    <h2 class="section-title">Game Room</h2>
                    <div class="game-stats">
                        <div class="stat-item">
                            <div class="stat-label">Wager</div>
                            <div class="stat-value" id="gameWager">0.1 SOL</div>
                        </div>
                        <div class="stat-item">
                            <div class="stat-label">Players</div>
                            <div class="stat-value" id="playerCount">1/2</div>
                        </div>
                        <div class="stat-item">
                            <div class="stat-label">Status</div>
                            <div class="stat-value" id="gameStatus">Waiting...</div>
                        </div>
                    </div>
                </div>
                
                <div class="pot-display">
                    <div class="pot-amount">Winner Takes All: <span id="totalPot">0.2</span> SOL</div>
                    <div class="pot-rules">Winner takes all!</div>
                </div>
                
                <div class="timer-section">
                    <div class="timer-display" id="timer">5:00</div>
                    <div class="timer-label">Time Remaining</div>
                </div>
                
                <div class="wordle-container">
                    <div class="wordle-grid" id="wordleGrid">
                        <!-- Grid will be generated -->
                    </div>
                    
                    <div class="input-section">
                        <input type="text" class="word-input" id="wordInput" maxlength="5" placeholder="Enter 5-letter word">
                        <button class="btn btn-primary" onclick="submitGuess()" id="submitBtn">Submit</button>
                    </div>
                    
                    <div id="errorMessage" style="display: none; color: #FF4444; text-align: center; margin-top: 10px; padding: 10px; background: rgba(255, 68, 68, 0.1); border: 1px solid #FF4444; border-radius: 5px;"></div>
                </div>
                
                <div style="text-align: center; margin-top: 30px;">
                    <button class="btn btn-danger" onclick="forfeitGame()" id="forfeitGameBtn">Forfeit Game</button>
                </div>
            </div>

            <!-- Game Over -->
            <div class="game-section hidden" id="gameOver">
                <div class="result" id="gameResult">
                    <h2 id="resultTitle">Game Over</h2>
                    <div class="result-message" id="resultMessage">The game has ended.</div>
                </div>
                
                <div style="text-align: center;">
                    <button class="btn btn-primary" onclick="backToLobby()" id="backToLobbyBtn">Back to Home</button>
                </div>
            </div>
        </div>
    </div>

        <script>
        
        // Game State
        let gameState = {
            currentScreen: 'lobby',
            wallet: null,
            walletAddress: null,
            balance: 0,
            currentGame: null,
            timeLeft: 300,
            timer: null,
            word: '',
            guesses: [],
            gameOver: false,
            isPlayer1: false,
            playerResult: null,
            opponentResult: null
        };
        
        // Server connection
        const SERVER_URL = 'https://wordle-wars-production.up.railway.app';
        let socket = null;
        
        // Available games (from server)
        let availableGames = [];
        
        // Word list
        const words = ['APPLE', 'BRAIN', 'CHAIR', 'DANCE', 'EARTH', 'FROST', 'GHOST', 'HEART', 'IGLOO', 'JUICE', 'KNIFE', 'LIGHT', 'MAGIC', 'NIGHT', 'OCEAN', 'POWER'];
        
        // Initialize
        document.addEventListener('DOMContentLoaded', function() {

            generateWordleGrid();
            loadGameState(); // Load any saved game state first
            checkActiveGame();
            checkWalletConnection(); // Check if wallet is already connected
            // Always connect socket so everyone sees connected wallets and game updates
            try { if (!socket) { connectToServer(); } } catch(e){}
            // Initial connected wallets from server
            fetch(`${SERVER_URL}/api/wallets`).then(r=>r.json()).then((wallets)=>{
                const finalList = mergeWalletsWithUser(wallets || []);
                window.renderConnectedWallets(finalList);
            }).catch(()=>{});
            const search = document.getElementById('walletSearch');
            if (search) {
                const performSearch = () => {
                    const list = document.getElementById('walletsList');
                    if (!list) return;
                    const val = search.value.trim().toLowerCase();
                    let firstMatch = null;

                    Array.from(list.children).forEach(child => {
                        child.classList.remove('wallet-highlight');
                        if (!val) return;

                        const span = child.querySelector('span');
                        const link = child.querySelector('a');
                        const displayText = (span?.textContent || '').toLowerCase();
                        const displayPrefix = displayText.substring(0, 8);
                        const fullAddress = (link?.href?.split('/')?.pop() || '').toLowerCase();

                        // Multiple matching strategies
                        const matchesFull = fullAddress.includes(val);
                        const matchesPrefix = displayPrefix.includes(val.substring(0,8));
                        const matchesDisplay = displayText.includes(val);

                        if (matchesFull || matchesPrefix || matchesDisplay) {
                            child.classList.add('wallet-highlight');
                            if (!firstMatch) firstMatch = child;
                        }
                    });
                    if (firstMatch) {
                        // Center the match in the viewport and flash it
                        const childTop = firstMatch.offsetTop;
                        const targetTop = Math.max(childTop - (list.clientHeight - firstMatch.clientHeight) / 2, 0);
                        list.scrollTo({ top: targetTop, behavior: 'smooth' });
                        firstMatch.classList.add('wallet-flash');
                        setTimeout(() => firstMatch.classList.remove('wallet-flash'), 1000);
                    }
                };
                search.addEventListener('input', performSearch);
                search.addEventListener('paste', () => setTimeout(performSearch, 0));
                search.addEventListener('keydown', (e) => { if (e.key === 'Enter') performSearch(); });
            }
        });
        
        // Screen Management
        function showScreen(screenName) {
            
            // Prevent navigation away from active games
            if (gameState.currentGame && !gameState.gameOver && screenName === 'lobby') {
                showError('Cannot leave active game! You must forfeit to end the game.', 'gameRoom');
                return;
            }
            
            document.getElementById('lobby').classList.add('hidden');
            document.getElementById('gameRoom').classList.add('hidden');
            document.getElementById('gameOver').classList.add('hidden');
            
            // Clear any error messages when switching screens
            clearError('lobby');
            clearError('game');
            
            document.getElementById(screenName).classList.remove('hidden');
            gameState.currentScreen = screenName;
            
        }
        
        // Check if wallet is already connected on page load (trust-only reconnect)
        async function checkWalletConnection() {
            try {
                const provider = getProvider();
                
                if (!provider) return;

                // Use Phantom trust-only reconnect to restore silently after refresh
                try {
                    if (provider.connect) {
                        await provider.connect({ onlyIfTrusted: true });
                    }
                } catch (_) {}

                const connected = (provider.isConnected && provider.isConnected()) || !!provider.publicKey;
                const publicKey = provider.publicKey?.toString();
                if (!connected || !publicKey) return;

                // Update game state
                gameState.wallet = 'phantom';
                gameState.walletAddress = publicKey;
                gameState.balance = await getWalletBalance(publicKey);
                
                // Update UI
                const walletAddressEl = document.getElementById('walletAddress');
                const walletBalanceEl = document.getElementById('walletBalance');
                const connectBtnEl = document.getElementById('connectBtn');
                const disconnectBtnEl = document.getElementById('disconnectBtn');
                
                if (walletAddressEl) {
                    walletAddressEl.textContent = `${publicKey.slice(0, 8)}...${publicKey.slice(-4)}`;
                }
                
                if (walletBalanceEl) {
                    walletBalanceEl.textContent = `${gameState.balance.toFixed(4)} SOL`;
                }
                
                if (connectBtnEl) {
                    connectBtnEl.style.display = 'none';
                }
                
                if (disconnectBtnEl) {
                    disconnectBtnEl.style.display = 'inline-block';
                }
                
                // Connect to server and register
                connectToServer();
                setTimeout(() => { if (socket) { try { socket.emit('registerWallet', publicKey); } catch(e){} } }, 300);
            } catch (error) {
            }
        }

        // Keep UI in sync with Phantom events
        (function attachWalletListeners(){
            try {
                const provider = getProvider();
                if (!provider) return;
                if (provider._ww_listenersAttached) return; // idempotent
                provider._ww_listenersAttached = true;

                provider.on && provider.on('connect', (pubKey) => {
                    const publicKey = (pubKey?.toString?.() || provider.publicKey?.toString?.() || '').toString();
                    if (!publicKey) return;
                    gameState.wallet = 'phantom';
                    gameState.walletAddress = publicKey;
                    // Update UI quickly; balance fetched async
                    const walletAddressEl = document.getElementById('walletAddress');
                    if (walletAddressEl) walletAddressEl.textContent = `${publicKey.slice(0, 8)}...${publicKey.slice(-4)}`;
                    const connectBtnEl = document.getElementById('connectBtn');
                    const disconnectBtnEl = document.getElementById('disconnectBtn');
                    if (connectBtnEl) connectBtnEl.style.display = 'none';
                    if (disconnectBtnEl) disconnectBtnEl.style.display = 'inline-block';
                    // Register with server
                    if (socket) { try { socket.emit('registerWallet', publicKey); } catch(e){} }
                    // Fetch balance in background
                    getWalletBalance(publicKey).then(bal => {
                        gameState.balance = bal;
                        const walletBalanceEl = document.getElementById('walletBalance');
                        if (walletBalanceEl) walletBalanceEl.textContent = `${bal.toFixed(4)} SOL`;
                    }).catch(()=>{});
                });

                provider.on && provider.on('disconnect', () => {
                    gameState.wallet = null;
                    gameState.walletAddress = null;
                    gameState.balance = 0;
                    const walletAddressEl = document.getElementById('walletAddress');
                    const walletBalanceEl = document.getElementById('walletBalance');
                    const connectBtnEl = document.getElementById('connectBtn');
                    const disconnectBtnEl = document.getElementById('disconnectBtn');
                    if (walletAddressEl) walletAddressEl.textContent = 'Not Connected';
                    if (walletBalanceEl) walletBalanceEl.textContent = '0.0000 SOL';
                    if (connectBtnEl) connectBtnEl.style.display = 'inline-block';
                    if (disconnectBtnEl) disconnectBtnEl.style.display = 'none';
                });

                provider.on && provider.on('accountChanged', (pubKey) => {
                    const publicKey = (pubKey?.toString?.() || provider.publicKey?.toString?.() || '').toString();
                    if (!publicKey) {
                        // treated as disconnect
                        if (typeof disconnectWallet === 'function') disconnectWallet();
                        return;
                    }
                    gameState.walletAddress = publicKey;
                    const walletAddressEl = document.getElementById('walletAddress');
                    if (walletAddressEl) walletAddressEl.textContent = `${publicKey.slice(0, 8)}...${publicKey.slice(-4)}`;
                    if (socket) { try { socket.emit('registerWallet', publicKey); } catch(e){} }
                    getWalletBalance(publicKey).then(bal => {
                        gameState.balance = bal;
                        const walletBalanceEl = document.getElementById('walletBalance');
                        if (walletBalanceEl) walletBalanceEl.textContent = `${bal.toFixed(4)} SOL`;
                    }).catch(()=>{});
                });
            } catch(_) {}
        })();

        function mergeWalletsWithUser(list) {
            try {
                const set = new Set(Array.isArray(list) ? list : []);
                if (gameState.walletAddress) set.add(gameState.walletAddress);
                return Array.from(set);
            } catch(_) { return Array.isArray(list) ? list : []; }
        }

        // Global renderer for connected wallets (used by both socket and initial load)
        window.renderConnectedWallets = function(wallets) {
            try {
                const list = document.getElementById('walletsList');
                if (!list) { return; }
                list.innerHTML = '';
                if (!wallets || wallets.length === 0) {
                    list.innerHTML = '<div class="wallet-item">None</div>';
                    return;
                }
                wallets.forEach(w => {
                    const item = document.createElement('div');
                    item.className = 'wallet-item';
                    const left = document.createElement('span');
                    left.textContent = w.slice(0, 8) + '...' + w.slice(-4);
                    const link = document.createElement('a');
                    link.href = `https://solscan.io/account/${w}`;
                    link.target = '_blank';
                    link.rel = 'noopener noreferrer';
                    link.className = 'wallet-link';
                    link.textContent = 'Solscan';
                    item.appendChild(left);
                    item.appendChild(link);
                    list.appendChild(item);
                });

                // Re-apply highlight and scroll after every render
                const input = document.getElementById('walletSearch');
                if (input && input.value) {
                    const val = input.value.trim().toLowerCase();
                    let firstMatch = null;
                    Array.from(list.children).forEach((child, index) => {
                        child.classList.remove('wallet-highlight');
                        const span = child.querySelector('span');
                        const link = child.querySelector('a');
                        const displayText = (span?.textContent || '').toLowerCase();
                        const displayPrefix = displayText.substring(0, 8);
                        const fullAddress = (link?.href?.split('/')?.pop() || '').toLowerCase();
                        const matchesFull = fullAddress.includes(val);
                        const matchesPrefix = displayPrefix.includes(val.substring(0,8));
                        const matchesDisplay = displayText.includes(val);
                        if (matchesFull || matchesPrefix || matchesDisplay) {
                            child.classList.add('wallet-highlight');
                            if (!firstMatch) firstMatch = child;
                        }
                    });
                    if (firstMatch) {
                        const childTop = firstMatch.offsetTop;
                        const listEl = document.getElementById('walletsList');
                        const targetTop = Math.max(childTop - (listEl.clientHeight - firstMatch.clientHeight) / 2, 0);
                        listEl.scrollTo({ top: targetTop, behavior: 'smooth' });
                        firstMatch.classList.add('wallet-flash');
                        setTimeout(() => firstMatch.classList.remove('wallet-flash'), 1000);
                    }
                }
            } catch (e) { }
        }
        
        // Wallet Functions
        
        function getProvider() {
            
            if ('phantom' in window) {
                const provider = window.phantom?.solana;
                if (provider?.isPhantom) {
                    return provider;
                }
            }
            
            // Fallback: check legacy window.solana
            if ('solana' in window && window.solana?.isPhantom) {
                return window.solana;
            }
            
            return null;
        }
        
        async function getWalletBalance(publicKey) {
            try {
                // Use Solana devnet for testing
                const endpoints = [
                    'https://api.devnet.solana.com',
                    'https://devnet.helius-rpc.com/?api-key=your-api-key'
                ];

                for (const endpoint of endpoints) {
                    try {
                        const connection = new solanaWeb3.Connection(endpoint, { commitment: 'processed' });
                        const publicKeyObj = new solanaWeb3.PublicKey(publicKey);
                        const balance = await connection.getBalance(publicKeyObj);
                        return balance / solanaWeb3.LAMPORTS_PER_SOL;
                    } catch (_) {
                        // try next endpoint
                    }
                }

                return 0;
            } catch (_) {
                return 0;
            }
        }
        
        async function connectWallet() {
            try {
                // Check if Phantom is installed
                const provider = getProvider();
                
                if (!provider) {
                    showError('Phantom wallet not found! Please install Phantom wallet.', 'lobby');
                    setTimeout(() => {
                        window.open('https://phantom.app/', '_blank');
                    }, 2000);
                    return;
                }
                
                
                
                // Don't interfere with Phantom's internal state
                // Check if already connected first
                
                let response;
                if (provider.isConnected && provider.publicKey) {
                    response = { publicKey: provider.publicKey };
                } else {
                    
                    // Use the correct Phantom connection method as per documentation
                    try {
                        
                        // Add a simple timeout to see if it's hanging
                        const connectPromise = provider.connect();
                        const timeoutPromise = new Promise((_, reject) => 
                            setTimeout(() => reject(new Error('Connection timeout - Phantom may not be responding')), 15000)
                        );
                        
                        response = await Promise.race([connectPromise, timeoutPromise]);
                    } catch (error) {
                        
                        // If user rejected, show appropriate message
                        if (error.code === 4001) {
                            throw new Error('User rejected the connection request');
                        } else if (error.message.includes('timeout')) {
                            throw new Error('Phantom connection timed out - try refreshing the page');
                        } else {
                            throw new Error(`Connection failed: ${error.message}`);
                        }
                    }
                }
                
                const publicKey = response.publicKey.toString();
                
                // Get real balance using QuickNode
                const solBalance = await getWalletBalance(publicKey);
                
                // Update game state
                gameState.wallet = 'phantom';
                gameState.walletAddress = publicKey;
                gameState.balance = solBalance;
                
                // Update UI
                const walletAddressEl = document.getElementById('walletAddress');
                const walletBalanceEl = document.getElementById('walletBalance');
                const connectBtnEl = document.getElementById('connectBtn');
                
                if (walletAddressEl) {
                    walletAddressEl.textContent = publicKey.slice(0, 8) + '...' + publicKey.slice(-4);
                }
                
                if (walletBalanceEl) {
                    walletBalanceEl.textContent = solBalance.toFixed(4) + ' SOL';
                }
                
                if (connectBtnEl) {
                    connectBtnEl.style.display = 'none';
                }
                
                const disconnectBtnEl = document.getElementById('disconnectBtn');
                if (disconnectBtnEl) {
                    disconnectBtnEl.style.display = 'inline-block';
                }
                
                const getDevnetSolBtn = document.getElementById('getDevnetSol');
                if (getDevnetSolBtn) {
                    getDevnetSolBtn.style.display = 'inline-block';
                }
                
                // Connect to server
                connectToServer();
                // Register wallet to backend list after socket connects
                setTimeout(() => { if (socket) { try { socket.emit('registerWallet', publicKey); } catch(e){} } }, 300);
                // Retry balance in background if initial fetch failed or returned 0
                if (!Number.isFinite(solBalance) || solBalance === 0) {
                    retryFetchBalance(publicKey, 3);
                }
                
            } catch (error) {
                
                if (error.message.includes('timeout')) {
                    showError('Wallet connection timed out. Please refresh and try again.', 'lobby');
                } else if (error.message.includes('User rejected')) {
                    showError('Wallet connection was cancelled by user.', 'lobby');
                } else {
                    showError(`Failed to connect wallet: ${error.message}`, 'lobby');
                }
            }
        }

        async function retryFetchBalance(publicKey, attempts) {
            try {
                for (let i = 0; i < attempts; i++) {
                    await new Promise(r => setTimeout(r, 1500 * (i + 1)));
                    const bal = await getWalletBalance(publicKey);
                    if (Number.isFinite(bal) && bal > 0) {
                        gameState.balance = bal;
                        const walletBalanceEl = document.getElementById('walletBalance');
                        if (walletBalanceEl) walletBalanceEl.textContent = bal.toFixed(4) + ' SOL';
                        return;
                    }
                }
            } catch (_) {}
        }
        
        async function disconnectWallet() {
            try {
                const provider = getProvider();
                if (provider && provider.disconnect) {
                    await provider.disconnect();
                    
                    // Force Phantom to forget this connection
                    if (provider._publicKey) {
                        provider._publicKey = null;
                    }
                    if (provider._connected) {
                        provider._connected = false;
                    }
                }
                
                // Reset game state
                gameState.wallet = null;
                gameState.walletAddress = null;
                gameState.balance = 0;
                
                // Update UI
                const walletAddressEl = document.getElementById('walletAddress');
                const walletBalanceEl = document.getElementById('walletBalance');
                const connectBtnEl = document.getElementById('connectBtn');
                const disconnectBtnEl = document.getElementById('disconnectBtn');
                
                if (walletAddressEl) {
                    walletAddressEl.textContent = 'Not Connected';
                }
                
                if (walletBalanceEl) {
                    walletBalanceEl.textContent = '0.0000 SOL';
                }
                
                if (connectBtnEl) {
                    connectBtnEl.style.display = 'inline-block';
                }
                
                if (disconnectBtnEl) {
                    disconnectBtnEl.style.display = 'none';
                }
                
                const getDevnetSolBtn = document.getElementById('getDevnetSol');
                if (getDevnetSolBtn) {
                    getDevnetSolBtn.style.display = 'none';
                }
                
                // Disconnect from server
                if (socket) {
                    socket.disconnect();
                    socket = null;
                }
                
            } catch (error) {
                // Silent error handling
            }
        }

        async function getDevnetSol() {
            if (!gameState.walletAddress) {
                showError('Please connect your wallet first', 'lobby');
                return;
            }

            try {
                const response = await fetch(`${SERVER_URL}/api/airdrop`, {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                    },
                    body: JSON.stringify({
                        walletAddress: gameState.walletAddress
                    })
                });

                if (response.ok) {
                    const result = await response.json();
                    showSuccessMessage('Airdrop successful! You received 2 SOL', 'lobby');
                    
                    // Refresh balance
                    setTimeout(async () => {
                        const newBalance = await getWalletBalance(gameState.walletAddress);
                        if (newBalance !== null) {
                            gameState.balance = newBalance;
                            updateWalletDisplay();
                        }
                    }, 2000);
                } else {
                    const error = await response.json();
                    showError('Airdrop failed: ' + error.error, 'lobby');
                }
            } catch (error) {
                showError('Airdrop failed: ' + error.message, 'lobby');
            }
        }

        async function createBlockchainTransaction(fromAddress, amount, type) {
            try {
                const provider = getProvider();
                if (!provider) {
                    return { success: false, error: 'Wallet not connected' };
                }

                // Create a real SOL transaction
                const connection = new solanaWeb3.Connection('https://api.devnet.solana.com', 'confirmed');
                const fromPubkey = new solanaWeb3.PublicKey(fromAddress);
                
                // Create a simple transfer to a known devnet address as escrow
                // Using a well-known devnet address for testing
                const escrowAddress = new solanaWeb3.PublicKey('9WzDXwBbmkg8ZTbNMqUxvQRAyrZzDsGYdLVL9zYtAWWM');
                
                const transaction = new solanaWeb3.Transaction().add(
                    solanaWeb3.SystemProgram.transfer({
                        fromPubkey: fromPubkey,
                        toPubkey: escrowAddress,
                        lamports: Math.floor(amount * solanaWeb3.LAMPORTS_PER_SOL * 0.001), // Small amount for testing
                    })
                );

                // Get recent blockhash
                const { blockhash } = await connection.getLatestBlockhash();
                transaction.recentBlockhash = blockhash;
                transaction.feePayer = fromPubkey;

                console.log('🔐 Requesting wallet signature for transaction...');
                console.log('📋 Transaction details:', {
                    from: fromAddress,
                    to: escrowAddress.toString(),
                    amount: Math.floor(amount * solanaWeb3.LAMPORTS_PER_SOL * 0.001),
                    type: type
                });
                
                // Request signature from wallet
                const signedTransaction = await provider.signTransaction(transaction);
                
                console.log('✅ Transaction signed successfully!');
                
                // Send the transaction
                const signature = await connection.sendRawTransaction(signedTransaction.serialize());
                console.log('📤 Transaction sent, waiting for confirmation...');
                
                await connection.confirmTransaction(signature, 'confirmed');
                
                console.log('✅ Transaction confirmed:', signature);
                
                return { 
                    success: true, 
                    signature,
                    message: 'Blockchain transaction completed successfully'
                };
                
            } catch (error) {
                console.error('❌ Blockchain transaction failed:', error);
                console.error('❌ Error details:', {
                    message: error.message,
                    code: error.code,
                    name: error.name
                });
                return { 
                    success: false, 
                    error: error.message,
                    code: error.code
                };
            }
        }
        
        function connectToServer() {
            // Connect to WebSocket server
            if (socket) return; // prevent duplicate connections
            socket = io(SERVER_URL);
            

            socket.on('connect', () => {
                // Connected to server - attempt to rejoin active game if exists
                // Clear any pending disconnect toast
                if (typeof disconnectToastTimer !== 'undefined' && disconnectToastTimer) { clearTimeout(disconnectToastTimer); disconnectToastTimer = null; }
                if (gameState.currentGame && gameState.walletAddress && !gameState.gameOver) {
                    attemptRejoinGame();
                }
            });
            
            socket.on('connect_error', (error) => {
                showError('Connection error. Please refresh the page.', 'lobby');
            });

            socket.on('gameCreated', (game) => {
                updateAvailableGames();
                trackGameFeed(game);
            });
            
            socket.on('gameJoined', (game) => {
                if (game.id === gameState.currentGame?.id) {
                    gameState.currentGame = game;
                    updateGameInfo();
                    
                    // If someone joined our game and we're in the lobby, automatically go to game room
                    if (gameState.currentScreen === 'lobby' && game.players.length === 2) {
                        // Show a brief success notification
                        showSuccessMessage('🎉 Someone joined your game! Starting now...', 'lobby');
                        
                        // Wait a moment for the user to see the notification, then switch to game room
                        setTimeout(() => {
                            showGameRoom();
                            startGame();
                        }, 1500);
                    } else if (gameState.currentScreen === 'gameRoom' && game.players.length === 2) {
                        // Creator is already in the room; start immediately when second player joins
                        startGame();
                    }
                }
                trackGameFeed(game);
            });
            
            socket.on('guessSubmitted', (data) => {
                if (data.gameId === gameState.currentGame?.id) {
                    // Update game state with new guess
                    updateGameInfo();
                }
            });

            socket.on('playerDone', (data) => {
                if (data.gameId !== gameState.currentGame?.id) return;
                // Optionally reflect that opponent finished; keep waiting for server completion
                const errorMessage = document.getElementById('errorMessage');
                if (errorMessage) {
                    errorMessage.style.display = 'block';
                    errorMessage.style.color = '#FFA500';
                    errorMessage.style.border = '1px solid #FFA500';
                    errorMessage.style.background = 'rgba(255,165,0,0.1)';
                    errorMessage.textContent = 'Opponent finished. Waiting for final result...';
                }
            });

            function renderConnectedWallets(wallets) {
                const list = document.getElementById('walletsList');
                if (!list) return;
                list.innerHTML = '';
                if (!wallets || wallets.length === 0) {
                    list.innerHTML = '<div class="wallet-item">None</div>';
                    return;
                }
                wallets.forEach(w => {
                    const item = document.createElement('div');
                    item.className = 'wallet-item';
                    const left = document.createElement('span');
                    left.textContent = w.slice(0, 8) + '...' + w.slice(-4);
                    const link = document.createElement('a');
                    link.href = `https://solscan.io/account/${w}`;
                    link.target = '_blank';
                    link.rel = 'noopener noreferrer';
                    link.className = 'wallet-link';
                    link.textContent = 'Solscan';
                    item.appendChild(left);
                    item.appendChild(link);
                    list.appendChild(item);
                });
                // Re-apply highlight and scroll after every render
                try {
                    const input = document.getElementById('walletSearch');
                    if (input && input.value) {
                        const val = input.value.trim().toLowerCase();
                        let firstMatch = null;
                        Array.from(list.children).forEach((child, index) => {
                            child.classList.remove('wallet-highlight');
                            const span = child.querySelector('span');
                            const link = child.querySelector('a');
                            const displayText = (span?.textContent || '').toLowerCase();
                            const displayPrefix = displayText.substring(0, 8);
                            const fullAddress = (link?.href?.split('/')?.pop() || '').toLowerCase();
                            
                            if (!val) return;
                            
                            // Multiple matching strategies
                            const matchesFull = fullAddress.includes(val);
                            const matchesPrefix = displayPrefix.includes(val.substring(0,8));
                            const matchesDisplay = displayText.includes(val);
                            
                            if (matchesFull || matchesPrefix || matchesDisplay) {
                                child.classList.add('wallet-highlight');
                                if (!firstMatch) firstMatch = child;
                            }
                        });
                        if (firstMatch) {
                            const childTop = firstMatch.offsetTop;
                            const targetTop = Math.max(childTop - (list.clientHeight - firstMatch.clientHeight) / 2, 0);
                            list.scrollTo({ top: targetTop, behavior: 'smooth' });
                            firstMatch.classList.add('wallet-flash');
                            setTimeout(() => firstMatch.classList.remove('wallet-flash'), 1000);
                        }
                    }
                } catch(e) {
                    // Silent error handling
                }
            }

            socket.on('connectedWallets', (wallets) => {
                window.renderConnectedWallets(mergeWalletsWithUser(wallets || []));
            });

            socket.on('recentGames', (games) => {
                try {
                    if (!Array.isArray(games)) return;
                    games.forEach(g => trackGameFeed({ id: g.id, wager: g.wager, status: g.status || 'completed' }));
                } catch (e) {}
            });
            
            socket.on('gameCompleted', (game) => {
                // Always end if this client was in that game (even if state cleared)
                const isThisGame = game.id === gameState.currentGame?.id || (gameState.currentGame && game.id === gameState.currentGame.id);
                if (!isThisGame) return;
                gameState.currentGame = game;
                // Stop local timer if still running
                if (gameState.timer) { clearInterval(gameState.timer); gameState.timer = null; }
                // Determine local result relative to server winner when available
                if (game.winner) {
                    if (game.winner === gameState.walletAddress) {
                        endGame('win');
                    } else {
                        endGame('lose');
                    }
                } else {
                    endGame('both_lost');
                }
                // Track in sidebar feed
                try { trackGameFeed(game); } catch (e) {}
            });
            
            // Listen for game removal
            socket.on('gameRemoved', (data) => {
                // Immediately update available games when a game is removed
                updateAvailableGames();
                try { if (typeof removeFromGameFeed === 'function') { removeFromGameFeed(data.gameId); } } catch (_) {}
            });
            
            // Handle disconnections (debounced user-facing toast)
            let lastDisconnectToast = 0;
            let disconnectToastTimer = null;
            socket.on('disconnect', (reason) => {
                const now = Date.now();
                // Suppress for intentional client disconnects
                const mayShow = reason !== 'io client disconnect' && (now - lastDisconnectToast > 8000);
                // Debounce: only show if we fail to reconnect within 4s
                if (mayShow) {
                    if (disconnectToastTimer) clearTimeout(disconnectToastTimer);
                    disconnectToastTimer = setTimeout(() => {
                        if (!socket || socket.disconnected) {
                            showError('Connection lost. Attempting to reconnect...', 'lobby');
                            lastDisconnectToast = Date.now();
                        }
                    }, 4000);
                }
                // Attempt to reconnect after a delay
                setTimeout(() => {
                    if (!socket || socket.disconnected) {
                        connectToServer();
                    }
                }, 3000);
            });
            
        }
        
        // Active Game Management
        function checkActiveGame() {
            if (gameState.currentGame && !gameState.gameOver) {
                // If user has an active game, go directly to game room
                showGameRoom();
            }
        }
        
        function rejoinGame() {
            if (gameState.currentGame) {
                showGameRoom();
                if (gameState.currentGame.status === 'playing') {
                    startGame();
                }
            }
        }
        
        async function attemptRejoinGame() {
            if (!gameState.currentGame || !gameState.walletAddress) return;
            
            try {
                const response = await fetch(`${SERVER_URL}/api/games/${gameState.currentGame.id}/rejoin`, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ playerAddress: gameState.walletAddress })
                });
                
                if (response.ok) {
                    const game = await response.json();
                    gameState.currentGame = game;
                    // Successfully rejoined game
                    
                    // Show game room and start if playing
                    showGameRoom();
                    if (game.status === 'playing') {
                        startGame();
                    }
                } else {
                    const error = await response.json();
                    // Failed to rejoin game
                    // Clear the invalid game state
                    clearGameState();
                    showScreen('lobby');
                    showError('Could not rejoin game. Game may have ended.', 'lobby');
                }
            } catch (error) {
                // Rejoin request failed
                // Clear the invalid game state
                clearGameState();
                showScreen('lobby');
                showError('Connection error. Please try again.', 'lobby');
            }
        }
        
        async function forfeitGame() {
            if (!gameState.currentGame) return;
            
            // Check if wallet is connected
            if (!gameState.walletAddress) {
                showError('Please connect your wallet first to forfeit the game.', 'gameRoom');
                return;
            }
            
            // Determine forfeit penalty based on game state
            const isGameStarted = gameState.currentGame.status === 'playing';
            const hasOtherPlayers = gameState.currentGame.players.length > 1;
            const forfeitFee = isGameStarted || hasOtherPlayers ? 1.0 : 0.05;
            const refundAmount = gameState.currentGame.wager * (1 - forfeitFee);
            const penaltyAmount = gameState.currentGame.wager * forfeitFee;
            
            const confirmMessage = `⚠️ FORFEIT GAME ⚠️\n\nAre you sure you want to forfeit this game?\n\n` +
                `💰 Your wager: ${gameState.currentGame.wager} SOL\n` +
                `💸 Forfeit fee: ${penaltyAmount.toFixed(4)} SOL (${(forfeitFee * 100).toFixed(0)}%)\n` +
                `🔄 Refund amount: ${refundAmount.toFixed(4)} SOL\n\n` +
                `This action cannot be undone.\n\nClick OK to forfeit, or Cancel to keep playing.`;
            
            if (!confirm(confirmMessage)) {
                return;
            }
            
            try {
                // Forfeit the game (remove player from game)
                const response = await fetch(`${SERVER_URL}/api/games/${gameState.currentGame.id}/forfeit`, {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                    },
                    body: JSON.stringify({
                        playerAddress: gameState.walletAddress
                    })
                });
                
                if (response.ok) {
                    const forfeitData = await response.json();
                    
                    // Clear game state FIRST before navigation
                    gameState.currentGame = null;
                    gameState.gameOver = false;
                    gameState.guesses = [];
                    gameState.playerResult = null;
                    gameState.opponentResult = null;
                    gameState.word = '';
                    
                    // Clear timer
                    if (gameState.timer) {
                        clearInterval(gameState.timer);
                        gameState.timer = null;
                    }
                    
                    // Save state and return to lobby
                    saveGameState();
                    
                    // Now return to lobby (after clearing game state)
                    showScreen('lobby');
                    updateAvailableGames();
                } else if (response.status === 404) {
                    // Game not found on server (probably from previous session)
                    
                    // Clear game state since server doesn't have it
                    gameState.currentGame = null;
                    gameState.gameOver = false;
                    gameState.guesses = [];
                    gameState.playerResult = null;
                    gameState.opponentResult = null;
                    gameState.word = '';
                    
                    // Clear timer
                    if (gameState.timer) {
                        clearInterval(gameState.timer);
                        gameState.timer = null;
                    }
                    
                    // Save state and return to lobby
                    saveGameState();
                    
                    // Return to lobby
                    showScreen('lobby');
                    updateAvailableGames();
                } else {
                    const errorData = await response.json().catch(() => ({ error: 'Unknown error' }));
                    showError(`Failed to forfeit game: ${errorData.error || 'Unknown error'}`, 'gameRoom');
                }
                
            } catch (error) {
                showError('Failed to forfeit game. Please try again.', 'lobby');
            }
        }
        
        
        
        // Game Creation
        async function createGame() {
            // Check for active game
            if (gameState.currentGame && !gameState.gameOver) {
                checkActiveGame(); // Show the active game section
                showError('You already have an active game! Use the "Rejoin Game" button below.', 'lobby');
                return;
            }
            
            if (!gameState.walletAddress) {
                showError('Please connect your wallet first!', 'lobby');
                return;
            }
            
            const wagerInput = document.getElementById('wagerAmount').value.trim();
            const wagerAmount = parseFloat(wagerInput);
            
            if (isNaN(wagerAmount) || wagerAmount <= 0) {
                showError('Please enter a valid wager amount!', 'lobby');
                return;
            }
            
            // Validate wager range
            if (wagerAmount < 0.022 || wagerAmount > 10) {
                showError('Wager must be between 0.022 and 10 SOL!', 'lobby');
                return;
            }
            
            if (wagerAmount > gameState.balance) {
                showError('Insufficient balance!', 'lobby');
                return;
            }
            
            // Show loading state
            const createBtn = document.querySelector('button[onclick="createGame()"]');
            const originalText = createBtn.textContent;
            createBtn.textContent = 'Creating...';
            createBtn.disabled = true;
            
            try {
                // Create game on server
                const response = await fetch(`${SERVER_URL}/api/games`, {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                    },
                    body: JSON.stringify({
                        wager: wagerAmount,
                        playerAddress: gameState.walletAddress
                    })
                });
                
                if (!response.ok) {
                    const errorData = await response.json().catch(() => ({ error: 'Unknown error' }));
                    throw new Error(errorData.error || 'Failed to create game');
                }
                
                const newGame = await response.json();
                
                console.log('🎮 Game created response:', newGame);
                console.log('🔍 requiresSignature:', newGame.requiresSignature);
                
                // If the game requires a blockchain signature, handle it
                if (newGame.requiresSignature) {
                    console.log('🔐 Game requires signature, requesting wallet signature...');
                    showMessage('Please sign the transaction to create your game escrow...', 'success');
                    
                    // Create and sign the blockchain transaction
                    const txResult = await createBlockchainTransaction(gameState.walletAddress, wagerAmount, 'create_game');
                    
                    if (!txResult.success) {
                        throw new Error('Blockchain transaction failed: ' + txResult.error);
                    }
                    
                    showMessage('Blockchain transaction signed! Game created successfully!', 'success');
                } else {
                    console.log('ℹ️ No signature required for this game');
                }
                
                // Clear previous game state
                gameState.currentGame = newGame;
                gameState.gameOver = false;
                gameState.guesses = [];
                gameState.playerResult = null;
                gameState.opponentResult = null;
                gameState.word = newGame.word;
                gameState.timeLeft = 300;
                gameState.isPlayer1 = true;
                
                // Clear any existing timer
                if (gameState.timer) {
                    clearInterval(gameState.timer);
                    gameState.timer = null;
                }
                
                // Automatically show game room when wager is made
                showGameRoom();
                updateGameInfo();
                saveGameState();
                checkActiveGame();
                
            } catch (error) {
                showError('Failed to create game. Please try again.', 'lobby');
            } finally {
                // Reset button state
                createBtn.textContent = originalText;
                createBtn.disabled = false;
            }
        }
        
        // Join Game
        async function joinGame(gameId) {
            if (!gameState.walletAddress) {
                showError('Please connect your wallet first!', 'lobby');
                return;
            }
            
            // Prevent joining if user has an active game
            if (gameState.currentGame && !gameState.gameOver) {
                showError('You already have an active game! Use "Rejoin Game" to return to it.', 'lobby');
                return;
            }
            
            // Check if this is my own game
            const gameToJoin = availableGames.find(g => g.id === gameId);
            if (gameToJoin && gameToJoin.players.includes(gameState.walletAddress)) {
                showError('You cannot join your own game! Use "Rejoin Game" if you need to return to it.', 'lobby');
                return;
            }
            
            // Show loading state
            const joinBtn = event.target;
            const originalText = joinBtn.textContent;
            joinBtn.textContent = 'Joining...';
            joinBtn.disabled = true;
            
            try {
                // Join game on server
                const response = await fetch(`${SERVER_URL}/api/games/${gameId}/join`, {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                    },
                    body: JSON.stringify({
                        playerAddress: gameState.walletAddress
                    })
                });
                
                if (!response.ok) {
                    const error = await response.json();
                    throw new Error(error.error || 'Failed to join game');
                }
                
                const game = await response.json();
                
                // Update game state
                gameState.currentGame = game;
                gameState.isPlayer1 = false;
                gameState.word = game.word;
                gameState.gameOver = false;
                gameState.guesses = [];
                gameState.playerResult = null;
                gameState.opponentResult = null;
                gameState.timeLeft = 300;
                
                // Clear any existing timer
                if (gameState.timer) {
                    clearInterval(gameState.timer);
                    gameState.timer = null;
                }
                
                // Automatically show game room when joining
                showGameRoom();
                startGame();
                saveGameState();
                checkActiveGame();
                
            } catch (error) {
                showError(error.message || 'Failed to join game. Please try again.', 'lobby');
            } finally {
                // Reset button state
                joinBtn.textContent = originalText;
                joinBtn.disabled = false;
            }
        }
        
        // Game Room Functions
        function showGameRoom() {
            showScreen('gameRoom');
            updateGameInfo();
            
            // Clear the Wordle grid for new games
            clearWordleGrid();
            
            // Reset timer display to 5:00
            updateTimerDisplay();
            
            // Only forfeit button is available - no navigation away from active games
            
            // Auto-focus on input and add keyboard shortcuts (only if game is active)
            setTimeout(() => {
                const input = document.getElementById('wordInput');
                if (input && gameState.currentGame && gameState.currentGame.status === 'playing') {
                    input.focus();
                    input.addEventListener('keypress', function(e) {
                        if (e.key === 'Enter') {
                            submitGuess();
                        }
                    });
                }
            }, 100);
            
            // Wait for real player to join - no AI opponent
        }
        
        function updateGameInfo() {
            if (!gameState.currentGame) return;
            
            document.getElementById('gameWager').textContent = gameState.currentGame.wager + ' SOL';
            document.getElementById('playerCount').textContent = gameState.currentGame.players.length + '/2';
            
            const status = gameState.currentGame.status === 'waiting' ? 'Waiting for player...' : 'Playing';
            document.getElementById('gameStatus').textContent = status;
            
            const totalPot = gameState.currentGame.wager * 2;
            document.getElementById('totalPot').textContent = totalPot;
            
            // Show/hide input section based on game status
            const inputSection = document.querySelector('.input-section');
            const errorMessage = document.getElementById('errorMessage');
            
            if (gameState.currentGame.status === 'waiting') {
                if (inputSection) inputSection.style.display = 'none';
                if (errorMessage) {
                    errorMessage.style.display = 'block';
                    errorMessage.textContent = 'Waiting for another player to join...';
                    errorMessage.style.color = '#FFA500';
                    errorMessage.style.borderColor = '#FFA500';
                    errorMessage.style.backgroundColor = 'rgba(255, 165, 0, 0.1)';
                }
            } else {
                if (inputSection) inputSection.style.display = 'block';
                if (errorMessage) errorMessage.style.display = 'none';
            }
        }
        
        function startGame() {
            gameState.word = gameState.currentGame.word;
            gameState.guesses = [];
            gameState.timeLeft = 300;
            gameState.gameOver = false;
            gameState.playerResult = null;
            gameState.opponentResult = null;
            
            clearWordleGrid();
            startTimer();
            updateGameInfo();
        }
        
        // Timer Functions
        function startTimer() {
            if (gameState.timer) clearInterval(gameState.timer);
            
            gameState.timer = setInterval(() => {
                gameState.timeLeft--;
                updateTimerDisplay();
                
                if (gameState.timeLeft <= 0) {
                    gameState.playerResult = 'timeout';
                    // Notify server of timeout and stop local timer
                    fetch(`${SERVER_URL}/api/games/${gameState.currentGame.id}/timeout`, {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify({ playerAddress: gameState.walletAddress })
                    }).catch(() => {});
                    clearInterval(gameState.timer);
                    gameState.timer = null;
                }
            }, 1000);
        }
        
        function updateTimerDisplay() {
            const minutes = Math.floor(gameState.timeLeft / 60);
            const seconds = gameState.timeLeft % 60;
            const timerElement = document.getElementById('timer');
            
            timerElement.textContent = `${minutes}:${seconds.toString().padStart(2, '0')}`;
            
            if (gameState.timeLeft <= 30) {
                timerElement.classList.add('timer-warning');
            } else {
                timerElement.classList.remove('timer-warning');
            }
        }
        
        // Check if both players have finished (server-authoritative)
        function checkBothPlayersFinished() {
            // No-op: server emits 'gameCompleted' when both sides are done
        }
        
        // Wordle Functions
        function generateWordleGrid() {
            const grid = document.getElementById('wordleGrid');
            grid.innerHTML = '';
            
            for (let row = 0; row < 6; row++) {
                const rowDiv = document.createElement('div');
                rowDiv.className = 'wordle-row';
                
                for (let col = 0; col < 5; col++) {
                    const cell = document.createElement('div');
                    cell.className = 'wordle-cell';
                    cell.id = `cell-${row}-${col}`;
                    rowDiv.appendChild(cell);
                }
                
                grid.appendChild(rowDiv);
            }
        }
        
        function clearWordleGrid() {
            const cells = document.querySelectorAll('.wordle-cell');
            cells.forEach(cell => {
                cell.textContent = '';
                cell.className = 'wordle-cell';
            });
        }
        
        function submitGuess() {
            if (gameState.gameOver || gameState.currentScreen !== 'gameRoom') return;
            
            // Check if game is actually active (has 2 players)
            if (!gameState.currentGame || gameState.currentGame.status !== 'playing') {
                showError('Waiting for another player to join the game...');
                return;
            }
            
            const input = document.getElementById('wordInput');
            const submitBtn = document.getElementById('submitBtn');
            const guess = input.value.trim().toUpperCase();
            
            // Input validation
            if (guess.length !== 5) {
                showError('Please enter a 5-letter word!');
                return;
            }
            
            // Validate word contains only letters
            if (!/^[A-Z]{5}$/.test(guess)) {
                showError('Word must contain only letters!');
                return;
            }
            
            // Remove restrictive word validation - let server handle it
            // The server has a much larger word list than our client-side validation
            
            if (gameState.guesses.includes(guess)) {
                showError('You already guessed this word!');
                return;
            }
            
            // Show loading state
            const originalText = submitBtn.textContent;
            submitBtn.textContent = 'Submitting...';
            submitBtn.disabled = true;
            
            // Clear any previous errors
            clearError();
            
            gameState.guesses.push(guess);
            updateWordleGrid();
            saveGameState();
            
            // If player reached 6 guesses, lock input and wait for opponent/server
            if (gameState.guesses.length >= 6 && guess !== gameState.word) {
                const inputSection = document.querySelector('.input-section');
                if (inputSection) inputSection.style.display = 'none';
                if (gameState.timer) { clearInterval(gameState.timer); gameState.timer = null; }
                const errorMessage = document.getElementById('errorMessage');
                if (errorMessage) {
                    errorMessage.style.display = 'block';
                    errorMessage.style.color = '#FFA500';
                    errorMessage.style.border = '1px solid #FFA500';
                    errorMessage.style.background = 'rgba(255,165,0,0.1)';
                    errorMessage.textContent = 'You used all guesses. You lost this match.';
                }
                // End locally as a loss; opponent may continue
                endGame('lose');
            }
            
            // Send guess to server; server decides wins/completion and broadcasts
            fetch(`${SERVER_URL}/api/games/${gameState.currentGame.id}/guess`, {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({
                    playerAddress: gameState.walletAddress,
                    guess
                })
            }).catch(() => {});
            
            input.value = '';
            
            // Reset button state
            submitBtn.textContent = originalText;
            submitBtn.disabled = false;
        }
        
        
        function showError(message, location = 'game') {
            let errorDiv;
            if (location === 'lobby') {
                errorDiv = document.getElementById('lobbyErrorMessage');
            } else {
                errorDiv = document.getElementById('errorMessage');
            }
            
            if (errorDiv) {
                errorDiv.textContent = message;
                errorDiv.style.display = 'block';
                errorDiv.style.color = '#FF4444';
                errorDiv.style.background = 'rgba(255, 68, 68, 0.1)';
                errorDiv.style.border = '1px solid #FF4444';
            }
        }
        
        function showSuccessMessage(message, location = 'game') {
            let errorDiv;
            if (location === 'lobby') {
                errorDiv = document.getElementById('lobbyErrorMessage');
            } else {
                errorDiv = document.getElementById('errorMessage');
            }
            
            if (errorDiv) {
                errorDiv.textContent = message;
                errorDiv.style.display = 'block';
                errorDiv.style.color = '#80FF80';
                errorDiv.style.background = 'rgba(128, 255, 128, 0.1)';
                errorDiv.style.border = '1px solid #80FF80';
            }
        }
        
        function clearError(location = 'game') {
            let errorDiv;
            if (location === 'lobby') {
                errorDiv = document.getElementById('lobbyErrorMessage');
            } else {
                errorDiv = document.getElementById('errorMessage');
            }
            
            if (errorDiv) {
                errorDiv.style.display = 'none';
            }
        }
        
        function updateWordleGrid() {
            const currentRow = gameState.guesses.length - 1;
            const guess = gameState.guesses[currentRow];
            
            for (let col = 0; col < 5; col++) {
                const cell = document.getElementById(`cell-${currentRow}-${col}`);
                const letter = guess[col];
                const correctLetter = gameState.word[col];
                
                cell.textContent = letter;
                
                if (letter === correctLetter) {
                    cell.classList.add('correct');
                } else if (gameState.word.includes(letter)) {
                    cell.classList.add('present');
                } else {
                    cell.classList.add('absent');
                }
            }
        }

        function restoreGameGrid() {
            // Simple function to restore the visual grid with previous guesses
            if (!gameState.guesses || gameState.guesses.length === 0) return;
            
            for (let row = 0; row < gameState.guesses.length; row++) {
                const guess = gameState.guesses[row];
                if (!guess) continue;
                
                for (let col = 0; col < 5; col++) {
                    const cell = document.getElementById(`cell-${row}-${col}`);
                    if (cell) {
                        const letter = guess[col];
                        const correctLetter = gameState.word[col];
                        
                        cell.textContent = letter;
                        
                        if (letter === correctLetter) {
                            cell.classList.add('correct');
                        } else if (gameState.word.includes(letter)) {
                            cell.classList.add('present');
                        } else {
                            cell.classList.add('absent');
                        }
                    }
                }
            }
        }
        
        // Game End Functions
        function endGame(result) {
            gameState.gameOver = true;
            if (gameState.timer) clearInterval(gameState.timer);
            
            showScreen('gameOver');
            clearGameState();
            
            const resultDiv = document.getElementById('gameResult');
            const titleElement = document.getElementById('resultTitle');
            const messageElement = document.getElementById('resultMessage');
            
            const totalPot = gameState.currentGame.wager * 2;
            
            switch (result) {
                case 'win':
                    titleElement.textContent = 'You Won the Pot!';
                    messageElement.innerHTML = `
                        <strong>Congratulations!</strong><br>
                        You guessed "${gameState.word}" in ${gameState.guesses.length} tries!<br>
                        <strong>You win: ${totalPot} SOL</strong> (entire pot)<br>
                        <small>Your wager: ${gameState.currentGame.wager} SOL + Opponent's wager: ${gameState.currentGame.wager} SOL</small>
                    `;
                    resultDiv.className = 'result win';
                    break;
                case 'lose':
                    titleElement.textContent = 'You Lost';
                    messageElement.innerHTML = `
                        The word was "${gameState.word}".<br>
                        <strong>Opponent wins: ${totalPot} SOL</strong><br>
                        <small>Returning to home...</small>
                    `;
                    resultDiv.className = 'result lose';
                    break;
                case 'timeout':
                    titleElement.textContent = 'You Lost (Time)';
                    messageElement.innerHTML = `
                        Time ran out! The word was "${gameState.word}".<br>
                        <strong>You lost your wager: ${gameState.currentGame.wager} SOL</strong><br>
                        <small>Returning to home...</small>
                    `;
                    resultDiv.className = 'result lose';
                    break;
                case 'both_lost':
                    titleElement.textContent = 'Match Ended';
                    messageElement.innerHTML = `
                        Both players ran out of tries.<br>
                        The word was "${gameState.word}".<br>
                        <small>Returning to home...</small>
                    `;
                    resultDiv.className = 'result lose';
                    break;
            }
            // Auto return to lobby after 4 seconds
            setTimeout(() => {
                gameState.currentGame = null;
                gameState.gameOver = false;
                showScreen('lobby');
                updateAvailableGames();
            }, 4000);
            
        }
        
        // Navigation Functions
        
        
        function backToLobby() {
            // Only allow going back to lobby if game is over
            if (gameState.gameOver) {
                if (gameState.timer) clearInterval(gameState.timer);
                
                if (gameState.currentGame) {
                    availableGames = availableGames.filter(g => g.id !== gameState.currentGame.id);
                }
                
                gameState.currentGame = null;
                gameState.gameOver = false;
                
                showScreen('lobby');
                updateAvailableGames();
            } else {
                // Game is still active - prevent navigation
                showError('Cannot leave active game! You must forfeit to end the game.', 'gameRoom');
            }
        }
        
        // Utility Functions
        async function updateAvailableGames() {
            try {
                // Fetch games from server
                const response = await fetch(`${SERVER_URL}/api/games`);
                if (response.ok) {
                    availableGames = await response.json();
                }
            } catch (error) {
                // Silent error handling
            }
            
            const gamesList = document.getElementById('gamesList');
            const waitingGames = availableGames.filter(g => g.status === 'waiting');
            
            if (waitingGames.length === 0) {
                gamesList.innerHTML = '<p style="color: #CCCCCC; text-align: center; padding: 20px;">No games available. Create one!</p>';
            } else {
                // Clear existing content safely
                gamesList.innerHTML = '';
                
                waitingGames.forEach(game => {
                    const isMyGame = gameState.walletAddress && game.players.includes(gameState.walletAddress);
                    const buttonText = isMyGame ? 'Your Game' : 'Join';
                    const buttonClass = isMyGame ? 'btn btn-secondary' : 'btn btn-primary';
                    
                    // Create elements safely to prevent XSS
                    const gameItem = document.createElement('div');
                    gameItem.className = 'game-item';
                    
                    const gameInfo = document.createElement('div');
                    gameInfo.className = 'game-info';
                    
                    const wagerDiv = document.createElement('div');
                    wagerDiv.className = 'game-wager';
                    wagerDiv.textContent = `${game.wager} SOL`;
                    
                    const playersDiv = document.createElement('div');
                    playersDiv.className = 'game-players';
                    playersDiv.textContent = `${game.players.length}/2 players`;
                    
                    const creatorDiv = document.createElement('div');
                    creatorDiv.className = 'game-creator';
                    creatorDiv.textContent = `Creator: ${game.players[0].slice(0, 8)}...${game.players[0].slice(-4)}`;
                    
                    const button = document.createElement('button');
                    button.className = buttonClass;
                    button.textContent = buttonText;
                    if (isMyGame) {
                        button.disabled = true;
                        button.onclick = () => rejoinGame();
                    } else {
                        button.onclick = () => joinGame(game.id);
                    }
                    
                    gameInfo.appendChild(wagerDiv);
                    gameInfo.appendChild(playersDiv);
                    gameInfo.appendChild(creatorDiv);
                    gameItem.appendChild(gameInfo);
                    gameItem.appendChild(button);
                    
                    gamesList.appendChild(gameItem);
                });
            }
        }
        
        
        // Event Listeners
        document.getElementById('wordInput').addEventListener('keypress', function(e) {
            if (e.key === 'Enter') {
                submitGuess();
            }
        });
        
        document.getElementById('wordInput').addEventListener('input', function(e) {
            e.target.value = e.target.value.toUpperCase();
        });
        
        // Game State Persistence
        function saveGameState() {
            try {
                localStorage.setItem('solWordleGameState', JSON.stringify({
                    currentGame: gameState.currentGame,
                    gameOver: gameState.gameOver,
                    guesses: gameState.guesses,
                    playerResult: gameState.playerResult,
                    opponentResult: gameState.opponentResult,
                    word: gameState.word,
                    timeLeft: gameState.timeLeft
                }));
            } catch (e) {
                // Silent error handling
            }
        }
        
        function loadGameState() {
            try {
                const saved = localStorage.getItem('solWordleGameState');
                if (saved) {
                    const savedState = JSON.parse(saved);
                    
                    // Only restore if game was in progress
                    if (savedState.currentGame && !savedState.gameOver) {
                        gameState.currentGame = savedState.currentGame;
                        gameState.guesses = savedState.guesses || [];
                        gameState.playerResult = savedState.playerResult;
                        gameState.opponentResult = savedState.opponentResult;
                        gameState.word = savedState.word;
                        gameState.timeLeft = savedState.timeLeft || 300;
                        
                        // If game was in progress, attempt to rejoin
                        if (gameState.currentGame.status === 'playing') {
                            // Restore the visual grid with previous guesses
                            restoreGameGrid();
                            
                            // Wait for socket connection before attempting rejoin
                            if (socket && socket.connected) {
                                attemptRejoinGame();
                            } else {
                                // Show game room immediately, rejoin will happen on socket connect
                                showGameRoom();
                            }
                        }
                    }
                }
            } catch (e) {
                // Silent error handling
            }
        }
        
        function clearGameState() {
            try {
                localStorage.removeItem('solWordleGameState');
            } catch (e) {
                // Silent error handling
            }
        }

        // Auto-update games list
        setInterval(updateAvailableGames, 2000);
        
        // Load saved game state on page load
        loadGameState();

        // Ongoing/completed games feed helpers
        const gameFeed = new Map();
        function trackGameFeed(game) {
            if (!game || !game.id) return;
            gameFeed.set(game.id, { id: game.id, wager: game.wager, status: game.status });
            const gamesList = document.getElementById('completedGamesList');
            if (!gamesList) return;
            // Re-render simple feed
            gamesList.innerHTML = '';
            const items = Array.from(gameFeed.values()).slice(-20);
            if (items.length === 0) {
                gamesList.innerHTML = '<div class="no-games">No completed games yet</div>';
                return;
            }
            items.forEach(entry => {
                const gameResult = document.createElement('div');
                gameResult.className = 'game-result';
                gameResult.innerHTML = `
                    <img src="transparent.png" alt="Wordle Wars" class="game-result-icon">
                    <div>
                        <div class="game-amount">${entry.wager} SOL</div>
                        <div style="color:#ccc;font-size:11px;">${entry.status}</div>
                    </div>
                `;
                gamesList.insertBefore(gameResult, gamesList.firstChild);
            });
        }

        // Completed games management
        function addCompletedGame(winnerWallet, amount, isCurrentUser) {
            const gamesList = document.getElementById('completedGamesList');
            
            // Remove "no games" message if it exists
            const noGames = gamesList.querySelector('.no-games');
            if (noGames) {
                noGames.remove();
            }
            
            // Create game result element
            const gameResult = document.createElement('div');
            gameResult.className = `game-result ${isCurrentUser ? 'winner' : 'loser'}`;
            
            const shortWallet = winnerWallet.slice(0, 4) + '...' + winnerWallet.slice(-4);
            gameResult.innerHTML = `
                <img src="transparent.png" alt="Wordle Wars" class="game-result-icon">
                <div>
                    <div class="game-wallet">${shortWallet}</div>
                    <div>won <span class="game-amount">${amount} SOL</span></div>
                </div>
            `;
            
            // Add to top of list
            gamesList.insertBefore(gameResult, gamesList.firstChild);
            
            // Keep only last 10 games
            const games = gamesList.querySelectorAll('.game-result');
            if (games.length > 10) {
                games[games.length - 1].remove();
            }
        }

        function clearCompletedGames() {
            const gamesList = document.getElementById('completedGamesList');
            gamesList.innerHTML = '<div class="no-games">No completed games yet</div>';
        }
    </script>
</body>
</html>
