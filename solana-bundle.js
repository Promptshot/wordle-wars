var SolanaBundle = (() => {
  var __create = Object.create;
  var __defProp = Object.defineProperty;
  var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
  var __getOwnPropNames = Object.getOwnPropertyNames;
  var __getProtoOf = Object.getPrototypeOf;
  var __hasOwnProp = Object.prototype.hasOwnProperty;
  var __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
  var __esm = (fn, res) => function __init() {
    return fn && (res = (0, fn[__getOwnPropNames(fn)[0]])(fn = 0)), res;
  };
  var __commonJS = (cb, mod) => function __require() {
    return mod || (0, cb[__getOwnPropNames(cb)[0]])((mod = { exports: {} }).exports, mod), mod.exports;
  };
  var __export = (target, all) => {
    for (var name in all)
      __defProp(target, name, { get: all[name], enumerable: true });
  };
  var __copyProps = (to, from, except, desc) => {
    if (from && typeof from === "object" || typeof from === "function") {
      for (let key of __getOwnPropNames(from))
        if (!__hasOwnProp.call(to, key) && key !== except)
          __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
    }
    return to;
  };
  var __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(
    // If the importer is in node compatibility mode or this is not an ESM
    // file that has been converted to a CommonJS file using a Babel-
    // compatible transform (i.e. "__esModule" has not been set), then set
    // "default" to the CommonJS "module.exports" for node compatibility.
    isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: true }) : target,
    mod
  ));
  var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);
  var __publicField = (obj, key, value) => __defNormalProp(obj, typeof key !== "symbol" ? key + "" : key, value);

  // node_modules/base64-js/index.js
  var require_base64_js = __commonJS({
    "node_modules/base64-js/index.js"(exports) {
      "use strict";
      exports.byteLength = byteLength;
      exports.toByteArray = toByteArray;
      exports.fromByteArray = fromByteArray;
      var lookup = [];
      var revLookup = [];
      var Arr = typeof Uint8Array !== "undefined" ? Uint8Array : Array;
      var code = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/";
      for (i = 0, len = code.length; i < len; ++i) {
        lookup[i] = code[i];
        revLookup[code.charCodeAt(i)] = i;
      }
      var i;
      var len;
      revLookup["-".charCodeAt(0)] = 62;
      revLookup["_".charCodeAt(0)] = 63;
      function getLens(b64) {
        var len2 = b64.length;
        if (len2 % 4 > 0) {
          throw new Error("Invalid string. Length must be a multiple of 4");
        }
        var validLen = b64.indexOf("=");
        if (validLen === -1) validLen = len2;
        var placeHoldersLen = validLen === len2 ? 0 : 4 - validLen % 4;
        return [validLen, placeHoldersLen];
      }
      function byteLength(b64) {
        var lens = getLens(b64);
        var validLen = lens[0];
        var placeHoldersLen = lens[1];
        return (validLen + placeHoldersLen) * 3 / 4 - placeHoldersLen;
      }
      function _byteLength(b64, validLen, placeHoldersLen) {
        return (validLen + placeHoldersLen) * 3 / 4 - placeHoldersLen;
      }
      function toByteArray(b64) {
        var tmp;
        var lens = getLens(b64);
        var validLen = lens[0];
        var placeHoldersLen = lens[1];
        var arr = new Arr(_byteLength(b64, validLen, placeHoldersLen));
        var curByte = 0;
        var len2 = placeHoldersLen > 0 ? validLen - 4 : validLen;
        var i2;
        for (i2 = 0; i2 < len2; i2 += 4) {
          tmp = revLookup[b64.charCodeAt(i2)] << 18 | revLookup[b64.charCodeAt(i2 + 1)] << 12 | revLookup[b64.charCodeAt(i2 + 2)] << 6 | revLookup[b64.charCodeAt(i2 + 3)];
          arr[curByte++] = tmp >> 16 & 255;
          arr[curByte++] = tmp >> 8 & 255;
          arr[curByte++] = tmp & 255;
        }
        if (placeHoldersLen === 2) {
          tmp = revLookup[b64.charCodeAt(i2)] << 2 | revLookup[b64.charCodeAt(i2 + 1)] >> 4;
          arr[curByte++] = tmp & 255;
        }
        if (placeHoldersLen === 1) {
          tmp = revLookup[b64.charCodeAt(i2)] << 10 | revLookup[b64.charCodeAt(i2 + 1)] << 4 | revLookup[b64.charCodeAt(i2 + 2)] >> 2;
          arr[curByte++] = tmp >> 8 & 255;
          arr[curByte++] = tmp & 255;
        }
        return arr;
      }
      function tripletToBase64(num) {
        return lookup[num >> 18 & 63] + lookup[num >> 12 & 63] + lookup[num >> 6 & 63] + lookup[num & 63];
      }
      function encodeChunk(uint8, start, end) {
        var tmp;
        var output = [];
        for (var i2 = start; i2 < end; i2 += 3) {
          tmp = (uint8[i2] << 16 & 16711680) + (uint8[i2 + 1] << 8 & 65280) + (uint8[i2 + 2] & 255);
          output.push(tripletToBase64(tmp));
        }
        return output.join("");
      }
      function fromByteArray(uint8) {
        var tmp;
        var len2 = uint8.length;
        var extraBytes = len2 % 3;
        var parts = [];
        var maxChunkLength = 16383;
        for (var i2 = 0, len22 = len2 - extraBytes; i2 < len22; i2 += maxChunkLength) {
          parts.push(encodeChunk(uint8, i2, i2 + maxChunkLength > len22 ? len22 : i2 + maxChunkLength));
        }
        if (extraBytes === 1) {
          tmp = uint8[len2 - 1];
          parts.push(
            lookup[tmp >> 2] + lookup[tmp << 4 & 63] + "=="
          );
        } else if (extraBytes === 2) {
          tmp = (uint8[len2 - 2] << 8) + uint8[len2 - 1];
          parts.push(
            lookup[tmp >> 10] + lookup[tmp >> 4 & 63] + lookup[tmp << 2 & 63] + "="
          );
        }
        return parts.join("");
      }
    }
  });

  // node_modules/ieee754/index.js
  var require_ieee754 = __commonJS({
    "node_modules/ieee754/index.js"(exports) {
      exports.read = function(buffer, offset2, isLE, mLen, nBytes) {
        var e, m;
        var eLen = nBytes * 8 - mLen - 1;
        var eMax = (1 << eLen) - 1;
        var eBias = eMax >> 1;
        var nBits = -7;
        var i = isLE ? nBytes - 1 : 0;
        var d = isLE ? -1 : 1;
        var s = buffer[offset2 + i];
        i += d;
        e = s & (1 << -nBits) - 1;
        s >>= -nBits;
        nBits += eLen;
        for (; nBits > 0; e = e * 256 + buffer[offset2 + i], i += d, nBits -= 8) {
        }
        m = e & (1 << -nBits) - 1;
        e >>= -nBits;
        nBits += mLen;
        for (; nBits > 0; m = m * 256 + buffer[offset2 + i], i += d, nBits -= 8) {
        }
        if (e === 0) {
          e = 1 - eBias;
        } else if (e === eMax) {
          return m ? NaN : (s ? -1 : 1) * Infinity;
        } else {
          m = m + Math.pow(2, mLen);
          e = e - eBias;
        }
        return (s ? -1 : 1) * m * Math.pow(2, e - mLen);
      };
      exports.write = function(buffer, value, offset2, isLE, mLen, nBytes) {
        var e, m, c;
        var eLen = nBytes * 8 - mLen - 1;
        var eMax = (1 << eLen) - 1;
        var eBias = eMax >> 1;
        var rt = mLen === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0;
        var i = isLE ? 0 : nBytes - 1;
        var d = isLE ? 1 : -1;
        var s = value < 0 || value === 0 && 1 / value < 0 ? 1 : 0;
        value = Math.abs(value);
        if (isNaN(value) || value === Infinity) {
          m = isNaN(value) ? 1 : 0;
          e = eMax;
        } else {
          e = Math.floor(Math.log(value) / Math.LN2);
          if (value * (c = Math.pow(2, -e)) < 1) {
            e--;
            c *= 2;
          }
          if (e + eBias >= 1) {
            value += rt / c;
          } else {
            value += rt * Math.pow(2, 1 - eBias);
          }
          if (value * c >= 2) {
            e++;
            c /= 2;
          }
          if (e + eBias >= eMax) {
            m = 0;
            e = eMax;
          } else if (e + eBias >= 1) {
            m = (value * c - 1) * Math.pow(2, mLen);
            e = e + eBias;
          } else {
            m = value * Math.pow(2, eBias - 1) * Math.pow(2, mLen);
            e = 0;
          }
        }
        for (; mLen >= 8; buffer[offset2 + i] = m & 255, i += d, m /= 256, mLen -= 8) {
        }
        e = e << mLen | m;
        eLen += mLen;
        for (; eLen > 0; buffer[offset2 + i] = e & 255, i += d, e /= 256, eLen -= 8) {
        }
        buffer[offset2 + i - d] |= s * 128;
      };
    }
  });

  // node_modules/buffer/index.js
  var require_buffer = __commonJS({
    "node_modules/buffer/index.js"(exports) {
      "use strict";
      var base642 = require_base64_js();
      var ieee754 = require_ieee754();
      var customInspectSymbol = typeof Symbol === "function" && typeof Symbol["for"] === "function" ? Symbol["for"]("nodejs.util.inspect.custom") : null;
      exports.Buffer = Buffer3;
      exports.SlowBuffer = SlowBuffer;
      exports.INSPECT_MAX_BYTES = 50;
      var K_MAX_LENGTH = 2147483647;
      exports.kMaxLength = K_MAX_LENGTH;
      Buffer3.TYPED_ARRAY_SUPPORT = typedArraySupport();
      if (!Buffer3.TYPED_ARRAY_SUPPORT && typeof console !== "undefined" && typeof console.error === "function") {
        console.error(
          "This browser lacks typed array (Uint8Array) support which is required by `buffer` v5.x. Use `buffer` v4.x if you require old browser support."
        );
      }
      function typedArraySupport() {
        try {
          const arr = new Uint8Array(1);
          const proto = { foo: function() {
            return 42;
          } };
          Object.setPrototypeOf(proto, Uint8Array.prototype);
          Object.setPrototypeOf(arr, proto);
          return arr.foo() === 42;
        } catch (e) {
          return false;
        }
      }
      Object.defineProperty(Buffer3.prototype, "parent", {
        enumerable: true,
        get: function() {
          if (!Buffer3.isBuffer(this)) return void 0;
          return this.buffer;
        }
      });
      Object.defineProperty(Buffer3.prototype, "offset", {
        enumerable: true,
        get: function() {
          if (!Buffer3.isBuffer(this)) return void 0;
          return this.byteOffset;
        }
      });
      function createBuffer(length) {
        if (length > K_MAX_LENGTH) {
          throw new RangeError('The value "' + length + '" is invalid for option "size"');
        }
        const buf = new Uint8Array(length);
        Object.setPrototypeOf(buf, Buffer3.prototype);
        return buf;
      }
      function Buffer3(arg, encodingOrOffset, length) {
        if (typeof arg === "number") {
          if (typeof encodingOrOffset === "string") {
            throw new TypeError(
              'The "string" argument must be of type string. Received type number'
            );
          }
          return allocUnsafe(arg);
        }
        return from(arg, encodingOrOffset, length);
      }
      Buffer3.poolSize = 8192;
      function from(value, encodingOrOffset, length) {
        if (typeof value === "string") {
          return fromString(value, encodingOrOffset);
        }
        if (ArrayBuffer.isView(value)) {
          return fromArrayView(value);
        }
        if (value == null) {
          throw new TypeError(
            "The first argument must be one of type string, Buffer, ArrayBuffer, Array, or Array-like Object. Received type " + typeof value
          );
        }
        if (isInstance(value, ArrayBuffer) || value && isInstance(value.buffer, ArrayBuffer)) {
          return fromArrayBuffer(value, encodingOrOffset, length);
        }
        if (typeof SharedArrayBuffer !== "undefined" && (isInstance(value, SharedArrayBuffer) || value && isInstance(value.buffer, SharedArrayBuffer))) {
          return fromArrayBuffer(value, encodingOrOffset, length);
        }
        if (typeof value === "number") {
          throw new TypeError(
            'The "value" argument must not be of type number. Received type number'
          );
        }
        const valueOf = value.valueOf && value.valueOf();
        if (valueOf != null && valueOf !== value) {
          return Buffer3.from(valueOf, encodingOrOffset, length);
        }
        const b = fromObject(value);
        if (b) return b;
        if (typeof Symbol !== "undefined" && Symbol.toPrimitive != null && typeof value[Symbol.toPrimitive] === "function") {
          return Buffer3.from(value[Symbol.toPrimitive]("string"), encodingOrOffset, length);
        }
        throw new TypeError(
          "The first argument must be one of type string, Buffer, ArrayBuffer, Array, or Array-like Object. Received type " + typeof value
        );
      }
      Buffer3.from = function(value, encodingOrOffset, length) {
        return from(value, encodingOrOffset, length);
      };
      Object.setPrototypeOf(Buffer3.prototype, Uint8Array.prototype);
      Object.setPrototypeOf(Buffer3, Uint8Array);
      function assertSize(size) {
        if (typeof size !== "number") {
          throw new TypeError('"size" argument must be of type number');
        } else if (size < 0) {
          throw new RangeError('The value "' + size + '" is invalid for option "size"');
        }
      }
      function alloc(size, fill, encoding) {
        assertSize(size);
        if (size <= 0) {
          return createBuffer(size);
        }
        if (fill !== void 0) {
          return typeof encoding === "string" ? createBuffer(size).fill(fill, encoding) : createBuffer(size).fill(fill);
        }
        return createBuffer(size);
      }
      Buffer3.alloc = function(size, fill, encoding) {
        return alloc(size, fill, encoding);
      };
      function allocUnsafe(size) {
        assertSize(size);
        return createBuffer(size < 0 ? 0 : checked(size) | 0);
      }
      Buffer3.allocUnsafe = function(size) {
        return allocUnsafe(size);
      };
      Buffer3.allocUnsafeSlow = function(size) {
        return allocUnsafe(size);
      };
      function fromString(string2, encoding) {
        if (typeof encoding !== "string" || encoding === "") {
          encoding = "utf8";
        }
        if (!Buffer3.isEncoding(encoding)) {
          throw new TypeError("Unknown encoding: " + encoding);
        }
        const length = byteLength(string2, encoding) | 0;
        let buf = createBuffer(length);
        const actual = buf.write(string2, encoding);
        if (actual !== length) {
          buf = buf.slice(0, actual);
        }
        return buf;
      }
      function fromArrayLike(array3) {
        const length = array3.length < 0 ? 0 : checked(array3.length) | 0;
        const buf = createBuffer(length);
        for (let i = 0; i < length; i += 1) {
          buf[i] = array3[i] & 255;
        }
        return buf;
      }
      function fromArrayView(arrayView) {
        if (isInstance(arrayView, Uint8Array)) {
          const copy = new Uint8Array(arrayView);
          return fromArrayBuffer(copy.buffer, copy.byteOffset, copy.byteLength);
        }
        return fromArrayLike(arrayView);
      }
      function fromArrayBuffer(array3, byteOffset, length) {
        if (byteOffset < 0 || array3.byteLength < byteOffset) {
          throw new RangeError('"offset" is outside of buffer bounds');
        }
        if (array3.byteLength < byteOffset + (length || 0)) {
          throw new RangeError('"length" is outside of buffer bounds');
        }
        let buf;
        if (byteOffset === void 0 && length === void 0) {
          buf = new Uint8Array(array3);
        } else if (length === void 0) {
          buf = new Uint8Array(array3, byteOffset);
        } else {
          buf = new Uint8Array(array3, byteOffset, length);
        }
        Object.setPrototypeOf(buf, Buffer3.prototype);
        return buf;
      }
      function fromObject(obj) {
        if (Buffer3.isBuffer(obj)) {
          const len = checked(obj.length) | 0;
          const buf = createBuffer(len);
          if (buf.length === 0) {
            return buf;
          }
          obj.copy(buf, 0, 0, len);
          return buf;
        }
        if (obj.length !== void 0) {
          if (typeof obj.length !== "number" || numberIsNaN(obj.length)) {
            return createBuffer(0);
          }
          return fromArrayLike(obj);
        }
        if (obj.type === "Buffer" && Array.isArray(obj.data)) {
          return fromArrayLike(obj.data);
        }
      }
      function checked(length) {
        if (length >= K_MAX_LENGTH) {
          throw new RangeError("Attempt to allocate Buffer larger than maximum size: 0x" + K_MAX_LENGTH.toString(16) + " bytes");
        }
        return length | 0;
      }
      function SlowBuffer(length) {
        if (+length != length) {
          length = 0;
        }
        return Buffer3.alloc(+length);
      }
      Buffer3.isBuffer = function isBuffer(b) {
        return b != null && b._isBuffer === true && b !== Buffer3.prototype;
      };
      Buffer3.compare = function compare(a, b) {
        if (isInstance(a, Uint8Array)) a = Buffer3.from(a, a.offset, a.byteLength);
        if (isInstance(b, Uint8Array)) b = Buffer3.from(b, b.offset, b.byteLength);
        if (!Buffer3.isBuffer(a) || !Buffer3.isBuffer(b)) {
          throw new TypeError(
            'The "buf1", "buf2" arguments must be one of type Buffer or Uint8Array'
          );
        }
        if (a === b) return 0;
        let x = a.length;
        let y = b.length;
        for (let i = 0, len = Math.min(x, y); i < len; ++i) {
          if (a[i] !== b[i]) {
            x = a[i];
            y = b[i];
            break;
          }
        }
        if (x < y) return -1;
        if (y < x) return 1;
        return 0;
      };
      Buffer3.isEncoding = function isEncoding(encoding) {
        switch (String(encoding).toLowerCase()) {
          case "hex":
          case "utf8":
          case "utf-8":
          case "ascii":
          case "latin1":
          case "binary":
          case "base64":
          case "ucs2":
          case "ucs-2":
          case "utf16le":
          case "utf-16le":
            return true;
          default:
            return false;
        }
      };
      Buffer3.concat = function concat(list, length) {
        if (!Array.isArray(list)) {
          throw new TypeError('"list" argument must be an Array of Buffers');
        }
        if (list.length === 0) {
          return Buffer3.alloc(0);
        }
        let i;
        if (length === void 0) {
          length = 0;
          for (i = 0; i < list.length; ++i) {
            length += list[i].length;
          }
        }
        const buffer = Buffer3.allocUnsafe(length);
        let pos = 0;
        for (i = 0; i < list.length; ++i) {
          let buf = list[i];
          if (isInstance(buf, Uint8Array)) {
            if (pos + buf.length > buffer.length) {
              if (!Buffer3.isBuffer(buf)) buf = Buffer3.from(buf);
              buf.copy(buffer, pos);
            } else {
              Uint8Array.prototype.set.call(
                buffer,
                buf,
                pos
              );
            }
          } else if (!Buffer3.isBuffer(buf)) {
            throw new TypeError('"list" argument must be an Array of Buffers');
          } else {
            buf.copy(buffer, pos);
          }
          pos += buf.length;
        }
        return buffer;
      };
      function byteLength(string2, encoding) {
        if (Buffer3.isBuffer(string2)) {
          return string2.length;
        }
        if (ArrayBuffer.isView(string2) || isInstance(string2, ArrayBuffer)) {
          return string2.byteLength;
        }
        if (typeof string2 !== "string") {
          throw new TypeError(
            'The "string" argument must be one of type string, Buffer, or ArrayBuffer. Received type ' + typeof string2
          );
        }
        const len = string2.length;
        const mustMatch = arguments.length > 2 && arguments[2] === true;
        if (!mustMatch && len === 0) return 0;
        let loweredCase = false;
        for (; ; ) {
          switch (encoding) {
            case "ascii":
            case "latin1":
            case "binary":
              return len;
            case "utf8":
            case "utf-8":
              return utf8ToBytes2(string2).length;
            case "ucs2":
            case "ucs-2":
            case "utf16le":
            case "utf-16le":
              return len * 2;
            case "hex":
              return len >>> 1;
            case "base64":
              return base64ToBytes(string2).length;
            default:
              if (loweredCase) {
                return mustMatch ? -1 : utf8ToBytes2(string2).length;
              }
              encoding = ("" + encoding).toLowerCase();
              loweredCase = true;
          }
        }
      }
      Buffer3.byteLength = byteLength;
      function slowToString(encoding, start, end) {
        let loweredCase = false;
        if (start === void 0 || start < 0) {
          start = 0;
        }
        if (start > this.length) {
          return "";
        }
        if (end === void 0 || end > this.length) {
          end = this.length;
        }
        if (end <= 0) {
          return "";
        }
        end >>>= 0;
        start >>>= 0;
        if (end <= start) {
          return "";
        }
        if (!encoding) encoding = "utf8";
        while (true) {
          switch (encoding) {
            case "hex":
              return hexSlice(this, start, end);
            case "utf8":
            case "utf-8":
              return utf8Slice(this, start, end);
            case "ascii":
              return asciiSlice(this, start, end);
            case "latin1":
            case "binary":
              return latin1Slice(this, start, end);
            case "base64":
              return base64Slice(this, start, end);
            case "ucs2":
            case "ucs-2":
            case "utf16le":
            case "utf-16le":
              return utf16leSlice(this, start, end);
            default:
              if (loweredCase) throw new TypeError("Unknown encoding: " + encoding);
              encoding = (encoding + "").toLowerCase();
              loweredCase = true;
          }
        }
      }
      Buffer3.prototype._isBuffer = true;
      function swap(b, n, m) {
        const i = b[n];
        b[n] = b[m];
        b[m] = i;
      }
      Buffer3.prototype.swap16 = function swap16() {
        const len = this.length;
        if (len % 2 !== 0) {
          throw new RangeError("Buffer size must be a multiple of 16-bits");
        }
        for (let i = 0; i < len; i += 2) {
          swap(this, i, i + 1);
        }
        return this;
      };
      Buffer3.prototype.swap32 = function swap32() {
        const len = this.length;
        if (len % 4 !== 0) {
          throw new RangeError("Buffer size must be a multiple of 32-bits");
        }
        for (let i = 0; i < len; i += 4) {
          swap(this, i, i + 3);
          swap(this, i + 1, i + 2);
        }
        return this;
      };
      Buffer3.prototype.swap64 = function swap64() {
        const len = this.length;
        if (len % 8 !== 0) {
          throw new RangeError("Buffer size must be a multiple of 64-bits");
        }
        for (let i = 0; i < len; i += 8) {
          swap(this, i, i + 7);
          swap(this, i + 1, i + 6);
          swap(this, i + 2, i + 5);
          swap(this, i + 3, i + 4);
        }
        return this;
      };
      Buffer3.prototype.toString = function toString2() {
        const length = this.length;
        if (length === 0) return "";
        if (arguments.length === 0) return utf8Slice(this, 0, length);
        return slowToString.apply(this, arguments);
      };
      Buffer3.prototype.toLocaleString = Buffer3.prototype.toString;
      Buffer3.prototype.equals = function equals(b) {
        if (!Buffer3.isBuffer(b)) throw new TypeError("Argument must be a Buffer");
        if (this === b) return true;
        return Buffer3.compare(this, b) === 0;
      };
      Buffer3.prototype.inspect = function inspect() {
        let str2 = "";
        const max = exports.INSPECT_MAX_BYTES;
        str2 = this.toString("hex", 0, max).replace(/(.{2})/g, "$1 ").trim();
        if (this.length > max) str2 += " ... ";
        return "<Buffer " + str2 + ">";
      };
      if (customInspectSymbol) {
        Buffer3.prototype[customInspectSymbol] = Buffer3.prototype.inspect;
      }
      Buffer3.prototype.compare = function compare(target, start, end, thisStart, thisEnd) {
        if (isInstance(target, Uint8Array)) {
          target = Buffer3.from(target, target.offset, target.byteLength);
        }
        if (!Buffer3.isBuffer(target)) {
          throw new TypeError(
            'The "target" argument must be one of type Buffer or Uint8Array. Received type ' + typeof target
          );
        }
        if (start === void 0) {
          start = 0;
        }
        if (end === void 0) {
          end = target ? target.length : 0;
        }
        if (thisStart === void 0) {
          thisStart = 0;
        }
        if (thisEnd === void 0) {
          thisEnd = this.length;
        }
        if (start < 0 || end > target.length || thisStart < 0 || thisEnd > this.length) {
          throw new RangeError("out of range index");
        }
        if (thisStart >= thisEnd && start >= end) {
          return 0;
        }
        if (thisStart >= thisEnd) {
          return -1;
        }
        if (start >= end) {
          return 1;
        }
        start >>>= 0;
        end >>>= 0;
        thisStart >>>= 0;
        thisEnd >>>= 0;
        if (this === target) return 0;
        let x = thisEnd - thisStart;
        let y = end - start;
        const len = Math.min(x, y);
        const thisCopy = this.slice(thisStart, thisEnd);
        const targetCopy = target.slice(start, end);
        for (let i = 0; i < len; ++i) {
          if (thisCopy[i] !== targetCopy[i]) {
            x = thisCopy[i];
            y = targetCopy[i];
            break;
          }
        }
        if (x < y) return -1;
        if (y < x) return 1;
        return 0;
      };
      function bidirectionalIndexOf(buffer, val, byteOffset, encoding, dir) {
        if (buffer.length === 0) return -1;
        if (typeof byteOffset === "string") {
          encoding = byteOffset;
          byteOffset = 0;
        } else if (byteOffset > 2147483647) {
          byteOffset = 2147483647;
        } else if (byteOffset < -2147483648) {
          byteOffset = -2147483648;
        }
        byteOffset = +byteOffset;
        if (numberIsNaN(byteOffset)) {
          byteOffset = dir ? 0 : buffer.length - 1;
        }
        if (byteOffset < 0) byteOffset = buffer.length + byteOffset;
        if (byteOffset >= buffer.length) {
          if (dir) return -1;
          else byteOffset = buffer.length - 1;
        } else if (byteOffset < 0) {
          if (dir) byteOffset = 0;
          else return -1;
        }
        if (typeof val === "string") {
          val = Buffer3.from(val, encoding);
        }
        if (Buffer3.isBuffer(val)) {
          if (val.length === 0) {
            return -1;
          }
          return arrayIndexOf(buffer, val, byteOffset, encoding, dir);
        } else if (typeof val === "number") {
          val = val & 255;
          if (typeof Uint8Array.prototype.indexOf === "function") {
            if (dir) {
              return Uint8Array.prototype.indexOf.call(buffer, val, byteOffset);
            } else {
              return Uint8Array.prototype.lastIndexOf.call(buffer, val, byteOffset);
            }
          }
          return arrayIndexOf(buffer, [val], byteOffset, encoding, dir);
        }
        throw new TypeError("val must be string, number or Buffer");
      }
      function arrayIndexOf(arr, val, byteOffset, encoding, dir) {
        let indexSize = 1;
        let arrLength = arr.length;
        let valLength = val.length;
        if (encoding !== void 0) {
          encoding = String(encoding).toLowerCase();
          if (encoding === "ucs2" || encoding === "ucs-2" || encoding === "utf16le" || encoding === "utf-16le") {
            if (arr.length < 2 || val.length < 2) {
              return -1;
            }
            indexSize = 2;
            arrLength /= 2;
            valLength /= 2;
            byteOffset /= 2;
          }
        }
        function read(buf, i2) {
          if (indexSize === 1) {
            return buf[i2];
          } else {
            return buf.readUInt16BE(i2 * indexSize);
          }
        }
        let i;
        if (dir) {
          let foundIndex = -1;
          for (i = byteOffset; i < arrLength; i++) {
            if (read(arr, i) === read(val, foundIndex === -1 ? 0 : i - foundIndex)) {
              if (foundIndex === -1) foundIndex = i;
              if (i - foundIndex + 1 === valLength) return foundIndex * indexSize;
            } else {
              if (foundIndex !== -1) i -= i - foundIndex;
              foundIndex = -1;
            }
          }
        } else {
          if (byteOffset + valLength > arrLength) byteOffset = arrLength - valLength;
          for (i = byteOffset; i >= 0; i--) {
            let found = true;
            for (let j = 0; j < valLength; j++) {
              if (read(arr, i + j) !== read(val, j)) {
                found = false;
                break;
              }
            }
            if (found) return i;
          }
        }
        return -1;
      }
      Buffer3.prototype.includes = function includes(val, byteOffset, encoding) {
        return this.indexOf(val, byteOffset, encoding) !== -1;
      };
      Buffer3.prototype.indexOf = function indexOf(val, byteOffset, encoding) {
        return bidirectionalIndexOf(this, val, byteOffset, encoding, true);
      };
      Buffer3.prototype.lastIndexOf = function lastIndexOf(val, byteOffset, encoding) {
        return bidirectionalIndexOf(this, val, byteOffset, encoding, false);
      };
      function hexWrite(buf, string2, offset2, length) {
        offset2 = Number(offset2) || 0;
        const remaining = buf.length - offset2;
        if (!length) {
          length = remaining;
        } else {
          length = Number(length);
          if (length > remaining) {
            length = remaining;
          }
        }
        const strLen = string2.length;
        if (length > strLen / 2) {
          length = strLen / 2;
        }
        let i;
        for (i = 0; i < length; ++i) {
          const parsed = parseInt(string2.substr(i * 2, 2), 16);
          if (numberIsNaN(parsed)) return i;
          buf[offset2 + i] = parsed;
        }
        return i;
      }
      function utf8Write(buf, string2, offset2, length) {
        return blitBuffer(utf8ToBytes2(string2, buf.length - offset2), buf, offset2, length);
      }
      function asciiWrite(buf, string2, offset2, length) {
        return blitBuffer(asciiToBytes(string2), buf, offset2, length);
      }
      function base64Write(buf, string2, offset2, length) {
        return blitBuffer(base64ToBytes(string2), buf, offset2, length);
      }
      function ucs2Write(buf, string2, offset2, length) {
        return blitBuffer(utf16leToBytes(string2, buf.length - offset2), buf, offset2, length);
      }
      Buffer3.prototype.write = function write(string2, offset2, length, encoding) {
        if (offset2 === void 0) {
          encoding = "utf8";
          length = this.length;
          offset2 = 0;
        } else if (length === void 0 && typeof offset2 === "string") {
          encoding = offset2;
          length = this.length;
          offset2 = 0;
        } else if (isFinite(offset2)) {
          offset2 = offset2 >>> 0;
          if (isFinite(length)) {
            length = length >>> 0;
            if (encoding === void 0) encoding = "utf8";
          } else {
            encoding = length;
            length = void 0;
          }
        } else {
          throw new Error(
            "Buffer.write(string, encoding, offset[, length]) is no longer supported"
          );
        }
        const remaining = this.length - offset2;
        if (length === void 0 || length > remaining) length = remaining;
        if (string2.length > 0 && (length < 0 || offset2 < 0) || offset2 > this.length) {
          throw new RangeError("Attempt to write outside buffer bounds");
        }
        if (!encoding) encoding = "utf8";
        let loweredCase = false;
        for (; ; ) {
          switch (encoding) {
            case "hex":
              return hexWrite(this, string2, offset2, length);
            case "utf8":
            case "utf-8":
              return utf8Write(this, string2, offset2, length);
            case "ascii":
            case "latin1":
            case "binary":
              return asciiWrite(this, string2, offset2, length);
            case "base64":
              return base64Write(this, string2, offset2, length);
            case "ucs2":
            case "ucs-2":
            case "utf16le":
            case "utf-16le":
              return ucs2Write(this, string2, offset2, length);
            default:
              if (loweredCase) throw new TypeError("Unknown encoding: " + encoding);
              encoding = ("" + encoding).toLowerCase();
              loweredCase = true;
          }
        }
      };
      Buffer3.prototype.toJSON = function toJSON() {
        return {
          type: "Buffer",
          data: Array.prototype.slice.call(this._arr || this, 0)
        };
      };
      function base64Slice(buf, start, end) {
        if (start === 0 && end === buf.length) {
          return base642.fromByteArray(buf);
        } else {
          return base642.fromByteArray(buf.slice(start, end));
        }
      }
      function utf8Slice(buf, start, end) {
        end = Math.min(buf.length, end);
        const res = [];
        let i = start;
        while (i < end) {
          const firstByte = buf[i];
          let codePoint = null;
          let bytesPerSequence = firstByte > 239 ? 4 : firstByte > 223 ? 3 : firstByte > 191 ? 2 : 1;
          if (i + bytesPerSequence <= end) {
            let secondByte, thirdByte, fourthByte, tempCodePoint;
            switch (bytesPerSequence) {
              case 1:
                if (firstByte < 128) {
                  codePoint = firstByte;
                }
                break;
              case 2:
                secondByte = buf[i + 1];
                if ((secondByte & 192) === 128) {
                  tempCodePoint = (firstByte & 31) << 6 | secondByte & 63;
                  if (tempCodePoint > 127) {
                    codePoint = tempCodePoint;
                  }
                }
                break;
              case 3:
                secondByte = buf[i + 1];
                thirdByte = buf[i + 2];
                if ((secondByte & 192) === 128 && (thirdByte & 192) === 128) {
                  tempCodePoint = (firstByte & 15) << 12 | (secondByte & 63) << 6 | thirdByte & 63;
                  if (tempCodePoint > 2047 && (tempCodePoint < 55296 || tempCodePoint > 57343)) {
                    codePoint = tempCodePoint;
                  }
                }
                break;
              case 4:
                secondByte = buf[i + 1];
                thirdByte = buf[i + 2];
                fourthByte = buf[i + 3];
                if ((secondByte & 192) === 128 && (thirdByte & 192) === 128 && (fourthByte & 192) === 128) {
                  tempCodePoint = (firstByte & 15) << 18 | (secondByte & 63) << 12 | (thirdByte & 63) << 6 | fourthByte & 63;
                  if (tempCodePoint > 65535 && tempCodePoint < 1114112) {
                    codePoint = tempCodePoint;
                  }
                }
            }
          }
          if (codePoint === null) {
            codePoint = 65533;
            bytesPerSequence = 1;
          } else if (codePoint > 65535) {
            codePoint -= 65536;
            res.push(codePoint >>> 10 & 1023 | 55296);
            codePoint = 56320 | codePoint & 1023;
          }
          res.push(codePoint);
          i += bytesPerSequence;
        }
        return decodeCodePointsArray(res);
      }
      var MAX_ARGUMENTS_LENGTH = 4096;
      function decodeCodePointsArray(codePoints) {
        const len = codePoints.length;
        if (len <= MAX_ARGUMENTS_LENGTH) {
          return String.fromCharCode.apply(String, codePoints);
        }
        let res = "";
        let i = 0;
        while (i < len) {
          res += String.fromCharCode.apply(
            String,
            codePoints.slice(i, i += MAX_ARGUMENTS_LENGTH)
          );
        }
        return res;
      }
      function asciiSlice(buf, start, end) {
        let ret = "";
        end = Math.min(buf.length, end);
        for (let i = start; i < end; ++i) {
          ret += String.fromCharCode(buf[i] & 127);
        }
        return ret;
      }
      function latin1Slice(buf, start, end) {
        let ret = "";
        end = Math.min(buf.length, end);
        for (let i = start; i < end; ++i) {
          ret += String.fromCharCode(buf[i]);
        }
        return ret;
      }
      function hexSlice(buf, start, end) {
        const len = buf.length;
        if (!start || start < 0) start = 0;
        if (!end || end < 0 || end > len) end = len;
        let out = "";
        for (let i = start; i < end; ++i) {
          out += hexSliceLookupTable[buf[i]];
        }
        return out;
      }
      function utf16leSlice(buf, start, end) {
        const bytes = buf.slice(start, end);
        let res = "";
        for (let i = 0; i < bytes.length - 1; i += 2) {
          res += String.fromCharCode(bytes[i] + bytes[i + 1] * 256);
        }
        return res;
      }
      Buffer3.prototype.slice = function slice(start, end) {
        const len = this.length;
        start = ~~start;
        end = end === void 0 ? len : ~~end;
        if (start < 0) {
          start += len;
          if (start < 0) start = 0;
        } else if (start > len) {
          start = len;
        }
        if (end < 0) {
          end += len;
          if (end < 0) end = 0;
        } else if (end > len) {
          end = len;
        }
        if (end < start) end = start;
        const newBuf = this.subarray(start, end);
        Object.setPrototypeOf(newBuf, Buffer3.prototype);
        return newBuf;
      };
      function checkOffset(offset2, ext, length) {
        if (offset2 % 1 !== 0 || offset2 < 0) throw new RangeError("offset is not uint");
        if (offset2 + ext > length) throw new RangeError("Trying to access beyond buffer length");
      }
      Buffer3.prototype.readUintLE = Buffer3.prototype.readUIntLE = function readUIntLE(offset2, byteLength2, noAssert) {
        offset2 = offset2 >>> 0;
        byteLength2 = byteLength2 >>> 0;
        if (!noAssert) checkOffset(offset2, byteLength2, this.length);
        let val = this[offset2];
        let mul = 1;
        let i = 0;
        while (++i < byteLength2 && (mul *= 256)) {
          val += this[offset2 + i] * mul;
        }
        return val;
      };
      Buffer3.prototype.readUintBE = Buffer3.prototype.readUIntBE = function readUIntBE(offset2, byteLength2, noAssert) {
        offset2 = offset2 >>> 0;
        byteLength2 = byteLength2 >>> 0;
        if (!noAssert) {
          checkOffset(offset2, byteLength2, this.length);
        }
        let val = this[offset2 + --byteLength2];
        let mul = 1;
        while (byteLength2 > 0 && (mul *= 256)) {
          val += this[offset2 + --byteLength2] * mul;
        }
        return val;
      };
      Buffer3.prototype.readUint8 = Buffer3.prototype.readUInt8 = function readUInt8(offset2, noAssert) {
        offset2 = offset2 >>> 0;
        if (!noAssert) checkOffset(offset2, 1, this.length);
        return this[offset2];
      };
      Buffer3.prototype.readUint16LE = Buffer3.prototype.readUInt16LE = function readUInt16LE(offset2, noAssert) {
        offset2 = offset2 >>> 0;
        if (!noAssert) checkOffset(offset2, 2, this.length);
        return this[offset2] | this[offset2 + 1] << 8;
      };
      Buffer3.prototype.readUint16BE = Buffer3.prototype.readUInt16BE = function readUInt16BE(offset2, noAssert) {
        offset2 = offset2 >>> 0;
        if (!noAssert) checkOffset(offset2, 2, this.length);
        return this[offset2] << 8 | this[offset2 + 1];
      };
      Buffer3.prototype.readUint32LE = Buffer3.prototype.readUInt32LE = function readUInt32LE(offset2, noAssert) {
        offset2 = offset2 >>> 0;
        if (!noAssert) checkOffset(offset2, 4, this.length);
        return (this[offset2] | this[offset2 + 1] << 8 | this[offset2 + 2] << 16) + this[offset2 + 3] * 16777216;
      };
      Buffer3.prototype.readUint32BE = Buffer3.prototype.readUInt32BE = function readUInt32BE(offset2, noAssert) {
        offset2 = offset2 >>> 0;
        if (!noAssert) checkOffset(offset2, 4, this.length);
        return this[offset2] * 16777216 + (this[offset2 + 1] << 16 | this[offset2 + 2] << 8 | this[offset2 + 3]);
      };
      Buffer3.prototype.readBigUInt64LE = defineBigIntMethod(function readBigUInt64LE(offset2) {
        offset2 = offset2 >>> 0;
        validateNumber(offset2, "offset");
        const first = this[offset2];
        const last = this[offset2 + 7];
        if (first === void 0 || last === void 0) {
          boundsError(offset2, this.length - 8);
        }
        const lo = first + this[++offset2] * 2 ** 8 + this[++offset2] * 2 ** 16 + this[++offset2] * 2 ** 24;
        const hi = this[++offset2] + this[++offset2] * 2 ** 8 + this[++offset2] * 2 ** 16 + last * 2 ** 24;
        return BigInt(lo) + (BigInt(hi) << BigInt(32));
      });
      Buffer3.prototype.readBigUInt64BE = defineBigIntMethod(function readBigUInt64BE(offset2) {
        offset2 = offset2 >>> 0;
        validateNumber(offset2, "offset");
        const first = this[offset2];
        const last = this[offset2 + 7];
        if (first === void 0 || last === void 0) {
          boundsError(offset2, this.length - 8);
        }
        const hi = first * 2 ** 24 + this[++offset2] * 2 ** 16 + this[++offset2] * 2 ** 8 + this[++offset2];
        const lo = this[++offset2] * 2 ** 24 + this[++offset2] * 2 ** 16 + this[++offset2] * 2 ** 8 + last;
        return (BigInt(hi) << BigInt(32)) + BigInt(lo);
      });
      Buffer3.prototype.readIntLE = function readIntLE(offset2, byteLength2, noAssert) {
        offset2 = offset2 >>> 0;
        byteLength2 = byteLength2 >>> 0;
        if (!noAssert) checkOffset(offset2, byteLength2, this.length);
        let val = this[offset2];
        let mul = 1;
        let i = 0;
        while (++i < byteLength2 && (mul *= 256)) {
          val += this[offset2 + i] * mul;
        }
        mul *= 128;
        if (val >= mul) val -= Math.pow(2, 8 * byteLength2);
        return val;
      };
      Buffer3.prototype.readIntBE = function readIntBE(offset2, byteLength2, noAssert) {
        offset2 = offset2 >>> 0;
        byteLength2 = byteLength2 >>> 0;
        if (!noAssert) checkOffset(offset2, byteLength2, this.length);
        let i = byteLength2;
        let mul = 1;
        let val = this[offset2 + --i];
        while (i > 0 && (mul *= 256)) {
          val += this[offset2 + --i] * mul;
        }
        mul *= 128;
        if (val >= mul) val -= Math.pow(2, 8 * byteLength2);
        return val;
      };
      Buffer3.prototype.readInt8 = function readInt8(offset2, noAssert) {
        offset2 = offset2 >>> 0;
        if (!noAssert) checkOffset(offset2, 1, this.length);
        if (!(this[offset2] & 128)) return this[offset2];
        return (255 - this[offset2] + 1) * -1;
      };
      Buffer3.prototype.readInt16LE = function readInt16LE(offset2, noAssert) {
        offset2 = offset2 >>> 0;
        if (!noAssert) checkOffset(offset2, 2, this.length);
        const val = this[offset2] | this[offset2 + 1] << 8;
        return val & 32768 ? val | 4294901760 : val;
      };
      Buffer3.prototype.readInt16BE = function readInt16BE(offset2, noAssert) {
        offset2 = offset2 >>> 0;
        if (!noAssert) checkOffset(offset2, 2, this.length);
        const val = this[offset2 + 1] | this[offset2] << 8;
        return val & 32768 ? val | 4294901760 : val;
      };
      Buffer3.prototype.readInt32LE = function readInt32LE(offset2, noAssert) {
        offset2 = offset2 >>> 0;
        if (!noAssert) checkOffset(offset2, 4, this.length);
        return this[offset2] | this[offset2 + 1] << 8 | this[offset2 + 2] << 16 | this[offset2 + 3] << 24;
      };
      Buffer3.prototype.readInt32BE = function readInt32BE(offset2, noAssert) {
        offset2 = offset2 >>> 0;
        if (!noAssert) checkOffset(offset2, 4, this.length);
        return this[offset2] << 24 | this[offset2 + 1] << 16 | this[offset2 + 2] << 8 | this[offset2 + 3];
      };
      Buffer3.prototype.readBigInt64LE = defineBigIntMethod(function readBigInt64LE(offset2) {
        offset2 = offset2 >>> 0;
        validateNumber(offset2, "offset");
        const first = this[offset2];
        const last = this[offset2 + 7];
        if (first === void 0 || last === void 0) {
          boundsError(offset2, this.length - 8);
        }
        const val = this[offset2 + 4] + this[offset2 + 5] * 2 ** 8 + this[offset2 + 6] * 2 ** 16 + (last << 24);
        return (BigInt(val) << BigInt(32)) + BigInt(first + this[++offset2] * 2 ** 8 + this[++offset2] * 2 ** 16 + this[++offset2] * 2 ** 24);
      });
      Buffer3.prototype.readBigInt64BE = defineBigIntMethod(function readBigInt64BE(offset2) {
        offset2 = offset2 >>> 0;
        validateNumber(offset2, "offset");
        const first = this[offset2];
        const last = this[offset2 + 7];
        if (first === void 0 || last === void 0) {
          boundsError(offset2, this.length - 8);
        }
        const val = (first << 24) + // Overflow
        this[++offset2] * 2 ** 16 + this[++offset2] * 2 ** 8 + this[++offset2];
        return (BigInt(val) << BigInt(32)) + BigInt(this[++offset2] * 2 ** 24 + this[++offset2] * 2 ** 16 + this[++offset2] * 2 ** 8 + last);
      });
      Buffer3.prototype.readFloatLE = function readFloatLE(offset2, noAssert) {
        offset2 = offset2 >>> 0;
        if (!noAssert) checkOffset(offset2, 4, this.length);
        return ieee754.read(this, offset2, true, 23, 4);
      };
      Buffer3.prototype.readFloatBE = function readFloatBE(offset2, noAssert) {
        offset2 = offset2 >>> 0;
        if (!noAssert) checkOffset(offset2, 4, this.length);
        return ieee754.read(this, offset2, false, 23, 4);
      };
      Buffer3.prototype.readDoubleLE = function readDoubleLE(offset2, noAssert) {
        offset2 = offset2 >>> 0;
        if (!noAssert) checkOffset(offset2, 8, this.length);
        return ieee754.read(this, offset2, true, 52, 8);
      };
      Buffer3.prototype.readDoubleBE = function readDoubleBE(offset2, noAssert) {
        offset2 = offset2 >>> 0;
        if (!noAssert) checkOffset(offset2, 8, this.length);
        return ieee754.read(this, offset2, false, 52, 8);
      };
      function checkInt(buf, value, offset2, ext, max, min) {
        if (!Buffer3.isBuffer(buf)) throw new TypeError('"buffer" argument must be a Buffer instance');
        if (value > max || value < min) throw new RangeError('"value" argument is out of bounds');
        if (offset2 + ext > buf.length) throw new RangeError("Index out of range");
      }
      Buffer3.prototype.writeUintLE = Buffer3.prototype.writeUIntLE = function writeUIntLE(value, offset2, byteLength2, noAssert) {
        value = +value;
        offset2 = offset2 >>> 0;
        byteLength2 = byteLength2 >>> 0;
        if (!noAssert) {
          const maxBytes = Math.pow(2, 8 * byteLength2) - 1;
          checkInt(this, value, offset2, byteLength2, maxBytes, 0);
        }
        let mul = 1;
        let i = 0;
        this[offset2] = value & 255;
        while (++i < byteLength2 && (mul *= 256)) {
          this[offset2 + i] = value / mul & 255;
        }
        return offset2 + byteLength2;
      };
      Buffer3.prototype.writeUintBE = Buffer3.prototype.writeUIntBE = function writeUIntBE(value, offset2, byteLength2, noAssert) {
        value = +value;
        offset2 = offset2 >>> 0;
        byteLength2 = byteLength2 >>> 0;
        if (!noAssert) {
          const maxBytes = Math.pow(2, 8 * byteLength2) - 1;
          checkInt(this, value, offset2, byteLength2, maxBytes, 0);
        }
        let i = byteLength2 - 1;
        let mul = 1;
        this[offset2 + i] = value & 255;
        while (--i >= 0 && (mul *= 256)) {
          this[offset2 + i] = value / mul & 255;
        }
        return offset2 + byteLength2;
      };
      Buffer3.prototype.writeUint8 = Buffer3.prototype.writeUInt8 = function writeUInt8(value, offset2, noAssert) {
        value = +value;
        offset2 = offset2 >>> 0;
        if (!noAssert) checkInt(this, value, offset2, 1, 255, 0);
        this[offset2] = value & 255;
        return offset2 + 1;
      };
      Buffer3.prototype.writeUint16LE = Buffer3.prototype.writeUInt16LE = function writeUInt16LE(value, offset2, noAssert) {
        value = +value;
        offset2 = offset2 >>> 0;
        if (!noAssert) checkInt(this, value, offset2, 2, 65535, 0);
        this[offset2] = value & 255;
        this[offset2 + 1] = value >>> 8;
        return offset2 + 2;
      };
      Buffer3.prototype.writeUint16BE = Buffer3.prototype.writeUInt16BE = function writeUInt16BE(value, offset2, noAssert) {
        value = +value;
        offset2 = offset2 >>> 0;
        if (!noAssert) checkInt(this, value, offset2, 2, 65535, 0);
        this[offset2] = value >>> 8;
        this[offset2 + 1] = value & 255;
        return offset2 + 2;
      };
      Buffer3.prototype.writeUint32LE = Buffer3.prototype.writeUInt32LE = function writeUInt32LE(value, offset2, noAssert) {
        value = +value;
        offset2 = offset2 >>> 0;
        if (!noAssert) checkInt(this, value, offset2, 4, 4294967295, 0);
        this[offset2 + 3] = value >>> 24;
        this[offset2 + 2] = value >>> 16;
        this[offset2 + 1] = value >>> 8;
        this[offset2] = value & 255;
        return offset2 + 4;
      };
      Buffer3.prototype.writeUint32BE = Buffer3.prototype.writeUInt32BE = function writeUInt32BE(value, offset2, noAssert) {
        value = +value;
        offset2 = offset2 >>> 0;
        if (!noAssert) checkInt(this, value, offset2, 4, 4294967295, 0);
        this[offset2] = value >>> 24;
        this[offset2 + 1] = value >>> 16;
        this[offset2 + 2] = value >>> 8;
        this[offset2 + 3] = value & 255;
        return offset2 + 4;
      };
      function wrtBigUInt64LE(buf, value, offset2, min, max) {
        checkIntBI(value, min, max, buf, offset2, 7);
        let lo = Number(value & BigInt(4294967295));
        buf[offset2++] = lo;
        lo = lo >> 8;
        buf[offset2++] = lo;
        lo = lo >> 8;
        buf[offset2++] = lo;
        lo = lo >> 8;
        buf[offset2++] = lo;
        let hi = Number(value >> BigInt(32) & BigInt(4294967295));
        buf[offset2++] = hi;
        hi = hi >> 8;
        buf[offset2++] = hi;
        hi = hi >> 8;
        buf[offset2++] = hi;
        hi = hi >> 8;
        buf[offset2++] = hi;
        return offset2;
      }
      function wrtBigUInt64BE(buf, value, offset2, min, max) {
        checkIntBI(value, min, max, buf, offset2, 7);
        let lo = Number(value & BigInt(4294967295));
        buf[offset2 + 7] = lo;
        lo = lo >> 8;
        buf[offset2 + 6] = lo;
        lo = lo >> 8;
        buf[offset2 + 5] = lo;
        lo = lo >> 8;
        buf[offset2 + 4] = lo;
        let hi = Number(value >> BigInt(32) & BigInt(4294967295));
        buf[offset2 + 3] = hi;
        hi = hi >> 8;
        buf[offset2 + 2] = hi;
        hi = hi >> 8;
        buf[offset2 + 1] = hi;
        hi = hi >> 8;
        buf[offset2] = hi;
        return offset2 + 8;
      }
      Buffer3.prototype.writeBigUInt64LE = defineBigIntMethod(function writeBigUInt64LE(value, offset2 = 0) {
        return wrtBigUInt64LE(this, value, offset2, BigInt(0), BigInt("0xffffffffffffffff"));
      });
      Buffer3.prototype.writeBigUInt64BE = defineBigIntMethod(function writeBigUInt64BE(value, offset2 = 0) {
        return wrtBigUInt64BE(this, value, offset2, BigInt(0), BigInt("0xffffffffffffffff"));
      });
      Buffer3.prototype.writeIntLE = function writeIntLE(value, offset2, byteLength2, noAssert) {
        value = +value;
        offset2 = offset2 >>> 0;
        if (!noAssert) {
          const limit = Math.pow(2, 8 * byteLength2 - 1);
          checkInt(this, value, offset2, byteLength2, limit - 1, -limit);
        }
        let i = 0;
        let mul = 1;
        let sub = 0;
        this[offset2] = value & 255;
        while (++i < byteLength2 && (mul *= 256)) {
          if (value < 0 && sub === 0 && this[offset2 + i - 1] !== 0) {
            sub = 1;
          }
          this[offset2 + i] = (value / mul >> 0) - sub & 255;
        }
        return offset2 + byteLength2;
      };
      Buffer3.prototype.writeIntBE = function writeIntBE(value, offset2, byteLength2, noAssert) {
        value = +value;
        offset2 = offset2 >>> 0;
        if (!noAssert) {
          const limit = Math.pow(2, 8 * byteLength2 - 1);
          checkInt(this, value, offset2, byteLength2, limit - 1, -limit);
        }
        let i = byteLength2 - 1;
        let mul = 1;
        let sub = 0;
        this[offset2 + i] = value & 255;
        while (--i >= 0 && (mul *= 256)) {
          if (value < 0 && sub === 0 && this[offset2 + i + 1] !== 0) {
            sub = 1;
          }
          this[offset2 + i] = (value / mul >> 0) - sub & 255;
        }
        return offset2 + byteLength2;
      };
      Buffer3.prototype.writeInt8 = function writeInt8(value, offset2, noAssert) {
        value = +value;
        offset2 = offset2 >>> 0;
        if (!noAssert) checkInt(this, value, offset2, 1, 127, -128);
        if (value < 0) value = 255 + value + 1;
        this[offset2] = value & 255;
        return offset2 + 1;
      };
      Buffer3.prototype.writeInt16LE = function writeInt16LE(value, offset2, noAssert) {
        value = +value;
        offset2 = offset2 >>> 0;
        if (!noAssert) checkInt(this, value, offset2, 2, 32767, -32768);
        this[offset2] = value & 255;
        this[offset2 + 1] = value >>> 8;
        return offset2 + 2;
      };
      Buffer3.prototype.writeInt16BE = function writeInt16BE(value, offset2, noAssert) {
        value = +value;
        offset2 = offset2 >>> 0;
        if (!noAssert) checkInt(this, value, offset2, 2, 32767, -32768);
        this[offset2] = value >>> 8;
        this[offset2 + 1] = value & 255;
        return offset2 + 2;
      };
      Buffer3.prototype.writeInt32LE = function writeInt32LE(value, offset2, noAssert) {
        value = +value;
        offset2 = offset2 >>> 0;
        if (!noAssert) checkInt(this, value, offset2, 4, 2147483647, -2147483648);
        this[offset2] = value & 255;
        this[offset2 + 1] = value >>> 8;
        this[offset2 + 2] = value >>> 16;
        this[offset2 + 3] = value >>> 24;
        return offset2 + 4;
      };
      Buffer3.prototype.writeInt32BE = function writeInt32BE(value, offset2, noAssert) {
        value = +value;
        offset2 = offset2 >>> 0;
        if (!noAssert) checkInt(this, value, offset2, 4, 2147483647, -2147483648);
        if (value < 0) value = 4294967295 + value + 1;
        this[offset2] = value >>> 24;
        this[offset2 + 1] = value >>> 16;
        this[offset2 + 2] = value >>> 8;
        this[offset2 + 3] = value & 255;
        return offset2 + 4;
      };
      Buffer3.prototype.writeBigInt64LE = defineBigIntMethod(function writeBigInt64LE(value, offset2 = 0) {
        return wrtBigUInt64LE(this, value, offset2, -BigInt("0x8000000000000000"), BigInt("0x7fffffffffffffff"));
      });
      Buffer3.prototype.writeBigInt64BE = defineBigIntMethod(function writeBigInt64BE(value, offset2 = 0) {
        return wrtBigUInt64BE(this, value, offset2, -BigInt("0x8000000000000000"), BigInt("0x7fffffffffffffff"));
      });
      function checkIEEE754(buf, value, offset2, ext, max, min) {
        if (offset2 + ext > buf.length) throw new RangeError("Index out of range");
        if (offset2 < 0) throw new RangeError("Index out of range");
      }
      function writeFloat(buf, value, offset2, littleEndian, noAssert) {
        value = +value;
        offset2 = offset2 >>> 0;
        if (!noAssert) {
          checkIEEE754(buf, value, offset2, 4, 34028234663852886e22, -34028234663852886e22);
        }
        ieee754.write(buf, value, offset2, littleEndian, 23, 4);
        return offset2 + 4;
      }
      Buffer3.prototype.writeFloatLE = function writeFloatLE(value, offset2, noAssert) {
        return writeFloat(this, value, offset2, true, noAssert);
      };
      Buffer3.prototype.writeFloatBE = function writeFloatBE(value, offset2, noAssert) {
        return writeFloat(this, value, offset2, false, noAssert);
      };
      function writeDouble(buf, value, offset2, littleEndian, noAssert) {
        value = +value;
        offset2 = offset2 >>> 0;
        if (!noAssert) {
          checkIEEE754(buf, value, offset2, 8, 17976931348623157e292, -17976931348623157e292);
        }
        ieee754.write(buf, value, offset2, littleEndian, 52, 8);
        return offset2 + 8;
      }
      Buffer3.prototype.writeDoubleLE = function writeDoubleLE(value, offset2, noAssert) {
        return writeDouble(this, value, offset2, true, noAssert);
      };
      Buffer3.prototype.writeDoubleBE = function writeDoubleBE(value, offset2, noAssert) {
        return writeDouble(this, value, offset2, false, noAssert);
      };
      Buffer3.prototype.copy = function copy(target, targetStart, start, end) {
        if (!Buffer3.isBuffer(target)) throw new TypeError("argument should be a Buffer");
        if (!start) start = 0;
        if (!end && end !== 0) end = this.length;
        if (targetStart >= target.length) targetStart = target.length;
        if (!targetStart) targetStart = 0;
        if (end > 0 && end < start) end = start;
        if (end === start) return 0;
        if (target.length === 0 || this.length === 0) return 0;
        if (targetStart < 0) {
          throw new RangeError("targetStart out of bounds");
        }
        if (start < 0 || start >= this.length) throw new RangeError("Index out of range");
        if (end < 0) throw new RangeError("sourceEnd out of bounds");
        if (end > this.length) end = this.length;
        if (target.length - targetStart < end - start) {
          end = target.length - targetStart + start;
        }
        const len = end - start;
        if (this === target && typeof Uint8Array.prototype.copyWithin === "function") {
          this.copyWithin(targetStart, start, end);
        } else {
          Uint8Array.prototype.set.call(
            target,
            this.subarray(start, end),
            targetStart
          );
        }
        return len;
      };
      Buffer3.prototype.fill = function fill(val, start, end, encoding) {
        if (typeof val === "string") {
          if (typeof start === "string") {
            encoding = start;
            start = 0;
            end = this.length;
          } else if (typeof end === "string") {
            encoding = end;
            end = this.length;
          }
          if (encoding !== void 0 && typeof encoding !== "string") {
            throw new TypeError("encoding must be a string");
          }
          if (typeof encoding === "string" && !Buffer3.isEncoding(encoding)) {
            throw new TypeError("Unknown encoding: " + encoding);
          }
          if (val.length === 1) {
            const code = val.charCodeAt(0);
            if (encoding === "utf8" && code < 128 || encoding === "latin1") {
              val = code;
            }
          }
        } else if (typeof val === "number") {
          val = val & 255;
        } else if (typeof val === "boolean") {
          val = Number(val);
        }
        if (start < 0 || this.length < start || this.length < end) {
          throw new RangeError("Out of range index");
        }
        if (end <= start) {
          return this;
        }
        start = start >>> 0;
        end = end === void 0 ? this.length : end >>> 0;
        if (!val) val = 0;
        let i;
        if (typeof val === "number") {
          for (i = start; i < end; ++i) {
            this[i] = val;
          }
        } else {
          const bytes = Buffer3.isBuffer(val) ? val : Buffer3.from(val, encoding);
          const len = bytes.length;
          if (len === 0) {
            throw new TypeError('The value "' + val + '" is invalid for argument "value"');
          }
          for (i = 0; i < end - start; ++i) {
            this[i + start] = bytes[i % len];
          }
        }
        return this;
      };
      var errors = {};
      function E(sym, getMessage, Base) {
        errors[sym] = class NodeError extends Base {
          constructor() {
            super();
            Object.defineProperty(this, "message", {
              value: getMessage.apply(this, arguments),
              writable: true,
              configurable: true
            });
            this.name = `${this.name} [${sym}]`;
            this.stack;
            delete this.name;
          }
          get code() {
            return sym;
          }
          set code(value) {
            Object.defineProperty(this, "code", {
              configurable: true,
              enumerable: true,
              value,
              writable: true
            });
          }
          toString() {
            return `${this.name} [${sym}]: ${this.message}`;
          }
        };
      }
      E(
        "ERR_BUFFER_OUT_OF_BOUNDS",
        function(name) {
          if (name) {
            return `${name} is outside of buffer bounds`;
          }
          return "Attempt to access memory outside buffer bounds";
        },
        RangeError
      );
      E(
        "ERR_INVALID_ARG_TYPE",
        function(name, actual) {
          return `The "${name}" argument must be of type number. Received type ${typeof actual}`;
        },
        TypeError
      );
      E(
        "ERR_OUT_OF_RANGE",
        function(str2, range, input) {
          let msg = `The value of "${str2}" is out of range.`;
          let received = input;
          if (Number.isInteger(input) && Math.abs(input) > 2 ** 32) {
            received = addNumericalSeparator(String(input));
          } else if (typeof input === "bigint") {
            received = String(input);
            if (input > BigInt(2) ** BigInt(32) || input < -(BigInt(2) ** BigInt(32))) {
              received = addNumericalSeparator(received);
            }
            received += "n";
          }
          msg += ` It must be ${range}. Received ${received}`;
          return msg;
        },
        RangeError
      );
      function addNumericalSeparator(val) {
        let res = "";
        let i = val.length;
        const start = val[0] === "-" ? 1 : 0;
        for (; i >= start + 4; i -= 3) {
          res = `_${val.slice(i - 3, i)}${res}`;
        }
        return `${val.slice(0, i)}${res}`;
      }
      function checkBounds(buf, offset2, byteLength2) {
        validateNumber(offset2, "offset");
        if (buf[offset2] === void 0 || buf[offset2 + byteLength2] === void 0) {
          boundsError(offset2, buf.length - (byteLength2 + 1));
        }
      }
      function checkIntBI(value, min, max, buf, offset2, byteLength2) {
        if (value > max || value < min) {
          const n = typeof min === "bigint" ? "n" : "";
          let range;
          if (byteLength2 > 3) {
            if (min === 0 || min === BigInt(0)) {
              range = `>= 0${n} and < 2${n} ** ${(byteLength2 + 1) * 8}${n}`;
            } else {
              range = `>= -(2${n} ** ${(byteLength2 + 1) * 8 - 1}${n}) and < 2 ** ${(byteLength2 + 1) * 8 - 1}${n}`;
            }
          } else {
            range = `>= ${min}${n} and <= ${max}${n}`;
          }
          throw new errors.ERR_OUT_OF_RANGE("value", range, value);
        }
        checkBounds(buf, offset2, byteLength2);
      }
      function validateNumber(value, name) {
        if (typeof value !== "number") {
          throw new errors.ERR_INVALID_ARG_TYPE(name, "number", value);
        }
      }
      function boundsError(value, length, type2) {
        if (Math.floor(value) !== value) {
          validateNumber(value, type2);
          throw new errors.ERR_OUT_OF_RANGE(type2 || "offset", "an integer", value);
        }
        if (length < 0) {
          throw new errors.ERR_BUFFER_OUT_OF_BOUNDS();
        }
        throw new errors.ERR_OUT_OF_RANGE(
          type2 || "offset",
          `>= ${type2 ? 1 : 0} and <= ${length}`,
          value
        );
      }
      var INVALID_BASE64_RE = /[^+/0-9A-Za-z-_]/g;
      function base64clean(str2) {
        str2 = str2.split("=")[0];
        str2 = str2.trim().replace(INVALID_BASE64_RE, "");
        if (str2.length < 2) return "";
        while (str2.length % 4 !== 0) {
          str2 = str2 + "=";
        }
        return str2;
      }
      function utf8ToBytes2(string2, units) {
        units = units || Infinity;
        let codePoint;
        const length = string2.length;
        let leadSurrogate = null;
        const bytes = [];
        for (let i = 0; i < length; ++i) {
          codePoint = string2.charCodeAt(i);
          if (codePoint > 55295 && codePoint < 57344) {
            if (!leadSurrogate) {
              if (codePoint > 56319) {
                if ((units -= 3) > -1) bytes.push(239, 191, 189);
                continue;
              } else if (i + 1 === length) {
                if ((units -= 3) > -1) bytes.push(239, 191, 189);
                continue;
              }
              leadSurrogate = codePoint;
              continue;
            }
            if (codePoint < 56320) {
              if ((units -= 3) > -1) bytes.push(239, 191, 189);
              leadSurrogate = codePoint;
              continue;
            }
            codePoint = (leadSurrogate - 55296 << 10 | codePoint - 56320) + 65536;
          } else if (leadSurrogate) {
            if ((units -= 3) > -1) bytes.push(239, 191, 189);
          }
          leadSurrogate = null;
          if (codePoint < 128) {
            if ((units -= 1) < 0) break;
            bytes.push(codePoint);
          } else if (codePoint < 2048) {
            if ((units -= 2) < 0) break;
            bytes.push(
              codePoint >> 6 | 192,
              codePoint & 63 | 128
            );
          } else if (codePoint < 65536) {
            if ((units -= 3) < 0) break;
            bytes.push(
              codePoint >> 12 | 224,
              codePoint >> 6 & 63 | 128,
              codePoint & 63 | 128
            );
          } else if (codePoint < 1114112) {
            if ((units -= 4) < 0) break;
            bytes.push(
              codePoint >> 18 | 240,
              codePoint >> 12 & 63 | 128,
              codePoint >> 6 & 63 | 128,
              codePoint & 63 | 128
            );
          } else {
            throw new Error("Invalid code point");
          }
        }
        return bytes;
      }
      function asciiToBytes(str2) {
        const byteArray = [];
        for (let i = 0; i < str2.length; ++i) {
          byteArray.push(str2.charCodeAt(i) & 255);
        }
        return byteArray;
      }
      function utf16leToBytes(str2, units) {
        let c, hi, lo;
        const byteArray = [];
        for (let i = 0; i < str2.length; ++i) {
          if ((units -= 2) < 0) break;
          c = str2.charCodeAt(i);
          hi = c >> 8;
          lo = c % 256;
          byteArray.push(lo);
          byteArray.push(hi);
        }
        return byteArray;
      }
      function base64ToBytes(str2) {
        return base642.toByteArray(base64clean(str2));
      }
      function blitBuffer(src, dst, offset2, length) {
        let i;
        for (i = 0; i < length; ++i) {
          if (i + offset2 >= dst.length || i >= src.length) break;
          dst[i + offset2] = src[i];
        }
        return i;
      }
      function isInstance(obj, type2) {
        return obj instanceof type2 || obj != null && obj.constructor != null && obj.constructor.name != null && obj.constructor.name === type2.name;
      }
      function numberIsNaN(obj) {
        return obj !== obj;
      }
      var hexSliceLookupTable = (function() {
        const alphabet = "0123456789abcdef";
        const table = new Array(256);
        for (let i = 0; i < 16; ++i) {
          const i162 = i * 16;
          for (let j = 0; j < 16; ++j) {
            table[i162 + j] = alphabet[i] + alphabet[j];
          }
        }
        return table;
      })();
      function defineBigIntMethod(fn) {
        return typeof BigInt === "undefined" ? BufferBigIntNotDefined : fn;
      }
      function BufferBigIntNotDefined() {
        throw new Error("BigInt not supported");
      }
    }
  });

  // node_modules/@noble/hashes/crypto.js
  var require_crypto = __commonJS({
    "node_modules/@noble/hashes/crypto.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.crypto = void 0;
      exports.crypto = typeof globalThis === "object" && "crypto" in globalThis ? globalThis.crypto : void 0;
    }
  });

  // node_modules/@noble/hashes/utils.js
  var require_utils = __commonJS({
    "node_modules/@noble/hashes/utils.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.wrapXOFConstructorWithOpts = exports.wrapConstructorWithOpts = exports.wrapConstructor = exports.Hash = exports.nextTick = exports.swap32IfBE = exports.byteSwapIfBE = exports.swap8IfBE = exports.isLE = void 0;
      exports.isBytes = isBytes2;
      exports.anumber = anumber;
      exports.abytes = abytes2;
      exports.ahash = ahash;
      exports.aexists = aexists2;
      exports.aoutput = aoutput2;
      exports.u8 = u83;
      exports.u32 = u323;
      exports.clean = clean2;
      exports.createView = createView2;
      exports.rotr = rotr2;
      exports.rotl = rotl;
      exports.byteSwap = byteSwap;
      exports.byteSwap32 = byteSwap32;
      exports.bytesToHex = bytesToHex;
      exports.hexToBytes = hexToBytes;
      exports.asyncLoop = asyncLoop;
      exports.utf8ToBytes = utf8ToBytes2;
      exports.bytesToUtf8 = bytesToUtf8;
      exports.toBytes = toBytes2;
      exports.kdfInputToBytes = kdfInputToBytes;
      exports.concatBytes = concatBytes;
      exports.checkOpts = checkOpts;
      exports.createHasher = createHasher2;
      exports.createOptHasher = createOptHasher;
      exports.createXOFer = createXOFer;
      exports.randomBytes = randomBytes;
      var crypto_1 = require_crypto();
      function isBytes2(a) {
        return a instanceof Uint8Array || ArrayBuffer.isView(a) && a.constructor.name === "Uint8Array";
      }
      function anumber(n) {
        if (!Number.isSafeInteger(n) || n < 0)
          throw new Error("positive integer expected, got " + n);
      }
      function abytes2(b, ...lengths) {
        if (!isBytes2(b))
          throw new Error("Uint8Array expected");
        if (lengths.length > 0 && !lengths.includes(b.length))
          throw new Error("Uint8Array expected of length " + lengths + ", got length=" + b.length);
      }
      function ahash(h) {
        if (typeof h !== "function" || typeof h.create !== "function")
          throw new Error("Hash should be wrapped by utils.createHasher");
        anumber(h.outputLen);
        anumber(h.blockLen);
      }
      function aexists2(instance, checkFinished = true) {
        if (instance.destroyed)
          throw new Error("Hash instance has been destroyed");
        if (checkFinished && instance.finished)
          throw new Error("Hash#digest() has already been called");
      }
      function aoutput2(out, instance) {
        abytes2(out);
        const min = instance.outputLen;
        if (out.length < min) {
          throw new Error("digestInto() expects output buffer of length at least " + min);
        }
      }
      function u83(arr) {
        return new Uint8Array(arr.buffer, arr.byteOffset, arr.byteLength);
      }
      function u323(arr) {
        return new Uint32Array(arr.buffer, arr.byteOffset, Math.floor(arr.byteLength / 4));
      }
      function clean2(...arrays) {
        for (let i = 0; i < arrays.length; i++) {
          arrays[i].fill(0);
        }
      }
      function createView2(arr) {
        return new DataView(arr.buffer, arr.byteOffset, arr.byteLength);
      }
      function rotr2(word, shift) {
        return word << 32 - shift | word >>> shift;
      }
      function rotl(word, shift) {
        return word << shift | word >>> 32 - shift >>> 0;
      }
      exports.isLE = (() => new Uint8Array(new Uint32Array([287454020]).buffer)[0] === 68)();
      function byteSwap(word) {
        return word << 24 & 4278190080 | word << 8 & 16711680 | word >>> 8 & 65280 | word >>> 24 & 255;
      }
      exports.swap8IfBE = exports.isLE ? (n) => n : (n) => byteSwap(n);
      exports.byteSwapIfBE = exports.swap8IfBE;
      function byteSwap32(arr) {
        for (let i = 0; i < arr.length; i++) {
          arr[i] = byteSwap(arr[i]);
        }
        return arr;
      }
      exports.swap32IfBE = exports.isLE ? (u) => u : byteSwap32;
      var hasHexBuiltin = /* @__PURE__ */ (() => (
        // @ts-ignore
        typeof Uint8Array.from([]).toHex === "function" && typeof Uint8Array.fromHex === "function"
      ))();
      var hexes = /* @__PURE__ */ Array.from({ length: 256 }, (_, i) => i.toString(16).padStart(2, "0"));
      function bytesToHex(bytes) {
        abytes2(bytes);
        if (hasHexBuiltin)
          return bytes.toHex();
        let hex2 = "";
        for (let i = 0; i < bytes.length; i++) {
          hex2 += hexes[bytes[i]];
        }
        return hex2;
      }
      var asciis = { _0: 48, _9: 57, A: 65, F: 70, a: 97, f: 102 };
      function asciiToBase16(ch) {
        if (ch >= asciis._0 && ch <= asciis._9)
          return ch - asciis._0;
        if (ch >= asciis.A && ch <= asciis.F)
          return ch - (asciis.A - 10);
        if (ch >= asciis.a && ch <= asciis.f)
          return ch - (asciis.a - 10);
        return;
      }
      function hexToBytes(hex2) {
        if (typeof hex2 !== "string")
          throw new Error("hex string expected, got " + typeof hex2);
        if (hasHexBuiltin)
          return Uint8Array.fromHex(hex2);
        const hl = hex2.length;
        const al = hl / 2;
        if (hl % 2)
          throw new Error("hex string expected, got unpadded hex of length " + hl);
        const array3 = new Uint8Array(al);
        for (let ai = 0, hi = 0; ai < al; ai++, hi += 2) {
          const n1 = asciiToBase16(hex2.charCodeAt(hi));
          const n2 = asciiToBase16(hex2.charCodeAt(hi + 1));
          if (n1 === void 0 || n2 === void 0) {
            const char = hex2[hi] + hex2[hi + 1];
            throw new Error('hex string expected, got non-hex character "' + char + '" at index ' + hi);
          }
          array3[ai] = n1 * 16 + n2;
        }
        return array3;
      }
      var nextTick = async () => {
      };
      exports.nextTick = nextTick;
      async function asyncLoop(iters, tick, cb) {
        let ts = Date.now();
        for (let i = 0; i < iters; i++) {
          cb(i);
          const diff = Date.now() - ts;
          if (diff >= 0 && diff < tick)
            continue;
          await (0, exports.nextTick)();
          ts += diff;
        }
      }
      function utf8ToBytes2(str2) {
        if (typeof str2 !== "string")
          throw new Error("string expected");
        return new Uint8Array(new TextEncoder().encode(str2));
      }
      function bytesToUtf8(bytes) {
        return new TextDecoder().decode(bytes);
      }
      function toBytes2(data) {
        if (typeof data === "string")
          data = utf8ToBytes2(data);
        abytes2(data);
        return data;
      }
      function kdfInputToBytes(data) {
        if (typeof data === "string")
          data = utf8ToBytes2(data);
        abytes2(data);
        return data;
      }
      function concatBytes(...arrays) {
        let sum = 0;
        for (let i = 0; i < arrays.length; i++) {
          const a = arrays[i];
          abytes2(a);
          sum += a.length;
        }
        const res = new Uint8Array(sum);
        for (let i = 0, pad = 0; i < arrays.length; i++) {
          const a = arrays[i];
          res.set(a, pad);
          pad += a.length;
        }
        return res;
      }
      function checkOpts(defaults, opts) {
        if (opts !== void 0 && {}.toString.call(opts) !== "[object Object]")
          throw new Error("options should be object or undefined");
        const merged = Object.assign(defaults, opts);
        return merged;
      }
      var Hash2 = class {
      };
      exports.Hash = Hash2;
      function createHasher2(hashCons) {
        const hashC = (msg) => hashCons().update(toBytes2(msg)).digest();
        const tmp = hashCons();
        hashC.outputLen = tmp.outputLen;
        hashC.blockLen = tmp.blockLen;
        hashC.create = () => hashCons();
        return hashC;
      }
      function createOptHasher(hashCons) {
        const hashC = (msg, opts) => hashCons(opts).update(toBytes2(msg)).digest();
        const tmp = hashCons({});
        hashC.outputLen = tmp.outputLen;
        hashC.blockLen = tmp.blockLen;
        hashC.create = (opts) => hashCons(opts);
        return hashC;
      }
      function createXOFer(hashCons) {
        const hashC = (msg, opts) => hashCons(opts).update(toBytes2(msg)).digest();
        const tmp = hashCons({});
        hashC.outputLen = tmp.outputLen;
        hashC.blockLen = tmp.blockLen;
        hashC.create = (opts) => hashCons(opts);
        return hashC;
      }
      exports.wrapConstructor = createHasher2;
      exports.wrapConstructorWithOpts = createOptHasher;
      exports.wrapXOFConstructorWithOpts = createXOFer;
      function randomBytes(bytesLength = 32) {
        if (crypto_1.crypto && typeof crypto_1.crypto.getRandomValues === "function") {
          return crypto_1.crypto.getRandomValues(new Uint8Array(bytesLength));
        }
        if (crypto_1.crypto && typeof crypto_1.crypto.randomBytes === "function") {
          return Uint8Array.from(crypto_1.crypto.randomBytes(bytesLength));
        }
        throw new Error("crypto.getRandomValues must be defined");
      }
    }
  });

  // node_modules/@noble/hashes/_md.js
  var require_md = __commonJS({
    "node_modules/@noble/hashes/_md.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.SHA512_IV = exports.SHA384_IV = exports.SHA224_IV = exports.SHA256_IV = exports.HashMD = void 0;
      exports.setBigUint64 = setBigUint642;
      exports.Chi = Chi2;
      exports.Maj = Maj2;
      var utils_ts_1 = require_utils();
      function setBigUint642(view, byteOffset, value, isLE) {
        if (typeof view.setBigUint64 === "function")
          return view.setBigUint64(byteOffset, value, isLE);
        const _32n = BigInt(32);
        const _u32_max = BigInt(4294967295);
        const wh = Number(value >> _32n & _u32_max);
        const wl = Number(value & _u32_max);
        const h = isLE ? 4 : 0;
        const l = isLE ? 0 : 4;
        view.setUint32(byteOffset + h, wh, isLE);
        view.setUint32(byteOffset + l, wl, isLE);
      }
      function Chi2(a, b, c) {
        return a & b ^ ~a & c;
      }
      function Maj2(a, b, c) {
        return a & b ^ a & c ^ b & c;
      }
      var HashMD2 = class extends utils_ts_1.Hash {
        constructor(blockLen, outputLen, padOffset, isLE) {
          super();
          this.finished = false;
          this.length = 0;
          this.pos = 0;
          this.destroyed = false;
          this.blockLen = blockLen;
          this.outputLen = outputLen;
          this.padOffset = padOffset;
          this.isLE = isLE;
          this.buffer = new Uint8Array(blockLen);
          this.view = (0, utils_ts_1.createView)(this.buffer);
        }
        update(data) {
          (0, utils_ts_1.aexists)(this);
          data = (0, utils_ts_1.toBytes)(data);
          (0, utils_ts_1.abytes)(data);
          const { view, buffer, blockLen } = this;
          const len = data.length;
          for (let pos = 0; pos < len; ) {
            const take = Math.min(blockLen - this.pos, len - pos);
            if (take === blockLen) {
              const dataView = (0, utils_ts_1.createView)(data);
              for (; blockLen <= len - pos; pos += blockLen)
                this.process(dataView, pos);
              continue;
            }
            buffer.set(data.subarray(pos, pos + take), this.pos);
            this.pos += take;
            pos += take;
            if (this.pos === blockLen) {
              this.process(view, 0);
              this.pos = 0;
            }
          }
          this.length += data.length;
          this.roundClean();
          return this;
        }
        digestInto(out) {
          (0, utils_ts_1.aexists)(this);
          (0, utils_ts_1.aoutput)(out, this);
          this.finished = true;
          const { buffer, view, blockLen, isLE } = this;
          let { pos } = this;
          buffer[pos++] = 128;
          (0, utils_ts_1.clean)(this.buffer.subarray(pos));
          if (this.padOffset > blockLen - pos) {
            this.process(view, 0);
            pos = 0;
          }
          for (let i = pos; i < blockLen; i++)
            buffer[i] = 0;
          setBigUint642(view, blockLen - 8, BigInt(this.length * 8), isLE);
          this.process(view, 0);
          const oview = (0, utils_ts_1.createView)(out);
          const len = this.outputLen;
          if (len % 4)
            throw new Error("_sha2: outputLen should be aligned to 32bit");
          const outLen = len / 4;
          const state = this.get();
          if (outLen > state.length)
            throw new Error("_sha2: outputLen bigger than state");
          for (let i = 0; i < outLen; i++)
            oview.setUint32(4 * i, state[i], isLE);
        }
        digest() {
          const { buffer, outputLen } = this;
          this.digestInto(buffer);
          const res = buffer.slice(0, outputLen);
          this.destroy();
          return res;
        }
        _cloneInto(to) {
          to || (to = new this.constructor());
          to.set(...this.get());
          const { blockLen, buffer, length, finished, destroyed, pos } = this;
          to.destroyed = destroyed;
          to.finished = finished;
          to.length = length;
          to.pos = pos;
          if (length % blockLen)
            to.buffer.set(buffer);
          return to;
        }
        clone() {
          return this._cloneInto();
        }
      };
      exports.HashMD = HashMD2;
      exports.SHA256_IV = Uint32Array.from([
        1779033703,
        3144134277,
        1013904242,
        2773480762,
        1359893119,
        2600822924,
        528734635,
        1541459225
      ]);
      exports.SHA224_IV = Uint32Array.from([
        3238371032,
        914150663,
        812702999,
        4144912697,
        4290775857,
        1750603025,
        1694076839,
        3204075428
      ]);
      exports.SHA384_IV = Uint32Array.from([
        3418070365,
        3238371032,
        1654270250,
        914150663,
        2438529370,
        812702999,
        355462360,
        4144912697,
        1731405415,
        4290775857,
        2394180231,
        1750603025,
        3675008525,
        1694076839,
        1203062813,
        3204075428
      ]);
      exports.SHA512_IV = Uint32Array.from([
        1779033703,
        4089235720,
        3144134277,
        2227873595,
        1013904242,
        4271175723,
        2773480762,
        1595750129,
        1359893119,
        2917565137,
        2600822924,
        725511199,
        528734635,
        4215389547,
        1541459225,
        327033209
      ]);
    }
  });

  // node_modules/@noble/hashes/_u64.js
  var require_u64 = __commonJS({
    "node_modules/@noble/hashes/_u64.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.toBig = exports.shrSL = exports.shrSH = exports.rotrSL = exports.rotrSH = exports.rotrBL = exports.rotrBH = exports.rotr32L = exports.rotr32H = exports.rotlSL = exports.rotlSH = exports.rotlBL = exports.rotlBH = exports.add5L = exports.add5H = exports.add4L = exports.add4H = exports.add3L = exports.add3H = void 0;
      exports.add = add;
      exports.fromBig = fromBig;
      exports.split = split;
      var U32_MASK64 = /* @__PURE__ */ BigInt(2 ** 32 - 1);
      var _32n = /* @__PURE__ */ BigInt(32);
      function fromBig(n, le = false) {
        if (le)
          return { h: Number(n & U32_MASK64), l: Number(n >> _32n & U32_MASK64) };
        return { h: Number(n >> _32n & U32_MASK64) | 0, l: Number(n & U32_MASK64) | 0 };
      }
      function split(lst, le = false) {
        const len = lst.length;
        let Ah = new Uint32Array(len);
        let Al = new Uint32Array(len);
        for (let i = 0; i < len; i++) {
          const { h, l } = fromBig(lst[i], le);
          [Ah[i], Al[i]] = [h, l];
        }
        return [Ah, Al];
      }
      var toBig = (h, l) => BigInt(h >>> 0) << _32n | BigInt(l >>> 0);
      exports.toBig = toBig;
      var shrSH = (h, _l, s) => h >>> s;
      exports.shrSH = shrSH;
      var shrSL = (h, l, s) => h << 32 - s | l >>> s;
      exports.shrSL = shrSL;
      var rotrSH = (h, l, s) => h >>> s | l << 32 - s;
      exports.rotrSH = rotrSH;
      var rotrSL = (h, l, s) => h << 32 - s | l >>> s;
      exports.rotrSL = rotrSL;
      var rotrBH = (h, l, s) => h << 64 - s | l >>> s - 32;
      exports.rotrBH = rotrBH;
      var rotrBL = (h, l, s) => h >>> s - 32 | l << 64 - s;
      exports.rotrBL = rotrBL;
      var rotr32H = (_h, l) => l;
      exports.rotr32H = rotr32H;
      var rotr32L = (h, _l) => h;
      exports.rotr32L = rotr32L;
      var rotlSH = (h, l, s) => h << s | l >>> 32 - s;
      exports.rotlSH = rotlSH;
      var rotlSL = (h, l, s) => l << s | h >>> 32 - s;
      exports.rotlSL = rotlSL;
      var rotlBH = (h, l, s) => l << s - 32 | h >>> 64 - s;
      exports.rotlBH = rotlBH;
      var rotlBL = (h, l, s) => h << s - 32 | l >>> 64 - s;
      exports.rotlBL = rotlBL;
      function add(Ah, Al, Bh, Bl) {
        const l = (Al >>> 0) + (Bl >>> 0);
        return { h: Ah + Bh + (l / 2 ** 32 | 0) | 0, l: l | 0 };
      }
      var add3L = (Al, Bl, Cl) => (Al >>> 0) + (Bl >>> 0) + (Cl >>> 0);
      exports.add3L = add3L;
      var add3H = (low, Ah, Bh, Ch) => Ah + Bh + Ch + (low / 2 ** 32 | 0) | 0;
      exports.add3H = add3H;
      var add4L = (Al, Bl, Cl, Dl) => (Al >>> 0) + (Bl >>> 0) + (Cl >>> 0) + (Dl >>> 0);
      exports.add4L = add4L;
      var add4H = (low, Ah, Bh, Ch, Dh) => Ah + Bh + Ch + Dh + (low / 2 ** 32 | 0) | 0;
      exports.add4H = add4H;
      var add5L = (Al, Bl, Cl, Dl, El) => (Al >>> 0) + (Bl >>> 0) + (Cl >>> 0) + (Dl >>> 0) + (El >>> 0);
      exports.add5L = add5L;
      var add5H = (low, Ah, Bh, Ch, Dh, Eh) => Ah + Bh + Ch + Dh + Eh + (low / 2 ** 32 | 0) | 0;
      exports.add5H = add5H;
      var u643 = {
        fromBig,
        split,
        toBig,
        shrSH,
        shrSL,
        rotrSH,
        rotrSL,
        rotrBH,
        rotrBL,
        rotr32H,
        rotr32L,
        rotlSH,
        rotlSL,
        rotlBH,
        rotlBL,
        add,
        add3L,
        add3H,
        add4L,
        add4H,
        add5H,
        add5L
      };
      exports.default = u643;
    }
  });

  // node_modules/@noble/hashes/sha2.js
  var require_sha2 = __commonJS({
    "node_modules/@noble/hashes/sha2.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.sha512_224 = exports.sha512_256 = exports.sha384 = exports.sha512 = exports.sha224 = exports.sha256 = exports.SHA512_256 = exports.SHA512_224 = exports.SHA384 = exports.SHA512 = exports.SHA224 = exports.SHA256 = void 0;
      var _md_ts_1 = require_md();
      var u643 = require_u64();
      var utils_ts_1 = require_utils();
      var SHA256_K2 = /* @__PURE__ */ Uint32Array.from([
        1116352408,
        1899447441,
        3049323471,
        3921009573,
        961987163,
        1508970993,
        2453635748,
        2870763221,
        3624381080,
        310598401,
        607225278,
        1426881987,
        1925078388,
        2162078206,
        2614888103,
        3248222580,
        3835390401,
        4022224774,
        264347078,
        604807628,
        770255983,
        1249150122,
        1555081692,
        1996064986,
        2554220882,
        2821834349,
        2952996808,
        3210313671,
        3336571891,
        3584528711,
        113926993,
        338241895,
        666307205,
        773529912,
        1294757372,
        1396182291,
        1695183700,
        1986661051,
        2177026350,
        2456956037,
        2730485921,
        2820302411,
        3259730800,
        3345764771,
        3516065817,
        3600352804,
        4094571909,
        275423344,
        430227734,
        506948616,
        659060556,
        883997877,
        958139571,
        1322822218,
        1537002063,
        1747873779,
        1955562222,
        2024104815,
        2227730452,
        2361852424,
        2428436474,
        2756734187,
        3204031479,
        3329325298
      ]);
      var SHA256_W2 = /* @__PURE__ */ new Uint32Array(64);
      var SHA2562 = class extends _md_ts_1.HashMD {
        constructor(outputLen = 32) {
          super(64, outputLen, 8, false);
          this.A = _md_ts_1.SHA256_IV[0] | 0;
          this.B = _md_ts_1.SHA256_IV[1] | 0;
          this.C = _md_ts_1.SHA256_IV[2] | 0;
          this.D = _md_ts_1.SHA256_IV[3] | 0;
          this.E = _md_ts_1.SHA256_IV[4] | 0;
          this.F = _md_ts_1.SHA256_IV[5] | 0;
          this.G = _md_ts_1.SHA256_IV[6] | 0;
          this.H = _md_ts_1.SHA256_IV[7] | 0;
        }
        get() {
          const { A, B, C, D, E, F, G, H } = this;
          return [A, B, C, D, E, F, G, H];
        }
        // prettier-ignore
        set(A, B, C, D, E, F, G, H) {
          this.A = A | 0;
          this.B = B | 0;
          this.C = C | 0;
          this.D = D | 0;
          this.E = E | 0;
          this.F = F | 0;
          this.G = G | 0;
          this.H = H | 0;
        }
        process(view, offset2) {
          for (let i = 0; i < 16; i++, offset2 += 4)
            SHA256_W2[i] = view.getUint32(offset2, false);
          for (let i = 16; i < 64; i++) {
            const W15 = SHA256_W2[i - 15];
            const W2 = SHA256_W2[i - 2];
            const s0 = (0, utils_ts_1.rotr)(W15, 7) ^ (0, utils_ts_1.rotr)(W15, 18) ^ W15 >>> 3;
            const s1 = (0, utils_ts_1.rotr)(W2, 17) ^ (0, utils_ts_1.rotr)(W2, 19) ^ W2 >>> 10;
            SHA256_W2[i] = s1 + SHA256_W2[i - 7] + s0 + SHA256_W2[i - 16] | 0;
          }
          let { A, B, C, D, E, F, G, H } = this;
          for (let i = 0; i < 64; i++) {
            const sigma1 = (0, utils_ts_1.rotr)(E, 6) ^ (0, utils_ts_1.rotr)(E, 11) ^ (0, utils_ts_1.rotr)(E, 25);
            const T1 = H + sigma1 + (0, _md_ts_1.Chi)(E, F, G) + SHA256_K2[i] + SHA256_W2[i] | 0;
            const sigma0 = (0, utils_ts_1.rotr)(A, 2) ^ (0, utils_ts_1.rotr)(A, 13) ^ (0, utils_ts_1.rotr)(A, 22);
            const T2 = sigma0 + (0, _md_ts_1.Maj)(A, B, C) | 0;
            H = G;
            G = F;
            F = E;
            E = D + T1 | 0;
            D = C;
            C = B;
            B = A;
            A = T1 + T2 | 0;
          }
          A = A + this.A | 0;
          B = B + this.B | 0;
          C = C + this.C | 0;
          D = D + this.D | 0;
          E = E + this.E | 0;
          F = F + this.F | 0;
          G = G + this.G | 0;
          H = H + this.H | 0;
          this.set(A, B, C, D, E, F, G, H);
        }
        roundClean() {
          (0, utils_ts_1.clean)(SHA256_W2);
        }
        destroy() {
          this.set(0, 0, 0, 0, 0, 0, 0, 0);
          (0, utils_ts_1.clean)(this.buffer);
        }
      };
      exports.SHA256 = SHA2562;
      var SHA2242 = class extends SHA2562 {
        constructor() {
          super(28);
          this.A = _md_ts_1.SHA224_IV[0] | 0;
          this.B = _md_ts_1.SHA224_IV[1] | 0;
          this.C = _md_ts_1.SHA224_IV[2] | 0;
          this.D = _md_ts_1.SHA224_IV[3] | 0;
          this.E = _md_ts_1.SHA224_IV[4] | 0;
          this.F = _md_ts_1.SHA224_IV[5] | 0;
          this.G = _md_ts_1.SHA224_IV[6] | 0;
          this.H = _md_ts_1.SHA224_IV[7] | 0;
        }
      };
      exports.SHA224 = SHA2242;
      var K512 = /* @__PURE__ */ (() => u643.split([
        "0x428a2f98d728ae22",
        "0x7137449123ef65cd",
        "0xb5c0fbcfec4d3b2f",
        "0xe9b5dba58189dbbc",
        "0x3956c25bf348b538",
        "0x59f111f1b605d019",
        "0x923f82a4af194f9b",
        "0xab1c5ed5da6d8118",
        "0xd807aa98a3030242",
        "0x12835b0145706fbe",
        "0x243185be4ee4b28c",
        "0x550c7dc3d5ffb4e2",
        "0x72be5d74f27b896f",
        "0x80deb1fe3b1696b1",
        "0x9bdc06a725c71235",
        "0xc19bf174cf692694",
        "0xe49b69c19ef14ad2",
        "0xefbe4786384f25e3",
        "0x0fc19dc68b8cd5b5",
        "0x240ca1cc77ac9c65",
        "0x2de92c6f592b0275",
        "0x4a7484aa6ea6e483",
        "0x5cb0a9dcbd41fbd4",
        "0x76f988da831153b5",
        "0x983e5152ee66dfab",
        "0xa831c66d2db43210",
        "0xb00327c898fb213f",
        "0xbf597fc7beef0ee4",
        "0xc6e00bf33da88fc2",
        "0xd5a79147930aa725",
        "0x06ca6351e003826f",
        "0x142929670a0e6e70",
        "0x27b70a8546d22ffc",
        "0x2e1b21385c26c926",
        "0x4d2c6dfc5ac42aed",
        "0x53380d139d95b3df",
        "0x650a73548baf63de",
        "0x766a0abb3c77b2a8",
        "0x81c2c92e47edaee6",
        "0x92722c851482353b",
        "0xa2bfe8a14cf10364",
        "0xa81a664bbc423001",
        "0xc24b8b70d0f89791",
        "0xc76c51a30654be30",
        "0xd192e819d6ef5218",
        "0xd69906245565a910",
        "0xf40e35855771202a",
        "0x106aa07032bbd1b8",
        "0x19a4c116b8d2d0c8",
        "0x1e376c085141ab53",
        "0x2748774cdf8eeb99",
        "0x34b0bcb5e19b48a8",
        "0x391c0cb3c5c95a63",
        "0x4ed8aa4ae3418acb",
        "0x5b9cca4f7763e373",
        "0x682e6ff3d6b2b8a3",
        "0x748f82ee5defb2fc",
        "0x78a5636f43172f60",
        "0x84c87814a1f0ab72",
        "0x8cc702081a6439ec",
        "0x90befffa23631e28",
        "0xa4506cebde82bde9",
        "0xbef9a3f7b2c67915",
        "0xc67178f2e372532b",
        "0xca273eceea26619c",
        "0xd186b8c721c0c207",
        "0xeada7dd6cde0eb1e",
        "0xf57d4f7fee6ed178",
        "0x06f067aa72176fba",
        "0x0a637dc5a2c898a6",
        "0x113f9804bef90dae",
        "0x1b710b35131c471b",
        "0x28db77f523047d84",
        "0x32caab7b40c72493",
        "0x3c9ebe0a15c9bebc",
        "0x431d67c49c100d4c",
        "0x4cc5d4becb3e42b6",
        "0x597f299cfc657e2a",
        "0x5fcb6fab3ad6faec",
        "0x6c44198c4a475817"
      ].map((n) => BigInt(n))))();
      var SHA512_Kh = /* @__PURE__ */ (() => K512[0])();
      var SHA512_Kl = /* @__PURE__ */ (() => K512[1])();
      var SHA512_W_H = /* @__PURE__ */ new Uint32Array(80);
      var SHA512_W_L = /* @__PURE__ */ new Uint32Array(80);
      var SHA512 = class extends _md_ts_1.HashMD {
        constructor(outputLen = 64) {
          super(128, outputLen, 16, false);
          this.Ah = _md_ts_1.SHA512_IV[0] | 0;
          this.Al = _md_ts_1.SHA512_IV[1] | 0;
          this.Bh = _md_ts_1.SHA512_IV[2] | 0;
          this.Bl = _md_ts_1.SHA512_IV[3] | 0;
          this.Ch = _md_ts_1.SHA512_IV[4] | 0;
          this.Cl = _md_ts_1.SHA512_IV[5] | 0;
          this.Dh = _md_ts_1.SHA512_IV[6] | 0;
          this.Dl = _md_ts_1.SHA512_IV[7] | 0;
          this.Eh = _md_ts_1.SHA512_IV[8] | 0;
          this.El = _md_ts_1.SHA512_IV[9] | 0;
          this.Fh = _md_ts_1.SHA512_IV[10] | 0;
          this.Fl = _md_ts_1.SHA512_IV[11] | 0;
          this.Gh = _md_ts_1.SHA512_IV[12] | 0;
          this.Gl = _md_ts_1.SHA512_IV[13] | 0;
          this.Hh = _md_ts_1.SHA512_IV[14] | 0;
          this.Hl = _md_ts_1.SHA512_IV[15] | 0;
        }
        // prettier-ignore
        get() {
          const { Ah, Al, Bh, Bl, Ch, Cl, Dh, Dl, Eh, El, Fh, Fl, Gh, Gl, Hh, Hl } = this;
          return [Ah, Al, Bh, Bl, Ch, Cl, Dh, Dl, Eh, El, Fh, Fl, Gh, Gl, Hh, Hl];
        }
        // prettier-ignore
        set(Ah, Al, Bh, Bl, Ch, Cl, Dh, Dl, Eh, El, Fh, Fl, Gh, Gl, Hh, Hl) {
          this.Ah = Ah | 0;
          this.Al = Al | 0;
          this.Bh = Bh | 0;
          this.Bl = Bl | 0;
          this.Ch = Ch | 0;
          this.Cl = Cl | 0;
          this.Dh = Dh | 0;
          this.Dl = Dl | 0;
          this.Eh = Eh | 0;
          this.El = El | 0;
          this.Fh = Fh | 0;
          this.Fl = Fl | 0;
          this.Gh = Gh | 0;
          this.Gl = Gl | 0;
          this.Hh = Hh | 0;
          this.Hl = Hl | 0;
        }
        process(view, offset2) {
          for (let i = 0; i < 16; i++, offset2 += 4) {
            SHA512_W_H[i] = view.getUint32(offset2);
            SHA512_W_L[i] = view.getUint32(offset2 += 4);
          }
          for (let i = 16; i < 80; i++) {
            const W15h = SHA512_W_H[i - 15] | 0;
            const W15l = SHA512_W_L[i - 15] | 0;
            const s0h = u643.rotrSH(W15h, W15l, 1) ^ u643.rotrSH(W15h, W15l, 8) ^ u643.shrSH(W15h, W15l, 7);
            const s0l = u643.rotrSL(W15h, W15l, 1) ^ u643.rotrSL(W15h, W15l, 8) ^ u643.shrSL(W15h, W15l, 7);
            const W2h = SHA512_W_H[i - 2] | 0;
            const W2l = SHA512_W_L[i - 2] | 0;
            const s1h = u643.rotrSH(W2h, W2l, 19) ^ u643.rotrBH(W2h, W2l, 61) ^ u643.shrSH(W2h, W2l, 6);
            const s1l = u643.rotrSL(W2h, W2l, 19) ^ u643.rotrBL(W2h, W2l, 61) ^ u643.shrSL(W2h, W2l, 6);
            const SUMl = u643.add4L(s0l, s1l, SHA512_W_L[i - 7], SHA512_W_L[i - 16]);
            const SUMh = u643.add4H(SUMl, s0h, s1h, SHA512_W_H[i - 7], SHA512_W_H[i - 16]);
            SHA512_W_H[i] = SUMh | 0;
            SHA512_W_L[i] = SUMl | 0;
          }
          let { Ah, Al, Bh, Bl, Ch, Cl, Dh, Dl, Eh, El, Fh, Fl, Gh, Gl, Hh, Hl } = this;
          for (let i = 0; i < 80; i++) {
            const sigma1h = u643.rotrSH(Eh, El, 14) ^ u643.rotrSH(Eh, El, 18) ^ u643.rotrBH(Eh, El, 41);
            const sigma1l = u643.rotrSL(Eh, El, 14) ^ u643.rotrSL(Eh, El, 18) ^ u643.rotrBL(Eh, El, 41);
            const CHIh = Eh & Fh ^ ~Eh & Gh;
            const CHIl = El & Fl ^ ~El & Gl;
            const T1ll = u643.add5L(Hl, sigma1l, CHIl, SHA512_Kl[i], SHA512_W_L[i]);
            const T1h = u643.add5H(T1ll, Hh, sigma1h, CHIh, SHA512_Kh[i], SHA512_W_H[i]);
            const T1l = T1ll | 0;
            const sigma0h = u643.rotrSH(Ah, Al, 28) ^ u643.rotrBH(Ah, Al, 34) ^ u643.rotrBH(Ah, Al, 39);
            const sigma0l = u643.rotrSL(Ah, Al, 28) ^ u643.rotrBL(Ah, Al, 34) ^ u643.rotrBL(Ah, Al, 39);
            const MAJh = Ah & Bh ^ Ah & Ch ^ Bh & Ch;
            const MAJl = Al & Bl ^ Al & Cl ^ Bl & Cl;
            Hh = Gh | 0;
            Hl = Gl | 0;
            Gh = Fh | 0;
            Gl = Fl | 0;
            Fh = Eh | 0;
            Fl = El | 0;
            ({ h: Eh, l: El } = u643.add(Dh | 0, Dl | 0, T1h | 0, T1l | 0));
            Dh = Ch | 0;
            Dl = Cl | 0;
            Ch = Bh | 0;
            Cl = Bl | 0;
            Bh = Ah | 0;
            Bl = Al | 0;
            const All = u643.add3L(T1l, sigma0l, MAJl);
            Ah = u643.add3H(All, T1h, sigma0h, MAJh);
            Al = All | 0;
          }
          ({ h: Ah, l: Al } = u643.add(this.Ah | 0, this.Al | 0, Ah | 0, Al | 0));
          ({ h: Bh, l: Bl } = u643.add(this.Bh | 0, this.Bl | 0, Bh | 0, Bl | 0));
          ({ h: Ch, l: Cl } = u643.add(this.Ch | 0, this.Cl | 0, Ch | 0, Cl | 0));
          ({ h: Dh, l: Dl } = u643.add(this.Dh | 0, this.Dl | 0, Dh | 0, Dl | 0));
          ({ h: Eh, l: El } = u643.add(this.Eh | 0, this.El | 0, Eh | 0, El | 0));
          ({ h: Fh, l: Fl } = u643.add(this.Fh | 0, this.Fl | 0, Fh | 0, Fl | 0));
          ({ h: Gh, l: Gl } = u643.add(this.Gh | 0, this.Gl | 0, Gh | 0, Gl | 0));
          ({ h: Hh, l: Hl } = u643.add(this.Hh | 0, this.Hl | 0, Hh | 0, Hl | 0));
          this.set(Ah, Al, Bh, Bl, Ch, Cl, Dh, Dl, Eh, El, Fh, Fl, Gh, Gl, Hh, Hl);
        }
        roundClean() {
          (0, utils_ts_1.clean)(SHA512_W_H, SHA512_W_L);
        }
        destroy() {
          (0, utils_ts_1.clean)(this.buffer);
          this.set(0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0);
        }
      };
      exports.SHA512 = SHA512;
      var SHA384 = class extends SHA512 {
        constructor() {
          super(48);
          this.Ah = _md_ts_1.SHA384_IV[0] | 0;
          this.Al = _md_ts_1.SHA384_IV[1] | 0;
          this.Bh = _md_ts_1.SHA384_IV[2] | 0;
          this.Bl = _md_ts_1.SHA384_IV[3] | 0;
          this.Ch = _md_ts_1.SHA384_IV[4] | 0;
          this.Cl = _md_ts_1.SHA384_IV[5] | 0;
          this.Dh = _md_ts_1.SHA384_IV[6] | 0;
          this.Dl = _md_ts_1.SHA384_IV[7] | 0;
          this.Eh = _md_ts_1.SHA384_IV[8] | 0;
          this.El = _md_ts_1.SHA384_IV[9] | 0;
          this.Fh = _md_ts_1.SHA384_IV[10] | 0;
          this.Fl = _md_ts_1.SHA384_IV[11] | 0;
          this.Gh = _md_ts_1.SHA384_IV[12] | 0;
          this.Gl = _md_ts_1.SHA384_IV[13] | 0;
          this.Hh = _md_ts_1.SHA384_IV[14] | 0;
          this.Hl = _md_ts_1.SHA384_IV[15] | 0;
        }
      };
      exports.SHA384 = SHA384;
      var T224_IV = /* @__PURE__ */ Uint32Array.from([
        2352822216,
        424955298,
        1944164710,
        2312950998,
        502970286,
        855612546,
        1738396948,
        1479516111,
        258812777,
        2077511080,
        2011393907,
        79989058,
        1067287976,
        1780299464,
        286451373,
        2446758561
      ]);
      var T256_IV = /* @__PURE__ */ Uint32Array.from([
        573645204,
        4230739756,
        2673172387,
        3360449730,
        596883563,
        1867755857,
        2520282905,
        1497426621,
        2519219938,
        2827943907,
        3193839141,
        1401305490,
        721525244,
        746961066,
        246885852,
        2177182882
      ]);
      var SHA512_224 = class extends SHA512 {
        constructor() {
          super(28);
          this.Ah = T224_IV[0] | 0;
          this.Al = T224_IV[1] | 0;
          this.Bh = T224_IV[2] | 0;
          this.Bl = T224_IV[3] | 0;
          this.Ch = T224_IV[4] | 0;
          this.Cl = T224_IV[5] | 0;
          this.Dh = T224_IV[6] | 0;
          this.Dl = T224_IV[7] | 0;
          this.Eh = T224_IV[8] | 0;
          this.El = T224_IV[9] | 0;
          this.Fh = T224_IV[10] | 0;
          this.Fl = T224_IV[11] | 0;
          this.Gh = T224_IV[12] | 0;
          this.Gl = T224_IV[13] | 0;
          this.Hh = T224_IV[14] | 0;
          this.Hl = T224_IV[15] | 0;
        }
      };
      exports.SHA512_224 = SHA512_224;
      var SHA512_256 = class extends SHA512 {
        constructor() {
          super(32);
          this.Ah = T256_IV[0] | 0;
          this.Al = T256_IV[1] | 0;
          this.Bh = T256_IV[2] | 0;
          this.Bl = T256_IV[3] | 0;
          this.Ch = T256_IV[4] | 0;
          this.Cl = T256_IV[5] | 0;
          this.Dh = T256_IV[6] | 0;
          this.Dl = T256_IV[7] | 0;
          this.Eh = T256_IV[8] | 0;
          this.El = T256_IV[9] | 0;
          this.Fh = T256_IV[10] | 0;
          this.Fl = T256_IV[11] | 0;
          this.Gh = T256_IV[12] | 0;
          this.Gl = T256_IV[13] | 0;
          this.Hh = T256_IV[14] | 0;
          this.Hl = T256_IV[15] | 0;
        }
      };
      exports.SHA512_256 = SHA512_256;
      exports.sha256 = (0, utils_ts_1.createHasher)(() => new SHA2562());
      exports.sha224 = (0, utils_ts_1.createHasher)(() => new SHA2242());
      exports.sha512 = (0, utils_ts_1.createHasher)(() => new SHA512());
      exports.sha384 = (0, utils_ts_1.createHasher)(() => new SHA384());
      exports.sha512_256 = (0, utils_ts_1.createHasher)(() => new SHA512_256());
      exports.sha512_224 = (0, utils_ts_1.createHasher)(() => new SHA512_224());
    }
  });

  // node_modules/@noble/curves/utils.js
  var require_utils2 = __commonJS({
    "node_modules/@noble/curves/utils.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.notImplemented = exports.bitMask = exports.utf8ToBytes = exports.randomBytes = exports.isBytes = exports.hexToBytes = exports.concatBytes = exports.bytesToUtf8 = exports.bytesToHex = exports.anumber = exports.abytes = void 0;
      exports.abool = abool;
      exports._abool2 = _abool2;
      exports._abytes2 = _abytes2;
      exports.numberToHexUnpadded = numberToHexUnpadded;
      exports.hexToNumber = hexToNumber;
      exports.bytesToNumberBE = bytesToNumberBE;
      exports.bytesToNumberLE = bytesToNumberLE;
      exports.numberToBytesBE = numberToBytesBE;
      exports.numberToBytesLE = numberToBytesLE;
      exports.numberToVarBytesBE = numberToVarBytesBE;
      exports.ensureBytes = ensureBytes;
      exports.equalBytes = equalBytes;
      exports.copyBytes = copyBytes;
      exports.asciiToBytes = asciiToBytes;
      exports.inRange = inRange;
      exports.aInRange = aInRange;
      exports.bitLen = bitLen;
      exports.bitGet = bitGet;
      exports.bitSet = bitSet;
      exports.createHmacDrbg = createHmacDrbg;
      exports.validateObject = validateObject;
      exports.isHash = isHash;
      exports._validateObject = _validateObject;
      exports.memoized = memoized;
      var utils_js_1 = require_utils();
      var utils_js_2 = require_utils();
      Object.defineProperty(exports, "abytes", { enumerable: true, get: function() {
        return utils_js_2.abytes;
      } });
      Object.defineProperty(exports, "anumber", { enumerable: true, get: function() {
        return utils_js_2.anumber;
      } });
      Object.defineProperty(exports, "bytesToHex", { enumerable: true, get: function() {
        return utils_js_2.bytesToHex;
      } });
      Object.defineProperty(exports, "bytesToUtf8", { enumerable: true, get: function() {
        return utils_js_2.bytesToUtf8;
      } });
      Object.defineProperty(exports, "concatBytes", { enumerable: true, get: function() {
        return utils_js_2.concatBytes;
      } });
      Object.defineProperty(exports, "hexToBytes", { enumerable: true, get: function() {
        return utils_js_2.hexToBytes;
      } });
      Object.defineProperty(exports, "isBytes", { enumerable: true, get: function() {
        return utils_js_2.isBytes;
      } });
      Object.defineProperty(exports, "randomBytes", { enumerable: true, get: function() {
        return utils_js_2.randomBytes;
      } });
      Object.defineProperty(exports, "utf8ToBytes", { enumerable: true, get: function() {
        return utils_js_2.utf8ToBytes;
      } });
      var _0n = /* @__PURE__ */ BigInt(0);
      var _1n = /* @__PURE__ */ BigInt(1);
      function abool(title, value) {
        if (typeof value !== "boolean")
          throw new Error(title + " boolean expected, got " + value);
      }
      function _abool2(value, title = "") {
        if (typeof value !== "boolean") {
          const prefix = title && `"${title}"`;
          throw new Error(prefix + "expected boolean, got type=" + typeof value);
        }
        return value;
      }
      function _abytes2(value, length, title = "") {
        const bytes = (0, utils_js_1.isBytes)(value);
        const len = value?.length;
        const needsLen = length !== void 0;
        if (!bytes || needsLen && len !== length) {
          const prefix = title && `"${title}" `;
          const ofLen = needsLen ? ` of length ${length}` : "";
          const got = bytes ? `length=${len}` : `type=${typeof value}`;
          throw new Error(prefix + "expected Uint8Array" + ofLen + ", got " + got);
        }
        return value;
      }
      function numberToHexUnpadded(num) {
        const hex2 = num.toString(16);
        return hex2.length & 1 ? "0" + hex2 : hex2;
      }
      function hexToNumber(hex2) {
        if (typeof hex2 !== "string")
          throw new Error("hex string expected, got " + typeof hex2);
        return hex2 === "" ? _0n : BigInt("0x" + hex2);
      }
      function bytesToNumberBE(bytes) {
        return hexToNumber((0, utils_js_1.bytesToHex)(bytes));
      }
      function bytesToNumberLE(bytes) {
        (0, utils_js_1.abytes)(bytes);
        return hexToNumber((0, utils_js_1.bytesToHex)(Uint8Array.from(bytes).reverse()));
      }
      function numberToBytesBE(n, len) {
        return (0, utils_js_1.hexToBytes)(n.toString(16).padStart(len * 2, "0"));
      }
      function numberToBytesLE(n, len) {
        return numberToBytesBE(n, len).reverse();
      }
      function numberToVarBytesBE(n) {
        return (0, utils_js_1.hexToBytes)(numberToHexUnpadded(n));
      }
      function ensureBytes(title, hex2, expectedLength) {
        let res;
        if (typeof hex2 === "string") {
          try {
            res = (0, utils_js_1.hexToBytes)(hex2);
          } catch (e) {
            throw new Error(title + " must be hex string or Uint8Array, cause: " + e);
          }
        } else if ((0, utils_js_1.isBytes)(hex2)) {
          res = Uint8Array.from(hex2);
        } else {
          throw new Error(title + " must be hex string or Uint8Array");
        }
        const len = res.length;
        if (typeof expectedLength === "number" && len !== expectedLength)
          throw new Error(title + " of length " + expectedLength + " expected, got " + len);
        return res;
      }
      function equalBytes(a, b) {
        if (a.length !== b.length)
          return false;
        let diff = 0;
        for (let i = 0; i < a.length; i++)
          diff |= a[i] ^ b[i];
        return diff === 0;
      }
      function copyBytes(bytes) {
        return Uint8Array.from(bytes);
      }
      function asciiToBytes(ascii) {
        return Uint8Array.from(ascii, (c, i) => {
          const charCode = c.charCodeAt(0);
          if (c.length !== 1 || charCode > 127) {
            throw new Error(`string contains non-ASCII character "${ascii[i]}" with code ${charCode} at position ${i}`);
          }
          return charCode;
        });
      }
      var isPosBig = (n) => typeof n === "bigint" && _0n <= n;
      function inRange(n, min, max) {
        return isPosBig(n) && isPosBig(min) && isPosBig(max) && min <= n && n < max;
      }
      function aInRange(title, n, min, max) {
        if (!inRange(n, min, max))
          throw new Error("expected valid " + title + ": " + min + " <= n < " + max + ", got " + n);
      }
      function bitLen(n) {
        let len;
        for (len = 0; n > _0n; n >>= _1n, len += 1)
          ;
        return len;
      }
      function bitGet(n, pos) {
        return n >> BigInt(pos) & _1n;
      }
      function bitSet(n, pos, value) {
        return n | (value ? _1n : _0n) << BigInt(pos);
      }
      var bitMask = (n) => (_1n << BigInt(n)) - _1n;
      exports.bitMask = bitMask;
      function createHmacDrbg(hashLen, qByteLen, hmacFn) {
        if (typeof hashLen !== "number" || hashLen < 2)
          throw new Error("hashLen must be a number");
        if (typeof qByteLen !== "number" || qByteLen < 2)
          throw new Error("qByteLen must be a number");
        if (typeof hmacFn !== "function")
          throw new Error("hmacFn must be a function");
        const u8n = (len) => new Uint8Array(len);
        const u8of = (byte) => Uint8Array.of(byte);
        let v = u8n(hashLen);
        let k = u8n(hashLen);
        let i = 0;
        const reset = () => {
          v.fill(1);
          k.fill(0);
          i = 0;
        };
        const h = (...b) => hmacFn(k, v, ...b);
        const reseed = (seed2 = u8n(0)) => {
          k = h(u8of(0), seed2);
          v = h();
          if (seed2.length === 0)
            return;
          k = h(u8of(1), seed2);
          v = h();
        };
        const gen = () => {
          if (i++ >= 1e3)
            throw new Error("drbg: tried 1000 values");
          let len = 0;
          const out = [];
          while (len < qByteLen) {
            v = h();
            const sl = v.slice();
            out.push(sl);
            len += v.length;
          }
          return (0, utils_js_1.concatBytes)(...out);
        };
        const genUntil = (seed2, pred) => {
          reset();
          reseed(seed2);
          let res = void 0;
          while (!(res = pred(gen())))
            reseed();
          reset();
          return res;
        };
        return genUntil;
      }
      var validatorFns = {
        bigint: (val) => typeof val === "bigint",
        function: (val) => typeof val === "function",
        boolean: (val) => typeof val === "boolean",
        string: (val) => typeof val === "string",
        stringOrUint8Array: (val) => typeof val === "string" || (0, utils_js_1.isBytes)(val),
        isSafeInteger: (val) => Number.isSafeInteger(val),
        array: (val) => Array.isArray(val),
        field: (val, object) => object.Fp.isValid(val),
        hash: (val) => typeof val === "function" && Number.isSafeInteger(val.outputLen)
      };
      function validateObject(object, validators, optValidators = {}) {
        const checkField = (fieldName, type2, isOptional) => {
          const checkVal = validatorFns[type2];
          if (typeof checkVal !== "function")
            throw new Error("invalid validator function");
          const val = object[fieldName];
          if (isOptional && val === void 0)
            return;
          if (!checkVal(val, object)) {
            throw new Error("param " + String(fieldName) + " is invalid. Expected " + type2 + ", got " + val);
          }
        };
        for (const [fieldName, type2] of Object.entries(validators))
          checkField(fieldName, type2, false);
        for (const [fieldName, type2] of Object.entries(optValidators))
          checkField(fieldName, type2, true);
        return object;
      }
      function isHash(val) {
        return typeof val === "function" && Number.isSafeInteger(val.outputLen);
      }
      function _validateObject(object, fields, optFields = {}) {
        if (!object || typeof object !== "object")
          throw new Error("expected valid options object");
        function checkField(fieldName, expectedType, isOpt) {
          const val = object[fieldName];
          if (isOpt && val === void 0)
            return;
          const current = typeof val;
          if (current !== expectedType || val === null)
            throw new Error(`param "${fieldName}" is invalid: expected ${expectedType}, got ${current}`);
        }
        Object.entries(fields).forEach(([k, v]) => checkField(k, v, false));
        Object.entries(optFields).forEach(([k, v]) => checkField(k, v, true));
      }
      var notImplemented = () => {
        throw new Error("not implemented");
      };
      exports.notImplemented = notImplemented;
      function memoized(fn) {
        const map = /* @__PURE__ */ new WeakMap();
        return (arg, ...args) => {
          const val = map.get(arg);
          if (val !== void 0)
            return val;
          const computed = fn(arg, ...args);
          map.set(arg, computed);
          return computed;
        };
      }
    }
  });

  // node_modules/@noble/curves/abstract/modular.js
  var require_modular = __commonJS({
    "node_modules/@noble/curves/abstract/modular.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.isNegativeLE = void 0;
      exports.mod = mod;
      exports.pow = pow;
      exports.pow2 = pow2;
      exports.invert = invert;
      exports.tonelliShanks = tonelliShanks;
      exports.FpSqrt = FpSqrt;
      exports.validateField = validateField;
      exports.FpPow = FpPow;
      exports.FpInvertBatch = FpInvertBatch;
      exports.FpDiv = FpDiv;
      exports.FpLegendre = FpLegendre;
      exports.FpIsSquare = FpIsSquare;
      exports.nLength = nLength;
      exports.Field = Field;
      exports.FpSqrtOdd = FpSqrtOdd;
      exports.FpSqrtEven = FpSqrtEven;
      exports.hashToPrivateScalar = hashToPrivateScalar;
      exports.getFieldBytesLength = getFieldBytesLength;
      exports.getMinHashLength = getMinHashLength;
      exports.mapHashToField = mapHashToField;
      var utils_ts_1 = require_utils2();
      var _0n = BigInt(0);
      var _1n = BigInt(1);
      var _2n = /* @__PURE__ */ BigInt(2);
      var _3n = /* @__PURE__ */ BigInt(3);
      var _4n = /* @__PURE__ */ BigInt(4);
      var _5n = /* @__PURE__ */ BigInt(5);
      var _7n = /* @__PURE__ */ BigInt(7);
      var _8n = /* @__PURE__ */ BigInt(8);
      var _9n = /* @__PURE__ */ BigInt(9);
      var _16n = /* @__PURE__ */ BigInt(16);
      function mod(a, b) {
        const result = a % b;
        return result >= _0n ? result : b + result;
      }
      function pow(num, power, modulo) {
        return FpPow(Field(modulo), num, power);
      }
      function pow2(x, power, modulo) {
        let res = x;
        while (power-- > _0n) {
          res *= res;
          res %= modulo;
        }
        return res;
      }
      function invert(number2, modulo) {
        if (number2 === _0n)
          throw new Error("invert: expected non-zero number");
        if (modulo <= _0n)
          throw new Error("invert: expected positive modulus, got " + modulo);
        let a = mod(number2, modulo);
        let b = modulo;
        let x = _0n, y = _1n, u = _1n, v = _0n;
        while (a !== _0n) {
          const q = b / a;
          const r = b % a;
          const m = x - u * q;
          const n = y - v * q;
          b = a, a = r, x = u, y = v, u = m, v = n;
        }
        const gcd = b;
        if (gcd !== _1n)
          throw new Error("invert: does not exist");
        return mod(x, modulo);
      }
      function assertIsSquare(Fp, root, n) {
        if (!Fp.eql(Fp.sqr(root), n))
          throw new Error("Cannot find square root");
      }
      function sqrt3mod4(Fp, n) {
        const p1div4 = (Fp.ORDER + _1n) / _4n;
        const root = Fp.pow(n, p1div4);
        assertIsSquare(Fp, root, n);
        return root;
      }
      function sqrt5mod8(Fp, n) {
        const p5div8 = (Fp.ORDER - _5n) / _8n;
        const n2 = Fp.mul(n, _2n);
        const v = Fp.pow(n2, p5div8);
        const nv = Fp.mul(n, v);
        const i = Fp.mul(Fp.mul(nv, _2n), v);
        const root = Fp.mul(nv, Fp.sub(i, Fp.ONE));
        assertIsSquare(Fp, root, n);
        return root;
      }
      function sqrt9mod16(P) {
        const Fp_ = Field(P);
        const tn = tonelliShanks(P);
        const c1 = tn(Fp_, Fp_.neg(Fp_.ONE));
        const c2 = tn(Fp_, c1);
        const c3 = tn(Fp_, Fp_.neg(c1));
        const c4 = (P + _7n) / _16n;
        return (Fp, n) => {
          let tv1 = Fp.pow(n, c4);
          let tv2 = Fp.mul(tv1, c1);
          const tv3 = Fp.mul(tv1, c2);
          const tv4 = Fp.mul(tv1, c3);
          const e1 = Fp.eql(Fp.sqr(tv2), n);
          const e2 = Fp.eql(Fp.sqr(tv3), n);
          tv1 = Fp.cmov(tv1, tv2, e1);
          tv2 = Fp.cmov(tv4, tv3, e2);
          const e3 = Fp.eql(Fp.sqr(tv2), n);
          const root = Fp.cmov(tv1, tv2, e3);
          assertIsSquare(Fp, root, n);
          return root;
        };
      }
      function tonelliShanks(P) {
        if (P < _3n)
          throw new Error("sqrt is not defined for small field");
        let Q = P - _1n;
        let S = 0;
        while (Q % _2n === _0n) {
          Q /= _2n;
          S++;
        }
        let Z = _2n;
        const _Fp = Field(P);
        while (FpLegendre(_Fp, Z) === 1) {
          if (Z++ > 1e3)
            throw new Error("Cannot find square root: probably non-prime P");
        }
        if (S === 1)
          return sqrt3mod4;
        let cc = _Fp.pow(Z, Q);
        const Q1div2 = (Q + _1n) / _2n;
        return function tonelliSlow(Fp, n) {
          if (Fp.is0(n))
            return n;
          if (FpLegendre(Fp, n) !== 1)
            throw new Error("Cannot find square root");
          let M = S;
          let c = Fp.mul(Fp.ONE, cc);
          let t = Fp.pow(n, Q);
          let R = Fp.pow(n, Q1div2);
          while (!Fp.eql(t, Fp.ONE)) {
            if (Fp.is0(t))
              return Fp.ZERO;
            let i = 1;
            let t_tmp = Fp.sqr(t);
            while (!Fp.eql(t_tmp, Fp.ONE)) {
              i++;
              t_tmp = Fp.sqr(t_tmp);
              if (i === M)
                throw new Error("Cannot find square root");
            }
            const exponent = _1n << BigInt(M - i - 1);
            const b = Fp.pow(c, exponent);
            M = i;
            c = Fp.sqr(b);
            t = Fp.mul(t, c);
            R = Fp.mul(R, b);
          }
          return R;
        };
      }
      function FpSqrt(P) {
        if (P % _4n === _3n)
          return sqrt3mod4;
        if (P % _8n === _5n)
          return sqrt5mod8;
        if (P % _16n === _9n)
          return sqrt9mod16(P);
        return tonelliShanks(P);
      }
      var isNegativeLE = (num, modulo) => (mod(num, modulo) & _1n) === _1n;
      exports.isNegativeLE = isNegativeLE;
      var FIELD_FIELDS = [
        "create",
        "isValid",
        "is0",
        "neg",
        "inv",
        "sqrt",
        "sqr",
        "eql",
        "add",
        "sub",
        "mul",
        "pow",
        "div",
        "addN",
        "subN",
        "mulN",
        "sqrN"
      ];
      function validateField(field) {
        const initial = {
          ORDER: "bigint",
          MASK: "bigint",
          BYTES: "number",
          BITS: "number"
        };
        const opts = FIELD_FIELDS.reduce((map, val) => {
          map[val] = "function";
          return map;
        }, initial);
        (0, utils_ts_1._validateObject)(field, opts);
        return field;
      }
      function FpPow(Fp, num, power) {
        if (power < _0n)
          throw new Error("invalid exponent, negatives unsupported");
        if (power === _0n)
          return Fp.ONE;
        if (power === _1n)
          return num;
        let p = Fp.ONE;
        let d = num;
        while (power > _0n) {
          if (power & _1n)
            p = Fp.mul(p, d);
          d = Fp.sqr(d);
          power >>= _1n;
        }
        return p;
      }
      function FpInvertBatch(Fp, nums, passZero = false) {
        const inverted = new Array(nums.length).fill(passZero ? Fp.ZERO : void 0);
        const multipliedAcc = nums.reduce((acc, num, i) => {
          if (Fp.is0(num))
            return acc;
          inverted[i] = acc;
          return Fp.mul(acc, num);
        }, Fp.ONE);
        const invertedAcc = Fp.inv(multipliedAcc);
        nums.reduceRight((acc, num, i) => {
          if (Fp.is0(num))
            return acc;
          inverted[i] = Fp.mul(acc, inverted[i]);
          return Fp.mul(acc, num);
        }, invertedAcc);
        return inverted;
      }
      function FpDiv(Fp, lhs, rhs) {
        return Fp.mul(lhs, typeof rhs === "bigint" ? invert(rhs, Fp.ORDER) : Fp.inv(rhs));
      }
      function FpLegendre(Fp, n) {
        const p1mod2 = (Fp.ORDER - _1n) / _2n;
        const powered = Fp.pow(n, p1mod2);
        const yes = Fp.eql(powered, Fp.ONE);
        const zero2 = Fp.eql(powered, Fp.ZERO);
        const no = Fp.eql(powered, Fp.neg(Fp.ONE));
        if (!yes && !zero2 && !no)
          throw new Error("invalid Legendre symbol result");
        return yes ? 1 : zero2 ? 0 : -1;
      }
      function FpIsSquare(Fp, n) {
        const l = FpLegendre(Fp, n);
        return l === 1;
      }
      function nLength(n, nBitLength) {
        if (nBitLength !== void 0)
          (0, utils_ts_1.anumber)(nBitLength);
        const _nBitLength = nBitLength !== void 0 ? nBitLength : n.toString(2).length;
        const nByteLength = Math.ceil(_nBitLength / 8);
        return { nBitLength: _nBitLength, nByteLength };
      }
      function Field(ORDER, bitLenOrOpts, isLE = false, opts = {}) {
        if (ORDER <= _0n)
          throw new Error("invalid field: expected ORDER > 0, got " + ORDER);
        let _nbitLength = void 0;
        let _sqrt = void 0;
        let modFromBytes = false;
        let allowedLengths = void 0;
        if (typeof bitLenOrOpts === "object" && bitLenOrOpts != null) {
          if (opts.sqrt || isLE)
            throw new Error("cannot specify opts in two arguments");
          const _opts = bitLenOrOpts;
          if (_opts.BITS)
            _nbitLength = _opts.BITS;
          if (_opts.sqrt)
            _sqrt = _opts.sqrt;
          if (typeof _opts.isLE === "boolean")
            isLE = _opts.isLE;
          if (typeof _opts.modFromBytes === "boolean")
            modFromBytes = _opts.modFromBytes;
          allowedLengths = _opts.allowedLengths;
        } else {
          if (typeof bitLenOrOpts === "number")
            _nbitLength = bitLenOrOpts;
          if (opts.sqrt)
            _sqrt = opts.sqrt;
        }
        const { nBitLength: BITS, nByteLength: BYTES } = nLength(ORDER, _nbitLength);
        if (BYTES > 2048)
          throw new Error("invalid field: expected ORDER of <= 2048 bytes");
        let sqrtP;
        const f2 = Object.freeze({
          ORDER,
          isLE,
          BITS,
          BYTES,
          MASK: (0, utils_ts_1.bitMask)(BITS),
          ZERO: _0n,
          ONE: _1n,
          allowedLengths,
          create: (num) => mod(num, ORDER),
          isValid: (num) => {
            if (typeof num !== "bigint")
              throw new Error("invalid field element: expected bigint, got " + typeof num);
            return _0n <= num && num < ORDER;
          },
          is0: (num) => num === _0n,
          // is valid and invertible
          isValidNot0: (num) => !f2.is0(num) && f2.isValid(num),
          isOdd: (num) => (num & _1n) === _1n,
          neg: (num) => mod(-num, ORDER),
          eql: (lhs, rhs) => lhs === rhs,
          sqr: (num) => mod(num * num, ORDER),
          add: (lhs, rhs) => mod(lhs + rhs, ORDER),
          sub: (lhs, rhs) => mod(lhs - rhs, ORDER),
          mul: (lhs, rhs) => mod(lhs * rhs, ORDER),
          pow: (num, power) => FpPow(f2, num, power),
          div: (lhs, rhs) => mod(lhs * invert(rhs, ORDER), ORDER),
          // Same as above, but doesn't normalize
          sqrN: (num) => num * num,
          addN: (lhs, rhs) => lhs + rhs,
          subN: (lhs, rhs) => lhs - rhs,
          mulN: (lhs, rhs) => lhs * rhs,
          inv: (num) => invert(num, ORDER),
          sqrt: _sqrt || ((n) => {
            if (!sqrtP)
              sqrtP = FpSqrt(ORDER);
            return sqrtP(f2, n);
          }),
          toBytes: (num) => isLE ? (0, utils_ts_1.numberToBytesLE)(num, BYTES) : (0, utils_ts_1.numberToBytesBE)(num, BYTES),
          fromBytes: (bytes, skipValidation = true) => {
            if (allowedLengths) {
              if (!allowedLengths.includes(bytes.length) || bytes.length > BYTES) {
                throw new Error("Field.fromBytes: expected " + allowedLengths + " bytes, got " + bytes.length);
              }
              const padded = new Uint8Array(BYTES);
              padded.set(bytes, isLE ? 0 : padded.length - bytes.length);
              bytes = padded;
            }
            if (bytes.length !== BYTES)
              throw new Error("Field.fromBytes: expected " + BYTES + " bytes, got " + bytes.length);
            let scalar = isLE ? (0, utils_ts_1.bytesToNumberLE)(bytes) : (0, utils_ts_1.bytesToNumberBE)(bytes);
            if (modFromBytes)
              scalar = mod(scalar, ORDER);
            if (!skipValidation) {
              if (!f2.isValid(scalar))
                throw new Error("invalid field element: outside of range 0..ORDER");
            }
            return scalar;
          },
          // TODO: we don't need it here, move out to separate fn
          invertBatch: (lst) => FpInvertBatch(f2, lst),
          // We can't move this out because Fp6, Fp12 implement it
          // and it's unclear what to return in there.
          cmov: (a, b, c) => c ? b : a
        });
        return Object.freeze(f2);
      }
      function FpSqrtOdd(Fp, elm) {
        if (!Fp.isOdd)
          throw new Error("Field doesn't have isOdd");
        const root = Fp.sqrt(elm);
        return Fp.isOdd(root) ? root : Fp.neg(root);
      }
      function FpSqrtEven(Fp, elm) {
        if (!Fp.isOdd)
          throw new Error("Field doesn't have isOdd");
        const root = Fp.sqrt(elm);
        return Fp.isOdd(root) ? Fp.neg(root) : root;
      }
      function hashToPrivateScalar(hash2, groupOrder, isLE = false) {
        hash2 = (0, utils_ts_1.ensureBytes)("privateHash", hash2);
        const hashLen = hash2.length;
        const minLen = nLength(groupOrder).nByteLength + 8;
        if (minLen < 24 || hashLen < minLen || hashLen > 1024)
          throw new Error("hashToPrivateScalar: expected " + minLen + "-1024 bytes of input, got " + hashLen);
        const num = isLE ? (0, utils_ts_1.bytesToNumberLE)(hash2) : (0, utils_ts_1.bytesToNumberBE)(hash2);
        return mod(num, groupOrder - _1n) + _1n;
      }
      function getFieldBytesLength(fieldOrder) {
        if (typeof fieldOrder !== "bigint")
          throw new Error("field order must be bigint");
        const bitLength = fieldOrder.toString(2).length;
        return Math.ceil(bitLength / 8);
      }
      function getMinHashLength(fieldOrder) {
        const length = getFieldBytesLength(fieldOrder);
        return length + Math.ceil(length / 2);
      }
      function mapHashToField(key, fieldOrder, isLE = false) {
        const len = key.length;
        const fieldLen = getFieldBytesLength(fieldOrder);
        const minLen = getMinHashLength(fieldOrder);
        if (len < 16 || len < minLen || len > 1024)
          throw new Error("expected " + minLen + "-1024 bytes of input, got " + len);
        const num = isLE ? (0, utils_ts_1.bytesToNumberLE)(key) : (0, utils_ts_1.bytesToNumberBE)(key);
        const reduced = mod(num, fieldOrder - _1n) + _1n;
        return isLE ? (0, utils_ts_1.numberToBytesLE)(reduced, fieldLen) : (0, utils_ts_1.numberToBytesBE)(reduced, fieldLen);
      }
    }
  });

  // node_modules/@noble/curves/abstract/curve.js
  var require_curve = __commonJS({
    "node_modules/@noble/curves/abstract/curve.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.wNAF = void 0;
      exports.negateCt = negateCt;
      exports.normalizeZ = normalizeZ;
      exports.mulEndoUnsafe = mulEndoUnsafe;
      exports.pippenger = pippenger;
      exports.precomputeMSMUnsafe = precomputeMSMUnsafe;
      exports.validateBasic = validateBasic;
      exports._createCurveFields = _createCurveFields;
      var utils_ts_1 = require_utils2();
      var modular_ts_1 = require_modular();
      var _0n = BigInt(0);
      var _1n = BigInt(1);
      function negateCt(condition, item) {
        const neg = item.negate();
        return condition ? neg : item;
      }
      function normalizeZ(c, points) {
        const invertedZs = (0, modular_ts_1.FpInvertBatch)(c.Fp, points.map((p) => p.Z));
        return points.map((p, i) => c.fromAffine(p.toAffine(invertedZs[i])));
      }
      function validateW(W, bits) {
        if (!Number.isSafeInteger(W) || W <= 0 || W > bits)
          throw new Error("invalid window size, expected [1.." + bits + "], got W=" + W);
      }
      function calcWOpts(W, scalarBits) {
        validateW(W, scalarBits);
        const windows = Math.ceil(scalarBits / W) + 1;
        const windowSize = 2 ** (W - 1);
        const maxNumber = 2 ** W;
        const mask2 = (0, utils_ts_1.bitMask)(W);
        const shiftBy = BigInt(W);
        return { windows, windowSize, mask: mask2, maxNumber, shiftBy };
      }
      function calcOffsets(n, window2, wOpts) {
        const { windowSize, mask: mask2, maxNumber, shiftBy } = wOpts;
        let wbits = Number(n & mask2);
        let nextN = n >> shiftBy;
        if (wbits > windowSize) {
          wbits -= maxNumber;
          nextN += _1n;
        }
        const offsetStart = window2 * windowSize;
        const offset2 = offsetStart + Math.abs(wbits) - 1;
        const isZero = wbits === 0;
        const isNeg = wbits < 0;
        const isNegF = window2 % 2 !== 0;
        const offsetF = offsetStart;
        return { nextN, offset: offset2, isZero, isNeg, isNegF, offsetF };
      }
      function validateMSMPoints(points, c) {
        if (!Array.isArray(points))
          throw new Error("array expected");
        points.forEach((p, i) => {
          if (!(p instanceof c))
            throw new Error("invalid point at index " + i);
        });
      }
      function validateMSMScalars(scalars, field) {
        if (!Array.isArray(scalars))
          throw new Error("array of scalars expected");
        scalars.forEach((s, i) => {
          if (!field.isValid(s))
            throw new Error("invalid scalar at index " + i);
        });
      }
      var pointPrecomputes = /* @__PURE__ */ new WeakMap();
      var pointWindowSizes = /* @__PURE__ */ new WeakMap();
      function getW(P) {
        return pointWindowSizes.get(P) || 1;
      }
      function assert0(n) {
        if (n !== _0n)
          throw new Error("invalid wNAF");
      }
      var wNAF = class {
        // Parametrized with a given Point class (not individual point)
        constructor(Point, bits) {
          this.BASE = Point.BASE;
          this.ZERO = Point.ZERO;
          this.Fn = Point.Fn;
          this.bits = bits;
        }
        // non-const time multiplication ladder
        _unsafeLadder(elm, n, p = this.ZERO) {
          let d = elm;
          while (n > _0n) {
            if (n & _1n)
              p = p.add(d);
            d = d.double();
            n >>= _1n;
          }
          return p;
        }
        /**
         * Creates a wNAF precomputation window. Used for caching.
         * Default window size is set by `utils.precompute()` and is equal to 8.
         * Number of precomputed points depends on the curve size:
         * 2^(𝑊−1) * (Math.ceil(𝑛 / 𝑊) + 1), where:
         * - 𝑊 is the window size
         * - 𝑛 is the bitlength of the curve order.
         * For a 256-bit curve and window size 8, the number of precomputed points is 128 * 33 = 4224.
         * @param point Point instance
         * @param W window size
         * @returns precomputed point tables flattened to a single array
         */
        precomputeWindow(point, W) {
          const { windows, windowSize } = calcWOpts(W, this.bits);
          const points = [];
          let p = point;
          let base = p;
          for (let window2 = 0; window2 < windows; window2++) {
            base = p;
            points.push(base);
            for (let i = 1; i < windowSize; i++) {
              base = base.add(p);
              points.push(base);
            }
            p = base.double();
          }
          return points;
        }
        /**
         * Implements ec multiplication using precomputed tables and w-ary non-adjacent form.
         * More compact implementation:
         * https://github.com/paulmillr/noble-secp256k1/blob/47cb1669b6e506ad66b35fe7d76132ae97465da2/index.ts#L502-L541
         * @returns real and fake (for const-time) points
         */
        wNAF(W, precomputes, n) {
          if (!this.Fn.isValid(n))
            throw new Error("invalid scalar");
          let p = this.ZERO;
          let f2 = this.BASE;
          const wo = calcWOpts(W, this.bits);
          for (let window2 = 0; window2 < wo.windows; window2++) {
            const { nextN, offset: offset2, isZero, isNeg, isNegF, offsetF } = calcOffsets(n, window2, wo);
            n = nextN;
            if (isZero) {
              f2 = f2.add(negateCt(isNegF, precomputes[offsetF]));
            } else {
              p = p.add(negateCt(isNeg, precomputes[offset2]));
            }
          }
          assert0(n);
          return { p, f: f2 };
        }
        /**
         * Implements ec unsafe (non const-time) multiplication using precomputed tables and w-ary non-adjacent form.
         * @param acc accumulator point to add result of multiplication
         * @returns point
         */
        wNAFUnsafe(W, precomputes, n, acc = this.ZERO) {
          const wo = calcWOpts(W, this.bits);
          for (let window2 = 0; window2 < wo.windows; window2++) {
            if (n === _0n)
              break;
            const { nextN, offset: offset2, isZero, isNeg } = calcOffsets(n, window2, wo);
            n = nextN;
            if (isZero) {
              continue;
            } else {
              const item = precomputes[offset2];
              acc = acc.add(isNeg ? item.negate() : item);
            }
          }
          assert0(n);
          return acc;
        }
        getPrecomputes(W, point, transform) {
          let comp = pointPrecomputes.get(point);
          if (!comp) {
            comp = this.precomputeWindow(point, W);
            if (W !== 1) {
              if (typeof transform === "function")
                comp = transform(comp);
              pointPrecomputes.set(point, comp);
            }
          }
          return comp;
        }
        cached(point, scalar, transform) {
          const W = getW(point);
          return this.wNAF(W, this.getPrecomputes(W, point, transform), scalar);
        }
        unsafe(point, scalar, transform, prev) {
          const W = getW(point);
          if (W === 1)
            return this._unsafeLadder(point, scalar, prev);
          return this.wNAFUnsafe(W, this.getPrecomputes(W, point, transform), scalar, prev);
        }
        // We calculate precomputes for elliptic curve point multiplication
        // using windowed method. This specifies window size and
        // stores precomputed values. Usually only base point would be precomputed.
        createCache(P, W) {
          validateW(W, this.bits);
          pointWindowSizes.set(P, W);
          pointPrecomputes.delete(P);
        }
        hasCache(elm) {
          return getW(elm) !== 1;
        }
      };
      exports.wNAF = wNAF;
      function mulEndoUnsafe(Point, point, k1, k2) {
        let acc = point;
        let p1 = Point.ZERO;
        let p2 = Point.ZERO;
        while (k1 > _0n || k2 > _0n) {
          if (k1 & _1n)
            p1 = p1.add(acc);
          if (k2 & _1n)
            p2 = p2.add(acc);
          acc = acc.double();
          k1 >>= _1n;
          k2 >>= _1n;
        }
        return { p1, p2 };
      }
      function pippenger(c, fieldN, points, scalars) {
        validateMSMPoints(points, c);
        validateMSMScalars(scalars, fieldN);
        const plength = points.length;
        const slength = scalars.length;
        if (plength !== slength)
          throw new Error("arrays of points and scalars must have equal length");
        const zero2 = c.ZERO;
        const wbits = (0, utils_ts_1.bitLen)(BigInt(plength));
        let windowSize = 1;
        if (wbits > 12)
          windowSize = wbits - 3;
        else if (wbits > 4)
          windowSize = wbits - 2;
        else if (wbits > 0)
          windowSize = 2;
        const MASK = (0, utils_ts_1.bitMask)(windowSize);
        const buckets = new Array(Number(MASK) + 1).fill(zero2);
        const lastBits = Math.floor((fieldN.BITS - 1) / windowSize) * windowSize;
        let sum = zero2;
        for (let i = lastBits; i >= 0; i -= windowSize) {
          buckets.fill(zero2);
          for (let j = 0; j < slength; j++) {
            const scalar = scalars[j];
            const wbits2 = Number(scalar >> BigInt(i) & MASK);
            buckets[wbits2] = buckets[wbits2].add(points[j]);
          }
          let resI = zero2;
          for (let j = buckets.length - 1, sumI = zero2; j > 0; j--) {
            sumI = sumI.add(buckets[j]);
            resI = resI.add(sumI);
          }
          sum = sum.add(resI);
          if (i !== 0)
            for (let j = 0; j < windowSize; j++)
              sum = sum.double();
        }
        return sum;
      }
      function precomputeMSMUnsafe(c, fieldN, points, windowSize) {
        validateW(windowSize, fieldN.BITS);
        validateMSMPoints(points, c);
        const zero2 = c.ZERO;
        const tableSize = 2 ** windowSize - 1;
        const chunks2 = Math.ceil(fieldN.BITS / windowSize);
        const MASK = (0, utils_ts_1.bitMask)(windowSize);
        const tables = points.map((p) => {
          const res = [];
          for (let i = 0, acc = p; i < tableSize; i++) {
            res.push(acc);
            acc = acc.add(p);
          }
          return res;
        });
        return (scalars) => {
          validateMSMScalars(scalars, fieldN);
          if (scalars.length > points.length)
            throw new Error("array of scalars must be smaller than array of points");
          let res = zero2;
          for (let i = 0; i < chunks2; i++) {
            if (res !== zero2)
              for (let j = 0; j < windowSize; j++)
                res = res.double();
            const shiftBy = BigInt(chunks2 * windowSize - (i + 1) * windowSize);
            for (let j = 0; j < scalars.length; j++) {
              const n = scalars[j];
              const curr = Number(n >> shiftBy & MASK);
              if (!curr)
                continue;
              res = res.add(tables[j][curr - 1]);
            }
          }
          return res;
        };
      }
      function validateBasic(curve) {
        (0, modular_ts_1.validateField)(curve.Fp);
        (0, utils_ts_1.validateObject)(curve, {
          n: "bigint",
          h: "bigint",
          Gx: "field",
          Gy: "field"
        }, {
          nBitLength: "isSafeInteger",
          nByteLength: "isSafeInteger"
        });
        return Object.freeze({
          ...(0, modular_ts_1.nLength)(curve.n, curve.nBitLength),
          ...curve,
          ...{ p: curve.Fp.ORDER }
        });
      }
      function createField(order, field, isLE) {
        if (field) {
          if (field.ORDER !== order)
            throw new Error("Field.ORDER must match order: Fp == p, Fn == n");
          (0, modular_ts_1.validateField)(field);
          return field;
        } else {
          return (0, modular_ts_1.Field)(order, { isLE });
        }
      }
      function _createCurveFields(type2, CURVE, curveOpts = {}, FpFnLE) {
        if (FpFnLE === void 0)
          FpFnLE = type2 === "edwards";
        if (!CURVE || typeof CURVE !== "object")
          throw new Error(`expected valid ${type2} CURVE object`);
        for (const p of ["p", "n", "h"]) {
          const val = CURVE[p];
          if (!(typeof val === "bigint" && val > _0n))
            throw new Error(`CURVE.${p} must be positive bigint`);
        }
        const Fp = createField(CURVE.p, curveOpts.Fp, FpFnLE);
        const Fn = createField(CURVE.n, curveOpts.Fn, FpFnLE);
        const _b = type2 === "weierstrass" ? "b" : "d";
        const params = ["Gx", "Gy", "a", _b];
        for (const p of params) {
          if (!Fp.isValid(CURVE[p]))
            throw new Error(`CURVE.${p} must be valid field element of CURVE.Fp`);
        }
        CURVE = Object.freeze(Object.assign({}, CURVE));
        return { CURVE, Fp, Fn };
      }
    }
  });

  // node_modules/@noble/curves/abstract/edwards.js
  var require_edwards = __commonJS({
    "node_modules/@noble/curves/abstract/edwards.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.PrimeEdwardsPoint = void 0;
      exports.edwards = edwards;
      exports.eddsa = eddsa;
      exports.twistedEdwards = twistedEdwards;
      var utils_ts_1 = require_utils2();
      var curve_ts_1 = require_curve();
      var modular_ts_1 = require_modular();
      var _0n = BigInt(0);
      var _1n = BigInt(1);
      var _2n = BigInt(2);
      var _8n = BigInt(8);
      function isEdValidXY(Fp, CURVE, x, y) {
        const x2 = Fp.sqr(x);
        const y2 = Fp.sqr(y);
        const left = Fp.add(Fp.mul(CURVE.a, x2), y2);
        const right = Fp.add(Fp.ONE, Fp.mul(CURVE.d, Fp.mul(x2, y2)));
        return Fp.eql(left, right);
      }
      function edwards(params, extraOpts = {}) {
        const validated = (0, curve_ts_1._createCurveFields)("edwards", params, extraOpts, extraOpts.FpFnLE);
        const { Fp, Fn } = validated;
        let CURVE = validated.CURVE;
        const { h: cofactor } = CURVE;
        (0, utils_ts_1._validateObject)(extraOpts, {}, { uvRatio: "function" });
        const MASK = _2n << BigInt(Fn.BYTES * 8) - _1n;
        const modP = (n) => Fp.create(n);
        const uvRatio = extraOpts.uvRatio || ((u, v) => {
          try {
            return { isValid: true, value: Fp.sqrt(Fp.div(u, v)) };
          } catch (e) {
            return { isValid: false, value: _0n };
          }
        });
        if (!isEdValidXY(Fp, CURVE, CURVE.Gx, CURVE.Gy))
          throw new Error("bad curve params: generator point");
        function acoord(title, n, banZero = false) {
          const min = banZero ? _1n : _0n;
          (0, utils_ts_1.aInRange)("coordinate " + title, n, min, MASK);
          return n;
        }
        function aextpoint(other) {
          if (!(other instanceof Point))
            throw new Error("ExtendedPoint expected");
        }
        const toAffineMemo = (0, utils_ts_1.memoized)((p, iz) => {
          const { X, Y, Z } = p;
          const is0 = p.is0();
          if (iz == null)
            iz = is0 ? _8n : Fp.inv(Z);
          const x = modP(X * iz);
          const y = modP(Y * iz);
          const zz = Fp.mul(Z, iz);
          if (is0)
            return { x: _0n, y: _1n };
          if (zz !== _1n)
            throw new Error("invZ was invalid");
          return { x, y };
        });
        const assertValidMemo = (0, utils_ts_1.memoized)((p) => {
          const { a, d } = CURVE;
          if (p.is0())
            throw new Error("bad point: ZERO");
          const { X, Y, Z, T } = p;
          const X2 = modP(X * X);
          const Y2 = modP(Y * Y);
          const Z2 = modP(Z * Z);
          const Z4 = modP(Z2 * Z2);
          const aX2 = modP(X2 * a);
          const left = modP(Z2 * modP(aX2 + Y2));
          const right = modP(Z4 + modP(d * modP(X2 * Y2)));
          if (left !== right)
            throw new Error("bad point: equation left != right (1)");
          const XY = modP(X * Y);
          const ZT = modP(Z * T);
          if (XY !== ZT)
            throw new Error("bad point: equation left != right (2)");
          return true;
        });
        class Point {
          constructor(X, Y, Z, T) {
            this.X = acoord("x", X);
            this.Y = acoord("y", Y);
            this.Z = acoord("z", Z, true);
            this.T = acoord("t", T);
            Object.freeze(this);
          }
          static CURVE() {
            return CURVE;
          }
          static fromAffine(p) {
            if (p instanceof Point)
              throw new Error("extended point not allowed");
            const { x, y } = p || {};
            acoord("x", x);
            acoord("y", y);
            return new Point(x, y, _1n, modP(x * y));
          }
          // Uses algo from RFC8032 5.1.3.
          static fromBytes(bytes, zip215 = false) {
            const len = Fp.BYTES;
            const { a, d } = CURVE;
            bytes = (0, utils_ts_1.copyBytes)((0, utils_ts_1._abytes2)(bytes, len, "point"));
            (0, utils_ts_1._abool2)(zip215, "zip215");
            const normed = (0, utils_ts_1.copyBytes)(bytes);
            const lastByte = bytes[len - 1];
            normed[len - 1] = lastByte & ~128;
            const y = (0, utils_ts_1.bytesToNumberLE)(normed);
            const max = zip215 ? MASK : Fp.ORDER;
            (0, utils_ts_1.aInRange)("point.y", y, _0n, max);
            const y2 = modP(y * y);
            const u = modP(y2 - _1n);
            const v = modP(d * y2 - a);
            let { isValid, value: x } = uvRatio(u, v);
            if (!isValid)
              throw new Error("bad point: invalid y coordinate");
            const isXOdd = (x & _1n) === _1n;
            const isLastByteOdd = (lastByte & 128) !== 0;
            if (!zip215 && x === _0n && isLastByteOdd)
              throw new Error("bad point: x=0 and x_0=1");
            if (isLastByteOdd !== isXOdd)
              x = modP(-x);
            return Point.fromAffine({ x, y });
          }
          static fromHex(bytes, zip215 = false) {
            return Point.fromBytes((0, utils_ts_1.ensureBytes)("point", bytes), zip215);
          }
          get x() {
            return this.toAffine().x;
          }
          get y() {
            return this.toAffine().y;
          }
          precompute(windowSize = 8, isLazy = true) {
            wnaf.createCache(this, windowSize);
            if (!isLazy)
              this.multiply(_2n);
            return this;
          }
          // Useful in fromAffine() - not for fromBytes(), which always created valid points.
          assertValidity() {
            assertValidMemo(this);
          }
          // Compare one point to another.
          equals(other) {
            aextpoint(other);
            const { X: X1, Y: Y1, Z: Z1 } = this;
            const { X: X2, Y: Y2, Z: Z2 } = other;
            const X1Z2 = modP(X1 * Z2);
            const X2Z1 = modP(X2 * Z1);
            const Y1Z2 = modP(Y1 * Z2);
            const Y2Z1 = modP(Y2 * Z1);
            return X1Z2 === X2Z1 && Y1Z2 === Y2Z1;
          }
          is0() {
            return this.equals(Point.ZERO);
          }
          negate() {
            return new Point(modP(-this.X), this.Y, this.Z, modP(-this.T));
          }
          // Fast algo for doubling Extended Point.
          // https://hyperelliptic.org/EFD/g1p/auto-twisted-extended.html#doubling-dbl-2008-hwcd
          // Cost: 4M + 4S + 1*a + 6add + 1*2.
          double() {
            const { a } = CURVE;
            const { X: X1, Y: Y1, Z: Z1 } = this;
            const A = modP(X1 * X1);
            const B = modP(Y1 * Y1);
            const C = modP(_2n * modP(Z1 * Z1));
            const D = modP(a * A);
            const x1y1 = X1 + Y1;
            const E = modP(modP(x1y1 * x1y1) - A - B);
            const G = D + B;
            const F = G - C;
            const H = D - B;
            const X3 = modP(E * F);
            const Y3 = modP(G * H);
            const T3 = modP(E * H);
            const Z3 = modP(F * G);
            return new Point(X3, Y3, Z3, T3);
          }
          // Fast algo for adding 2 Extended Points.
          // https://hyperelliptic.org/EFD/g1p/auto-twisted-extended.html#addition-add-2008-hwcd
          // Cost: 9M + 1*a + 1*d + 7add.
          add(other) {
            aextpoint(other);
            const { a, d } = CURVE;
            const { X: X1, Y: Y1, Z: Z1, T: T1 } = this;
            const { X: X2, Y: Y2, Z: Z2, T: T2 } = other;
            const A = modP(X1 * X2);
            const B = modP(Y1 * Y2);
            const C = modP(T1 * d * T2);
            const D = modP(Z1 * Z2);
            const E = modP((X1 + Y1) * (X2 + Y2) - A - B);
            const F = D - C;
            const G = D + C;
            const H = modP(B - a * A);
            const X3 = modP(E * F);
            const Y3 = modP(G * H);
            const T3 = modP(E * H);
            const Z3 = modP(F * G);
            return new Point(X3, Y3, Z3, T3);
          }
          subtract(other) {
            return this.add(other.negate());
          }
          // Constant-time multiplication.
          multiply(scalar) {
            if (!Fn.isValidNot0(scalar))
              throw new Error("invalid scalar: expected 1 <= sc < curve.n");
            const { p, f: f2 } = wnaf.cached(this, scalar, (p2) => (0, curve_ts_1.normalizeZ)(Point, p2));
            return (0, curve_ts_1.normalizeZ)(Point, [p, f2])[0];
          }
          // Non-constant-time multiplication. Uses double-and-add algorithm.
          // It's faster, but should only be used when you don't care about
          // an exposed private key e.g. sig verification.
          // Does NOT allow scalars higher than CURVE.n.
          // Accepts optional accumulator to merge with multiply (important for sparse scalars)
          multiplyUnsafe(scalar, acc = Point.ZERO) {
            if (!Fn.isValid(scalar))
              throw new Error("invalid scalar: expected 0 <= sc < curve.n");
            if (scalar === _0n)
              return Point.ZERO;
            if (this.is0() || scalar === _1n)
              return this;
            return wnaf.unsafe(this, scalar, (p) => (0, curve_ts_1.normalizeZ)(Point, p), acc);
          }
          // Checks if point is of small order.
          // If you add something to small order point, you will have "dirty"
          // point with torsion component.
          // Multiplies point by cofactor and checks if the result is 0.
          isSmallOrder() {
            return this.multiplyUnsafe(cofactor).is0();
          }
          // Multiplies point by curve order and checks if the result is 0.
          // Returns `false` is the point is dirty.
          isTorsionFree() {
            return wnaf.unsafe(this, CURVE.n).is0();
          }
          // Converts Extended point to default (x, y) coordinates.
          // Can accept precomputed Z^-1 - for example, from invertBatch.
          toAffine(invertedZ) {
            return toAffineMemo(this, invertedZ);
          }
          clearCofactor() {
            if (cofactor === _1n)
              return this;
            return this.multiplyUnsafe(cofactor);
          }
          toBytes() {
            const { x, y } = this.toAffine();
            const bytes = Fp.toBytes(y);
            bytes[bytes.length - 1] |= x & _1n ? 128 : 0;
            return bytes;
          }
          toHex() {
            return (0, utils_ts_1.bytesToHex)(this.toBytes());
          }
          toString() {
            return `<Point ${this.is0() ? "ZERO" : this.toHex()}>`;
          }
          // TODO: remove
          get ex() {
            return this.X;
          }
          get ey() {
            return this.Y;
          }
          get ez() {
            return this.Z;
          }
          get et() {
            return this.T;
          }
          static normalizeZ(points) {
            return (0, curve_ts_1.normalizeZ)(Point, points);
          }
          static msm(points, scalars) {
            return (0, curve_ts_1.pippenger)(Point, Fn, points, scalars);
          }
          _setWindowSize(windowSize) {
            this.precompute(windowSize);
          }
          toRawBytes() {
            return this.toBytes();
          }
        }
        Point.BASE = new Point(CURVE.Gx, CURVE.Gy, _1n, modP(CURVE.Gx * CURVE.Gy));
        Point.ZERO = new Point(_0n, _1n, _1n, _0n);
        Point.Fp = Fp;
        Point.Fn = Fn;
        const wnaf = new curve_ts_1.wNAF(Point, Fn.BITS);
        Point.BASE.precompute(8);
        return Point;
      }
      var PrimeEdwardsPoint = class {
        constructor(ep) {
          this.ep = ep;
        }
        // Static methods that must be implemented by subclasses
        static fromBytes(_bytes) {
          (0, utils_ts_1.notImplemented)();
        }
        static fromHex(_hex) {
          (0, utils_ts_1.notImplemented)();
        }
        get x() {
          return this.toAffine().x;
        }
        get y() {
          return this.toAffine().y;
        }
        // Common implementations
        clearCofactor() {
          return this;
        }
        assertValidity() {
          this.ep.assertValidity();
        }
        toAffine(invertedZ) {
          return this.ep.toAffine(invertedZ);
        }
        toHex() {
          return (0, utils_ts_1.bytesToHex)(this.toBytes());
        }
        toString() {
          return this.toHex();
        }
        isTorsionFree() {
          return true;
        }
        isSmallOrder() {
          return false;
        }
        add(other) {
          this.assertSame(other);
          return this.init(this.ep.add(other.ep));
        }
        subtract(other) {
          this.assertSame(other);
          return this.init(this.ep.subtract(other.ep));
        }
        multiply(scalar) {
          return this.init(this.ep.multiply(scalar));
        }
        multiplyUnsafe(scalar) {
          return this.init(this.ep.multiplyUnsafe(scalar));
        }
        double() {
          return this.init(this.ep.double());
        }
        negate() {
          return this.init(this.ep.negate());
        }
        precompute(windowSize, isLazy) {
          return this.init(this.ep.precompute(windowSize, isLazy));
        }
        /** @deprecated use `toBytes` */
        toRawBytes() {
          return this.toBytes();
        }
      };
      exports.PrimeEdwardsPoint = PrimeEdwardsPoint;
      function eddsa(Point, cHash, eddsaOpts = {}) {
        if (typeof cHash !== "function")
          throw new Error('"hash" function param is required');
        (0, utils_ts_1._validateObject)(eddsaOpts, {}, {
          adjustScalarBytes: "function",
          randomBytes: "function",
          domain: "function",
          prehash: "function",
          mapToCurve: "function"
        });
        const { prehash } = eddsaOpts;
        const { BASE, Fp, Fn } = Point;
        const randomBytes = eddsaOpts.randomBytes || utils_ts_1.randomBytes;
        const adjustScalarBytes = eddsaOpts.adjustScalarBytes || ((bytes) => bytes);
        const domain = eddsaOpts.domain || ((data, ctx, phflag) => {
          (0, utils_ts_1._abool2)(phflag, "phflag");
          if (ctx.length || phflag)
            throw new Error("Contexts/pre-hash are not supported");
          return data;
        });
        function modN_LE(hash2) {
          return Fn.create((0, utils_ts_1.bytesToNumberLE)(hash2));
        }
        function getPrivateScalar(key) {
          const len = lengths.secretKey;
          key = (0, utils_ts_1.ensureBytes)("private key", key, len);
          const hashed = (0, utils_ts_1.ensureBytes)("hashed private key", cHash(key), 2 * len);
          const head = adjustScalarBytes(hashed.slice(0, len));
          const prefix = hashed.slice(len, 2 * len);
          const scalar = modN_LE(head);
          return { head, prefix, scalar };
        }
        function getExtendedPublicKey(secretKey) {
          const { head, prefix, scalar } = getPrivateScalar(secretKey);
          const point = BASE.multiply(scalar);
          const pointBytes = point.toBytes();
          return { head, prefix, scalar, point, pointBytes };
        }
        function getPublicKey(secretKey) {
          return getExtendedPublicKey(secretKey).pointBytes;
        }
        function hashDomainToScalar(context = Uint8Array.of(), ...msgs) {
          const msg = (0, utils_ts_1.concatBytes)(...msgs);
          return modN_LE(cHash(domain(msg, (0, utils_ts_1.ensureBytes)("context", context), !!prehash)));
        }
        function sign(msg, secretKey, options = {}) {
          msg = (0, utils_ts_1.ensureBytes)("message", msg);
          if (prehash)
            msg = prehash(msg);
          const { prefix, scalar, pointBytes } = getExtendedPublicKey(secretKey);
          const r = hashDomainToScalar(options.context, prefix, msg);
          const R = BASE.multiply(r).toBytes();
          const k = hashDomainToScalar(options.context, R, pointBytes, msg);
          const s = Fn.create(r + k * scalar);
          if (!Fn.isValid(s))
            throw new Error("sign failed: invalid s");
          const rs = (0, utils_ts_1.concatBytes)(R, Fn.toBytes(s));
          return (0, utils_ts_1._abytes2)(rs, lengths.signature, "result");
        }
        const verifyOpts = { zip215: true };
        function verify(sig, msg, publicKey3, options = verifyOpts) {
          const { context, zip215 } = options;
          const len = lengths.signature;
          sig = (0, utils_ts_1.ensureBytes)("signature", sig, len);
          msg = (0, utils_ts_1.ensureBytes)("message", msg);
          publicKey3 = (0, utils_ts_1.ensureBytes)("publicKey", publicKey3, lengths.publicKey);
          if (zip215 !== void 0)
            (0, utils_ts_1._abool2)(zip215, "zip215");
          if (prehash)
            msg = prehash(msg);
          const mid = len / 2;
          const r = sig.subarray(0, mid);
          const s = (0, utils_ts_1.bytesToNumberLE)(sig.subarray(mid, len));
          let A, R, SB;
          try {
            A = Point.fromBytes(publicKey3, zip215);
            R = Point.fromBytes(r, zip215);
            SB = BASE.multiplyUnsafe(s);
          } catch (error) {
            return false;
          }
          if (!zip215 && A.isSmallOrder())
            return false;
          const k = hashDomainToScalar(context, R.toBytes(), A.toBytes(), msg);
          const RkA = R.add(A.multiplyUnsafe(k));
          return RkA.subtract(SB).clearCofactor().is0();
        }
        const _size = Fp.BYTES;
        const lengths = {
          secretKey: _size,
          publicKey: _size,
          signature: 2 * _size,
          seed: _size
        };
        function randomSecretKey(seed2 = randomBytes(lengths.seed)) {
          return (0, utils_ts_1._abytes2)(seed2, lengths.seed, "seed");
        }
        function keygen(seed2) {
          const secretKey = utils.randomSecretKey(seed2);
          return { secretKey, publicKey: getPublicKey(secretKey) };
        }
        function isValidSecretKey(key) {
          return (0, utils_ts_1.isBytes)(key) && key.length === Fn.BYTES;
        }
        function isValidPublicKey(key, zip215) {
          try {
            return !!Point.fromBytes(key, zip215);
          } catch (error) {
            return false;
          }
        }
        const utils = {
          getExtendedPublicKey,
          randomSecretKey,
          isValidSecretKey,
          isValidPublicKey,
          /**
           * Converts ed public key to x public key. Uses formula:
           * - ed25519:
           *   - `(u, v) = ((1+y)/(1-y), sqrt(-486664)*u/x)`
           *   - `(x, y) = (sqrt(-486664)*u/v, (u-1)/(u+1))`
           * - ed448:
           *   - `(u, v) = ((y-1)/(y+1), sqrt(156324)*u/x)`
           *   - `(x, y) = (sqrt(156324)*u/v, (1+u)/(1-u))`
           */
          toMontgomery(publicKey3) {
            const { y } = Point.fromBytes(publicKey3);
            const size = lengths.publicKey;
            const is25519 = size === 32;
            if (!is25519 && size !== 57)
              throw new Error("only defined for 25519 and 448");
            const u = is25519 ? Fp.div(_1n + y, _1n - y) : Fp.div(y - _1n, y + _1n);
            return Fp.toBytes(u);
          },
          toMontgomerySecret(secretKey) {
            const size = lengths.secretKey;
            (0, utils_ts_1._abytes2)(secretKey, size);
            const hashed = cHash(secretKey.subarray(0, size));
            return adjustScalarBytes(hashed).subarray(0, size);
          },
          /** @deprecated */
          randomPrivateKey: randomSecretKey,
          /** @deprecated */
          precompute(windowSize = 8, point = Point.BASE) {
            return point.precompute(windowSize, false);
          }
        };
        return Object.freeze({
          keygen,
          getPublicKey,
          sign,
          verify,
          utils,
          Point,
          lengths
        });
      }
      function _eddsa_legacy_opts_to_new(c) {
        const CURVE = {
          a: c.a,
          d: c.d,
          p: c.Fp.ORDER,
          n: c.n,
          h: c.h,
          Gx: c.Gx,
          Gy: c.Gy
        };
        const Fp = c.Fp;
        const Fn = (0, modular_ts_1.Field)(CURVE.n, c.nBitLength, true);
        const curveOpts = { Fp, Fn, uvRatio: c.uvRatio };
        const eddsaOpts = {
          randomBytes: c.randomBytes,
          adjustScalarBytes: c.adjustScalarBytes,
          domain: c.domain,
          prehash: c.prehash,
          mapToCurve: c.mapToCurve
        };
        return { CURVE, curveOpts, hash: c.hash, eddsaOpts };
      }
      function _eddsa_new_output_to_legacy(c, eddsa2) {
        const Point = eddsa2.Point;
        const legacy = Object.assign({}, eddsa2, {
          ExtendedPoint: Point,
          CURVE: c,
          nBitLength: Point.Fn.BITS,
          nByteLength: Point.Fn.BYTES
        });
        return legacy;
      }
      function twistedEdwards(c) {
        const { CURVE, curveOpts, hash: hash2, eddsaOpts } = _eddsa_legacy_opts_to_new(c);
        const Point = edwards(CURVE, curveOpts);
        const EDDSA = eddsa(Point, hash2, eddsaOpts);
        return _eddsa_new_output_to_legacy(c, EDDSA);
      }
    }
  });

  // node_modules/@noble/curves/abstract/hash-to-curve.js
  var require_hash_to_curve = __commonJS({
    "node_modules/@noble/curves/abstract/hash-to-curve.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports._DST_scalar = void 0;
      exports.expand_message_xmd = expand_message_xmd;
      exports.expand_message_xof = expand_message_xof;
      exports.hash_to_field = hash_to_field;
      exports.isogenyMap = isogenyMap;
      exports.createHasher = createHasher2;
      var utils_ts_1 = require_utils2();
      var modular_ts_1 = require_modular();
      var os2ip = utils_ts_1.bytesToNumberBE;
      function i2osp(value, length) {
        anum(value);
        anum(length);
        if (value < 0 || value >= 1 << 8 * length)
          throw new Error("invalid I2OSP input: " + value);
        const res = Array.from({ length }).fill(0);
        for (let i = length - 1; i >= 0; i--) {
          res[i] = value & 255;
          value >>>= 8;
        }
        return new Uint8Array(res);
      }
      function strxor(a, b) {
        const arr = new Uint8Array(a.length);
        for (let i = 0; i < a.length; i++) {
          arr[i] = a[i] ^ b[i];
        }
        return arr;
      }
      function anum(item) {
        if (!Number.isSafeInteger(item))
          throw new Error("number expected");
      }
      function normDST(DST) {
        if (!(0, utils_ts_1.isBytes)(DST) && typeof DST !== "string")
          throw new Error("DST must be Uint8Array or string");
        return typeof DST === "string" ? (0, utils_ts_1.utf8ToBytes)(DST) : DST;
      }
      function expand_message_xmd(msg, DST, lenInBytes, H) {
        (0, utils_ts_1.abytes)(msg);
        anum(lenInBytes);
        DST = normDST(DST);
        if (DST.length > 255)
          DST = H((0, utils_ts_1.concatBytes)((0, utils_ts_1.utf8ToBytes)("H2C-OVERSIZE-DST-"), DST));
        const { outputLen: b_in_bytes, blockLen: r_in_bytes } = H;
        const ell = Math.ceil(lenInBytes / b_in_bytes);
        if (lenInBytes > 65535 || ell > 255)
          throw new Error("expand_message_xmd: invalid lenInBytes");
        const DST_prime = (0, utils_ts_1.concatBytes)(DST, i2osp(DST.length, 1));
        const Z_pad = i2osp(0, r_in_bytes);
        const l_i_b_str = i2osp(lenInBytes, 2);
        const b = new Array(ell);
        const b_0 = H((0, utils_ts_1.concatBytes)(Z_pad, msg, l_i_b_str, i2osp(0, 1), DST_prime));
        b[0] = H((0, utils_ts_1.concatBytes)(b_0, i2osp(1, 1), DST_prime));
        for (let i = 1; i <= ell; i++) {
          const args = [strxor(b_0, b[i - 1]), i2osp(i + 1, 1), DST_prime];
          b[i] = H((0, utils_ts_1.concatBytes)(...args));
        }
        const pseudo_random_bytes = (0, utils_ts_1.concatBytes)(...b);
        return pseudo_random_bytes.slice(0, lenInBytes);
      }
      function expand_message_xof(msg, DST, lenInBytes, k, H) {
        (0, utils_ts_1.abytes)(msg);
        anum(lenInBytes);
        DST = normDST(DST);
        if (DST.length > 255) {
          const dkLen = Math.ceil(2 * k / 8);
          DST = H.create({ dkLen }).update((0, utils_ts_1.utf8ToBytes)("H2C-OVERSIZE-DST-")).update(DST).digest();
        }
        if (lenInBytes > 65535 || DST.length > 255)
          throw new Error("expand_message_xof: invalid lenInBytes");
        return H.create({ dkLen: lenInBytes }).update(msg).update(i2osp(lenInBytes, 2)).update(DST).update(i2osp(DST.length, 1)).digest();
      }
      function hash_to_field(msg, count, options) {
        (0, utils_ts_1._validateObject)(options, {
          p: "bigint",
          m: "number",
          k: "number",
          hash: "function"
        });
        const { p, k, m, hash: hash2, expand, DST } = options;
        if (!(0, utils_ts_1.isHash)(options.hash))
          throw new Error("expected valid hash");
        (0, utils_ts_1.abytes)(msg);
        anum(count);
        const log2p = p.toString(2).length;
        const L = Math.ceil((log2p + k) / 8);
        const len_in_bytes = count * m * L;
        let prb;
        if (expand === "xmd") {
          prb = expand_message_xmd(msg, DST, len_in_bytes, hash2);
        } else if (expand === "xof") {
          prb = expand_message_xof(msg, DST, len_in_bytes, k, hash2);
        } else if (expand === "_internal_pass") {
          prb = msg;
        } else {
          throw new Error('expand must be "xmd" or "xof"');
        }
        const u = new Array(count);
        for (let i = 0; i < count; i++) {
          const e = new Array(m);
          for (let j = 0; j < m; j++) {
            const elm_offset = L * (j + i * m);
            const tv = prb.subarray(elm_offset, elm_offset + L);
            e[j] = (0, modular_ts_1.mod)(os2ip(tv), p);
          }
          u[i] = e;
        }
        return u;
      }
      function isogenyMap(field, map) {
        const coeff = map.map((i) => Array.from(i).reverse());
        return (x, y) => {
          const [xn, xd, yn, yd] = coeff.map((val) => val.reduce((acc, i) => field.add(field.mul(acc, x), i)));
          const [xd_inv, yd_inv] = (0, modular_ts_1.FpInvertBatch)(field, [xd, yd], true);
          x = field.mul(xn, xd_inv);
          y = field.mul(y, field.mul(yn, yd_inv));
          return { x, y };
        };
      }
      exports._DST_scalar = (0, utils_ts_1.utf8ToBytes)("HashToScalar-");
      function createHasher2(Point, mapToCurve, defaults) {
        if (typeof mapToCurve !== "function")
          throw new Error("mapToCurve() must be defined");
        function map(num) {
          return Point.fromAffine(mapToCurve(num));
        }
        function clear(initial) {
          const P = initial.clearCofactor();
          if (P.equals(Point.ZERO))
            return Point.ZERO;
          P.assertValidity();
          return P;
        }
        return {
          defaults,
          hashToCurve(msg, options) {
            const opts = Object.assign({}, defaults, options);
            const u = hash_to_field(msg, 2, opts);
            const u0 = map(u[0]);
            const u1 = map(u[1]);
            return clear(u0.add(u1));
          },
          encodeToCurve(msg, options) {
            const optsDst = defaults.encodeDST ? { DST: defaults.encodeDST } : {};
            const opts = Object.assign({}, defaults, optsDst, options);
            const u = hash_to_field(msg, 1, opts);
            const u0 = map(u[0]);
            return clear(u0);
          },
          /** See {@link H2CHasher} */
          mapToCurve(scalars) {
            if (!Array.isArray(scalars))
              throw new Error("expected array of bigints");
            for (const i of scalars)
              if (typeof i !== "bigint")
                throw new Error("expected array of bigints");
            return clear(map(scalars));
          },
          // hash_to_scalar can produce 0: https://www.rfc-editor.org/errata/eid8393
          // RFC 9380, draft-irtf-cfrg-bbs-signatures-08
          hashToScalar(msg, options) {
            const N = Point.Fn.ORDER;
            const opts = Object.assign({}, defaults, { p: N, m: 1, DST: exports._DST_scalar }, options);
            return hash_to_field(msg, 1, opts)[0][0];
          }
        };
      }
    }
  });

  // node_modules/@noble/curves/abstract/montgomery.js
  var require_montgomery = __commonJS({
    "node_modules/@noble/curves/abstract/montgomery.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.montgomery = montgomery;
      var utils_ts_1 = require_utils2();
      var modular_ts_1 = require_modular();
      var _0n = BigInt(0);
      var _1n = BigInt(1);
      var _2n = BigInt(2);
      function validateOpts(curve) {
        (0, utils_ts_1._validateObject)(curve, {
          adjustScalarBytes: "function",
          powPminus2: "function"
        });
        return Object.freeze({ ...curve });
      }
      function montgomery(curveDef) {
        const CURVE = validateOpts(curveDef);
        const { P, type: type2, adjustScalarBytes, powPminus2, randomBytes: rand } = CURVE;
        const is25519 = type2 === "x25519";
        if (!is25519 && type2 !== "x448")
          throw new Error("invalid type");
        const randomBytes_ = rand || utils_ts_1.randomBytes;
        const montgomeryBits = is25519 ? 255 : 448;
        const fieldLen = is25519 ? 32 : 56;
        const Gu = is25519 ? BigInt(9) : BigInt(5);
        const a24 = is25519 ? BigInt(121665) : BigInt(39081);
        const minScalar = is25519 ? _2n ** BigInt(254) : _2n ** BigInt(447);
        const maxAdded = is25519 ? BigInt(8) * _2n ** BigInt(251) - _1n : BigInt(4) * _2n ** BigInt(445) - _1n;
        const maxScalar = minScalar + maxAdded + _1n;
        const modP = (n) => (0, modular_ts_1.mod)(n, P);
        const GuBytes = encodeU(Gu);
        function encodeU(u) {
          return (0, utils_ts_1.numberToBytesLE)(modP(u), fieldLen);
        }
        function decodeU(u) {
          const _u = (0, utils_ts_1.ensureBytes)("u coordinate", u, fieldLen);
          if (is25519)
            _u[31] &= 127;
          return modP((0, utils_ts_1.bytesToNumberLE)(_u));
        }
        function decodeScalar(scalar) {
          return (0, utils_ts_1.bytesToNumberLE)(adjustScalarBytes((0, utils_ts_1.ensureBytes)("scalar", scalar, fieldLen)));
        }
        function scalarMult(scalar, u) {
          const pu = montgomeryLadder(decodeU(u), decodeScalar(scalar));
          if (pu === _0n)
            throw new Error("invalid private or public key received");
          return encodeU(pu);
        }
        function scalarMultBase(scalar) {
          return scalarMult(scalar, GuBytes);
        }
        function cswap(swap, x_2, x_3) {
          const dummy = modP(swap * (x_2 - x_3));
          x_2 = modP(x_2 - dummy);
          x_3 = modP(x_3 + dummy);
          return { x_2, x_3 };
        }
        function montgomeryLadder(u, scalar) {
          (0, utils_ts_1.aInRange)("u", u, _0n, P);
          (0, utils_ts_1.aInRange)("scalar", scalar, minScalar, maxScalar);
          const k = scalar;
          const x_1 = u;
          let x_2 = _1n;
          let z_2 = _0n;
          let x_3 = u;
          let z_3 = _1n;
          let swap = _0n;
          for (let t = BigInt(montgomeryBits - 1); t >= _0n; t--) {
            const k_t = k >> t & _1n;
            swap ^= k_t;
            ({ x_2, x_3 } = cswap(swap, x_2, x_3));
            ({ x_2: z_2, x_3: z_3 } = cswap(swap, z_2, z_3));
            swap = k_t;
            const A = x_2 + z_2;
            const AA = modP(A * A);
            const B = x_2 - z_2;
            const BB = modP(B * B);
            const E = AA - BB;
            const C = x_3 + z_3;
            const D = x_3 - z_3;
            const DA = modP(D * A);
            const CB = modP(C * B);
            const dacb = DA + CB;
            const da_cb = DA - CB;
            x_3 = modP(dacb * dacb);
            z_3 = modP(x_1 * modP(da_cb * da_cb));
            x_2 = modP(AA * BB);
            z_2 = modP(E * (AA + modP(a24 * E)));
          }
          ({ x_2, x_3 } = cswap(swap, x_2, x_3));
          ({ x_2: z_2, x_3: z_3 } = cswap(swap, z_2, z_3));
          const z2 = powPminus2(z_2);
          return modP(x_2 * z2);
        }
        const lengths = {
          secretKey: fieldLen,
          publicKey: fieldLen,
          seed: fieldLen
        };
        const randomSecretKey = (seed2 = randomBytes_(fieldLen)) => {
          (0, utils_ts_1.abytes)(seed2, lengths.seed);
          return seed2;
        };
        function keygen(seed2) {
          const secretKey = randomSecretKey(seed2);
          return { secretKey, publicKey: scalarMultBase(secretKey) };
        }
        const utils = {
          randomSecretKey,
          randomPrivateKey: randomSecretKey
        };
        return {
          keygen,
          getSharedSecret: (secretKey, publicKey3) => scalarMult(secretKey, publicKey3),
          getPublicKey: (secretKey) => scalarMultBase(secretKey),
          scalarMult,
          scalarMultBase,
          utils,
          GuBytes: GuBytes.slice(),
          lengths
        };
      }
    }
  });

  // node_modules/@noble/curves/ed25519.js
  var require_ed25519 = __commonJS({
    "node_modules/@noble/curves/ed25519.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.hash_to_ristretto255 = exports.hashToRistretto255 = exports.encodeToCurve = exports.hashToCurve = exports.RistrettoPoint = exports.edwardsToMontgomery = exports.ED25519_TORSION_SUBGROUP = exports.ristretto255_hasher = exports.ristretto255 = exports.ed25519_hasher = exports.x25519 = exports.ed25519ph = exports.ed25519ctx = exports.ed25519 = void 0;
      exports.edwardsToMontgomeryPub = edwardsToMontgomeryPub;
      exports.edwardsToMontgomeryPriv = edwardsToMontgomeryPriv;
      var sha2_js_1 = require_sha2();
      var utils_js_1 = require_utils();
      var curve_ts_1 = require_curve();
      var edwards_ts_1 = require_edwards();
      var hash_to_curve_ts_1 = require_hash_to_curve();
      var modular_ts_1 = require_modular();
      var montgomery_ts_1 = require_montgomery();
      var utils_ts_1 = require_utils2();
      var _0n = /* @__PURE__ */ BigInt(0);
      var _1n = BigInt(1);
      var _2n = BigInt(2);
      var _3n = BigInt(3);
      var _5n = BigInt(5);
      var _8n = BigInt(8);
      var ed25519_CURVE_p = BigInt("0x7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffed");
      var ed25519_CURVE = /* @__PURE__ */ (() => ({
        p: ed25519_CURVE_p,
        n: BigInt("0x1000000000000000000000000000000014def9dea2f79cd65812631a5cf5d3ed"),
        h: _8n,
        a: BigInt("0x7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffec"),
        d: BigInt("0x52036cee2b6ffe738cc740797779e89800700a4d4141d8ab75eb4dca135978a3"),
        Gx: BigInt("0x216936d3cd6e53fec0a4e231fdd6dc5c692cc7609525a7b2c9562d608f25d51a"),
        Gy: BigInt("0x6666666666666666666666666666666666666666666666666666666666666658")
      }))();
      function ed25519_pow_2_252_3(x) {
        const _10n = BigInt(10), _20n = BigInt(20), _40n = BigInt(40), _80n = BigInt(80);
        const P = ed25519_CURVE_p;
        const x2 = x * x % P;
        const b2 = x2 * x % P;
        const b4 = (0, modular_ts_1.pow2)(b2, _2n, P) * b2 % P;
        const b5 = (0, modular_ts_1.pow2)(b4, _1n, P) * x % P;
        const b10 = (0, modular_ts_1.pow2)(b5, _5n, P) * b5 % P;
        const b20 = (0, modular_ts_1.pow2)(b10, _10n, P) * b10 % P;
        const b40 = (0, modular_ts_1.pow2)(b20, _20n, P) * b20 % P;
        const b80 = (0, modular_ts_1.pow2)(b40, _40n, P) * b40 % P;
        const b160 = (0, modular_ts_1.pow2)(b80, _80n, P) * b80 % P;
        const b240 = (0, modular_ts_1.pow2)(b160, _80n, P) * b80 % P;
        const b250 = (0, modular_ts_1.pow2)(b240, _10n, P) * b10 % P;
        const pow_p_5_8 = (0, modular_ts_1.pow2)(b250, _2n, P) * x % P;
        return { pow_p_5_8, b2 };
      }
      function adjustScalarBytes(bytes) {
        bytes[0] &= 248;
        bytes[31] &= 127;
        bytes[31] |= 64;
        return bytes;
      }
      var ED25519_SQRT_M1 = /* @__PURE__ */ BigInt("19681161376707505956807079304988542015446066515923890162744021073123829784752");
      function uvRatio(u, v) {
        const P = ed25519_CURVE_p;
        const v32 = (0, modular_ts_1.mod)(v * v * v, P);
        const v7 = (0, modular_ts_1.mod)(v32 * v32 * v, P);
        const pow = ed25519_pow_2_252_3(u * v7).pow_p_5_8;
        let x = (0, modular_ts_1.mod)(u * v32 * pow, P);
        const vx2 = (0, modular_ts_1.mod)(v * x * x, P);
        const root1 = x;
        const root2 = (0, modular_ts_1.mod)(x * ED25519_SQRT_M1, P);
        const useRoot1 = vx2 === u;
        const useRoot2 = vx2 === (0, modular_ts_1.mod)(-u, P);
        const noRoot = vx2 === (0, modular_ts_1.mod)(-u * ED25519_SQRT_M1, P);
        if (useRoot1)
          x = root1;
        if (useRoot2 || noRoot)
          x = root2;
        if ((0, modular_ts_1.isNegativeLE)(x, P))
          x = (0, modular_ts_1.mod)(-x, P);
        return { isValid: useRoot1 || useRoot2, value: x };
      }
      var Fp = /* @__PURE__ */ (() => (0, modular_ts_1.Field)(ed25519_CURVE.p, { isLE: true }))();
      var Fn = /* @__PURE__ */ (() => (0, modular_ts_1.Field)(ed25519_CURVE.n, { isLE: true }))();
      var ed25519Defaults = /* @__PURE__ */ (() => ({
        ...ed25519_CURVE,
        Fp,
        hash: sha2_js_1.sha512,
        adjustScalarBytes,
        // dom2
        // Ratio of u to v. Allows us to combine inversion and square root. Uses algo from RFC8032 5.1.3.
        // Constant-time, u/√v
        uvRatio
      }))();
      exports.ed25519 = (() => (0, edwards_ts_1.twistedEdwards)(ed25519Defaults))();
      function ed25519_domain(data, ctx, phflag) {
        if (ctx.length > 255)
          throw new Error("Context is too big");
        return (0, utils_js_1.concatBytes)((0, utils_js_1.utf8ToBytes)("SigEd25519 no Ed25519 collisions"), new Uint8Array([phflag ? 1 : 0, ctx.length]), ctx, data);
      }
      exports.ed25519ctx = (() => (0, edwards_ts_1.twistedEdwards)({
        ...ed25519Defaults,
        domain: ed25519_domain
      }))();
      exports.ed25519ph = (() => (0, edwards_ts_1.twistedEdwards)(Object.assign({}, ed25519Defaults, {
        domain: ed25519_domain,
        prehash: sha2_js_1.sha512
      })))();
      exports.x25519 = (() => {
        const P = Fp.ORDER;
        return (0, montgomery_ts_1.montgomery)({
          P,
          type: "x25519",
          powPminus2: (x) => {
            const { pow_p_5_8, b2 } = ed25519_pow_2_252_3(x);
            return (0, modular_ts_1.mod)((0, modular_ts_1.pow2)(pow_p_5_8, _3n, P) * b2, P);
          },
          adjustScalarBytes
        });
      })();
      var ELL2_C1 = /* @__PURE__ */ (() => (ed25519_CURVE_p + _3n) / _8n)();
      var ELL2_C2 = /* @__PURE__ */ (() => Fp.pow(_2n, ELL2_C1))();
      var ELL2_C3 = /* @__PURE__ */ (() => Fp.sqrt(Fp.neg(Fp.ONE)))();
      function map_to_curve_elligator2_curve25519(u) {
        const ELL2_C4 = (ed25519_CURVE_p - _5n) / _8n;
        const ELL2_J = BigInt(486662);
        let tv1 = Fp.sqr(u);
        tv1 = Fp.mul(tv1, _2n);
        let xd = Fp.add(tv1, Fp.ONE);
        let x1n = Fp.neg(ELL2_J);
        let tv2 = Fp.sqr(xd);
        let gxd = Fp.mul(tv2, xd);
        let gx1 = Fp.mul(tv1, ELL2_J);
        gx1 = Fp.mul(gx1, x1n);
        gx1 = Fp.add(gx1, tv2);
        gx1 = Fp.mul(gx1, x1n);
        let tv3 = Fp.sqr(gxd);
        tv2 = Fp.sqr(tv3);
        tv3 = Fp.mul(tv3, gxd);
        tv3 = Fp.mul(tv3, gx1);
        tv2 = Fp.mul(tv2, tv3);
        let y11 = Fp.pow(tv2, ELL2_C4);
        y11 = Fp.mul(y11, tv3);
        let y12 = Fp.mul(y11, ELL2_C3);
        tv2 = Fp.sqr(y11);
        tv2 = Fp.mul(tv2, gxd);
        let e1 = Fp.eql(tv2, gx1);
        let y1 = Fp.cmov(y12, y11, e1);
        let x2n = Fp.mul(x1n, tv1);
        let y21 = Fp.mul(y11, u);
        y21 = Fp.mul(y21, ELL2_C2);
        let y22 = Fp.mul(y21, ELL2_C3);
        let gx2 = Fp.mul(gx1, tv1);
        tv2 = Fp.sqr(y21);
        tv2 = Fp.mul(tv2, gxd);
        let e2 = Fp.eql(tv2, gx2);
        let y2 = Fp.cmov(y22, y21, e2);
        tv2 = Fp.sqr(y1);
        tv2 = Fp.mul(tv2, gxd);
        let e3 = Fp.eql(tv2, gx1);
        let xn = Fp.cmov(x2n, x1n, e3);
        let y = Fp.cmov(y2, y1, e3);
        let e4 = Fp.isOdd(y);
        y = Fp.cmov(y, Fp.neg(y), e3 !== e4);
        return { xMn: xn, xMd: xd, yMn: y, yMd: _1n };
      }
      var ELL2_C1_EDWARDS = /* @__PURE__ */ (() => (0, modular_ts_1.FpSqrtEven)(Fp, Fp.neg(BigInt(486664))))();
      function map_to_curve_elligator2_edwards25519(u) {
        const { xMn, xMd, yMn, yMd } = map_to_curve_elligator2_curve25519(u);
        let xn = Fp.mul(xMn, yMd);
        xn = Fp.mul(xn, ELL2_C1_EDWARDS);
        let xd = Fp.mul(xMd, yMn);
        let yn = Fp.sub(xMn, xMd);
        let yd = Fp.add(xMn, xMd);
        let tv1 = Fp.mul(xd, yd);
        let e = Fp.eql(tv1, Fp.ZERO);
        xn = Fp.cmov(xn, Fp.ZERO, e);
        xd = Fp.cmov(xd, Fp.ONE, e);
        yn = Fp.cmov(yn, Fp.ONE, e);
        yd = Fp.cmov(yd, Fp.ONE, e);
        const [xd_inv, yd_inv] = (0, modular_ts_1.FpInvertBatch)(Fp, [xd, yd], true);
        return { x: Fp.mul(xn, xd_inv), y: Fp.mul(yn, yd_inv) };
      }
      exports.ed25519_hasher = (() => (0, hash_to_curve_ts_1.createHasher)(exports.ed25519.Point, (scalars) => map_to_curve_elligator2_edwards25519(scalars[0]), {
        DST: "edwards25519_XMD:SHA-512_ELL2_RO_",
        encodeDST: "edwards25519_XMD:SHA-512_ELL2_NU_",
        p: ed25519_CURVE_p,
        m: 1,
        k: 128,
        expand: "xmd",
        hash: sha2_js_1.sha512
      }))();
      var SQRT_M1 = ED25519_SQRT_M1;
      var SQRT_AD_MINUS_ONE = /* @__PURE__ */ BigInt("25063068953384623474111414158702152701244531502492656460079210482610430750235");
      var INVSQRT_A_MINUS_D = /* @__PURE__ */ BigInt("54469307008909316920995813868745141605393597292927456921205312896311721017578");
      var ONE_MINUS_D_SQ = /* @__PURE__ */ BigInt("1159843021668779879193775521855586647937357759715417654439879720876111806838");
      var D_MINUS_ONE_SQ = /* @__PURE__ */ BigInt("40440834346308536858101042469323190826248399146238708352240133220865137265952");
      var invertSqrt = (number2) => uvRatio(_1n, number2);
      var MAX_255B = /* @__PURE__ */ BigInt("0x7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff");
      var bytes255ToNumberLE = (bytes) => exports.ed25519.Point.Fp.create((0, utils_ts_1.bytesToNumberLE)(bytes) & MAX_255B);
      function calcElligatorRistrettoMap(r0) {
        const { d } = ed25519_CURVE;
        const P = ed25519_CURVE_p;
        const mod = (n) => Fp.create(n);
        const r = mod(SQRT_M1 * r0 * r0);
        const Ns = mod((r + _1n) * ONE_MINUS_D_SQ);
        let c = BigInt(-1);
        const D = mod((c - d * r) * mod(r + d));
        let { isValid: Ns_D_is_sq, value: s } = uvRatio(Ns, D);
        let s_ = mod(s * r0);
        if (!(0, modular_ts_1.isNegativeLE)(s_, P))
          s_ = mod(-s_);
        if (!Ns_D_is_sq)
          s = s_;
        if (!Ns_D_is_sq)
          c = r;
        const Nt = mod(c * (r - _1n) * D_MINUS_ONE_SQ - D);
        const s2 = s * s;
        const W0 = mod((s + s) * D);
        const W1 = mod(Nt * SQRT_AD_MINUS_ONE);
        const W2 = mod(_1n - s2);
        const W3 = mod(_1n + s2);
        return new exports.ed25519.Point(mod(W0 * W3), mod(W2 * W1), mod(W1 * W3), mod(W0 * W2));
      }
      function ristretto255_map(bytes) {
        (0, utils_js_1.abytes)(bytes, 64);
        const r1 = bytes255ToNumberLE(bytes.subarray(0, 32));
        const R1 = calcElligatorRistrettoMap(r1);
        const r2 = bytes255ToNumberLE(bytes.subarray(32, 64));
        const R2 = calcElligatorRistrettoMap(r2);
        return new _RistrettoPoint(R1.add(R2));
      }
      var _RistrettoPoint = class __RistrettoPoint extends edwards_ts_1.PrimeEdwardsPoint {
        constructor(ep) {
          super(ep);
        }
        static fromAffine(ap) {
          return new __RistrettoPoint(exports.ed25519.Point.fromAffine(ap));
        }
        assertSame(other) {
          if (!(other instanceof __RistrettoPoint))
            throw new Error("RistrettoPoint expected");
        }
        init(ep) {
          return new __RistrettoPoint(ep);
        }
        /** @deprecated use `import { ristretto255_hasher } from '@noble/curves/ed25519.js';` */
        static hashToCurve(hex2) {
          return ristretto255_map((0, utils_ts_1.ensureBytes)("ristrettoHash", hex2, 64));
        }
        static fromBytes(bytes) {
          (0, utils_js_1.abytes)(bytes, 32);
          const { a, d } = ed25519_CURVE;
          const P = ed25519_CURVE_p;
          const mod = (n) => Fp.create(n);
          const s = bytes255ToNumberLE(bytes);
          if (!(0, utils_ts_1.equalBytes)(Fp.toBytes(s), bytes) || (0, modular_ts_1.isNegativeLE)(s, P))
            throw new Error("invalid ristretto255 encoding 1");
          const s2 = mod(s * s);
          const u1 = mod(_1n + a * s2);
          const u2 = mod(_1n - a * s2);
          const u1_2 = mod(u1 * u1);
          const u2_2 = mod(u2 * u2);
          const v = mod(a * d * u1_2 - u2_2);
          const { isValid, value: I } = invertSqrt(mod(v * u2_2));
          const Dx = mod(I * u2);
          const Dy = mod(I * Dx * v);
          let x = mod((s + s) * Dx);
          if ((0, modular_ts_1.isNegativeLE)(x, P))
            x = mod(-x);
          const y = mod(u1 * Dy);
          const t = mod(x * y);
          if (!isValid || (0, modular_ts_1.isNegativeLE)(t, P) || y === _0n)
            throw new Error("invalid ristretto255 encoding 2");
          return new __RistrettoPoint(new exports.ed25519.Point(x, y, _1n, t));
        }
        /**
         * Converts ristretto-encoded string to ristretto point.
         * Described in [RFC9496](https://www.rfc-editor.org/rfc/rfc9496#name-decode).
         * @param hex Ristretto-encoded 32 bytes. Not every 32-byte string is valid ristretto encoding
         */
        static fromHex(hex2) {
          return __RistrettoPoint.fromBytes((0, utils_ts_1.ensureBytes)("ristrettoHex", hex2, 32));
        }
        static msm(points, scalars) {
          return (0, curve_ts_1.pippenger)(__RistrettoPoint, exports.ed25519.Point.Fn, points, scalars);
        }
        /**
         * Encodes ristretto point to Uint8Array.
         * Described in [RFC9496](https://www.rfc-editor.org/rfc/rfc9496#name-encode).
         */
        toBytes() {
          let { X, Y, Z, T } = this.ep;
          const P = ed25519_CURVE_p;
          const mod = (n) => Fp.create(n);
          const u1 = mod(mod(Z + Y) * mod(Z - Y));
          const u2 = mod(X * Y);
          const u2sq = mod(u2 * u2);
          const { value: invsqrt } = invertSqrt(mod(u1 * u2sq));
          const D1 = mod(invsqrt * u1);
          const D2 = mod(invsqrt * u2);
          const zInv = mod(D1 * D2 * T);
          let D;
          if ((0, modular_ts_1.isNegativeLE)(T * zInv, P)) {
            let _x = mod(Y * SQRT_M1);
            let _y = mod(X * SQRT_M1);
            X = _x;
            Y = _y;
            D = mod(D1 * INVSQRT_A_MINUS_D);
          } else {
            D = D2;
          }
          if ((0, modular_ts_1.isNegativeLE)(X * zInv, P))
            Y = mod(-Y);
          let s = mod((Z - Y) * D);
          if ((0, modular_ts_1.isNegativeLE)(s, P))
            s = mod(-s);
          return Fp.toBytes(s);
        }
        /**
         * Compares two Ristretto points.
         * Described in [RFC9496](https://www.rfc-editor.org/rfc/rfc9496#name-equals).
         */
        equals(other) {
          this.assertSame(other);
          const { X: X1, Y: Y1 } = this.ep;
          const { X: X2, Y: Y2 } = other.ep;
          const mod = (n) => Fp.create(n);
          const one = mod(X1 * Y2) === mod(Y1 * X2);
          const two = mod(Y1 * Y2) === mod(X1 * X2);
          return one || two;
        }
        is0() {
          return this.equals(__RistrettoPoint.ZERO);
        }
      };
      _RistrettoPoint.BASE = /* @__PURE__ */ (() => new _RistrettoPoint(exports.ed25519.Point.BASE))();
      _RistrettoPoint.ZERO = /* @__PURE__ */ (() => new _RistrettoPoint(exports.ed25519.Point.ZERO))();
      _RistrettoPoint.Fp = /* @__PURE__ */ (() => Fp)();
      _RistrettoPoint.Fn = /* @__PURE__ */ (() => Fn)();
      exports.ristretto255 = { Point: _RistrettoPoint };
      exports.ristretto255_hasher = {
        hashToCurve(msg, options) {
          const DST = options?.DST || "ristretto255_XMD:SHA-512_R255MAP_RO_";
          const xmd = (0, hash_to_curve_ts_1.expand_message_xmd)(msg, DST, 64, sha2_js_1.sha512);
          return ristretto255_map(xmd);
        },
        hashToScalar(msg, options = { DST: hash_to_curve_ts_1._DST_scalar }) {
          const xmd = (0, hash_to_curve_ts_1.expand_message_xmd)(msg, options.DST, 64, sha2_js_1.sha512);
          return Fn.create((0, utils_ts_1.bytesToNumberLE)(xmd));
        }
      };
      exports.ED25519_TORSION_SUBGROUP = [
        "0100000000000000000000000000000000000000000000000000000000000000",
        "c7176a703d4dd84fba3c0b760d10670f2a2053fa2c39ccc64ec7fd7792ac037a",
        "0000000000000000000000000000000000000000000000000000000000000080",
        "26e8958fc2b227b045c3f489f2ef98f0d5dfac05d3c63339b13802886d53fc05",
        "ecffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff7f",
        "26e8958fc2b227b045c3f489f2ef98f0d5dfac05d3c63339b13802886d53fc85",
        "0000000000000000000000000000000000000000000000000000000000000000",
        "c7176a703d4dd84fba3c0b760d10670f2a2053fa2c39ccc64ec7fd7792ac03fa"
      ];
      function edwardsToMontgomeryPub(edwardsPub) {
        return exports.ed25519.utils.toMontgomery((0, utils_ts_1.ensureBytes)("pub", edwardsPub));
      }
      exports.edwardsToMontgomery = edwardsToMontgomeryPub;
      function edwardsToMontgomeryPriv(edwardsPriv) {
        return exports.ed25519.utils.toMontgomerySecret((0, utils_ts_1.ensureBytes)("pub", edwardsPriv));
      }
      exports.RistrettoPoint = _RistrettoPoint;
      exports.hashToCurve = (() => exports.ed25519_hasher.hashToCurve)();
      exports.encodeToCurve = (() => exports.ed25519_hasher.encodeToCurve)();
      exports.hashToRistretto255 = (() => exports.ristretto255_hasher.hashToCurve)();
      exports.hash_to_ristretto255 = (() => exports.ristretto255_hasher.hashToCurve)();
    }
  });

  // (disabled):node_modules/buffer/index.js
  var require_buffer2 = __commonJS({
    "(disabled):node_modules/buffer/index.js"() {
    }
  });

  // node_modules/bn.js/lib/bn.js
  var require_bn = __commonJS({
    "node_modules/bn.js/lib/bn.js"(exports, module) {
      (function(module2, exports2) {
        "use strict";
        function assert2(val, msg) {
          if (!val) throw new Error(msg || "Assertion failed");
        }
        function inherits(ctor, superCtor) {
          ctor.super_ = superCtor;
          var TempCtor = function() {
          };
          TempCtor.prototype = superCtor.prototype;
          ctor.prototype = new TempCtor();
          ctor.prototype.constructor = ctor;
        }
        function BN2(number2, base, endian) {
          if (BN2.isBN(number2)) {
            return number2;
          }
          this.negative = 0;
          this.words = null;
          this.length = 0;
          this.red = null;
          if (number2 !== null) {
            if (base === "le" || base === "be") {
              endian = base;
              base = 10;
            }
            this._init(number2 || 0, base || 10, endian || "be");
          }
        }
        if (typeof module2 === "object") {
          module2.exports = BN2;
        } else {
          exports2.BN = BN2;
        }
        BN2.BN = BN2;
        BN2.wordSize = 26;
        var Buffer3;
        try {
          if (typeof window !== "undefined" && typeof window.Buffer !== "undefined") {
            Buffer3 = window.Buffer;
          } else {
            Buffer3 = require_buffer2().Buffer;
          }
        } catch (e) {
        }
        BN2.isBN = function isBN(num) {
          if (num instanceof BN2) {
            return true;
          }
          return num !== null && typeof num === "object" && num.constructor.wordSize === BN2.wordSize && Array.isArray(num.words);
        };
        BN2.max = function max(left, right) {
          if (left.cmp(right) > 0) return left;
          return right;
        };
        BN2.min = function min(left, right) {
          if (left.cmp(right) < 0) return left;
          return right;
        };
        BN2.prototype._init = function init(number2, base, endian) {
          if (typeof number2 === "number") {
            return this._initNumber(number2, base, endian);
          }
          if (typeof number2 === "object") {
            return this._initArray(number2, base, endian);
          }
          if (base === "hex") {
            base = 16;
          }
          assert2(base === (base | 0) && base >= 2 && base <= 36);
          number2 = number2.toString().replace(/\s+/g, "");
          var start = 0;
          if (number2[0] === "-") {
            start++;
            this.negative = 1;
          }
          if (start < number2.length) {
            if (base === 16) {
              this._parseHex(number2, start, endian);
            } else {
              this._parseBase(number2, base, start);
              if (endian === "le") {
                this._initArray(this.toArray(), base, endian);
              }
            }
          }
        };
        BN2.prototype._initNumber = function _initNumber(number2, base, endian) {
          if (number2 < 0) {
            this.negative = 1;
            number2 = -number2;
          }
          if (number2 < 67108864) {
            this.words = [number2 & 67108863];
            this.length = 1;
          } else if (number2 < 4503599627370496) {
            this.words = [
              number2 & 67108863,
              number2 / 67108864 & 67108863
            ];
            this.length = 2;
          } else {
            assert2(number2 < 9007199254740992);
            this.words = [
              number2 & 67108863,
              number2 / 67108864 & 67108863,
              1
            ];
            this.length = 3;
          }
          if (endian !== "le") return;
          this._initArray(this.toArray(), base, endian);
        };
        BN2.prototype._initArray = function _initArray(number2, base, endian) {
          assert2(typeof number2.length === "number");
          if (number2.length <= 0) {
            this.words = [0];
            this.length = 1;
            return this;
          }
          this.length = Math.ceil(number2.length / 3);
          this.words = new Array(this.length);
          for (var i = 0; i < this.length; i++) {
            this.words[i] = 0;
          }
          var j, w;
          var off = 0;
          if (endian === "be") {
            for (i = number2.length - 1, j = 0; i >= 0; i -= 3) {
              w = number2[i] | number2[i - 1] << 8 | number2[i - 2] << 16;
              this.words[j] |= w << off & 67108863;
              this.words[j + 1] = w >>> 26 - off & 67108863;
              off += 24;
              if (off >= 26) {
                off -= 26;
                j++;
              }
            }
          } else if (endian === "le") {
            for (i = 0, j = 0; i < number2.length; i += 3) {
              w = number2[i] | number2[i + 1] << 8 | number2[i + 2] << 16;
              this.words[j] |= w << off & 67108863;
              this.words[j + 1] = w >>> 26 - off & 67108863;
              off += 24;
              if (off >= 26) {
                off -= 26;
                j++;
              }
            }
          }
          return this._strip();
        };
        function parseHex4Bits(string2, index2) {
          var c = string2.charCodeAt(index2);
          if (c >= 48 && c <= 57) {
            return c - 48;
          } else if (c >= 65 && c <= 70) {
            return c - 55;
          } else if (c >= 97 && c <= 102) {
            return c - 87;
          } else {
            assert2(false, "Invalid character in " + string2);
          }
        }
        function parseHexByte(string2, lowerBound, index2) {
          var r = parseHex4Bits(string2, index2);
          if (index2 - 1 >= lowerBound) {
            r |= parseHex4Bits(string2, index2 - 1) << 4;
          }
          return r;
        }
        BN2.prototype._parseHex = function _parseHex(number2, start, endian) {
          this.length = Math.ceil((number2.length - start) / 6);
          this.words = new Array(this.length);
          for (var i = 0; i < this.length; i++) {
            this.words[i] = 0;
          }
          var off = 0;
          var j = 0;
          var w;
          if (endian === "be") {
            for (i = number2.length - 1; i >= start; i -= 2) {
              w = parseHexByte(number2, start, i) << off;
              this.words[j] |= w & 67108863;
              if (off >= 18) {
                off -= 18;
                j += 1;
                this.words[j] |= w >>> 26;
              } else {
                off += 8;
              }
            }
          } else {
            var parseLength = number2.length - start;
            for (i = parseLength % 2 === 0 ? start + 1 : start; i < number2.length; i += 2) {
              w = parseHexByte(number2, start, i) << off;
              this.words[j] |= w & 67108863;
              if (off >= 18) {
                off -= 18;
                j += 1;
                this.words[j] |= w >>> 26;
              } else {
                off += 8;
              }
            }
          }
          this._strip();
        };
        function parseBase(str2, start, end, mul) {
          var r = 0;
          var b = 0;
          var len = Math.min(str2.length, end);
          for (var i = start; i < len; i++) {
            var c = str2.charCodeAt(i) - 48;
            r *= mul;
            if (c >= 49) {
              b = c - 49 + 10;
            } else if (c >= 17) {
              b = c - 17 + 10;
            } else {
              b = c;
            }
            assert2(c >= 0 && b < mul, "Invalid character");
            r += b;
          }
          return r;
        }
        BN2.prototype._parseBase = function _parseBase(number2, base, start) {
          this.words = [0];
          this.length = 1;
          for (var limbLen = 0, limbPow = 1; limbPow <= 67108863; limbPow *= base) {
            limbLen++;
          }
          limbLen--;
          limbPow = limbPow / base | 0;
          var total = number2.length - start;
          var mod = total % limbLen;
          var end = Math.min(total, total - mod) + start;
          var word = 0;
          for (var i = start; i < end; i += limbLen) {
            word = parseBase(number2, i, i + limbLen, base);
            this.imuln(limbPow);
            if (this.words[0] + word < 67108864) {
              this.words[0] += word;
            } else {
              this._iaddn(word);
            }
          }
          if (mod !== 0) {
            var pow = 1;
            word = parseBase(number2, i, number2.length, base);
            for (i = 0; i < mod; i++) {
              pow *= base;
            }
            this.imuln(pow);
            if (this.words[0] + word < 67108864) {
              this.words[0] += word;
            } else {
              this._iaddn(word);
            }
          }
          this._strip();
        };
        BN2.prototype.copy = function copy(dest) {
          dest.words = new Array(this.length);
          for (var i = 0; i < this.length; i++) {
            dest.words[i] = this.words[i];
          }
          dest.length = this.length;
          dest.negative = this.negative;
          dest.red = this.red;
        };
        function move(dest, src) {
          dest.words = src.words;
          dest.length = src.length;
          dest.negative = src.negative;
          dest.red = src.red;
        }
        BN2.prototype._move = function _move(dest) {
          move(dest, this);
        };
        BN2.prototype.clone = function clone() {
          var r = new BN2(null);
          this.copy(r);
          return r;
        };
        BN2.prototype._expand = function _expand(size) {
          while (this.length < size) {
            this.words[this.length++] = 0;
          }
          return this;
        };
        BN2.prototype._strip = function strip() {
          while (this.length > 1 && this.words[this.length - 1] === 0) {
            this.length--;
          }
          return this._normSign();
        };
        BN2.prototype._normSign = function _normSign() {
          if (this.length === 1 && this.words[0] === 0) {
            this.negative = 0;
          }
          return this;
        };
        if (typeof Symbol !== "undefined" && typeof Symbol.for === "function") {
          try {
            BN2.prototype[Symbol.for("nodejs.util.inspect.custom")] = inspect;
          } catch (e) {
            BN2.prototype.inspect = inspect;
          }
        } else {
          BN2.prototype.inspect = inspect;
        }
        function inspect() {
          return (this.red ? "<BN-R: " : "<BN: ") + this.toString(16) + ">";
        }
        var zeros = [
          "",
          "0",
          "00",
          "000",
          "0000",
          "00000",
          "000000",
          "0000000",
          "00000000",
          "000000000",
          "0000000000",
          "00000000000",
          "000000000000",
          "0000000000000",
          "00000000000000",
          "000000000000000",
          "0000000000000000",
          "00000000000000000",
          "000000000000000000",
          "0000000000000000000",
          "00000000000000000000",
          "000000000000000000000",
          "0000000000000000000000",
          "00000000000000000000000",
          "000000000000000000000000",
          "0000000000000000000000000"
        ];
        var groupSizes = [
          0,
          0,
          25,
          16,
          12,
          11,
          10,
          9,
          8,
          8,
          7,
          7,
          7,
          7,
          6,
          6,
          6,
          6,
          6,
          6,
          6,
          5,
          5,
          5,
          5,
          5,
          5,
          5,
          5,
          5,
          5,
          5,
          5,
          5,
          5,
          5,
          5
        ];
        var groupBases = [
          0,
          0,
          33554432,
          43046721,
          16777216,
          48828125,
          60466176,
          40353607,
          16777216,
          43046721,
          1e7,
          19487171,
          35831808,
          62748517,
          7529536,
          11390625,
          16777216,
          24137569,
          34012224,
          47045881,
          64e6,
          4084101,
          5153632,
          6436343,
          7962624,
          9765625,
          11881376,
          14348907,
          17210368,
          20511149,
          243e5,
          28629151,
          33554432,
          39135393,
          45435424,
          52521875,
          60466176
        ];
        BN2.prototype.toString = function toString2(base, padding) {
          base = base || 10;
          padding = padding | 0 || 1;
          var out;
          if (base === 16 || base === "hex") {
            out = "";
            var off = 0;
            var carry = 0;
            for (var i = 0; i < this.length; i++) {
              var w = this.words[i];
              var word = ((w << off | carry) & 16777215).toString(16);
              carry = w >>> 24 - off & 16777215;
              off += 2;
              if (off >= 26) {
                off -= 26;
                i--;
              }
              if (carry !== 0 || i !== this.length - 1) {
                out = zeros[6 - word.length] + word + out;
              } else {
                out = word + out;
              }
            }
            if (carry !== 0) {
              out = carry.toString(16) + out;
            }
            while (out.length % padding !== 0) {
              out = "0" + out;
            }
            if (this.negative !== 0) {
              out = "-" + out;
            }
            return out;
          }
          if (base === (base | 0) && base >= 2 && base <= 36) {
            var groupSize = groupSizes[base];
            var groupBase = groupBases[base];
            out = "";
            var c = this.clone();
            c.negative = 0;
            while (!c.isZero()) {
              var r = c.modrn(groupBase).toString(base);
              c = c.idivn(groupBase);
              if (!c.isZero()) {
                out = zeros[groupSize - r.length] + r + out;
              } else {
                out = r + out;
              }
            }
            if (this.isZero()) {
              out = "0" + out;
            }
            while (out.length % padding !== 0) {
              out = "0" + out;
            }
            if (this.negative !== 0) {
              out = "-" + out;
            }
            return out;
          }
          assert2(false, "Base should be between 2 and 36");
        };
        BN2.prototype.toNumber = function toNumber() {
          var ret = this.words[0];
          if (this.length === 2) {
            ret += this.words[1] * 67108864;
          } else if (this.length === 3 && this.words[2] === 1) {
            ret += 4503599627370496 + this.words[1] * 67108864;
          } else if (this.length > 2) {
            assert2(false, "Number can only safely store up to 53 bits");
          }
          return this.negative !== 0 ? -ret : ret;
        };
        BN2.prototype.toJSON = function toJSON() {
          return this.toString(16, 2);
        };
        if (Buffer3) {
          BN2.prototype.toBuffer = function toBuffer(endian, length) {
            return this.toArrayLike(Buffer3, endian, length);
          };
        }
        BN2.prototype.toArray = function toArray(endian, length) {
          return this.toArrayLike(Array, endian, length);
        };
        var allocate = function allocate2(ArrayType, size) {
          if (ArrayType.allocUnsafe) {
            return ArrayType.allocUnsafe(size);
          }
          return new ArrayType(size);
        };
        BN2.prototype.toArrayLike = function toArrayLike(ArrayType, endian, length) {
          this._strip();
          var byteLength = this.byteLength();
          var reqLength = length || Math.max(1, byteLength);
          assert2(byteLength <= reqLength, "byte array longer than desired length");
          assert2(reqLength > 0, "Requested array length <= 0");
          var res = allocate(ArrayType, reqLength);
          var postfix = endian === "le" ? "LE" : "BE";
          this["_toArrayLike" + postfix](res, byteLength);
          return res;
        };
        BN2.prototype._toArrayLikeLE = function _toArrayLikeLE(res, byteLength) {
          var position = 0;
          var carry = 0;
          for (var i = 0, shift = 0; i < this.length; i++) {
            var word = this.words[i] << shift | carry;
            res[position++] = word & 255;
            if (position < res.length) {
              res[position++] = word >> 8 & 255;
            }
            if (position < res.length) {
              res[position++] = word >> 16 & 255;
            }
            if (shift === 6) {
              if (position < res.length) {
                res[position++] = word >> 24 & 255;
              }
              carry = 0;
              shift = 0;
            } else {
              carry = word >>> 24;
              shift += 2;
            }
          }
          if (position < res.length) {
            res[position++] = carry;
            while (position < res.length) {
              res[position++] = 0;
            }
          }
        };
        BN2.prototype._toArrayLikeBE = function _toArrayLikeBE(res, byteLength) {
          var position = res.length - 1;
          var carry = 0;
          for (var i = 0, shift = 0; i < this.length; i++) {
            var word = this.words[i] << shift | carry;
            res[position--] = word & 255;
            if (position >= 0) {
              res[position--] = word >> 8 & 255;
            }
            if (position >= 0) {
              res[position--] = word >> 16 & 255;
            }
            if (shift === 6) {
              if (position >= 0) {
                res[position--] = word >> 24 & 255;
              }
              carry = 0;
              shift = 0;
            } else {
              carry = word >>> 24;
              shift += 2;
            }
          }
          if (position >= 0) {
            res[position--] = carry;
            while (position >= 0) {
              res[position--] = 0;
            }
          }
        };
        if (Math.clz32) {
          BN2.prototype._countBits = function _countBits(w) {
            return 32 - Math.clz32(w);
          };
        } else {
          BN2.prototype._countBits = function _countBits(w) {
            var t = w;
            var r = 0;
            if (t >= 4096) {
              r += 13;
              t >>>= 13;
            }
            if (t >= 64) {
              r += 7;
              t >>>= 7;
            }
            if (t >= 8) {
              r += 4;
              t >>>= 4;
            }
            if (t >= 2) {
              r += 2;
              t >>>= 2;
            }
            return r + t;
          };
        }
        BN2.prototype._zeroBits = function _zeroBits(w) {
          if (w === 0) return 26;
          var t = w;
          var r = 0;
          if ((t & 8191) === 0) {
            r += 13;
            t >>>= 13;
          }
          if ((t & 127) === 0) {
            r += 7;
            t >>>= 7;
          }
          if ((t & 15) === 0) {
            r += 4;
            t >>>= 4;
          }
          if ((t & 3) === 0) {
            r += 2;
            t >>>= 2;
          }
          if ((t & 1) === 0) {
            r++;
          }
          return r;
        };
        BN2.prototype.bitLength = function bitLength() {
          var w = this.words[this.length - 1];
          var hi = this._countBits(w);
          return (this.length - 1) * 26 + hi;
        };
        function toBitArray(num) {
          var w = new Array(num.bitLength());
          for (var bit = 0; bit < w.length; bit++) {
            var off = bit / 26 | 0;
            var wbit = bit % 26;
            w[bit] = num.words[off] >>> wbit & 1;
          }
          return w;
        }
        BN2.prototype.zeroBits = function zeroBits() {
          if (this.isZero()) return 0;
          var r = 0;
          for (var i = 0; i < this.length; i++) {
            var b = this._zeroBits(this.words[i]);
            r += b;
            if (b !== 26) break;
          }
          return r;
        };
        BN2.prototype.byteLength = function byteLength() {
          return Math.ceil(this.bitLength() / 8);
        };
        BN2.prototype.toTwos = function toTwos(width) {
          if (this.negative !== 0) {
            return this.abs().inotn(width).iaddn(1);
          }
          return this.clone();
        };
        BN2.prototype.fromTwos = function fromTwos(width) {
          if (this.testn(width - 1)) {
            return this.notn(width).iaddn(1).ineg();
          }
          return this.clone();
        };
        BN2.prototype.isNeg = function isNeg() {
          return this.negative !== 0;
        };
        BN2.prototype.neg = function neg() {
          return this.clone().ineg();
        };
        BN2.prototype.ineg = function ineg() {
          if (!this.isZero()) {
            this.negative ^= 1;
          }
          return this;
        };
        BN2.prototype.iuor = function iuor(num) {
          while (this.length < num.length) {
            this.words[this.length++] = 0;
          }
          for (var i = 0; i < num.length; i++) {
            this.words[i] = this.words[i] | num.words[i];
          }
          return this._strip();
        };
        BN2.prototype.ior = function ior(num) {
          assert2((this.negative | num.negative) === 0);
          return this.iuor(num);
        };
        BN2.prototype.or = function or(num) {
          if (this.length > num.length) return this.clone().ior(num);
          return num.clone().ior(this);
        };
        BN2.prototype.uor = function uor(num) {
          if (this.length > num.length) return this.clone().iuor(num);
          return num.clone().iuor(this);
        };
        BN2.prototype.iuand = function iuand(num) {
          var b;
          if (this.length > num.length) {
            b = num;
          } else {
            b = this;
          }
          for (var i = 0; i < b.length; i++) {
            this.words[i] = this.words[i] & num.words[i];
          }
          this.length = b.length;
          return this._strip();
        };
        BN2.prototype.iand = function iand(num) {
          assert2((this.negative | num.negative) === 0);
          return this.iuand(num);
        };
        BN2.prototype.and = function and(num) {
          if (this.length > num.length) return this.clone().iand(num);
          return num.clone().iand(this);
        };
        BN2.prototype.uand = function uand(num) {
          if (this.length > num.length) return this.clone().iuand(num);
          return num.clone().iuand(this);
        };
        BN2.prototype.iuxor = function iuxor(num) {
          var a;
          var b;
          if (this.length > num.length) {
            a = this;
            b = num;
          } else {
            a = num;
            b = this;
          }
          for (var i = 0; i < b.length; i++) {
            this.words[i] = a.words[i] ^ b.words[i];
          }
          if (this !== a) {
            for (; i < a.length; i++) {
              this.words[i] = a.words[i];
            }
          }
          this.length = a.length;
          return this._strip();
        };
        BN2.prototype.ixor = function ixor(num) {
          assert2((this.negative | num.negative) === 0);
          return this.iuxor(num);
        };
        BN2.prototype.xor = function xor(num) {
          if (this.length > num.length) return this.clone().ixor(num);
          return num.clone().ixor(this);
        };
        BN2.prototype.uxor = function uxor(num) {
          if (this.length > num.length) return this.clone().iuxor(num);
          return num.clone().iuxor(this);
        };
        BN2.prototype.inotn = function inotn(width) {
          assert2(typeof width === "number" && width >= 0);
          var bytesNeeded = Math.ceil(width / 26) | 0;
          var bitsLeft = width % 26;
          this._expand(bytesNeeded);
          if (bitsLeft > 0) {
            bytesNeeded--;
          }
          for (var i = 0; i < bytesNeeded; i++) {
            this.words[i] = ~this.words[i] & 67108863;
          }
          if (bitsLeft > 0) {
            this.words[i] = ~this.words[i] & 67108863 >> 26 - bitsLeft;
          }
          return this._strip();
        };
        BN2.prototype.notn = function notn(width) {
          return this.clone().inotn(width);
        };
        BN2.prototype.setn = function setn(bit, val) {
          assert2(typeof bit === "number" && bit >= 0);
          var off = bit / 26 | 0;
          var wbit = bit % 26;
          this._expand(off + 1);
          if (val) {
            this.words[off] = this.words[off] | 1 << wbit;
          } else {
            this.words[off] = this.words[off] & ~(1 << wbit);
          }
          return this._strip();
        };
        BN2.prototype.iadd = function iadd(num) {
          var r;
          if (this.negative !== 0 && num.negative === 0) {
            this.negative = 0;
            r = this.isub(num);
            this.negative ^= 1;
            return this._normSign();
          } else if (this.negative === 0 && num.negative !== 0) {
            num.negative = 0;
            r = this.isub(num);
            num.negative = 1;
            return r._normSign();
          }
          var a, b;
          if (this.length > num.length) {
            a = this;
            b = num;
          } else {
            a = num;
            b = this;
          }
          var carry = 0;
          for (var i = 0; i < b.length; i++) {
            r = (a.words[i] | 0) + (b.words[i] | 0) + carry;
            this.words[i] = r & 67108863;
            carry = r >>> 26;
          }
          for (; carry !== 0 && i < a.length; i++) {
            r = (a.words[i] | 0) + carry;
            this.words[i] = r & 67108863;
            carry = r >>> 26;
          }
          this.length = a.length;
          if (carry !== 0) {
            this.words[this.length] = carry;
            this.length++;
          } else if (a !== this) {
            for (; i < a.length; i++) {
              this.words[i] = a.words[i];
            }
          }
          return this;
        };
        BN2.prototype.add = function add(num) {
          var res;
          if (num.negative !== 0 && this.negative === 0) {
            num.negative = 0;
            res = this.sub(num);
            num.negative ^= 1;
            return res;
          } else if (num.negative === 0 && this.negative !== 0) {
            this.negative = 0;
            res = num.sub(this);
            this.negative = 1;
            return res;
          }
          if (this.length > num.length) return this.clone().iadd(num);
          return num.clone().iadd(this);
        };
        BN2.prototype.isub = function isub(num) {
          if (num.negative !== 0) {
            num.negative = 0;
            var r = this.iadd(num);
            num.negative = 1;
            return r._normSign();
          } else if (this.negative !== 0) {
            this.negative = 0;
            this.iadd(num);
            this.negative = 1;
            return this._normSign();
          }
          var cmp = this.cmp(num);
          if (cmp === 0) {
            this.negative = 0;
            this.length = 1;
            this.words[0] = 0;
            return this;
          }
          var a, b;
          if (cmp > 0) {
            a = this;
            b = num;
          } else {
            a = num;
            b = this;
          }
          var carry = 0;
          for (var i = 0; i < b.length; i++) {
            r = (a.words[i] | 0) - (b.words[i] | 0) + carry;
            carry = r >> 26;
            this.words[i] = r & 67108863;
          }
          for (; carry !== 0 && i < a.length; i++) {
            r = (a.words[i] | 0) + carry;
            carry = r >> 26;
            this.words[i] = r & 67108863;
          }
          if (carry === 0 && i < a.length && a !== this) {
            for (; i < a.length; i++) {
              this.words[i] = a.words[i];
            }
          }
          this.length = Math.max(this.length, i);
          if (a !== this) {
            this.negative = 1;
          }
          return this._strip();
        };
        BN2.prototype.sub = function sub(num) {
          return this.clone().isub(num);
        };
        function smallMulTo(self2, num, out) {
          out.negative = num.negative ^ self2.negative;
          var len = self2.length + num.length | 0;
          out.length = len;
          len = len - 1 | 0;
          var a = self2.words[0] | 0;
          var b = num.words[0] | 0;
          var r = a * b;
          var lo = r & 67108863;
          var carry = r / 67108864 | 0;
          out.words[0] = lo;
          for (var k = 1; k < len; k++) {
            var ncarry = carry >>> 26;
            var rword = carry & 67108863;
            var maxJ = Math.min(k, num.length - 1);
            for (var j = Math.max(0, k - self2.length + 1); j <= maxJ; j++) {
              var i = k - j | 0;
              a = self2.words[i] | 0;
              b = num.words[j] | 0;
              r = a * b + rword;
              ncarry += r / 67108864 | 0;
              rword = r & 67108863;
            }
            out.words[k] = rword | 0;
            carry = ncarry | 0;
          }
          if (carry !== 0) {
            out.words[k] = carry | 0;
          } else {
            out.length--;
          }
          return out._strip();
        }
        var comb10MulTo = function comb10MulTo2(self2, num, out) {
          var a = self2.words;
          var b = num.words;
          var o = out.words;
          var c = 0;
          var lo;
          var mid;
          var hi;
          var a0 = a[0] | 0;
          var al0 = a0 & 8191;
          var ah0 = a0 >>> 13;
          var a1 = a[1] | 0;
          var al1 = a1 & 8191;
          var ah1 = a1 >>> 13;
          var a2 = a[2] | 0;
          var al2 = a2 & 8191;
          var ah2 = a2 >>> 13;
          var a3 = a[3] | 0;
          var al3 = a3 & 8191;
          var ah3 = a3 >>> 13;
          var a4 = a[4] | 0;
          var al4 = a4 & 8191;
          var ah4 = a4 >>> 13;
          var a5 = a[5] | 0;
          var al5 = a5 & 8191;
          var ah5 = a5 >>> 13;
          var a6 = a[6] | 0;
          var al6 = a6 & 8191;
          var ah6 = a6 >>> 13;
          var a7 = a[7] | 0;
          var al7 = a7 & 8191;
          var ah7 = a7 >>> 13;
          var a8 = a[8] | 0;
          var al8 = a8 & 8191;
          var ah8 = a8 >>> 13;
          var a9 = a[9] | 0;
          var al9 = a9 & 8191;
          var ah9 = a9 >>> 13;
          var b0 = b[0] | 0;
          var bl0 = b0 & 8191;
          var bh0 = b0 >>> 13;
          var b1 = b[1] | 0;
          var bl1 = b1 & 8191;
          var bh1 = b1 >>> 13;
          var b2 = b[2] | 0;
          var bl2 = b2 & 8191;
          var bh2 = b2 >>> 13;
          var b3 = b[3] | 0;
          var bl3 = b3 & 8191;
          var bh3 = b3 >>> 13;
          var b4 = b[4] | 0;
          var bl4 = b4 & 8191;
          var bh4 = b4 >>> 13;
          var b5 = b[5] | 0;
          var bl5 = b5 & 8191;
          var bh5 = b5 >>> 13;
          var b6 = b[6] | 0;
          var bl6 = b6 & 8191;
          var bh6 = b6 >>> 13;
          var b7 = b[7] | 0;
          var bl7 = b7 & 8191;
          var bh7 = b7 >>> 13;
          var b8 = b[8] | 0;
          var bl8 = b8 & 8191;
          var bh8 = b8 >>> 13;
          var b9 = b[9] | 0;
          var bl9 = b9 & 8191;
          var bh9 = b9 >>> 13;
          out.negative = self2.negative ^ num.negative;
          out.length = 19;
          lo = Math.imul(al0, bl0);
          mid = Math.imul(al0, bh0);
          mid = mid + Math.imul(ah0, bl0) | 0;
          hi = Math.imul(ah0, bh0);
          var w0 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
          c = (hi + (mid >>> 13) | 0) + (w0 >>> 26) | 0;
          w0 &= 67108863;
          lo = Math.imul(al1, bl0);
          mid = Math.imul(al1, bh0);
          mid = mid + Math.imul(ah1, bl0) | 0;
          hi = Math.imul(ah1, bh0);
          lo = lo + Math.imul(al0, bl1) | 0;
          mid = mid + Math.imul(al0, bh1) | 0;
          mid = mid + Math.imul(ah0, bl1) | 0;
          hi = hi + Math.imul(ah0, bh1) | 0;
          var w1 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
          c = (hi + (mid >>> 13) | 0) + (w1 >>> 26) | 0;
          w1 &= 67108863;
          lo = Math.imul(al2, bl0);
          mid = Math.imul(al2, bh0);
          mid = mid + Math.imul(ah2, bl0) | 0;
          hi = Math.imul(ah2, bh0);
          lo = lo + Math.imul(al1, bl1) | 0;
          mid = mid + Math.imul(al1, bh1) | 0;
          mid = mid + Math.imul(ah1, bl1) | 0;
          hi = hi + Math.imul(ah1, bh1) | 0;
          lo = lo + Math.imul(al0, bl2) | 0;
          mid = mid + Math.imul(al0, bh2) | 0;
          mid = mid + Math.imul(ah0, bl2) | 0;
          hi = hi + Math.imul(ah0, bh2) | 0;
          var w2 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
          c = (hi + (mid >>> 13) | 0) + (w2 >>> 26) | 0;
          w2 &= 67108863;
          lo = Math.imul(al3, bl0);
          mid = Math.imul(al3, bh0);
          mid = mid + Math.imul(ah3, bl0) | 0;
          hi = Math.imul(ah3, bh0);
          lo = lo + Math.imul(al2, bl1) | 0;
          mid = mid + Math.imul(al2, bh1) | 0;
          mid = mid + Math.imul(ah2, bl1) | 0;
          hi = hi + Math.imul(ah2, bh1) | 0;
          lo = lo + Math.imul(al1, bl2) | 0;
          mid = mid + Math.imul(al1, bh2) | 0;
          mid = mid + Math.imul(ah1, bl2) | 0;
          hi = hi + Math.imul(ah1, bh2) | 0;
          lo = lo + Math.imul(al0, bl3) | 0;
          mid = mid + Math.imul(al0, bh3) | 0;
          mid = mid + Math.imul(ah0, bl3) | 0;
          hi = hi + Math.imul(ah0, bh3) | 0;
          var w3 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
          c = (hi + (mid >>> 13) | 0) + (w3 >>> 26) | 0;
          w3 &= 67108863;
          lo = Math.imul(al4, bl0);
          mid = Math.imul(al4, bh0);
          mid = mid + Math.imul(ah4, bl0) | 0;
          hi = Math.imul(ah4, bh0);
          lo = lo + Math.imul(al3, bl1) | 0;
          mid = mid + Math.imul(al3, bh1) | 0;
          mid = mid + Math.imul(ah3, bl1) | 0;
          hi = hi + Math.imul(ah3, bh1) | 0;
          lo = lo + Math.imul(al2, bl2) | 0;
          mid = mid + Math.imul(al2, bh2) | 0;
          mid = mid + Math.imul(ah2, bl2) | 0;
          hi = hi + Math.imul(ah2, bh2) | 0;
          lo = lo + Math.imul(al1, bl3) | 0;
          mid = mid + Math.imul(al1, bh3) | 0;
          mid = mid + Math.imul(ah1, bl3) | 0;
          hi = hi + Math.imul(ah1, bh3) | 0;
          lo = lo + Math.imul(al0, bl4) | 0;
          mid = mid + Math.imul(al0, bh4) | 0;
          mid = mid + Math.imul(ah0, bl4) | 0;
          hi = hi + Math.imul(ah0, bh4) | 0;
          var w4 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
          c = (hi + (mid >>> 13) | 0) + (w4 >>> 26) | 0;
          w4 &= 67108863;
          lo = Math.imul(al5, bl0);
          mid = Math.imul(al5, bh0);
          mid = mid + Math.imul(ah5, bl0) | 0;
          hi = Math.imul(ah5, bh0);
          lo = lo + Math.imul(al4, bl1) | 0;
          mid = mid + Math.imul(al4, bh1) | 0;
          mid = mid + Math.imul(ah4, bl1) | 0;
          hi = hi + Math.imul(ah4, bh1) | 0;
          lo = lo + Math.imul(al3, bl2) | 0;
          mid = mid + Math.imul(al3, bh2) | 0;
          mid = mid + Math.imul(ah3, bl2) | 0;
          hi = hi + Math.imul(ah3, bh2) | 0;
          lo = lo + Math.imul(al2, bl3) | 0;
          mid = mid + Math.imul(al2, bh3) | 0;
          mid = mid + Math.imul(ah2, bl3) | 0;
          hi = hi + Math.imul(ah2, bh3) | 0;
          lo = lo + Math.imul(al1, bl4) | 0;
          mid = mid + Math.imul(al1, bh4) | 0;
          mid = mid + Math.imul(ah1, bl4) | 0;
          hi = hi + Math.imul(ah1, bh4) | 0;
          lo = lo + Math.imul(al0, bl5) | 0;
          mid = mid + Math.imul(al0, bh5) | 0;
          mid = mid + Math.imul(ah0, bl5) | 0;
          hi = hi + Math.imul(ah0, bh5) | 0;
          var w5 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
          c = (hi + (mid >>> 13) | 0) + (w5 >>> 26) | 0;
          w5 &= 67108863;
          lo = Math.imul(al6, bl0);
          mid = Math.imul(al6, bh0);
          mid = mid + Math.imul(ah6, bl0) | 0;
          hi = Math.imul(ah6, bh0);
          lo = lo + Math.imul(al5, bl1) | 0;
          mid = mid + Math.imul(al5, bh1) | 0;
          mid = mid + Math.imul(ah5, bl1) | 0;
          hi = hi + Math.imul(ah5, bh1) | 0;
          lo = lo + Math.imul(al4, bl2) | 0;
          mid = mid + Math.imul(al4, bh2) | 0;
          mid = mid + Math.imul(ah4, bl2) | 0;
          hi = hi + Math.imul(ah4, bh2) | 0;
          lo = lo + Math.imul(al3, bl3) | 0;
          mid = mid + Math.imul(al3, bh3) | 0;
          mid = mid + Math.imul(ah3, bl3) | 0;
          hi = hi + Math.imul(ah3, bh3) | 0;
          lo = lo + Math.imul(al2, bl4) | 0;
          mid = mid + Math.imul(al2, bh4) | 0;
          mid = mid + Math.imul(ah2, bl4) | 0;
          hi = hi + Math.imul(ah2, bh4) | 0;
          lo = lo + Math.imul(al1, bl5) | 0;
          mid = mid + Math.imul(al1, bh5) | 0;
          mid = mid + Math.imul(ah1, bl5) | 0;
          hi = hi + Math.imul(ah1, bh5) | 0;
          lo = lo + Math.imul(al0, bl6) | 0;
          mid = mid + Math.imul(al0, bh6) | 0;
          mid = mid + Math.imul(ah0, bl6) | 0;
          hi = hi + Math.imul(ah0, bh6) | 0;
          var w6 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
          c = (hi + (mid >>> 13) | 0) + (w6 >>> 26) | 0;
          w6 &= 67108863;
          lo = Math.imul(al7, bl0);
          mid = Math.imul(al7, bh0);
          mid = mid + Math.imul(ah7, bl0) | 0;
          hi = Math.imul(ah7, bh0);
          lo = lo + Math.imul(al6, bl1) | 0;
          mid = mid + Math.imul(al6, bh1) | 0;
          mid = mid + Math.imul(ah6, bl1) | 0;
          hi = hi + Math.imul(ah6, bh1) | 0;
          lo = lo + Math.imul(al5, bl2) | 0;
          mid = mid + Math.imul(al5, bh2) | 0;
          mid = mid + Math.imul(ah5, bl2) | 0;
          hi = hi + Math.imul(ah5, bh2) | 0;
          lo = lo + Math.imul(al4, bl3) | 0;
          mid = mid + Math.imul(al4, bh3) | 0;
          mid = mid + Math.imul(ah4, bl3) | 0;
          hi = hi + Math.imul(ah4, bh3) | 0;
          lo = lo + Math.imul(al3, bl4) | 0;
          mid = mid + Math.imul(al3, bh4) | 0;
          mid = mid + Math.imul(ah3, bl4) | 0;
          hi = hi + Math.imul(ah3, bh4) | 0;
          lo = lo + Math.imul(al2, bl5) | 0;
          mid = mid + Math.imul(al2, bh5) | 0;
          mid = mid + Math.imul(ah2, bl5) | 0;
          hi = hi + Math.imul(ah2, bh5) | 0;
          lo = lo + Math.imul(al1, bl6) | 0;
          mid = mid + Math.imul(al1, bh6) | 0;
          mid = mid + Math.imul(ah1, bl6) | 0;
          hi = hi + Math.imul(ah1, bh6) | 0;
          lo = lo + Math.imul(al0, bl7) | 0;
          mid = mid + Math.imul(al0, bh7) | 0;
          mid = mid + Math.imul(ah0, bl7) | 0;
          hi = hi + Math.imul(ah0, bh7) | 0;
          var w7 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
          c = (hi + (mid >>> 13) | 0) + (w7 >>> 26) | 0;
          w7 &= 67108863;
          lo = Math.imul(al8, bl0);
          mid = Math.imul(al8, bh0);
          mid = mid + Math.imul(ah8, bl0) | 0;
          hi = Math.imul(ah8, bh0);
          lo = lo + Math.imul(al7, bl1) | 0;
          mid = mid + Math.imul(al7, bh1) | 0;
          mid = mid + Math.imul(ah7, bl1) | 0;
          hi = hi + Math.imul(ah7, bh1) | 0;
          lo = lo + Math.imul(al6, bl2) | 0;
          mid = mid + Math.imul(al6, bh2) | 0;
          mid = mid + Math.imul(ah6, bl2) | 0;
          hi = hi + Math.imul(ah6, bh2) | 0;
          lo = lo + Math.imul(al5, bl3) | 0;
          mid = mid + Math.imul(al5, bh3) | 0;
          mid = mid + Math.imul(ah5, bl3) | 0;
          hi = hi + Math.imul(ah5, bh3) | 0;
          lo = lo + Math.imul(al4, bl4) | 0;
          mid = mid + Math.imul(al4, bh4) | 0;
          mid = mid + Math.imul(ah4, bl4) | 0;
          hi = hi + Math.imul(ah4, bh4) | 0;
          lo = lo + Math.imul(al3, bl5) | 0;
          mid = mid + Math.imul(al3, bh5) | 0;
          mid = mid + Math.imul(ah3, bl5) | 0;
          hi = hi + Math.imul(ah3, bh5) | 0;
          lo = lo + Math.imul(al2, bl6) | 0;
          mid = mid + Math.imul(al2, bh6) | 0;
          mid = mid + Math.imul(ah2, bl6) | 0;
          hi = hi + Math.imul(ah2, bh6) | 0;
          lo = lo + Math.imul(al1, bl7) | 0;
          mid = mid + Math.imul(al1, bh7) | 0;
          mid = mid + Math.imul(ah1, bl7) | 0;
          hi = hi + Math.imul(ah1, bh7) | 0;
          lo = lo + Math.imul(al0, bl8) | 0;
          mid = mid + Math.imul(al0, bh8) | 0;
          mid = mid + Math.imul(ah0, bl8) | 0;
          hi = hi + Math.imul(ah0, bh8) | 0;
          var w8 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
          c = (hi + (mid >>> 13) | 0) + (w8 >>> 26) | 0;
          w8 &= 67108863;
          lo = Math.imul(al9, bl0);
          mid = Math.imul(al9, bh0);
          mid = mid + Math.imul(ah9, bl0) | 0;
          hi = Math.imul(ah9, bh0);
          lo = lo + Math.imul(al8, bl1) | 0;
          mid = mid + Math.imul(al8, bh1) | 0;
          mid = mid + Math.imul(ah8, bl1) | 0;
          hi = hi + Math.imul(ah8, bh1) | 0;
          lo = lo + Math.imul(al7, bl2) | 0;
          mid = mid + Math.imul(al7, bh2) | 0;
          mid = mid + Math.imul(ah7, bl2) | 0;
          hi = hi + Math.imul(ah7, bh2) | 0;
          lo = lo + Math.imul(al6, bl3) | 0;
          mid = mid + Math.imul(al6, bh3) | 0;
          mid = mid + Math.imul(ah6, bl3) | 0;
          hi = hi + Math.imul(ah6, bh3) | 0;
          lo = lo + Math.imul(al5, bl4) | 0;
          mid = mid + Math.imul(al5, bh4) | 0;
          mid = mid + Math.imul(ah5, bl4) | 0;
          hi = hi + Math.imul(ah5, bh4) | 0;
          lo = lo + Math.imul(al4, bl5) | 0;
          mid = mid + Math.imul(al4, bh5) | 0;
          mid = mid + Math.imul(ah4, bl5) | 0;
          hi = hi + Math.imul(ah4, bh5) | 0;
          lo = lo + Math.imul(al3, bl6) | 0;
          mid = mid + Math.imul(al3, bh6) | 0;
          mid = mid + Math.imul(ah3, bl6) | 0;
          hi = hi + Math.imul(ah3, bh6) | 0;
          lo = lo + Math.imul(al2, bl7) | 0;
          mid = mid + Math.imul(al2, bh7) | 0;
          mid = mid + Math.imul(ah2, bl7) | 0;
          hi = hi + Math.imul(ah2, bh7) | 0;
          lo = lo + Math.imul(al1, bl8) | 0;
          mid = mid + Math.imul(al1, bh8) | 0;
          mid = mid + Math.imul(ah1, bl8) | 0;
          hi = hi + Math.imul(ah1, bh8) | 0;
          lo = lo + Math.imul(al0, bl9) | 0;
          mid = mid + Math.imul(al0, bh9) | 0;
          mid = mid + Math.imul(ah0, bl9) | 0;
          hi = hi + Math.imul(ah0, bh9) | 0;
          var w9 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
          c = (hi + (mid >>> 13) | 0) + (w9 >>> 26) | 0;
          w9 &= 67108863;
          lo = Math.imul(al9, bl1);
          mid = Math.imul(al9, bh1);
          mid = mid + Math.imul(ah9, bl1) | 0;
          hi = Math.imul(ah9, bh1);
          lo = lo + Math.imul(al8, bl2) | 0;
          mid = mid + Math.imul(al8, bh2) | 0;
          mid = mid + Math.imul(ah8, bl2) | 0;
          hi = hi + Math.imul(ah8, bh2) | 0;
          lo = lo + Math.imul(al7, bl3) | 0;
          mid = mid + Math.imul(al7, bh3) | 0;
          mid = mid + Math.imul(ah7, bl3) | 0;
          hi = hi + Math.imul(ah7, bh3) | 0;
          lo = lo + Math.imul(al6, bl4) | 0;
          mid = mid + Math.imul(al6, bh4) | 0;
          mid = mid + Math.imul(ah6, bl4) | 0;
          hi = hi + Math.imul(ah6, bh4) | 0;
          lo = lo + Math.imul(al5, bl5) | 0;
          mid = mid + Math.imul(al5, bh5) | 0;
          mid = mid + Math.imul(ah5, bl5) | 0;
          hi = hi + Math.imul(ah5, bh5) | 0;
          lo = lo + Math.imul(al4, bl6) | 0;
          mid = mid + Math.imul(al4, bh6) | 0;
          mid = mid + Math.imul(ah4, bl6) | 0;
          hi = hi + Math.imul(ah4, bh6) | 0;
          lo = lo + Math.imul(al3, bl7) | 0;
          mid = mid + Math.imul(al3, bh7) | 0;
          mid = mid + Math.imul(ah3, bl7) | 0;
          hi = hi + Math.imul(ah3, bh7) | 0;
          lo = lo + Math.imul(al2, bl8) | 0;
          mid = mid + Math.imul(al2, bh8) | 0;
          mid = mid + Math.imul(ah2, bl8) | 0;
          hi = hi + Math.imul(ah2, bh8) | 0;
          lo = lo + Math.imul(al1, bl9) | 0;
          mid = mid + Math.imul(al1, bh9) | 0;
          mid = mid + Math.imul(ah1, bl9) | 0;
          hi = hi + Math.imul(ah1, bh9) | 0;
          var w10 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
          c = (hi + (mid >>> 13) | 0) + (w10 >>> 26) | 0;
          w10 &= 67108863;
          lo = Math.imul(al9, bl2);
          mid = Math.imul(al9, bh2);
          mid = mid + Math.imul(ah9, bl2) | 0;
          hi = Math.imul(ah9, bh2);
          lo = lo + Math.imul(al8, bl3) | 0;
          mid = mid + Math.imul(al8, bh3) | 0;
          mid = mid + Math.imul(ah8, bl3) | 0;
          hi = hi + Math.imul(ah8, bh3) | 0;
          lo = lo + Math.imul(al7, bl4) | 0;
          mid = mid + Math.imul(al7, bh4) | 0;
          mid = mid + Math.imul(ah7, bl4) | 0;
          hi = hi + Math.imul(ah7, bh4) | 0;
          lo = lo + Math.imul(al6, bl5) | 0;
          mid = mid + Math.imul(al6, bh5) | 0;
          mid = mid + Math.imul(ah6, bl5) | 0;
          hi = hi + Math.imul(ah6, bh5) | 0;
          lo = lo + Math.imul(al5, bl6) | 0;
          mid = mid + Math.imul(al5, bh6) | 0;
          mid = mid + Math.imul(ah5, bl6) | 0;
          hi = hi + Math.imul(ah5, bh6) | 0;
          lo = lo + Math.imul(al4, bl7) | 0;
          mid = mid + Math.imul(al4, bh7) | 0;
          mid = mid + Math.imul(ah4, bl7) | 0;
          hi = hi + Math.imul(ah4, bh7) | 0;
          lo = lo + Math.imul(al3, bl8) | 0;
          mid = mid + Math.imul(al3, bh8) | 0;
          mid = mid + Math.imul(ah3, bl8) | 0;
          hi = hi + Math.imul(ah3, bh8) | 0;
          lo = lo + Math.imul(al2, bl9) | 0;
          mid = mid + Math.imul(al2, bh9) | 0;
          mid = mid + Math.imul(ah2, bl9) | 0;
          hi = hi + Math.imul(ah2, bh9) | 0;
          var w11 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
          c = (hi + (mid >>> 13) | 0) + (w11 >>> 26) | 0;
          w11 &= 67108863;
          lo = Math.imul(al9, bl3);
          mid = Math.imul(al9, bh3);
          mid = mid + Math.imul(ah9, bl3) | 0;
          hi = Math.imul(ah9, bh3);
          lo = lo + Math.imul(al8, bl4) | 0;
          mid = mid + Math.imul(al8, bh4) | 0;
          mid = mid + Math.imul(ah8, bl4) | 0;
          hi = hi + Math.imul(ah8, bh4) | 0;
          lo = lo + Math.imul(al7, bl5) | 0;
          mid = mid + Math.imul(al7, bh5) | 0;
          mid = mid + Math.imul(ah7, bl5) | 0;
          hi = hi + Math.imul(ah7, bh5) | 0;
          lo = lo + Math.imul(al6, bl6) | 0;
          mid = mid + Math.imul(al6, bh6) | 0;
          mid = mid + Math.imul(ah6, bl6) | 0;
          hi = hi + Math.imul(ah6, bh6) | 0;
          lo = lo + Math.imul(al5, bl7) | 0;
          mid = mid + Math.imul(al5, bh7) | 0;
          mid = mid + Math.imul(ah5, bl7) | 0;
          hi = hi + Math.imul(ah5, bh7) | 0;
          lo = lo + Math.imul(al4, bl8) | 0;
          mid = mid + Math.imul(al4, bh8) | 0;
          mid = mid + Math.imul(ah4, bl8) | 0;
          hi = hi + Math.imul(ah4, bh8) | 0;
          lo = lo + Math.imul(al3, bl9) | 0;
          mid = mid + Math.imul(al3, bh9) | 0;
          mid = mid + Math.imul(ah3, bl9) | 0;
          hi = hi + Math.imul(ah3, bh9) | 0;
          var w12 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
          c = (hi + (mid >>> 13) | 0) + (w12 >>> 26) | 0;
          w12 &= 67108863;
          lo = Math.imul(al9, bl4);
          mid = Math.imul(al9, bh4);
          mid = mid + Math.imul(ah9, bl4) | 0;
          hi = Math.imul(ah9, bh4);
          lo = lo + Math.imul(al8, bl5) | 0;
          mid = mid + Math.imul(al8, bh5) | 0;
          mid = mid + Math.imul(ah8, bl5) | 0;
          hi = hi + Math.imul(ah8, bh5) | 0;
          lo = lo + Math.imul(al7, bl6) | 0;
          mid = mid + Math.imul(al7, bh6) | 0;
          mid = mid + Math.imul(ah7, bl6) | 0;
          hi = hi + Math.imul(ah7, bh6) | 0;
          lo = lo + Math.imul(al6, bl7) | 0;
          mid = mid + Math.imul(al6, bh7) | 0;
          mid = mid + Math.imul(ah6, bl7) | 0;
          hi = hi + Math.imul(ah6, bh7) | 0;
          lo = lo + Math.imul(al5, bl8) | 0;
          mid = mid + Math.imul(al5, bh8) | 0;
          mid = mid + Math.imul(ah5, bl8) | 0;
          hi = hi + Math.imul(ah5, bh8) | 0;
          lo = lo + Math.imul(al4, bl9) | 0;
          mid = mid + Math.imul(al4, bh9) | 0;
          mid = mid + Math.imul(ah4, bl9) | 0;
          hi = hi + Math.imul(ah4, bh9) | 0;
          var w13 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
          c = (hi + (mid >>> 13) | 0) + (w13 >>> 26) | 0;
          w13 &= 67108863;
          lo = Math.imul(al9, bl5);
          mid = Math.imul(al9, bh5);
          mid = mid + Math.imul(ah9, bl5) | 0;
          hi = Math.imul(ah9, bh5);
          lo = lo + Math.imul(al8, bl6) | 0;
          mid = mid + Math.imul(al8, bh6) | 0;
          mid = mid + Math.imul(ah8, bl6) | 0;
          hi = hi + Math.imul(ah8, bh6) | 0;
          lo = lo + Math.imul(al7, bl7) | 0;
          mid = mid + Math.imul(al7, bh7) | 0;
          mid = mid + Math.imul(ah7, bl7) | 0;
          hi = hi + Math.imul(ah7, bh7) | 0;
          lo = lo + Math.imul(al6, bl8) | 0;
          mid = mid + Math.imul(al6, bh8) | 0;
          mid = mid + Math.imul(ah6, bl8) | 0;
          hi = hi + Math.imul(ah6, bh8) | 0;
          lo = lo + Math.imul(al5, bl9) | 0;
          mid = mid + Math.imul(al5, bh9) | 0;
          mid = mid + Math.imul(ah5, bl9) | 0;
          hi = hi + Math.imul(ah5, bh9) | 0;
          var w14 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
          c = (hi + (mid >>> 13) | 0) + (w14 >>> 26) | 0;
          w14 &= 67108863;
          lo = Math.imul(al9, bl6);
          mid = Math.imul(al9, bh6);
          mid = mid + Math.imul(ah9, bl6) | 0;
          hi = Math.imul(ah9, bh6);
          lo = lo + Math.imul(al8, bl7) | 0;
          mid = mid + Math.imul(al8, bh7) | 0;
          mid = mid + Math.imul(ah8, bl7) | 0;
          hi = hi + Math.imul(ah8, bh7) | 0;
          lo = lo + Math.imul(al7, bl8) | 0;
          mid = mid + Math.imul(al7, bh8) | 0;
          mid = mid + Math.imul(ah7, bl8) | 0;
          hi = hi + Math.imul(ah7, bh8) | 0;
          lo = lo + Math.imul(al6, bl9) | 0;
          mid = mid + Math.imul(al6, bh9) | 0;
          mid = mid + Math.imul(ah6, bl9) | 0;
          hi = hi + Math.imul(ah6, bh9) | 0;
          var w15 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
          c = (hi + (mid >>> 13) | 0) + (w15 >>> 26) | 0;
          w15 &= 67108863;
          lo = Math.imul(al9, bl7);
          mid = Math.imul(al9, bh7);
          mid = mid + Math.imul(ah9, bl7) | 0;
          hi = Math.imul(ah9, bh7);
          lo = lo + Math.imul(al8, bl8) | 0;
          mid = mid + Math.imul(al8, bh8) | 0;
          mid = mid + Math.imul(ah8, bl8) | 0;
          hi = hi + Math.imul(ah8, bh8) | 0;
          lo = lo + Math.imul(al7, bl9) | 0;
          mid = mid + Math.imul(al7, bh9) | 0;
          mid = mid + Math.imul(ah7, bl9) | 0;
          hi = hi + Math.imul(ah7, bh9) | 0;
          var w16 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
          c = (hi + (mid >>> 13) | 0) + (w16 >>> 26) | 0;
          w16 &= 67108863;
          lo = Math.imul(al9, bl8);
          mid = Math.imul(al9, bh8);
          mid = mid + Math.imul(ah9, bl8) | 0;
          hi = Math.imul(ah9, bh8);
          lo = lo + Math.imul(al8, bl9) | 0;
          mid = mid + Math.imul(al8, bh9) | 0;
          mid = mid + Math.imul(ah8, bl9) | 0;
          hi = hi + Math.imul(ah8, bh9) | 0;
          var w17 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
          c = (hi + (mid >>> 13) | 0) + (w17 >>> 26) | 0;
          w17 &= 67108863;
          lo = Math.imul(al9, bl9);
          mid = Math.imul(al9, bh9);
          mid = mid + Math.imul(ah9, bl9) | 0;
          hi = Math.imul(ah9, bh9);
          var w18 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
          c = (hi + (mid >>> 13) | 0) + (w18 >>> 26) | 0;
          w18 &= 67108863;
          o[0] = w0;
          o[1] = w1;
          o[2] = w2;
          o[3] = w3;
          o[4] = w4;
          o[5] = w5;
          o[6] = w6;
          o[7] = w7;
          o[8] = w8;
          o[9] = w9;
          o[10] = w10;
          o[11] = w11;
          o[12] = w12;
          o[13] = w13;
          o[14] = w14;
          o[15] = w15;
          o[16] = w16;
          o[17] = w17;
          o[18] = w18;
          if (c !== 0) {
            o[19] = c;
            out.length++;
          }
          return out;
        };
        if (!Math.imul) {
          comb10MulTo = smallMulTo;
        }
        function bigMulTo(self2, num, out) {
          out.negative = num.negative ^ self2.negative;
          out.length = self2.length + num.length;
          var carry = 0;
          var hncarry = 0;
          for (var k = 0; k < out.length - 1; k++) {
            var ncarry = hncarry;
            hncarry = 0;
            var rword = carry & 67108863;
            var maxJ = Math.min(k, num.length - 1);
            for (var j = Math.max(0, k - self2.length + 1); j <= maxJ; j++) {
              var i = k - j;
              var a = self2.words[i] | 0;
              var b = num.words[j] | 0;
              var r = a * b;
              var lo = r & 67108863;
              ncarry = ncarry + (r / 67108864 | 0) | 0;
              lo = lo + rword | 0;
              rword = lo & 67108863;
              ncarry = ncarry + (lo >>> 26) | 0;
              hncarry += ncarry >>> 26;
              ncarry &= 67108863;
            }
            out.words[k] = rword;
            carry = ncarry;
            ncarry = hncarry;
          }
          if (carry !== 0) {
            out.words[k] = carry;
          } else {
            out.length--;
          }
          return out._strip();
        }
        function jumboMulTo(self2, num, out) {
          return bigMulTo(self2, num, out);
        }
        BN2.prototype.mulTo = function mulTo(num, out) {
          var res;
          var len = this.length + num.length;
          if (this.length === 10 && num.length === 10) {
            res = comb10MulTo(this, num, out);
          } else if (len < 63) {
            res = smallMulTo(this, num, out);
          } else if (len < 1024) {
            res = bigMulTo(this, num, out);
          } else {
            res = jumboMulTo(this, num, out);
          }
          return res;
        };
        function FFTM(x, y) {
          this.x = x;
          this.y = y;
        }
        FFTM.prototype.makeRBT = function makeRBT(N) {
          var t = new Array(N);
          var l = BN2.prototype._countBits(N) - 1;
          for (var i = 0; i < N; i++) {
            t[i] = this.revBin(i, l, N);
          }
          return t;
        };
        FFTM.prototype.revBin = function revBin(x, l, N) {
          if (x === 0 || x === N - 1) return x;
          var rb = 0;
          for (var i = 0; i < l; i++) {
            rb |= (x & 1) << l - i - 1;
            x >>= 1;
          }
          return rb;
        };
        FFTM.prototype.permute = function permute(rbt, rws, iws, rtws, itws, N) {
          for (var i = 0; i < N; i++) {
            rtws[i] = rws[rbt[i]];
            itws[i] = iws[rbt[i]];
          }
        };
        FFTM.prototype.transform = function transform(rws, iws, rtws, itws, N, rbt) {
          this.permute(rbt, rws, iws, rtws, itws, N);
          for (var s = 1; s < N; s <<= 1) {
            var l = s << 1;
            var rtwdf = Math.cos(2 * Math.PI / l);
            var itwdf = Math.sin(2 * Math.PI / l);
            for (var p = 0; p < N; p += l) {
              var rtwdf_ = rtwdf;
              var itwdf_ = itwdf;
              for (var j = 0; j < s; j++) {
                var re = rtws[p + j];
                var ie = itws[p + j];
                var ro = rtws[p + j + s];
                var io = itws[p + j + s];
                var rx = rtwdf_ * ro - itwdf_ * io;
                io = rtwdf_ * io + itwdf_ * ro;
                ro = rx;
                rtws[p + j] = re + ro;
                itws[p + j] = ie + io;
                rtws[p + j + s] = re - ro;
                itws[p + j + s] = ie - io;
                if (j !== l) {
                  rx = rtwdf * rtwdf_ - itwdf * itwdf_;
                  itwdf_ = rtwdf * itwdf_ + itwdf * rtwdf_;
                  rtwdf_ = rx;
                }
              }
            }
          }
        };
        FFTM.prototype.guessLen13b = function guessLen13b(n, m) {
          var N = Math.max(m, n) | 1;
          var odd = N & 1;
          var i = 0;
          for (N = N / 2 | 0; N; N = N >>> 1) {
            i++;
          }
          return 1 << i + 1 + odd;
        };
        FFTM.prototype.conjugate = function conjugate(rws, iws, N) {
          if (N <= 1) return;
          for (var i = 0; i < N / 2; i++) {
            var t = rws[i];
            rws[i] = rws[N - i - 1];
            rws[N - i - 1] = t;
            t = iws[i];
            iws[i] = -iws[N - i - 1];
            iws[N - i - 1] = -t;
          }
        };
        FFTM.prototype.normalize13b = function normalize13b(ws, N) {
          var carry = 0;
          for (var i = 0; i < N / 2; i++) {
            var w = Math.round(ws[2 * i + 1] / N) * 8192 + Math.round(ws[2 * i] / N) + carry;
            ws[i] = w & 67108863;
            if (w < 67108864) {
              carry = 0;
            } else {
              carry = w / 67108864 | 0;
            }
          }
          return ws;
        };
        FFTM.prototype.convert13b = function convert13b(ws, len, rws, N) {
          var carry = 0;
          for (var i = 0; i < len; i++) {
            carry = carry + (ws[i] | 0);
            rws[2 * i] = carry & 8191;
            carry = carry >>> 13;
            rws[2 * i + 1] = carry & 8191;
            carry = carry >>> 13;
          }
          for (i = 2 * len; i < N; ++i) {
            rws[i] = 0;
          }
          assert2(carry === 0);
          assert2((carry & ~8191) === 0);
        };
        FFTM.prototype.stub = function stub(N) {
          var ph = new Array(N);
          for (var i = 0; i < N; i++) {
            ph[i] = 0;
          }
          return ph;
        };
        FFTM.prototype.mulp = function mulp(x, y, out) {
          var N = 2 * this.guessLen13b(x.length, y.length);
          var rbt = this.makeRBT(N);
          var _ = this.stub(N);
          var rws = new Array(N);
          var rwst = new Array(N);
          var iwst = new Array(N);
          var nrws = new Array(N);
          var nrwst = new Array(N);
          var niwst = new Array(N);
          var rmws = out.words;
          rmws.length = N;
          this.convert13b(x.words, x.length, rws, N);
          this.convert13b(y.words, y.length, nrws, N);
          this.transform(rws, _, rwst, iwst, N, rbt);
          this.transform(nrws, _, nrwst, niwst, N, rbt);
          for (var i = 0; i < N; i++) {
            var rx = rwst[i] * nrwst[i] - iwst[i] * niwst[i];
            iwst[i] = rwst[i] * niwst[i] + iwst[i] * nrwst[i];
            rwst[i] = rx;
          }
          this.conjugate(rwst, iwst, N);
          this.transform(rwst, iwst, rmws, _, N, rbt);
          this.conjugate(rmws, _, N);
          this.normalize13b(rmws, N);
          out.negative = x.negative ^ y.negative;
          out.length = x.length + y.length;
          return out._strip();
        };
        BN2.prototype.mul = function mul(num) {
          var out = new BN2(null);
          out.words = new Array(this.length + num.length);
          return this.mulTo(num, out);
        };
        BN2.prototype.mulf = function mulf(num) {
          var out = new BN2(null);
          out.words = new Array(this.length + num.length);
          return jumboMulTo(this, num, out);
        };
        BN2.prototype.imul = function imul(num) {
          return this.clone().mulTo(num, this);
        };
        BN2.prototype.imuln = function imuln(num) {
          var isNegNum = num < 0;
          if (isNegNum) num = -num;
          assert2(typeof num === "number");
          assert2(num < 67108864);
          var carry = 0;
          for (var i = 0; i < this.length; i++) {
            var w = (this.words[i] | 0) * num;
            var lo = (w & 67108863) + (carry & 67108863);
            carry >>= 26;
            carry += w / 67108864 | 0;
            carry += lo >>> 26;
            this.words[i] = lo & 67108863;
          }
          if (carry !== 0) {
            this.words[i] = carry;
            this.length++;
          }
          this.length = num === 0 ? 1 : this.length;
          return isNegNum ? this.ineg() : this;
        };
        BN2.prototype.muln = function muln(num) {
          return this.clone().imuln(num);
        };
        BN2.prototype.sqr = function sqr() {
          return this.mul(this);
        };
        BN2.prototype.isqr = function isqr() {
          return this.imul(this.clone());
        };
        BN2.prototype.pow = function pow(num) {
          var w = toBitArray(num);
          if (w.length === 0) return new BN2(1);
          var res = this;
          for (var i = 0; i < w.length; i++, res = res.sqr()) {
            if (w[i] !== 0) break;
          }
          if (++i < w.length) {
            for (var q = res.sqr(); i < w.length; i++, q = q.sqr()) {
              if (w[i] === 0) continue;
              res = res.mul(q);
            }
          }
          return res;
        };
        BN2.prototype.iushln = function iushln(bits) {
          assert2(typeof bits === "number" && bits >= 0);
          var r = bits % 26;
          var s = (bits - r) / 26;
          var carryMask = 67108863 >>> 26 - r << 26 - r;
          var i;
          if (r !== 0) {
            var carry = 0;
            for (i = 0; i < this.length; i++) {
              var newCarry = this.words[i] & carryMask;
              var c = (this.words[i] | 0) - newCarry << r;
              this.words[i] = c | carry;
              carry = newCarry >>> 26 - r;
            }
            if (carry) {
              this.words[i] = carry;
              this.length++;
            }
          }
          if (s !== 0) {
            for (i = this.length - 1; i >= 0; i--) {
              this.words[i + s] = this.words[i];
            }
            for (i = 0; i < s; i++) {
              this.words[i] = 0;
            }
            this.length += s;
          }
          return this._strip();
        };
        BN2.prototype.ishln = function ishln(bits) {
          assert2(this.negative === 0);
          return this.iushln(bits);
        };
        BN2.prototype.iushrn = function iushrn(bits, hint, extended) {
          assert2(typeof bits === "number" && bits >= 0);
          var h;
          if (hint) {
            h = (hint - hint % 26) / 26;
          } else {
            h = 0;
          }
          var r = bits % 26;
          var s = Math.min((bits - r) / 26, this.length);
          var mask2 = 67108863 ^ 67108863 >>> r << r;
          var maskedWords = extended;
          h -= s;
          h = Math.max(0, h);
          if (maskedWords) {
            for (var i = 0; i < s; i++) {
              maskedWords.words[i] = this.words[i];
            }
            maskedWords.length = s;
          }
          if (s === 0) {
          } else if (this.length > s) {
            this.length -= s;
            for (i = 0; i < this.length; i++) {
              this.words[i] = this.words[i + s];
            }
          } else {
            this.words[0] = 0;
            this.length = 1;
          }
          var carry = 0;
          for (i = this.length - 1; i >= 0 && (carry !== 0 || i >= h); i--) {
            var word = this.words[i] | 0;
            this.words[i] = carry << 26 - r | word >>> r;
            carry = word & mask2;
          }
          if (maskedWords && carry !== 0) {
            maskedWords.words[maskedWords.length++] = carry;
          }
          if (this.length === 0) {
            this.words[0] = 0;
            this.length = 1;
          }
          return this._strip();
        };
        BN2.prototype.ishrn = function ishrn(bits, hint, extended) {
          assert2(this.negative === 0);
          return this.iushrn(bits, hint, extended);
        };
        BN2.prototype.shln = function shln(bits) {
          return this.clone().ishln(bits);
        };
        BN2.prototype.ushln = function ushln(bits) {
          return this.clone().iushln(bits);
        };
        BN2.prototype.shrn = function shrn(bits) {
          return this.clone().ishrn(bits);
        };
        BN2.prototype.ushrn = function ushrn(bits) {
          return this.clone().iushrn(bits);
        };
        BN2.prototype.testn = function testn(bit) {
          assert2(typeof bit === "number" && bit >= 0);
          var r = bit % 26;
          var s = (bit - r) / 26;
          var q = 1 << r;
          if (this.length <= s) return false;
          var w = this.words[s];
          return !!(w & q);
        };
        BN2.prototype.imaskn = function imaskn(bits) {
          assert2(typeof bits === "number" && bits >= 0);
          var r = bits % 26;
          var s = (bits - r) / 26;
          assert2(this.negative === 0, "imaskn works only with positive numbers");
          if (this.length <= s) {
            return this;
          }
          if (r !== 0) {
            s++;
          }
          this.length = Math.min(s, this.length);
          if (r !== 0) {
            var mask2 = 67108863 ^ 67108863 >>> r << r;
            this.words[this.length - 1] &= mask2;
          }
          return this._strip();
        };
        BN2.prototype.maskn = function maskn(bits) {
          return this.clone().imaskn(bits);
        };
        BN2.prototype.iaddn = function iaddn(num) {
          assert2(typeof num === "number");
          assert2(num < 67108864);
          if (num < 0) return this.isubn(-num);
          if (this.negative !== 0) {
            if (this.length === 1 && (this.words[0] | 0) <= num) {
              this.words[0] = num - (this.words[0] | 0);
              this.negative = 0;
              return this;
            }
            this.negative = 0;
            this.isubn(num);
            this.negative = 1;
            return this;
          }
          return this._iaddn(num);
        };
        BN2.prototype._iaddn = function _iaddn(num) {
          this.words[0] += num;
          for (var i = 0; i < this.length && this.words[i] >= 67108864; i++) {
            this.words[i] -= 67108864;
            if (i === this.length - 1) {
              this.words[i + 1] = 1;
            } else {
              this.words[i + 1]++;
            }
          }
          this.length = Math.max(this.length, i + 1);
          return this;
        };
        BN2.prototype.isubn = function isubn(num) {
          assert2(typeof num === "number");
          assert2(num < 67108864);
          if (num < 0) return this.iaddn(-num);
          if (this.negative !== 0) {
            this.negative = 0;
            this.iaddn(num);
            this.negative = 1;
            return this;
          }
          this.words[0] -= num;
          if (this.length === 1 && this.words[0] < 0) {
            this.words[0] = -this.words[0];
            this.negative = 1;
          } else {
            for (var i = 0; i < this.length && this.words[i] < 0; i++) {
              this.words[i] += 67108864;
              this.words[i + 1] -= 1;
            }
          }
          return this._strip();
        };
        BN2.prototype.addn = function addn(num) {
          return this.clone().iaddn(num);
        };
        BN2.prototype.subn = function subn(num) {
          return this.clone().isubn(num);
        };
        BN2.prototype.iabs = function iabs() {
          this.negative = 0;
          return this;
        };
        BN2.prototype.abs = function abs() {
          return this.clone().iabs();
        };
        BN2.prototype._ishlnsubmul = function _ishlnsubmul(num, mul, shift) {
          var len = num.length + shift;
          var i;
          this._expand(len);
          var w;
          var carry = 0;
          for (i = 0; i < num.length; i++) {
            w = (this.words[i + shift] | 0) + carry;
            var right = (num.words[i] | 0) * mul;
            w -= right & 67108863;
            carry = (w >> 26) - (right / 67108864 | 0);
            this.words[i + shift] = w & 67108863;
          }
          for (; i < this.length - shift; i++) {
            w = (this.words[i + shift] | 0) + carry;
            carry = w >> 26;
            this.words[i + shift] = w & 67108863;
          }
          if (carry === 0) return this._strip();
          assert2(carry === -1);
          carry = 0;
          for (i = 0; i < this.length; i++) {
            w = -(this.words[i] | 0) + carry;
            carry = w >> 26;
            this.words[i] = w & 67108863;
          }
          this.negative = 1;
          return this._strip();
        };
        BN2.prototype._wordDiv = function _wordDiv(num, mode) {
          var shift = this.length - num.length;
          var a = this.clone();
          var b = num;
          var bhi = b.words[b.length - 1] | 0;
          var bhiBits = this._countBits(bhi);
          shift = 26 - bhiBits;
          if (shift !== 0) {
            b = b.ushln(shift);
            a.iushln(shift);
            bhi = b.words[b.length - 1] | 0;
          }
          var m = a.length - b.length;
          var q;
          if (mode !== "mod") {
            q = new BN2(null);
            q.length = m + 1;
            q.words = new Array(q.length);
            for (var i = 0; i < q.length; i++) {
              q.words[i] = 0;
            }
          }
          var diff = a.clone()._ishlnsubmul(b, 1, m);
          if (diff.negative === 0) {
            a = diff;
            if (q) {
              q.words[m] = 1;
            }
          }
          for (var j = m - 1; j >= 0; j--) {
            var qj = (a.words[b.length + j] | 0) * 67108864 + (a.words[b.length + j - 1] | 0);
            qj = Math.min(qj / bhi | 0, 67108863);
            a._ishlnsubmul(b, qj, j);
            while (a.negative !== 0) {
              qj--;
              a.negative = 0;
              a._ishlnsubmul(b, 1, j);
              if (!a.isZero()) {
                a.negative ^= 1;
              }
            }
            if (q) {
              q.words[j] = qj;
            }
          }
          if (q) {
            q._strip();
          }
          a._strip();
          if (mode !== "div" && shift !== 0) {
            a.iushrn(shift);
          }
          return {
            div: q || null,
            mod: a
          };
        };
        BN2.prototype.divmod = function divmod(num, mode, positive) {
          assert2(!num.isZero());
          if (this.isZero()) {
            return {
              div: new BN2(0),
              mod: new BN2(0)
            };
          }
          var div, mod, res;
          if (this.negative !== 0 && num.negative === 0) {
            res = this.neg().divmod(num, mode);
            if (mode !== "mod") {
              div = res.div.neg();
            }
            if (mode !== "div") {
              mod = res.mod.neg();
              if (positive && mod.negative !== 0) {
                mod.iadd(num);
              }
            }
            return {
              div,
              mod
            };
          }
          if (this.negative === 0 && num.negative !== 0) {
            res = this.divmod(num.neg(), mode);
            if (mode !== "mod") {
              div = res.div.neg();
            }
            return {
              div,
              mod: res.mod
            };
          }
          if ((this.negative & num.negative) !== 0) {
            res = this.neg().divmod(num.neg(), mode);
            if (mode !== "div") {
              mod = res.mod.neg();
              if (positive && mod.negative !== 0) {
                mod.isub(num);
              }
            }
            return {
              div: res.div,
              mod
            };
          }
          if (num.length > this.length || this.cmp(num) < 0) {
            return {
              div: new BN2(0),
              mod: this
            };
          }
          if (num.length === 1) {
            if (mode === "div") {
              return {
                div: this.divn(num.words[0]),
                mod: null
              };
            }
            if (mode === "mod") {
              return {
                div: null,
                mod: new BN2(this.modrn(num.words[0]))
              };
            }
            return {
              div: this.divn(num.words[0]),
              mod: new BN2(this.modrn(num.words[0]))
            };
          }
          return this._wordDiv(num, mode);
        };
        BN2.prototype.div = function div(num) {
          return this.divmod(num, "div", false).div;
        };
        BN2.prototype.mod = function mod(num) {
          return this.divmod(num, "mod", false).mod;
        };
        BN2.prototype.umod = function umod(num) {
          return this.divmod(num, "mod", true).mod;
        };
        BN2.prototype.divRound = function divRound(num) {
          var dm = this.divmod(num);
          if (dm.mod.isZero()) return dm.div;
          var mod = dm.div.negative !== 0 ? dm.mod.isub(num) : dm.mod;
          var half = num.ushrn(1);
          var r2 = num.andln(1);
          var cmp = mod.cmp(half);
          if (cmp < 0 || r2 === 1 && cmp === 0) return dm.div;
          return dm.div.negative !== 0 ? dm.div.isubn(1) : dm.div.iaddn(1);
        };
        BN2.prototype.modrn = function modrn(num) {
          var isNegNum = num < 0;
          if (isNegNum) num = -num;
          assert2(num <= 67108863);
          var p = (1 << 26) % num;
          var acc = 0;
          for (var i = this.length - 1; i >= 0; i--) {
            acc = (p * acc + (this.words[i] | 0)) % num;
          }
          return isNegNum ? -acc : acc;
        };
        BN2.prototype.modn = function modn(num) {
          return this.modrn(num);
        };
        BN2.prototype.idivn = function idivn(num) {
          var isNegNum = num < 0;
          if (isNegNum) num = -num;
          assert2(num <= 67108863);
          var carry = 0;
          for (var i = this.length - 1; i >= 0; i--) {
            var w = (this.words[i] | 0) + carry * 67108864;
            this.words[i] = w / num | 0;
            carry = w % num;
          }
          this._strip();
          return isNegNum ? this.ineg() : this;
        };
        BN2.prototype.divn = function divn(num) {
          return this.clone().idivn(num);
        };
        BN2.prototype.egcd = function egcd(p) {
          assert2(p.negative === 0);
          assert2(!p.isZero());
          var x = this;
          var y = p.clone();
          if (x.negative !== 0) {
            x = x.umod(p);
          } else {
            x = x.clone();
          }
          var A = new BN2(1);
          var B = new BN2(0);
          var C = new BN2(0);
          var D = new BN2(1);
          var g = 0;
          while (x.isEven() && y.isEven()) {
            x.iushrn(1);
            y.iushrn(1);
            ++g;
          }
          var yp = y.clone();
          var xp = x.clone();
          while (!x.isZero()) {
            for (var i = 0, im = 1; (x.words[0] & im) === 0 && i < 26; ++i, im <<= 1) ;
            if (i > 0) {
              x.iushrn(i);
              while (i-- > 0) {
                if (A.isOdd() || B.isOdd()) {
                  A.iadd(yp);
                  B.isub(xp);
                }
                A.iushrn(1);
                B.iushrn(1);
              }
            }
            for (var j = 0, jm = 1; (y.words[0] & jm) === 0 && j < 26; ++j, jm <<= 1) ;
            if (j > 0) {
              y.iushrn(j);
              while (j-- > 0) {
                if (C.isOdd() || D.isOdd()) {
                  C.iadd(yp);
                  D.isub(xp);
                }
                C.iushrn(1);
                D.iushrn(1);
              }
            }
            if (x.cmp(y) >= 0) {
              x.isub(y);
              A.isub(C);
              B.isub(D);
            } else {
              y.isub(x);
              C.isub(A);
              D.isub(B);
            }
          }
          return {
            a: C,
            b: D,
            gcd: y.iushln(g)
          };
        };
        BN2.prototype._invmp = function _invmp(p) {
          assert2(p.negative === 0);
          assert2(!p.isZero());
          var a = this;
          var b = p.clone();
          if (a.negative !== 0) {
            a = a.umod(p);
          } else {
            a = a.clone();
          }
          var x1 = new BN2(1);
          var x2 = new BN2(0);
          var delta = b.clone();
          while (a.cmpn(1) > 0 && b.cmpn(1) > 0) {
            for (var i = 0, im = 1; (a.words[0] & im) === 0 && i < 26; ++i, im <<= 1) ;
            if (i > 0) {
              a.iushrn(i);
              while (i-- > 0) {
                if (x1.isOdd()) {
                  x1.iadd(delta);
                }
                x1.iushrn(1);
              }
            }
            for (var j = 0, jm = 1; (b.words[0] & jm) === 0 && j < 26; ++j, jm <<= 1) ;
            if (j > 0) {
              b.iushrn(j);
              while (j-- > 0) {
                if (x2.isOdd()) {
                  x2.iadd(delta);
                }
                x2.iushrn(1);
              }
            }
            if (a.cmp(b) >= 0) {
              a.isub(b);
              x1.isub(x2);
            } else {
              b.isub(a);
              x2.isub(x1);
            }
          }
          var res;
          if (a.cmpn(1) === 0) {
            res = x1;
          } else {
            res = x2;
          }
          if (res.cmpn(0) < 0) {
            res.iadd(p);
          }
          return res;
        };
        BN2.prototype.gcd = function gcd(num) {
          if (this.isZero()) return num.abs();
          if (num.isZero()) return this.abs();
          var a = this.clone();
          var b = num.clone();
          a.negative = 0;
          b.negative = 0;
          for (var shift = 0; a.isEven() && b.isEven(); shift++) {
            a.iushrn(1);
            b.iushrn(1);
          }
          do {
            while (a.isEven()) {
              a.iushrn(1);
            }
            while (b.isEven()) {
              b.iushrn(1);
            }
            var r = a.cmp(b);
            if (r < 0) {
              var t = a;
              a = b;
              b = t;
            } else if (r === 0 || b.cmpn(1) === 0) {
              break;
            }
            a.isub(b);
          } while (true);
          return b.iushln(shift);
        };
        BN2.prototype.invm = function invm(num) {
          return this.egcd(num).a.umod(num);
        };
        BN2.prototype.isEven = function isEven() {
          return (this.words[0] & 1) === 0;
        };
        BN2.prototype.isOdd = function isOdd() {
          return (this.words[0] & 1) === 1;
        };
        BN2.prototype.andln = function andln(num) {
          return this.words[0] & num;
        };
        BN2.prototype.bincn = function bincn(bit) {
          assert2(typeof bit === "number");
          var r = bit % 26;
          var s = (bit - r) / 26;
          var q = 1 << r;
          if (this.length <= s) {
            this._expand(s + 1);
            this.words[s] |= q;
            return this;
          }
          var carry = q;
          for (var i = s; carry !== 0 && i < this.length; i++) {
            var w = this.words[i] | 0;
            w += carry;
            carry = w >>> 26;
            w &= 67108863;
            this.words[i] = w;
          }
          if (carry !== 0) {
            this.words[i] = carry;
            this.length++;
          }
          return this;
        };
        BN2.prototype.isZero = function isZero() {
          return this.length === 1 && this.words[0] === 0;
        };
        BN2.prototype.cmpn = function cmpn(num) {
          var negative = num < 0;
          if (this.negative !== 0 && !negative) return -1;
          if (this.negative === 0 && negative) return 1;
          this._strip();
          var res;
          if (this.length > 1) {
            res = 1;
          } else {
            if (negative) {
              num = -num;
            }
            assert2(num <= 67108863, "Number is too big");
            var w = this.words[0] | 0;
            res = w === num ? 0 : w < num ? -1 : 1;
          }
          if (this.negative !== 0) return -res | 0;
          return res;
        };
        BN2.prototype.cmp = function cmp(num) {
          if (this.negative !== 0 && num.negative === 0) return -1;
          if (this.negative === 0 && num.negative !== 0) return 1;
          var res = this.ucmp(num);
          if (this.negative !== 0) return -res | 0;
          return res;
        };
        BN2.prototype.ucmp = function ucmp(num) {
          if (this.length > num.length) return 1;
          if (this.length < num.length) return -1;
          var res = 0;
          for (var i = this.length - 1; i >= 0; i--) {
            var a = this.words[i] | 0;
            var b = num.words[i] | 0;
            if (a === b) continue;
            if (a < b) {
              res = -1;
            } else if (a > b) {
              res = 1;
            }
            break;
          }
          return res;
        };
        BN2.prototype.gtn = function gtn(num) {
          return this.cmpn(num) === 1;
        };
        BN2.prototype.gt = function gt(num) {
          return this.cmp(num) === 1;
        };
        BN2.prototype.gten = function gten(num) {
          return this.cmpn(num) >= 0;
        };
        BN2.prototype.gte = function gte(num) {
          return this.cmp(num) >= 0;
        };
        BN2.prototype.ltn = function ltn(num) {
          return this.cmpn(num) === -1;
        };
        BN2.prototype.lt = function lt(num) {
          return this.cmp(num) === -1;
        };
        BN2.prototype.lten = function lten(num) {
          return this.cmpn(num) <= 0;
        };
        BN2.prototype.lte = function lte(num) {
          return this.cmp(num) <= 0;
        };
        BN2.prototype.eqn = function eqn(num) {
          return this.cmpn(num) === 0;
        };
        BN2.prototype.eq = function eq(num) {
          return this.cmp(num) === 0;
        };
        BN2.red = function red(num) {
          return new Red(num);
        };
        BN2.prototype.toRed = function toRed(ctx) {
          assert2(!this.red, "Already a number in reduction context");
          assert2(this.negative === 0, "red works only with positives");
          return ctx.convertTo(this)._forceRed(ctx);
        };
        BN2.prototype.fromRed = function fromRed() {
          assert2(this.red, "fromRed works only with numbers in reduction context");
          return this.red.convertFrom(this);
        };
        BN2.prototype._forceRed = function _forceRed(ctx) {
          this.red = ctx;
          return this;
        };
        BN2.prototype.forceRed = function forceRed(ctx) {
          assert2(!this.red, "Already a number in reduction context");
          return this._forceRed(ctx);
        };
        BN2.prototype.redAdd = function redAdd(num) {
          assert2(this.red, "redAdd works only with red numbers");
          return this.red.add(this, num);
        };
        BN2.prototype.redIAdd = function redIAdd(num) {
          assert2(this.red, "redIAdd works only with red numbers");
          return this.red.iadd(this, num);
        };
        BN2.prototype.redSub = function redSub(num) {
          assert2(this.red, "redSub works only with red numbers");
          return this.red.sub(this, num);
        };
        BN2.prototype.redISub = function redISub(num) {
          assert2(this.red, "redISub works only with red numbers");
          return this.red.isub(this, num);
        };
        BN2.prototype.redShl = function redShl(num) {
          assert2(this.red, "redShl works only with red numbers");
          return this.red.shl(this, num);
        };
        BN2.prototype.redMul = function redMul(num) {
          assert2(this.red, "redMul works only with red numbers");
          this.red._verify2(this, num);
          return this.red.mul(this, num);
        };
        BN2.prototype.redIMul = function redIMul(num) {
          assert2(this.red, "redMul works only with red numbers");
          this.red._verify2(this, num);
          return this.red.imul(this, num);
        };
        BN2.prototype.redSqr = function redSqr() {
          assert2(this.red, "redSqr works only with red numbers");
          this.red._verify1(this);
          return this.red.sqr(this);
        };
        BN2.prototype.redISqr = function redISqr() {
          assert2(this.red, "redISqr works only with red numbers");
          this.red._verify1(this);
          return this.red.isqr(this);
        };
        BN2.prototype.redSqrt = function redSqrt() {
          assert2(this.red, "redSqrt works only with red numbers");
          this.red._verify1(this);
          return this.red.sqrt(this);
        };
        BN2.prototype.redInvm = function redInvm() {
          assert2(this.red, "redInvm works only with red numbers");
          this.red._verify1(this);
          return this.red.invm(this);
        };
        BN2.prototype.redNeg = function redNeg() {
          assert2(this.red, "redNeg works only with red numbers");
          this.red._verify1(this);
          return this.red.neg(this);
        };
        BN2.prototype.redPow = function redPow(num) {
          assert2(this.red && !num.red, "redPow(normalNum)");
          this.red._verify1(this);
          return this.red.pow(this, num);
        };
        var primes = {
          k256: null,
          p224: null,
          p192: null,
          p25519: null
        };
        function MPrime(name, p) {
          this.name = name;
          this.p = new BN2(p, 16);
          this.n = this.p.bitLength();
          this.k = new BN2(1).iushln(this.n).isub(this.p);
          this.tmp = this._tmp();
        }
        MPrime.prototype._tmp = function _tmp() {
          var tmp = new BN2(null);
          tmp.words = new Array(Math.ceil(this.n / 13));
          return tmp;
        };
        MPrime.prototype.ireduce = function ireduce(num) {
          var r = num;
          var rlen;
          do {
            this.split(r, this.tmp);
            r = this.imulK(r);
            r = r.iadd(this.tmp);
            rlen = r.bitLength();
          } while (rlen > this.n);
          var cmp = rlen < this.n ? -1 : r.ucmp(this.p);
          if (cmp === 0) {
            r.words[0] = 0;
            r.length = 1;
          } else if (cmp > 0) {
            r.isub(this.p);
          } else {
            if (r.strip !== void 0) {
              r.strip();
            } else {
              r._strip();
            }
          }
          return r;
        };
        MPrime.prototype.split = function split(input, out) {
          input.iushrn(this.n, 0, out);
        };
        MPrime.prototype.imulK = function imulK(num) {
          return num.imul(this.k);
        };
        function K256() {
          MPrime.call(
            this,
            "k256",
            "ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffe fffffc2f"
          );
        }
        inherits(K256, MPrime);
        K256.prototype.split = function split(input, output) {
          var mask2 = 4194303;
          var outLen = Math.min(input.length, 9);
          for (var i = 0; i < outLen; i++) {
            output.words[i] = input.words[i];
          }
          output.length = outLen;
          if (input.length <= 9) {
            input.words[0] = 0;
            input.length = 1;
            return;
          }
          var prev = input.words[9];
          output.words[output.length++] = prev & mask2;
          for (i = 10; i < input.length; i++) {
            var next = input.words[i] | 0;
            input.words[i - 10] = (next & mask2) << 4 | prev >>> 22;
            prev = next;
          }
          prev >>>= 22;
          input.words[i - 10] = prev;
          if (prev === 0 && input.length > 10) {
            input.length -= 10;
          } else {
            input.length -= 9;
          }
        };
        K256.prototype.imulK = function imulK(num) {
          num.words[num.length] = 0;
          num.words[num.length + 1] = 0;
          num.length += 2;
          var lo = 0;
          for (var i = 0; i < num.length; i++) {
            var w = num.words[i] | 0;
            lo += w * 977;
            num.words[i] = lo & 67108863;
            lo = w * 64 + (lo / 67108864 | 0);
          }
          if (num.words[num.length - 1] === 0) {
            num.length--;
            if (num.words[num.length - 1] === 0) {
              num.length--;
            }
          }
          return num;
        };
        function P224() {
          MPrime.call(
            this,
            "p224",
            "ffffffff ffffffff ffffffff ffffffff 00000000 00000000 00000001"
          );
        }
        inherits(P224, MPrime);
        function P192() {
          MPrime.call(
            this,
            "p192",
            "ffffffff ffffffff ffffffff fffffffe ffffffff ffffffff"
          );
        }
        inherits(P192, MPrime);
        function P25519() {
          MPrime.call(
            this,
            "25519",
            "7fffffffffffffff ffffffffffffffff ffffffffffffffff ffffffffffffffed"
          );
        }
        inherits(P25519, MPrime);
        P25519.prototype.imulK = function imulK(num) {
          var carry = 0;
          for (var i = 0; i < num.length; i++) {
            var hi = (num.words[i] | 0) * 19 + carry;
            var lo = hi & 67108863;
            hi >>>= 26;
            num.words[i] = lo;
            carry = hi;
          }
          if (carry !== 0) {
            num.words[num.length++] = carry;
          }
          return num;
        };
        BN2._prime = function prime(name) {
          if (primes[name]) return primes[name];
          var prime2;
          if (name === "k256") {
            prime2 = new K256();
          } else if (name === "p224") {
            prime2 = new P224();
          } else if (name === "p192") {
            prime2 = new P192();
          } else if (name === "p25519") {
            prime2 = new P25519();
          } else {
            throw new Error("Unknown prime " + name);
          }
          primes[name] = prime2;
          return prime2;
        };
        function Red(m) {
          if (typeof m === "string") {
            var prime = BN2._prime(m);
            this.m = prime.p;
            this.prime = prime;
          } else {
            assert2(m.gtn(1), "modulus must be greater than 1");
            this.m = m;
            this.prime = null;
          }
        }
        Red.prototype._verify1 = function _verify1(a) {
          assert2(a.negative === 0, "red works only with positives");
          assert2(a.red, "red works only with red numbers");
        };
        Red.prototype._verify2 = function _verify2(a, b) {
          assert2((a.negative | b.negative) === 0, "red works only with positives");
          assert2(
            a.red && a.red === b.red,
            "red works only with red numbers"
          );
        };
        Red.prototype.imod = function imod(a) {
          if (this.prime) return this.prime.ireduce(a)._forceRed(this);
          move(a, a.umod(this.m)._forceRed(this));
          return a;
        };
        Red.prototype.neg = function neg(a) {
          if (a.isZero()) {
            return a.clone();
          }
          return this.m.sub(a)._forceRed(this);
        };
        Red.prototype.add = function add(a, b) {
          this._verify2(a, b);
          var res = a.add(b);
          if (res.cmp(this.m) >= 0) {
            res.isub(this.m);
          }
          return res._forceRed(this);
        };
        Red.prototype.iadd = function iadd(a, b) {
          this._verify2(a, b);
          var res = a.iadd(b);
          if (res.cmp(this.m) >= 0) {
            res.isub(this.m);
          }
          return res;
        };
        Red.prototype.sub = function sub(a, b) {
          this._verify2(a, b);
          var res = a.sub(b);
          if (res.cmpn(0) < 0) {
            res.iadd(this.m);
          }
          return res._forceRed(this);
        };
        Red.prototype.isub = function isub(a, b) {
          this._verify2(a, b);
          var res = a.isub(b);
          if (res.cmpn(0) < 0) {
            res.iadd(this.m);
          }
          return res;
        };
        Red.prototype.shl = function shl(a, num) {
          this._verify1(a);
          return this.imod(a.ushln(num));
        };
        Red.prototype.imul = function imul(a, b) {
          this._verify2(a, b);
          return this.imod(a.imul(b));
        };
        Red.prototype.mul = function mul(a, b) {
          this._verify2(a, b);
          return this.imod(a.mul(b));
        };
        Red.prototype.isqr = function isqr(a) {
          return this.imul(a, a.clone());
        };
        Red.prototype.sqr = function sqr(a) {
          return this.mul(a, a);
        };
        Red.prototype.sqrt = function sqrt(a) {
          if (a.isZero()) return a.clone();
          var mod3 = this.m.andln(3);
          assert2(mod3 % 2 === 1);
          if (mod3 === 3) {
            var pow = this.m.add(new BN2(1)).iushrn(2);
            return this.pow(a, pow);
          }
          var q = this.m.subn(1);
          var s = 0;
          while (!q.isZero() && q.andln(1) === 0) {
            s++;
            q.iushrn(1);
          }
          assert2(!q.isZero());
          var one = new BN2(1).toRed(this);
          var nOne = one.redNeg();
          var lpow = this.m.subn(1).iushrn(1);
          var z = this.m.bitLength();
          z = new BN2(2 * z * z).toRed(this);
          while (this.pow(z, lpow).cmp(nOne) !== 0) {
            z.redIAdd(nOne);
          }
          var c = this.pow(z, q);
          var r = this.pow(a, q.addn(1).iushrn(1));
          var t = this.pow(a, q);
          var m = s;
          while (t.cmp(one) !== 0) {
            var tmp = t;
            for (var i = 0; tmp.cmp(one) !== 0; i++) {
              tmp = tmp.redSqr();
            }
            assert2(i < m);
            var b = this.pow(c, new BN2(1).iushln(m - i - 1));
            r = r.redMul(b);
            c = b.redSqr();
            t = t.redMul(c);
            m = i;
          }
          return r;
        };
        Red.prototype.invm = function invm(a) {
          var inv = a._invmp(this.m);
          if (inv.negative !== 0) {
            inv.negative = 0;
            return this.imod(inv).redNeg();
          } else {
            return this.imod(inv);
          }
        };
        Red.prototype.pow = function pow(a, num) {
          if (num.isZero()) return new BN2(1).toRed(this);
          if (num.cmpn(1) === 0) return a.clone();
          var windowSize = 4;
          var wnd = new Array(1 << windowSize);
          wnd[0] = new BN2(1).toRed(this);
          wnd[1] = a;
          for (var i = 2; i < wnd.length; i++) {
            wnd[i] = this.mul(wnd[i - 1], a);
          }
          var res = wnd[0];
          var current = 0;
          var currentLen = 0;
          var start = num.bitLength() % 26;
          if (start === 0) {
            start = 26;
          }
          for (i = num.length - 1; i >= 0; i--) {
            var word = num.words[i];
            for (var j = start - 1; j >= 0; j--) {
              var bit = word >> j & 1;
              if (res !== wnd[0]) {
                res = this.sqr(res);
              }
              if (bit === 0 && current === 0) {
                currentLen = 0;
                continue;
              }
              current <<= 1;
              current |= bit;
              currentLen++;
              if (currentLen !== windowSize && (i !== 0 || j !== 0)) continue;
              res = this.mul(res, wnd[current]);
              currentLen = 0;
              current = 0;
            }
            start = 26;
          }
          return res;
        };
        Red.prototype.convertTo = function convertTo(num) {
          var r = num.umod(this.m);
          return r === num ? r.clone() : r;
        };
        Red.prototype.convertFrom = function convertFrom(num) {
          var res = num.clone();
          res.red = null;
          return res;
        };
        BN2.mont = function mont(num) {
          return new Mont(num);
        };
        function Mont(m) {
          Red.call(this, m);
          this.shift = this.m.bitLength();
          if (this.shift % 26 !== 0) {
            this.shift += 26 - this.shift % 26;
          }
          this.r = new BN2(1).iushln(this.shift);
          this.r2 = this.imod(this.r.sqr());
          this.rinv = this.r._invmp(this.m);
          this.minv = this.rinv.mul(this.r).isubn(1).div(this.m);
          this.minv = this.minv.umod(this.r);
          this.minv = this.r.sub(this.minv);
        }
        inherits(Mont, Red);
        Mont.prototype.convertTo = function convertTo(num) {
          return this.imod(num.ushln(this.shift));
        };
        Mont.prototype.convertFrom = function convertFrom(num) {
          var r = this.imod(num.mul(this.rinv));
          r.red = null;
          return r;
        };
        Mont.prototype.imul = function imul(a, b) {
          if (a.isZero() || b.isZero()) {
            a.words[0] = 0;
            a.length = 1;
            return a;
          }
          var t = a.imul(b);
          var c = t.maskn(this.shift).mul(this.minv).imaskn(this.shift).mul(this.m);
          var u = t.isub(c).iushrn(this.shift);
          var res = u;
          if (u.cmp(this.m) >= 0) {
            res = u.isub(this.m);
          } else if (u.cmpn(0) < 0) {
            res = u.iadd(this.m);
          }
          return res._forceRed(this);
        };
        Mont.prototype.mul = function mul(a, b) {
          if (a.isZero() || b.isZero()) return new BN2(0)._forceRed(this);
          var t = a.mul(b);
          var c = t.maskn(this.shift).mul(this.minv).imaskn(this.shift).mul(this.m);
          var u = t.isub(c).iushrn(this.shift);
          var res = u;
          if (u.cmp(this.m) >= 0) {
            res = u.isub(this.m);
          } else if (u.cmpn(0) < 0) {
            res = u.iadd(this.m);
          }
          return res._forceRed(this);
        };
        Mont.prototype.invm = function invm(a) {
          var res = this.imod(a._invmp(this.m).mul(this.r2));
          return res._forceRed(this);
        };
      })(typeof module === "undefined" || module, exports);
    }
  });

  // node_modules/safe-buffer/index.js
  var require_safe_buffer = __commonJS({
    "node_modules/safe-buffer/index.js"(exports, module) {
      var buffer = require_buffer();
      var Buffer3 = buffer.Buffer;
      function copyProps(src, dst) {
        for (var key in src) {
          dst[key] = src[key];
        }
      }
      if (Buffer3.from && Buffer3.alloc && Buffer3.allocUnsafe && Buffer3.allocUnsafeSlow) {
        module.exports = buffer;
      } else {
        copyProps(buffer, exports);
        exports.Buffer = SafeBuffer;
      }
      function SafeBuffer(arg, encodingOrOffset, length) {
        return Buffer3(arg, encodingOrOffset, length);
      }
      SafeBuffer.prototype = Object.create(Buffer3.prototype);
      copyProps(Buffer3, SafeBuffer);
      SafeBuffer.from = function(arg, encodingOrOffset, length) {
        if (typeof arg === "number") {
          throw new TypeError("Argument must not be a number");
        }
        return Buffer3(arg, encodingOrOffset, length);
      };
      SafeBuffer.alloc = function(size, fill, encoding) {
        if (typeof size !== "number") {
          throw new TypeError("Argument must be a number");
        }
        var buf = Buffer3(size);
        if (fill !== void 0) {
          if (typeof encoding === "string") {
            buf.fill(fill, encoding);
          } else {
            buf.fill(fill);
          }
        } else {
          buf.fill(0);
        }
        return buf;
      };
      SafeBuffer.allocUnsafe = function(size) {
        if (typeof size !== "number") {
          throw new TypeError("Argument must be a number");
        }
        return Buffer3(size);
      };
      SafeBuffer.allocUnsafeSlow = function(size) {
        if (typeof size !== "number") {
          throw new TypeError("Argument must be a number");
        }
        return buffer.SlowBuffer(size);
      };
    }
  });

  // node_modules/base-x/src/index.js
  var require_src = __commonJS({
    "node_modules/base-x/src/index.js"(exports, module) {
      "use strict";
      var _Buffer = require_safe_buffer().Buffer;
      function base(ALPHABET) {
        if (ALPHABET.length >= 255) {
          throw new TypeError("Alphabet too long");
        }
        var BASE_MAP = new Uint8Array(256);
        for (var j = 0; j < BASE_MAP.length; j++) {
          BASE_MAP[j] = 255;
        }
        for (var i = 0; i < ALPHABET.length; i++) {
          var x = ALPHABET.charAt(i);
          var xc = x.charCodeAt(0);
          if (BASE_MAP[xc] !== 255) {
            throw new TypeError(x + " is ambiguous");
          }
          BASE_MAP[xc] = i;
        }
        var BASE = ALPHABET.length;
        var LEADER = ALPHABET.charAt(0);
        var FACTOR = Math.log(BASE) / Math.log(256);
        var iFACTOR = Math.log(256) / Math.log(BASE);
        function encode2(source) {
          if (Array.isArray(source) || source instanceof Uint8Array) {
            source = _Buffer.from(source);
          }
          if (!_Buffer.isBuffer(source)) {
            throw new TypeError("Expected Buffer");
          }
          if (source.length === 0) {
            return "";
          }
          var zeroes = 0;
          var length = 0;
          var pbegin = 0;
          var pend = source.length;
          while (pbegin !== pend && source[pbegin] === 0) {
            pbegin++;
            zeroes++;
          }
          var size = (pend - pbegin) * iFACTOR + 1 >>> 0;
          var b58 = new Uint8Array(size);
          while (pbegin !== pend) {
            var carry = source[pbegin];
            var i2 = 0;
            for (var it1 = size - 1; (carry !== 0 || i2 < length) && it1 !== -1; it1--, i2++) {
              carry += 256 * b58[it1] >>> 0;
              b58[it1] = carry % BASE >>> 0;
              carry = carry / BASE >>> 0;
            }
            if (carry !== 0) {
              throw new Error("Non-zero carry");
            }
            length = i2;
            pbegin++;
          }
          var it2 = size - length;
          while (it2 !== size && b58[it2] === 0) {
            it2++;
          }
          var str2 = LEADER.repeat(zeroes);
          for (; it2 < size; ++it2) {
            str2 += ALPHABET.charAt(b58[it2]);
          }
          return str2;
        }
        function decodeUnsafe(source) {
          if (typeof source !== "string") {
            throw new TypeError("Expected String");
          }
          if (source.length === 0) {
            return _Buffer.alloc(0);
          }
          var psz = 0;
          var zeroes = 0;
          var length = 0;
          while (source[psz] === LEADER) {
            zeroes++;
            psz++;
          }
          var size = (source.length - psz) * FACTOR + 1 >>> 0;
          var b256 = new Uint8Array(size);
          while (psz < source.length) {
            var charCode = source.charCodeAt(psz);
            if (charCode > 255) {
              return;
            }
            var carry = BASE_MAP[charCode];
            if (carry === 255) {
              return;
            }
            var i2 = 0;
            for (var it3 = size - 1; (carry !== 0 || i2 < length) && it3 !== -1; it3--, i2++) {
              carry += BASE * b256[it3] >>> 0;
              b256[it3] = carry % 256 >>> 0;
              carry = carry / 256 >>> 0;
            }
            if (carry !== 0) {
              throw new Error("Non-zero carry");
            }
            length = i2;
            psz++;
          }
          var it4 = size - length;
          while (it4 !== size && b256[it4] === 0) {
            it4++;
          }
          var vch = _Buffer.allocUnsafe(zeroes + (size - it4));
          vch.fill(0, 0, zeroes);
          var j2 = zeroes;
          while (it4 !== size) {
            vch[j2++] = b256[it4++];
          }
          return vch;
        }
        function decode2(string2) {
          var buffer = decodeUnsafe(string2);
          if (buffer) {
            return buffer;
          }
          throw new Error("Non-base" + BASE + " character");
        }
        return {
          encode: encode2,
          decodeUnsafe,
          decode: decode2
        };
      }
      module.exports = base;
    }
  });

  // node_modules/bs58/index.js
  var require_bs58 = __commonJS({
    "node_modules/bs58/index.js"(exports, module) {
      var basex = require_src();
      var ALPHABET = "123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz";
      module.exports = basex(ALPHABET);
    }
  });

  // node_modules/@noble/hashes/sha256.js
  var require_sha256 = __commonJS({
    "node_modules/@noble/hashes/sha256.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.sha224 = exports.SHA224 = exports.sha256 = exports.SHA256 = void 0;
      var sha2_ts_1 = require_sha2();
      exports.SHA256 = sha2_ts_1.SHA256;
      exports.sha256 = sha2_ts_1.sha256;
      exports.SHA224 = sha2_ts_1.SHA224;
      exports.sha224 = sha2_ts_1.sha224;
    }
  });

  // node_modules/text-encoding-utf-8/lib/encoding.lib.js
  var require_encoding_lib = __commonJS({
    "node_modules/text-encoding-utf-8/lib/encoding.lib.js"(exports) {
      "use strict";
      function inRange(a, min, max) {
        return min <= a && a <= max;
      }
      function ToDictionary(o) {
        if (o === void 0) return {};
        if (o === Object(o)) return o;
        throw TypeError("Could not convert argument to dictionary");
      }
      function stringToCodePoints(string2) {
        var s = String(string2);
        var n = s.length;
        var i = 0;
        var u = [];
        while (i < n) {
          var c = s.charCodeAt(i);
          if (c < 55296 || c > 57343) {
            u.push(c);
          } else if (56320 <= c && c <= 57343) {
            u.push(65533);
          } else if (55296 <= c && c <= 56319) {
            if (i === n - 1) {
              u.push(65533);
            } else {
              var d = string2.charCodeAt(i + 1);
              if (56320 <= d && d <= 57343) {
                var a = c & 1023;
                var b = d & 1023;
                u.push(65536 + (a << 10) + b);
                i += 1;
              } else {
                u.push(65533);
              }
            }
          }
          i += 1;
        }
        return u;
      }
      function codePointsToString(code_points) {
        var s = "";
        for (var i = 0; i < code_points.length; ++i) {
          var cp = code_points[i];
          if (cp <= 65535) {
            s += String.fromCharCode(cp);
          } else {
            cp -= 65536;
            s += String.fromCharCode(
              (cp >> 10) + 55296,
              (cp & 1023) + 56320
            );
          }
        }
        return s;
      }
      var end_of_stream = -1;
      function Stream(tokens) {
        this.tokens = [].slice.call(tokens);
      }
      Stream.prototype = {
        /**
         * @return {boolean} True if end-of-stream has been hit.
         */
        endOfStream: function() {
          return !this.tokens.length;
        },
        /**
         * When a token is read from a stream, the first token in the
         * stream must be returned and subsequently removed, and
         * end-of-stream must be returned otherwise.
         *
         * @return {number} Get the next token from the stream, or
         * end_of_stream.
         */
        read: function() {
          if (!this.tokens.length)
            return end_of_stream;
          return this.tokens.shift();
        },
        /**
         * When one or more tokens are prepended to a stream, those tokens
         * must be inserted, in given order, before the first token in the
         * stream.
         *
         * @param {(number|!Array.<number>)} token The token(s) to prepend to the stream.
         */
        prepend: function(token2) {
          if (Array.isArray(token2)) {
            var tokens = (
              /**@type {!Array.<number>}*/
              token2
            );
            while (tokens.length)
              this.tokens.unshift(tokens.pop());
          } else {
            this.tokens.unshift(token2);
          }
        },
        /**
         * When one or more tokens are pushed to a stream, those tokens
         * must be inserted, in given order, after the last token in the
         * stream.
         *
         * @param {(number|!Array.<number>)} token The tokens(s) to prepend to the stream.
         */
        push: function(token2) {
          if (Array.isArray(token2)) {
            var tokens = (
              /**@type {!Array.<number>}*/
              token2
            );
            while (tokens.length)
              this.tokens.push(tokens.shift());
          } else {
            this.tokens.push(token2);
          }
        }
      };
      var finished = -1;
      function decoderError(fatal, opt_code_point) {
        if (fatal)
          throw TypeError("Decoder error");
        return opt_code_point || 65533;
      }
      var DEFAULT_ENCODING = "utf-8";
      function TextDecoder2(encoding, options) {
        if (!(this instanceof TextDecoder2)) {
          return new TextDecoder2(encoding, options);
        }
        encoding = encoding !== void 0 ? String(encoding).toLowerCase() : DEFAULT_ENCODING;
        if (encoding !== DEFAULT_ENCODING) {
          throw new Error("Encoding not supported. Only utf-8 is supported");
        }
        options = ToDictionary(options);
        this._streaming = false;
        this._BOMseen = false;
        this._decoder = null;
        this._fatal = Boolean(options["fatal"]);
        this._ignoreBOM = Boolean(options["ignoreBOM"]);
        Object.defineProperty(this, "encoding", { value: "utf-8" });
        Object.defineProperty(this, "fatal", { value: this._fatal });
        Object.defineProperty(this, "ignoreBOM", { value: this._ignoreBOM });
      }
      TextDecoder2.prototype = {
        /**
         * @param {ArrayBufferView=} input The buffer of bytes to decode.
         * @param {Object=} options
         * @return {string} The decoded string.
         */
        decode: function decode2(input, options) {
          var bytes;
          if (typeof input === "object" && input instanceof ArrayBuffer) {
            bytes = new Uint8Array(input);
          } else if (typeof input === "object" && "buffer" in input && input.buffer instanceof ArrayBuffer) {
            bytes = new Uint8Array(
              input.buffer,
              input.byteOffset,
              input.byteLength
            );
          } else {
            bytes = new Uint8Array(0);
          }
          options = ToDictionary(options);
          if (!this._streaming) {
            this._decoder = new UTF8Decoder({ fatal: this._fatal });
            this._BOMseen = false;
          }
          this._streaming = Boolean(options["stream"]);
          var input_stream = new Stream(bytes);
          var code_points = [];
          var result;
          while (!input_stream.endOfStream()) {
            result = this._decoder.handler(input_stream, input_stream.read());
            if (result === finished)
              break;
            if (result === null)
              continue;
            if (Array.isArray(result))
              code_points.push.apply(
                code_points,
                /**@type {!Array.<number>}*/
                result
              );
            else
              code_points.push(result);
          }
          if (!this._streaming) {
            do {
              result = this._decoder.handler(input_stream, input_stream.read());
              if (result === finished)
                break;
              if (result === null)
                continue;
              if (Array.isArray(result))
                code_points.push.apply(
                  code_points,
                  /**@type {!Array.<number>}*/
                  result
                );
              else
                code_points.push(result);
            } while (!input_stream.endOfStream());
            this._decoder = null;
          }
          if (code_points.length) {
            if (["utf-8"].indexOf(this.encoding) !== -1 && !this._ignoreBOM && !this._BOMseen) {
              if (code_points[0] === 65279) {
                this._BOMseen = true;
                code_points.shift();
              } else {
                this._BOMseen = true;
              }
            }
          }
          return codePointsToString(code_points);
        }
      };
      function TextEncoder2(encoding, options) {
        if (!(this instanceof TextEncoder2))
          return new TextEncoder2(encoding, options);
        encoding = encoding !== void 0 ? String(encoding).toLowerCase() : DEFAULT_ENCODING;
        if (encoding !== DEFAULT_ENCODING) {
          throw new Error("Encoding not supported. Only utf-8 is supported");
        }
        options = ToDictionary(options);
        this._streaming = false;
        this._encoder = null;
        this._options = { fatal: Boolean(options["fatal"]) };
        Object.defineProperty(this, "encoding", { value: "utf-8" });
      }
      TextEncoder2.prototype = {
        /**
         * @param {string=} opt_string The string to encode.
         * @param {Object=} options
         * @return {Uint8Array} Encoded bytes, as a Uint8Array.
         */
        encode: function encode2(opt_string, options) {
          opt_string = opt_string ? String(opt_string) : "";
          options = ToDictionary(options);
          if (!this._streaming)
            this._encoder = new UTF8Encoder(this._options);
          this._streaming = Boolean(options["stream"]);
          var bytes = [];
          var input_stream = new Stream(stringToCodePoints(opt_string));
          var result;
          while (!input_stream.endOfStream()) {
            result = this._encoder.handler(input_stream, input_stream.read());
            if (result === finished)
              break;
            if (Array.isArray(result))
              bytes.push.apply(
                bytes,
                /**@type {!Array.<number>}*/
                result
              );
            else
              bytes.push(result);
          }
          if (!this._streaming) {
            while (true) {
              result = this._encoder.handler(input_stream, input_stream.read());
              if (result === finished)
                break;
              if (Array.isArray(result))
                bytes.push.apply(
                  bytes,
                  /**@type {!Array.<number>}*/
                  result
                );
              else
                bytes.push(result);
            }
            this._encoder = null;
          }
          return new Uint8Array(bytes);
        }
      };
      function UTF8Decoder(options) {
        var fatal = options.fatal;
        var utf8_code_point = 0, utf8_bytes_seen = 0, utf8_bytes_needed = 0, utf8_lower_boundary = 128, utf8_upper_boundary = 191;
        this.handler = function(stream, bite) {
          if (bite === end_of_stream && utf8_bytes_needed !== 0) {
            utf8_bytes_needed = 0;
            return decoderError(fatal);
          }
          if (bite === end_of_stream)
            return finished;
          if (utf8_bytes_needed === 0) {
            if (inRange(bite, 0, 127)) {
              return bite;
            }
            if (inRange(bite, 194, 223)) {
              utf8_bytes_needed = 1;
              utf8_code_point = bite - 192;
            } else if (inRange(bite, 224, 239)) {
              if (bite === 224)
                utf8_lower_boundary = 160;
              if (bite === 237)
                utf8_upper_boundary = 159;
              utf8_bytes_needed = 2;
              utf8_code_point = bite - 224;
            } else if (inRange(bite, 240, 244)) {
              if (bite === 240)
                utf8_lower_boundary = 144;
              if (bite === 244)
                utf8_upper_boundary = 143;
              utf8_bytes_needed = 3;
              utf8_code_point = bite - 240;
            } else {
              return decoderError(fatal);
            }
            utf8_code_point = utf8_code_point << 6 * utf8_bytes_needed;
            return null;
          }
          if (!inRange(bite, utf8_lower_boundary, utf8_upper_boundary)) {
            utf8_code_point = utf8_bytes_needed = utf8_bytes_seen = 0;
            utf8_lower_boundary = 128;
            utf8_upper_boundary = 191;
            stream.prepend(bite);
            return decoderError(fatal);
          }
          utf8_lower_boundary = 128;
          utf8_upper_boundary = 191;
          utf8_bytes_seen += 1;
          utf8_code_point += bite - 128 << 6 * (utf8_bytes_needed - utf8_bytes_seen);
          if (utf8_bytes_seen !== utf8_bytes_needed)
            return null;
          var code_point = utf8_code_point;
          utf8_code_point = utf8_bytes_needed = utf8_bytes_seen = 0;
          return code_point;
        };
      }
      function UTF8Encoder(options) {
        var fatal = options.fatal;
        this.handler = function(stream, code_point) {
          if (code_point === end_of_stream)
            return finished;
          if (inRange(code_point, 0, 127))
            return code_point;
          var count, offset2;
          if (inRange(code_point, 128, 2047)) {
            count = 1;
            offset2 = 192;
          } else if (inRange(code_point, 2048, 65535)) {
            count = 2;
            offset2 = 224;
          } else if (inRange(code_point, 65536, 1114111)) {
            count = 3;
            offset2 = 240;
          }
          var bytes = [(code_point >> 6 * count) + offset2];
          while (count > 0) {
            var temp = code_point >> 6 * (count - 1);
            bytes.push(128 | temp & 63);
            count -= 1;
          }
          return bytes;
        };
      }
      exports.TextEncoder = TextEncoder2;
      exports.TextDecoder = TextDecoder2;
    }
  });

  // node_modules/borsh/lib/index.js
  var require_lib = __commonJS({
    "node_modules/borsh/lib/index.js"(exports) {
      "use strict";
      var __createBinding = exports && exports.__createBinding || (Object.create ? (function(o, m, k, k2) {
        if (k2 === void 0) k2 = k;
        Object.defineProperty(o, k2, { enumerable: true, get: function() {
          return m[k];
        } });
      }) : (function(o, m, k, k2) {
        if (k2 === void 0) k2 = k;
        o[k2] = m[k];
      }));
      var __setModuleDefault = exports && exports.__setModuleDefault || (Object.create ? (function(o, v) {
        Object.defineProperty(o, "default", { enumerable: true, value: v });
      }) : function(o, v) {
        o["default"] = v;
      });
      var __decorate = exports && exports.__decorate || function(decorators, target, key, desc) {
        var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
        if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
        else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
        return c > 3 && r && Object.defineProperty(target, key, r), r;
      };
      var __importStar = exports && exports.__importStar || function(mod) {
        if (mod && mod.__esModule) return mod;
        var result = {};
        if (mod != null) {
          for (var k in mod) if (k !== "default" && Object.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
        }
        __setModuleDefault(result, mod);
        return result;
      };
      var __importDefault = exports && exports.__importDefault || function(mod) {
        return mod && mod.__esModule ? mod : { "default": mod };
      };
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.deserializeUnchecked = exports.deserialize = exports.serialize = exports.BinaryReader = exports.BinaryWriter = exports.BorshError = exports.baseDecode = exports.baseEncode = void 0;
      var bn_js_1 = __importDefault(require_bn());
      var bs58_1 = __importDefault(require_bs58());
      var encoding = __importStar(require_encoding_lib());
      var ResolvedTextDecoder = typeof TextDecoder !== "function" ? encoding.TextDecoder : TextDecoder;
      var textDecoder = new ResolvedTextDecoder("utf-8", { fatal: true });
      function baseEncode(value) {
        if (typeof value === "string") {
          value = Buffer.from(value, "utf8");
        }
        return bs58_1.default.encode(Buffer.from(value));
      }
      exports.baseEncode = baseEncode;
      function baseDecode(value) {
        return Buffer.from(bs58_1.default.decode(value));
      }
      exports.baseDecode = baseDecode;
      var INITIAL_LENGTH = 1024;
      var BorshError = class extends Error {
        constructor(message) {
          super(message);
          this.fieldPath = [];
          this.originalMessage = message;
        }
        addToFieldPath(fieldName) {
          this.fieldPath.splice(0, 0, fieldName);
          this.message = this.originalMessage + ": " + this.fieldPath.join(".");
        }
      };
      exports.BorshError = BorshError;
      var BinaryWriter = class {
        constructor() {
          this.buf = Buffer.alloc(INITIAL_LENGTH);
          this.length = 0;
        }
        maybeResize() {
          if (this.buf.length < 16 + this.length) {
            this.buf = Buffer.concat([this.buf, Buffer.alloc(INITIAL_LENGTH)]);
          }
        }
        writeU8(value) {
          this.maybeResize();
          this.buf.writeUInt8(value, this.length);
          this.length += 1;
        }
        writeU16(value) {
          this.maybeResize();
          this.buf.writeUInt16LE(value, this.length);
          this.length += 2;
        }
        writeU32(value) {
          this.maybeResize();
          this.buf.writeUInt32LE(value, this.length);
          this.length += 4;
        }
        writeU64(value) {
          this.maybeResize();
          this.writeBuffer(Buffer.from(new bn_js_1.default(value).toArray("le", 8)));
        }
        writeU128(value) {
          this.maybeResize();
          this.writeBuffer(Buffer.from(new bn_js_1.default(value).toArray("le", 16)));
        }
        writeU256(value) {
          this.maybeResize();
          this.writeBuffer(Buffer.from(new bn_js_1.default(value).toArray("le", 32)));
        }
        writeU512(value) {
          this.maybeResize();
          this.writeBuffer(Buffer.from(new bn_js_1.default(value).toArray("le", 64)));
        }
        writeBuffer(buffer) {
          this.buf = Buffer.concat([
            Buffer.from(this.buf.subarray(0, this.length)),
            buffer,
            Buffer.alloc(INITIAL_LENGTH)
          ]);
          this.length += buffer.length;
        }
        writeString(str2) {
          this.maybeResize();
          const b = Buffer.from(str2, "utf8");
          this.writeU32(b.length);
          this.writeBuffer(b);
        }
        writeFixedArray(array3) {
          this.writeBuffer(Buffer.from(array3));
        }
        writeArray(array3, fn) {
          this.maybeResize();
          this.writeU32(array3.length);
          for (const elem of array3) {
            this.maybeResize();
            fn(elem);
          }
        }
        toArray() {
          return this.buf.subarray(0, this.length);
        }
      };
      exports.BinaryWriter = BinaryWriter;
      function handlingRangeError(target, propertyKey, propertyDescriptor) {
        const originalMethod = propertyDescriptor.value;
        propertyDescriptor.value = function(...args) {
          try {
            return originalMethod.apply(this, args);
          } catch (e) {
            if (e instanceof RangeError) {
              const code = e.code;
              if (["ERR_BUFFER_OUT_OF_BOUNDS", "ERR_OUT_OF_RANGE"].indexOf(code) >= 0) {
                throw new BorshError("Reached the end of buffer when deserializing");
              }
            }
            throw e;
          }
        };
      }
      var BinaryReader = class {
        constructor(buf) {
          this.buf = buf;
          this.offset = 0;
        }
        readU8() {
          const value = this.buf.readUInt8(this.offset);
          this.offset += 1;
          return value;
        }
        readU16() {
          const value = this.buf.readUInt16LE(this.offset);
          this.offset += 2;
          return value;
        }
        readU32() {
          const value = this.buf.readUInt32LE(this.offset);
          this.offset += 4;
          return value;
        }
        readU64() {
          const buf = this.readBuffer(8);
          return new bn_js_1.default(buf, "le");
        }
        readU128() {
          const buf = this.readBuffer(16);
          return new bn_js_1.default(buf, "le");
        }
        readU256() {
          const buf = this.readBuffer(32);
          return new bn_js_1.default(buf, "le");
        }
        readU512() {
          const buf = this.readBuffer(64);
          return new bn_js_1.default(buf, "le");
        }
        readBuffer(len) {
          if (this.offset + len > this.buf.length) {
            throw new BorshError(`Expected buffer length ${len} isn't within bounds`);
          }
          const result = this.buf.slice(this.offset, this.offset + len);
          this.offset += len;
          return result;
        }
        readString() {
          const len = this.readU32();
          const buf = this.readBuffer(len);
          try {
            return textDecoder.decode(buf);
          } catch (e) {
            throw new BorshError(`Error decoding UTF-8 string: ${e}`);
          }
        }
        readFixedArray(len) {
          return new Uint8Array(this.readBuffer(len));
        }
        readArray(fn) {
          const len = this.readU32();
          const result = Array();
          for (let i = 0; i < len; ++i) {
            result.push(fn());
          }
          return result;
        }
      };
      __decorate([
        handlingRangeError
      ], BinaryReader.prototype, "readU8", null);
      __decorate([
        handlingRangeError
      ], BinaryReader.prototype, "readU16", null);
      __decorate([
        handlingRangeError
      ], BinaryReader.prototype, "readU32", null);
      __decorate([
        handlingRangeError
      ], BinaryReader.prototype, "readU64", null);
      __decorate([
        handlingRangeError
      ], BinaryReader.prototype, "readU128", null);
      __decorate([
        handlingRangeError
      ], BinaryReader.prototype, "readU256", null);
      __decorate([
        handlingRangeError
      ], BinaryReader.prototype, "readU512", null);
      __decorate([
        handlingRangeError
      ], BinaryReader.prototype, "readString", null);
      __decorate([
        handlingRangeError
      ], BinaryReader.prototype, "readFixedArray", null);
      __decorate([
        handlingRangeError
      ], BinaryReader.prototype, "readArray", null);
      exports.BinaryReader = BinaryReader;
      function capitalizeFirstLetter(string2) {
        return string2.charAt(0).toUpperCase() + string2.slice(1);
      }
      function serializeField(schema, fieldName, value, fieldType, writer) {
        try {
          if (typeof fieldType === "string") {
            writer[`write${capitalizeFirstLetter(fieldType)}`](value);
          } else if (fieldType instanceof Array) {
            if (typeof fieldType[0] === "number") {
              if (value.length !== fieldType[0]) {
                throw new BorshError(`Expecting byte array of length ${fieldType[0]}, but got ${value.length} bytes`);
              }
              writer.writeFixedArray(value);
            } else if (fieldType.length === 2 && typeof fieldType[1] === "number") {
              if (value.length !== fieldType[1]) {
                throw new BorshError(`Expecting byte array of length ${fieldType[1]}, but got ${value.length} bytes`);
              }
              for (let i = 0; i < fieldType[1]; i++) {
                serializeField(schema, null, value[i], fieldType[0], writer);
              }
            } else {
              writer.writeArray(value, (item) => {
                serializeField(schema, fieldName, item, fieldType[0], writer);
              });
            }
          } else if (fieldType.kind !== void 0) {
            switch (fieldType.kind) {
              case "option": {
                if (value === null || value === void 0) {
                  writer.writeU8(0);
                } else {
                  writer.writeU8(1);
                  serializeField(schema, fieldName, value, fieldType.type, writer);
                }
                break;
              }
              case "map": {
                writer.writeU32(value.size);
                value.forEach((val, key) => {
                  serializeField(schema, fieldName, key, fieldType.key, writer);
                  serializeField(schema, fieldName, val, fieldType.value, writer);
                });
                break;
              }
              default:
                throw new BorshError(`FieldType ${fieldType} unrecognized`);
            }
          } else {
            serializeStruct(schema, value, writer);
          }
        } catch (error) {
          if (error instanceof BorshError) {
            error.addToFieldPath(fieldName);
          }
          throw error;
        }
      }
      function serializeStruct(schema, obj, writer) {
        if (typeof obj.borshSerialize === "function") {
          obj.borshSerialize(writer);
          return;
        }
        const structSchema = schema.get(obj.constructor);
        if (!structSchema) {
          throw new BorshError(`Class ${obj.constructor.name} is missing in schema`);
        }
        if (structSchema.kind === "struct") {
          structSchema.fields.map(([fieldName, fieldType]) => {
            serializeField(schema, fieldName, obj[fieldName], fieldType, writer);
          });
        } else if (structSchema.kind === "enum") {
          const name = obj[structSchema.field];
          for (let idx = 0; idx < structSchema.values.length; ++idx) {
            const [fieldName, fieldType] = structSchema.values[idx];
            if (fieldName === name) {
              writer.writeU8(idx);
              serializeField(schema, fieldName, obj[fieldName], fieldType, writer);
              break;
            }
          }
        } else {
          throw new BorshError(`Unexpected schema kind: ${structSchema.kind} for ${obj.constructor.name}`);
        }
      }
      function serialize(schema, obj, Writer = BinaryWriter) {
        const writer = new Writer();
        serializeStruct(schema, obj, writer);
        return writer.toArray();
      }
      exports.serialize = serialize;
      function deserializeField(schema, fieldName, fieldType, reader) {
        try {
          if (typeof fieldType === "string") {
            return reader[`read${capitalizeFirstLetter(fieldType)}`]();
          }
          if (fieldType instanceof Array) {
            if (typeof fieldType[0] === "number") {
              return reader.readFixedArray(fieldType[0]);
            } else if (typeof fieldType[1] === "number") {
              const arr = [];
              for (let i = 0; i < fieldType[1]; i++) {
                arr.push(deserializeField(schema, null, fieldType[0], reader));
              }
              return arr;
            } else {
              return reader.readArray(() => deserializeField(schema, fieldName, fieldType[0], reader));
            }
          }
          if (fieldType.kind === "option") {
            const option2 = reader.readU8();
            if (option2) {
              return deserializeField(schema, fieldName, fieldType.type, reader);
            }
            return void 0;
          }
          if (fieldType.kind === "map") {
            let map = /* @__PURE__ */ new Map();
            const length = reader.readU32();
            for (let i = 0; i < length; i++) {
              const key = deserializeField(schema, fieldName, fieldType.key, reader);
              const val = deserializeField(schema, fieldName, fieldType.value, reader);
              map.set(key, val);
            }
            return map;
          }
          return deserializeStruct(schema, fieldType, reader);
        } catch (error) {
          if (error instanceof BorshError) {
            error.addToFieldPath(fieldName);
          }
          throw error;
        }
      }
      function deserializeStruct(schema, classType, reader) {
        if (typeof classType.borshDeserialize === "function") {
          return classType.borshDeserialize(reader);
        }
        const structSchema = schema.get(classType);
        if (!structSchema) {
          throw new BorshError(`Class ${classType.name} is missing in schema`);
        }
        if (structSchema.kind === "struct") {
          const result = {};
          for (const [fieldName, fieldType] of schema.get(classType).fields) {
            result[fieldName] = deserializeField(schema, fieldName, fieldType, reader);
          }
          return new classType(result);
        }
        if (structSchema.kind === "enum") {
          const idx = reader.readU8();
          if (idx >= structSchema.values.length) {
            throw new BorshError(`Enum index: ${idx} is out of range`);
          }
          const [fieldName, fieldType] = structSchema.values[idx];
          const fieldValue = deserializeField(schema, fieldName, fieldType, reader);
          return new classType({ [fieldName]: fieldValue });
        }
        throw new BorshError(`Unexpected schema kind: ${structSchema.kind} for ${classType.constructor.name}`);
      }
      function deserialize(schema, classType, buffer, Reader = BinaryReader) {
        const reader = new Reader(buffer);
        const result = deserializeStruct(schema, classType, reader);
        if (reader.offset < buffer.length) {
          throw new BorshError(`Unexpected ${buffer.length - reader.offset} bytes after deserialized data`);
        }
        return result;
      }
      exports.deserialize = deserialize;
      function deserializeUnchecked(schema, classType, buffer, Reader = BinaryReader) {
        const reader = new Reader(buffer);
        return deserializeStruct(schema, classType, reader);
      }
      exports.deserializeUnchecked = deserializeUnchecked;
    }
  });

  // node_modules/@solana/buffer-layout/lib/Layout.js
  var require_Layout = __commonJS({
    "node_modules/@solana/buffer-layout/lib/Layout.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.s16 = exports.s8 = exports.nu64be = exports.u48be = exports.u40be = exports.u32be = exports.u24be = exports.u16be = exports.nu64 = exports.u48 = exports.u40 = exports.u32 = exports.u24 = exports.u16 = exports.u8 = exports.offset = exports.greedy = exports.Constant = exports.UTF8 = exports.CString = exports.Blob = exports.Boolean = exports.BitField = exports.BitStructure = exports.VariantLayout = exports.Union = exports.UnionLayoutDiscriminator = exports.UnionDiscriminator = exports.Structure = exports.Sequence = exports.DoubleBE = exports.Double = exports.FloatBE = exports.Float = exports.NearInt64BE = exports.NearInt64 = exports.NearUInt64BE = exports.NearUInt64 = exports.IntBE = exports.Int = exports.UIntBE = exports.UInt = exports.OffsetLayout = exports.GreedyCount = exports.ExternalLayout = exports.bindConstructorLayout = exports.nameWithProperty = exports.Layout = exports.uint8ArrayToBuffer = exports.checkUint8Array = void 0;
      exports.constant = exports.utf8 = exports.cstr = exports.blob = exports.unionLayoutDiscriminator = exports.union = exports.seq = exports.bits = exports.struct = exports.f64be = exports.f64 = exports.f32be = exports.f32 = exports.ns64be = exports.s48be = exports.s40be = exports.s32be = exports.s24be = exports.s16be = exports.ns64 = exports.s48 = exports.s40 = exports.s32 = exports.s24 = void 0;
      var buffer_1 = require_buffer();
      function checkUint8Array(b) {
        if (!(b instanceof Uint8Array)) {
          throw new TypeError("b must be a Uint8Array");
        }
      }
      exports.checkUint8Array = checkUint8Array;
      function uint8ArrayToBuffer(b) {
        checkUint8Array(b);
        return buffer_1.Buffer.from(b.buffer, b.byteOffset, b.length);
      }
      exports.uint8ArrayToBuffer = uint8ArrayToBuffer;
      var Layout2 = class {
        constructor(span, property) {
          if (!Number.isInteger(span)) {
            throw new TypeError("span must be an integer");
          }
          this.span = span;
          this.property = property;
        }
        /** Function to create an Object into which decoded properties will
         * be written.
         *
         * Used only for layouts that {@link Layout#decode|decode} to Object
         * instances, which means:
         * * {@link Structure}
         * * {@link Union}
         * * {@link VariantLayout}
         * * {@link BitStructure}
         *
         * If left undefined the JavaScript representation of these layouts
         * will be Object instances.
         *
         * See {@link bindConstructorLayout}.
         */
        makeDestinationObject() {
          return {};
        }
        /**
         * Calculate the span of a specific instance of a layout.
         *
         * @param {Uint8Array} b - the buffer that contains an encoded instance.
         *
         * @param {Number} [offset] - the offset at which the encoded instance
         * starts.  If absent a zero offset is inferred.
         *
         * @return {Number} - the number of bytes covered by the layout
         * instance.  If this method is not overridden in a subclass the
         * definition-time constant {@link Layout#span|span} will be
         * returned.
         *
         * @throws {RangeError} - if the length of the value cannot be
         * determined.
         */
        getSpan(b, offset2) {
          if (0 > this.span) {
            throw new RangeError("indeterminate span");
          }
          return this.span;
        }
        /**
         * Replicate the layout using a new property.
         *
         * This function must be used to get a structurally-equivalent layout
         * with a different name since all {@link Layout} instances are
         * immutable.
         *
         * **NOTE** This is a shallow copy.  All fields except {@link
         * Layout#property|property} are strictly equal to the origin layout.
         *
         * @param {String} property - the value for {@link
         * Layout#property|property} in the replica.
         *
         * @returns {Layout} - the copy with {@link Layout#property|property}
         * set to `property`.
         */
        replicate(property) {
          const rv = Object.create(this.constructor.prototype);
          Object.assign(rv, this);
          rv.property = property;
          return rv;
        }
        /**
         * Create an object from layout properties and an array of values.
         *
         * **NOTE** This function returns `undefined` if invoked on a layout
         * that does not return its value as an Object.  Objects are
         * returned for things that are a {@link Structure}, which includes
         * {@link VariantLayout|variant layouts} if they are structures, and
         * excludes {@link Union}s.  If you want this feature for a union
         * you must use {@link Union.getVariant|getVariant} to select the
         * desired layout.
         *
         * @param {Array} values - an array of values that correspond to the
         * default order for properties.  As with {@link Layout#decode|decode}
         * layout elements that have no property name are skipped when
         * iterating over the array values.  Only the top-level properties are
         * assigned; arguments are not assigned to properties of contained
         * layouts.  Any unused values are ignored.
         *
         * @return {(Object|undefined)}
         */
        fromArray(values) {
          return void 0;
        }
      };
      exports.Layout = Layout2;
      function nameWithProperty2(name, lo) {
        if (lo.property) {
          return name + "[" + lo.property + "]";
        }
        return name;
      }
      exports.nameWithProperty = nameWithProperty2;
      function bindConstructorLayout(Class, layout) {
        if ("function" !== typeof Class) {
          throw new TypeError("Class must be constructor");
        }
        if (Object.prototype.hasOwnProperty.call(Class, "layout_")) {
          throw new Error("Class is already bound to a layout");
        }
        if (!(layout && layout instanceof Layout2)) {
          throw new TypeError("layout must be a Layout");
        }
        if (Object.prototype.hasOwnProperty.call(layout, "boundConstructor_")) {
          throw new Error("layout is already bound to a constructor");
        }
        Class.layout_ = layout;
        layout.boundConstructor_ = Class;
        layout.makeDestinationObject = (() => new Class());
        Object.defineProperty(Class.prototype, "encode", {
          value(b, offset2) {
            return layout.encode(this, b, offset2);
          },
          writable: true
        });
        Object.defineProperty(Class, "decode", {
          value(b, offset2) {
            return layout.decode(b, offset2);
          },
          writable: true
        });
      }
      exports.bindConstructorLayout = bindConstructorLayout;
      var ExternalLayout2 = class extends Layout2 {
        /**
         * Return `true` iff the external layout decodes to an unsigned
         * integer layout.
         *
         * In that case it can be used as the source of {@link
         * Sequence#count|Sequence counts}, {@link Blob#length|Blob lengths},
         * or as {@link UnionLayoutDiscriminator#layout|external union
         * discriminators}.
         *
         * @abstract
         */
        isCount() {
          throw new Error("ExternalLayout is abstract");
        }
      };
      exports.ExternalLayout = ExternalLayout2;
      var GreedyCount = class extends ExternalLayout2 {
        constructor(elementSpan = 1, property) {
          if (!Number.isInteger(elementSpan) || 0 >= elementSpan) {
            throw new TypeError("elementSpan must be a (positive) integer");
          }
          super(-1, property);
          this.elementSpan = elementSpan;
        }
        /** @override */
        isCount() {
          return true;
        }
        /** @override */
        decode(b, offset2 = 0) {
          checkUint8Array(b);
          const rem = b.length - offset2;
          return Math.floor(rem / this.elementSpan);
        }
        /** @override */
        encode(src, b, offset2) {
          return 0;
        }
      };
      exports.GreedyCount = GreedyCount;
      var OffsetLayout2 = class extends ExternalLayout2 {
        constructor(layout, offset2 = 0, property) {
          if (!(layout instanceof Layout2)) {
            throw new TypeError("layout must be a Layout");
          }
          if (!Number.isInteger(offset2)) {
            throw new TypeError("offset must be integer or undefined");
          }
          super(layout.span, property || layout.property);
          this.layout = layout;
          this.offset = offset2;
        }
        /** @override */
        isCount() {
          return this.layout instanceof UInt2 || this.layout instanceof UIntBE2;
        }
        /** @override */
        decode(b, offset2 = 0) {
          return this.layout.decode(b, offset2 + this.offset);
        }
        /** @override */
        encode(src, b, offset2 = 0) {
          return this.layout.encode(src, b, offset2 + this.offset);
        }
      };
      exports.OffsetLayout = OffsetLayout2;
      var UInt2 = class extends Layout2 {
        constructor(span, property) {
          super(span, property);
          if (6 < this.span) {
            throw new RangeError("span must not exceed 6 bytes");
          }
        }
        /** @override */
        decode(b, offset2 = 0) {
          return uint8ArrayToBuffer(b).readUIntLE(offset2, this.span);
        }
        /** @override */
        encode(src, b, offset2 = 0) {
          uint8ArrayToBuffer(b).writeUIntLE(src, offset2, this.span);
          return this.span;
        }
      };
      exports.UInt = UInt2;
      var UIntBE2 = class extends Layout2 {
        constructor(span, property) {
          super(span, property);
          if (6 < this.span) {
            throw new RangeError("span must not exceed 6 bytes");
          }
        }
        /** @override */
        decode(b, offset2 = 0) {
          return uint8ArrayToBuffer(b).readUIntBE(offset2, this.span);
        }
        /** @override */
        encode(src, b, offset2 = 0) {
          uint8ArrayToBuffer(b).writeUIntBE(src, offset2, this.span);
          return this.span;
        }
      };
      exports.UIntBE = UIntBE2;
      var Int = class extends Layout2 {
        constructor(span, property) {
          super(span, property);
          if (6 < this.span) {
            throw new RangeError("span must not exceed 6 bytes");
          }
        }
        /** @override */
        decode(b, offset2 = 0) {
          return uint8ArrayToBuffer(b).readIntLE(offset2, this.span);
        }
        /** @override */
        encode(src, b, offset2 = 0) {
          uint8ArrayToBuffer(b).writeIntLE(src, offset2, this.span);
          return this.span;
        }
      };
      exports.Int = Int;
      var IntBE = class extends Layout2 {
        constructor(span, property) {
          super(span, property);
          if (6 < this.span) {
            throw new RangeError("span must not exceed 6 bytes");
          }
        }
        /** @override */
        decode(b, offset2 = 0) {
          return uint8ArrayToBuffer(b).readIntBE(offset2, this.span);
        }
        /** @override */
        encode(src, b, offset2 = 0) {
          uint8ArrayToBuffer(b).writeIntBE(src, offset2, this.span);
          return this.span;
        }
      };
      exports.IntBE = IntBE;
      var V2E322 = Math.pow(2, 32);
      function divmodInt642(src) {
        const hi32 = Math.floor(src / V2E322);
        const lo32 = src - hi32 * V2E322;
        return { hi32, lo32 };
      }
      function roundedInt642(hi32, lo32) {
        return hi32 * V2E322 + lo32;
      }
      var NearUInt642 = class extends Layout2 {
        constructor(property) {
          super(8, property);
        }
        /** @override */
        decode(b, offset2 = 0) {
          const buffer = uint8ArrayToBuffer(b);
          const lo32 = buffer.readUInt32LE(offset2);
          const hi32 = buffer.readUInt32LE(offset2 + 4);
          return roundedInt642(hi32, lo32);
        }
        /** @override */
        encode(src, b, offset2 = 0) {
          const split = divmodInt642(src);
          const buffer = uint8ArrayToBuffer(b);
          buffer.writeUInt32LE(split.lo32, offset2);
          buffer.writeUInt32LE(split.hi32, offset2 + 4);
          return 8;
        }
      };
      exports.NearUInt64 = NearUInt642;
      var NearUInt64BE = class extends Layout2 {
        constructor(property) {
          super(8, property);
        }
        /** @override */
        decode(b, offset2 = 0) {
          const buffer = uint8ArrayToBuffer(b);
          const hi32 = buffer.readUInt32BE(offset2);
          const lo32 = buffer.readUInt32BE(offset2 + 4);
          return roundedInt642(hi32, lo32);
        }
        /** @override */
        encode(src, b, offset2 = 0) {
          const split = divmodInt642(src);
          const buffer = uint8ArrayToBuffer(b);
          buffer.writeUInt32BE(split.hi32, offset2);
          buffer.writeUInt32BE(split.lo32, offset2 + 4);
          return 8;
        }
      };
      exports.NearUInt64BE = NearUInt64BE;
      var NearInt642 = class extends Layout2 {
        constructor(property) {
          super(8, property);
        }
        /** @override */
        decode(b, offset2 = 0) {
          const buffer = uint8ArrayToBuffer(b);
          const lo32 = buffer.readUInt32LE(offset2);
          const hi32 = buffer.readInt32LE(offset2 + 4);
          return roundedInt642(hi32, lo32);
        }
        /** @override */
        encode(src, b, offset2 = 0) {
          const split = divmodInt642(src);
          const buffer = uint8ArrayToBuffer(b);
          buffer.writeUInt32LE(split.lo32, offset2);
          buffer.writeInt32LE(split.hi32, offset2 + 4);
          return 8;
        }
      };
      exports.NearInt64 = NearInt642;
      var NearInt64BE = class extends Layout2 {
        constructor(property) {
          super(8, property);
        }
        /** @override */
        decode(b, offset2 = 0) {
          const buffer = uint8ArrayToBuffer(b);
          const hi32 = buffer.readInt32BE(offset2);
          const lo32 = buffer.readUInt32BE(offset2 + 4);
          return roundedInt642(hi32, lo32);
        }
        /** @override */
        encode(src, b, offset2 = 0) {
          const split = divmodInt642(src);
          const buffer = uint8ArrayToBuffer(b);
          buffer.writeInt32BE(split.hi32, offset2);
          buffer.writeUInt32BE(split.lo32, offset2 + 4);
          return 8;
        }
      };
      exports.NearInt64BE = NearInt64BE;
      var Float = class extends Layout2 {
        constructor(property) {
          super(4, property);
        }
        /** @override */
        decode(b, offset2 = 0) {
          return uint8ArrayToBuffer(b).readFloatLE(offset2);
        }
        /** @override */
        encode(src, b, offset2 = 0) {
          uint8ArrayToBuffer(b).writeFloatLE(src, offset2);
          return 4;
        }
      };
      exports.Float = Float;
      var FloatBE = class extends Layout2 {
        constructor(property) {
          super(4, property);
        }
        /** @override */
        decode(b, offset2 = 0) {
          return uint8ArrayToBuffer(b).readFloatBE(offset2);
        }
        /** @override */
        encode(src, b, offset2 = 0) {
          uint8ArrayToBuffer(b).writeFloatBE(src, offset2);
          return 4;
        }
      };
      exports.FloatBE = FloatBE;
      var Double = class extends Layout2 {
        constructor(property) {
          super(8, property);
        }
        /** @override */
        decode(b, offset2 = 0) {
          return uint8ArrayToBuffer(b).readDoubleLE(offset2);
        }
        /** @override */
        encode(src, b, offset2 = 0) {
          uint8ArrayToBuffer(b).writeDoubleLE(src, offset2);
          return 8;
        }
      };
      exports.Double = Double;
      var DoubleBE = class extends Layout2 {
        constructor(property) {
          super(8, property);
        }
        /** @override */
        decode(b, offset2 = 0) {
          return uint8ArrayToBuffer(b).readDoubleBE(offset2);
        }
        /** @override */
        encode(src, b, offset2 = 0) {
          uint8ArrayToBuffer(b).writeDoubleBE(src, offset2);
          return 8;
        }
      };
      exports.DoubleBE = DoubleBE;
      var Sequence = class extends Layout2 {
        constructor(elementLayout, count, property) {
          if (!(elementLayout instanceof Layout2)) {
            throw new TypeError("elementLayout must be a Layout");
          }
          if (!(count instanceof ExternalLayout2 && count.isCount() || Number.isInteger(count) && 0 <= count)) {
            throw new TypeError("count must be non-negative integer or an unsigned integer ExternalLayout");
          }
          let span = -1;
          if (!(count instanceof ExternalLayout2) && 0 < elementLayout.span) {
            span = count * elementLayout.span;
          }
          super(span, property);
          this.elementLayout = elementLayout;
          this.count = count;
        }
        /** @override */
        getSpan(b, offset2 = 0) {
          if (0 <= this.span) {
            return this.span;
          }
          let span = 0;
          let count = this.count;
          if (count instanceof ExternalLayout2) {
            count = count.decode(b, offset2);
          }
          if (0 < this.elementLayout.span) {
            span = count * this.elementLayout.span;
          } else {
            let idx = 0;
            while (idx < count) {
              span += this.elementLayout.getSpan(b, offset2 + span);
              ++idx;
            }
          }
          return span;
        }
        /** @override */
        decode(b, offset2 = 0) {
          const rv = [];
          let i = 0;
          let count = this.count;
          if (count instanceof ExternalLayout2) {
            count = count.decode(b, offset2);
          }
          while (i < count) {
            rv.push(this.elementLayout.decode(b, offset2));
            offset2 += this.elementLayout.getSpan(b, offset2);
            i += 1;
          }
          return rv;
        }
        /** Implement {@link Layout#encode|encode} for {@link Sequence}.
         *
         * **NOTE** If `src` is shorter than {@link Sequence#count|count} then
         * the unused space in the buffer is left unchanged.  If `src` is
         * longer than {@link Sequence#count|count} the unneeded elements are
         * ignored.
         *
         * **NOTE** If {@link Layout#count|count} is an instance of {@link
         * ExternalLayout} then the length of `src` will be encoded as the
         * count after `src` is encoded. */
        encode(src, b, offset2 = 0) {
          const elo = this.elementLayout;
          const span = src.reduce((span2, v) => {
            return span2 + elo.encode(v, b, offset2 + span2);
          }, 0);
          if (this.count instanceof ExternalLayout2) {
            this.count.encode(src.length, b, offset2);
          }
          return span;
        }
      };
      exports.Sequence = Sequence;
      var Structure2 = class extends Layout2 {
        constructor(fields, property, decodePrefixes) {
          if (!(Array.isArray(fields) && fields.reduce((acc, v) => acc && v instanceof Layout2, true))) {
            throw new TypeError("fields must be array of Layout instances");
          }
          if ("boolean" === typeof property && void 0 === decodePrefixes) {
            decodePrefixes = property;
            property = void 0;
          }
          for (const fd of fields) {
            if (0 > fd.span && void 0 === fd.property) {
              throw new Error("fields cannot contain unnamed variable-length layout");
            }
          }
          let span = -1;
          try {
            span = fields.reduce((span2, fd) => span2 + fd.getSpan(), 0);
          } catch (e) {
          }
          super(span, property);
          this.fields = fields;
          this.decodePrefixes = !!decodePrefixes;
        }
        /** @override */
        getSpan(b, offset2 = 0) {
          if (0 <= this.span) {
            return this.span;
          }
          let span = 0;
          try {
            span = this.fields.reduce((span2, fd) => {
              const fsp = fd.getSpan(b, offset2);
              offset2 += fsp;
              return span2 + fsp;
            }, 0);
          } catch (e) {
            throw new RangeError("indeterminate span");
          }
          return span;
        }
        /** @override */
        decode(b, offset2 = 0) {
          checkUint8Array(b);
          const dest = this.makeDestinationObject();
          for (const fd of this.fields) {
            if (void 0 !== fd.property) {
              dest[fd.property] = fd.decode(b, offset2);
            }
            offset2 += fd.getSpan(b, offset2);
            if (this.decodePrefixes && b.length === offset2) {
              break;
            }
          }
          return dest;
        }
        /** Implement {@link Layout#encode|encode} for {@link Structure}.
         *
         * If `src` is missing a property for a member with a defined {@link
         * Layout#property|property} the corresponding region of the buffer is
         * left unmodified. */
        encode(src, b, offset2 = 0) {
          const firstOffset = offset2;
          let lastOffset = 0;
          let lastWrote = 0;
          for (const fd of this.fields) {
            let span = fd.span;
            lastWrote = 0 < span ? span : 0;
            if (void 0 !== fd.property) {
              const fv = src[fd.property];
              if (void 0 !== fv) {
                lastWrote = fd.encode(fv, b, offset2);
                if (0 > span) {
                  span = fd.getSpan(b, offset2);
                }
              }
            }
            lastOffset = offset2;
            offset2 += span;
          }
          return lastOffset + lastWrote - firstOffset;
        }
        /** @override */
        fromArray(values) {
          const dest = this.makeDestinationObject();
          for (const fd of this.fields) {
            if (void 0 !== fd.property && 0 < values.length) {
              dest[fd.property] = values.shift();
            }
          }
          return dest;
        }
        /**
         * Get access to the layout of a given property.
         *
         * @param {String} property - the structure member of interest.
         *
         * @return {Layout} - the layout associated with `property`, or
         * undefined if there is no such property.
         */
        layoutFor(property) {
          if ("string" !== typeof property) {
            throw new TypeError("property must be string");
          }
          for (const fd of this.fields) {
            if (fd.property === property) {
              return fd;
            }
          }
          return void 0;
        }
        /**
         * Get the offset of a structure member.
         *
         * @param {String} property - the structure member of interest.
         *
         * @return {Number} - the offset in bytes to the start of `property`
         * within the structure, or undefined if `property` is not a field
         * within the structure.  If the property is a member but follows a
         * variable-length structure member a negative number will be
         * returned.
         */
        offsetOf(property) {
          if ("string" !== typeof property) {
            throw new TypeError("property must be string");
          }
          let offset2 = 0;
          for (const fd of this.fields) {
            if (fd.property === property) {
              return offset2;
            }
            if (0 > fd.span) {
              offset2 = -1;
            } else if (0 <= offset2) {
              offset2 += fd.span;
            }
          }
          return void 0;
        }
      };
      exports.Structure = Structure2;
      var UnionDiscriminator2 = class {
        constructor(property) {
          this.property = property;
        }
        /** Analog to {@link Layout#decode|Layout decode} for union discriminators.
         *
         * The implementation of this method need not reference the buffer if
         * variant information is available through other means. */
        decode(b, offset2) {
          throw new Error("UnionDiscriminator is abstract");
        }
        /** Analog to {@link Layout#decode|Layout encode} for union discriminators.
         *
         * The implementation of this method need not store the value if
         * variant information is maintained through other means. */
        encode(src, b, offset2) {
          throw new Error("UnionDiscriminator is abstract");
        }
      };
      exports.UnionDiscriminator = UnionDiscriminator2;
      var UnionLayoutDiscriminator2 = class extends UnionDiscriminator2 {
        constructor(layout, property) {
          if (!(layout instanceof ExternalLayout2 && layout.isCount())) {
            throw new TypeError("layout must be an unsigned integer ExternalLayout");
          }
          super(property || layout.property || "variant");
          this.layout = layout;
        }
        /** Delegate decoding to {@link UnionLayoutDiscriminator#layout|layout}. */
        decode(b, offset2) {
          return this.layout.decode(b, offset2);
        }
        /** Delegate encoding to {@link UnionLayoutDiscriminator#layout|layout}. */
        encode(src, b, offset2) {
          return this.layout.encode(src, b, offset2);
        }
      };
      exports.UnionLayoutDiscriminator = UnionLayoutDiscriminator2;
      var Union2 = class extends Layout2 {
        constructor(discr, defaultLayout, property) {
          let discriminator2;
          if (discr instanceof UInt2 || discr instanceof UIntBE2) {
            discriminator2 = new UnionLayoutDiscriminator2(new OffsetLayout2(discr));
          } else if (discr instanceof ExternalLayout2 && discr.isCount()) {
            discriminator2 = new UnionLayoutDiscriminator2(discr);
          } else if (!(discr instanceof UnionDiscriminator2)) {
            throw new TypeError("discr must be a UnionDiscriminator or an unsigned integer layout");
          } else {
            discriminator2 = discr;
          }
          if (void 0 === defaultLayout) {
            defaultLayout = null;
          }
          if (!(null === defaultLayout || defaultLayout instanceof Layout2)) {
            throw new TypeError("defaultLayout must be null or a Layout");
          }
          if (null !== defaultLayout) {
            if (0 > defaultLayout.span) {
              throw new Error("defaultLayout must have constant span");
            }
            if (void 0 === defaultLayout.property) {
              defaultLayout = defaultLayout.replicate("content");
            }
          }
          let span = -1;
          if (defaultLayout) {
            span = defaultLayout.span;
            if (0 <= span && (discr instanceof UInt2 || discr instanceof UIntBE2)) {
              span += discriminator2.layout.span;
            }
          }
          super(span, property);
          this.discriminator = discriminator2;
          this.usesPrefixDiscriminator = discr instanceof UInt2 || discr instanceof UIntBE2;
          this.defaultLayout = defaultLayout;
          this.registry = {};
          let boundGetSourceVariant = this.defaultGetSourceVariant.bind(this);
          this.getSourceVariant = function(src) {
            return boundGetSourceVariant(src);
          };
          this.configGetSourceVariant = function(gsv) {
            boundGetSourceVariant = gsv.bind(this);
          };
        }
        /** @override */
        getSpan(b, offset2 = 0) {
          if (0 <= this.span) {
            return this.span;
          }
          const vlo = this.getVariant(b, offset2);
          if (!vlo) {
            throw new Error("unable to determine span for unrecognized variant");
          }
          return vlo.getSpan(b, offset2);
        }
        /**
         * Method to infer a registered Union variant compatible with `src`.
         *
         * The first satisfied rule in the following sequence defines the
         * return value:
         * * If `src` has properties matching the Union discriminator and
         *   the default layout, `undefined` is returned regardless of the
         *   value of the discriminator property (this ensures the default
         *   layout will be used);
         * * If `src` has a property matching the Union discriminator, the
         *   value of the discriminator identifies a registered variant, and
         *   either (a) the variant has no layout, or (b) `src` has the
         *   variant's property, then the variant is returned (because the
         *   source satisfies the constraints of the variant it identifies);
         * * If `src` does not have a property matching the Union
         *   discriminator, but does have a property matching a registered
         *   variant, then the variant is returned (because the source
         *   matches a variant without an explicit conflict);
         * * An error is thrown (because we either can't identify a variant,
         *   or we were explicitly told the variant but can't satisfy it).
         *
         * @param {Object} src - an object presumed to be compatible with
         * the content of the Union.
         *
         * @return {(undefined|VariantLayout)} - as described above.
         *
         * @throws {Error} - if `src` cannot be associated with a default or
         * registered variant.
         */
        defaultGetSourceVariant(src) {
          if (Object.prototype.hasOwnProperty.call(src, this.discriminator.property)) {
            if (this.defaultLayout && this.defaultLayout.property && Object.prototype.hasOwnProperty.call(src, this.defaultLayout.property)) {
              return void 0;
            }
            const vlo = this.registry[src[this.discriminator.property]];
            if (vlo && (!vlo.layout || vlo.property && Object.prototype.hasOwnProperty.call(src, vlo.property))) {
              return vlo;
            }
          } else {
            for (const tag in this.registry) {
              const vlo = this.registry[tag];
              if (vlo.property && Object.prototype.hasOwnProperty.call(src, vlo.property)) {
                return vlo;
              }
            }
          }
          throw new Error("unable to infer src variant");
        }
        /** Implement {@link Layout#decode|decode} for {@link Union}.
         *
         * If the variant is {@link Union#addVariant|registered} the return
         * value is an instance of that variant, with no explicit
         * discriminator.  Otherwise the {@link Union#defaultLayout|default
         * layout} is used to decode the content. */
        decode(b, offset2 = 0) {
          let dest;
          const dlo = this.discriminator;
          const discr = dlo.decode(b, offset2);
          const clo = this.registry[discr];
          if (void 0 === clo) {
            const defaultLayout = this.defaultLayout;
            let contentOffset = 0;
            if (this.usesPrefixDiscriminator) {
              contentOffset = dlo.layout.span;
            }
            dest = this.makeDestinationObject();
            dest[dlo.property] = discr;
            dest[defaultLayout.property] = defaultLayout.decode(b, offset2 + contentOffset);
          } else {
            dest = clo.decode(b, offset2);
          }
          return dest;
        }
        /** Implement {@link Layout#encode|encode} for {@link Union}.
         *
         * This API assumes the `src` object is consistent with the union's
         * {@link Union#defaultLayout|default layout}.  To encode variants
         * use the appropriate variant-specific {@link VariantLayout#encode}
         * method. */
        encode(src, b, offset2 = 0) {
          const vlo = this.getSourceVariant(src);
          if (void 0 === vlo) {
            const dlo = this.discriminator;
            const clo = this.defaultLayout;
            let contentOffset = 0;
            if (this.usesPrefixDiscriminator) {
              contentOffset = dlo.layout.span;
            }
            dlo.encode(src[dlo.property], b, offset2);
            return contentOffset + clo.encode(src[clo.property], b, offset2 + contentOffset);
          }
          return vlo.encode(src, b, offset2);
        }
        /** Register a new variant structure within a union.  The newly
         * created variant is returned.
         *
         * @param {Number} variant - initializer for {@link
         * VariantLayout#variant|variant}.
         *
         * @param {Layout} layout - initializer for {@link
         * VariantLayout#layout|layout}.
         *
         * @param {String} property - initializer for {@link
         * Layout#property|property}.
         *
         * @return {VariantLayout} */
        addVariant(variant, layout, property) {
          const rv = new VariantLayout2(this, variant, layout, property);
          this.registry[variant] = rv;
          return rv;
        }
        /**
         * Get the layout associated with a registered variant.
         *
         * If `vb` does not produce a registered variant the function returns
         * `undefined`.
         *
         * @param {(Number|Uint8Array)} vb - either the variant number, or a
         * buffer from which the discriminator is to be read.
         *
         * @param {Number} offset - offset into `vb` for the start of the
         * union.  Used only when `vb` is an instance of {Uint8Array}.
         *
         * @return {({VariantLayout}|undefined)}
         */
        getVariant(vb, offset2 = 0) {
          let variant;
          if (vb instanceof Uint8Array) {
            variant = this.discriminator.decode(vb, offset2);
          } else {
            variant = vb;
          }
          return this.registry[variant];
        }
      };
      exports.Union = Union2;
      var VariantLayout2 = class extends Layout2 {
        constructor(union2, variant, layout, property) {
          if (!(union2 instanceof Union2)) {
            throw new TypeError("union must be a Union");
          }
          if (!Number.isInteger(variant) || 0 > variant) {
            throw new TypeError("variant must be a (non-negative) integer");
          }
          if ("string" === typeof layout && void 0 === property) {
            property = layout;
            layout = null;
          }
          if (layout) {
            if (!(layout instanceof Layout2)) {
              throw new TypeError("layout must be a Layout");
            }
            if (null !== union2.defaultLayout && 0 <= layout.span && layout.span > union2.defaultLayout.span) {
              throw new Error("variant span exceeds span of containing union");
            }
            if ("string" !== typeof property) {
              throw new TypeError("variant must have a String property");
            }
          }
          let span = union2.span;
          if (0 > union2.span) {
            span = layout ? layout.span : 0;
            if (0 <= span && union2.usesPrefixDiscriminator) {
              span += union2.discriminator.layout.span;
            }
          }
          super(span, property);
          this.union = union2;
          this.variant = variant;
          this.layout = layout || null;
        }
        /** @override */
        getSpan(b, offset2 = 0) {
          if (0 <= this.span) {
            return this.span;
          }
          let contentOffset = 0;
          if (this.union.usesPrefixDiscriminator) {
            contentOffset = this.union.discriminator.layout.span;
          }
          let span = 0;
          if (this.layout) {
            span = this.layout.getSpan(b, offset2 + contentOffset);
          }
          return contentOffset + span;
        }
        /** @override */
        decode(b, offset2 = 0) {
          const dest = this.makeDestinationObject();
          if (this !== this.union.getVariant(b, offset2)) {
            throw new Error("variant mismatch");
          }
          let contentOffset = 0;
          if (this.union.usesPrefixDiscriminator) {
            contentOffset = this.union.discriminator.layout.span;
          }
          if (this.layout) {
            dest[this.property] = this.layout.decode(b, offset2 + contentOffset);
          } else if (this.property) {
            dest[this.property] = true;
          } else if (this.union.usesPrefixDiscriminator) {
            dest[this.union.discriminator.property] = this.variant;
          }
          return dest;
        }
        /** @override */
        encode(src, b, offset2 = 0) {
          let contentOffset = 0;
          if (this.union.usesPrefixDiscriminator) {
            contentOffset = this.union.discriminator.layout.span;
          }
          if (this.layout && !Object.prototype.hasOwnProperty.call(src, this.property)) {
            throw new TypeError("variant lacks property " + this.property);
          }
          this.union.discriminator.encode(this.variant, b, offset2);
          let span = contentOffset;
          if (this.layout) {
            this.layout.encode(src[this.property], b, offset2 + contentOffset);
            span += this.layout.getSpan(b, offset2 + contentOffset);
            if (0 <= this.union.span && span > this.union.span) {
              throw new Error("encoded variant overruns containing union");
            }
          }
          return span;
        }
        /** Delegate {@link Layout#fromArray|fromArray} to {@link
         * VariantLayout#layout|layout}. */
        fromArray(values) {
          if (this.layout) {
            return this.layout.fromArray(values);
          }
          return void 0;
        }
      };
      exports.VariantLayout = VariantLayout2;
      function fixBitwiseResult(v) {
        if (0 > v) {
          v += 4294967296;
        }
        return v;
      }
      var BitStructure = class extends Layout2 {
        constructor(word, msb, property) {
          if (!(word instanceof UInt2 || word instanceof UIntBE2)) {
            throw new TypeError("word must be a UInt or UIntBE layout");
          }
          if ("string" === typeof msb && void 0 === property) {
            property = msb;
            msb = false;
          }
          if (4 < word.span) {
            throw new RangeError("word cannot exceed 32 bits");
          }
          super(word.span, property);
          this.word = word;
          this.msb = !!msb;
          this.fields = [];
          let value = 0;
          this._packedSetValue = function(v) {
            value = fixBitwiseResult(v);
            return this;
          };
          this._packedGetValue = function() {
            return value;
          };
        }
        /** @override */
        decode(b, offset2 = 0) {
          const dest = this.makeDestinationObject();
          const value = this.word.decode(b, offset2);
          this._packedSetValue(value);
          for (const fd of this.fields) {
            if (void 0 !== fd.property) {
              dest[fd.property] = fd.decode(b);
            }
          }
          return dest;
        }
        /** Implement {@link Layout#encode|encode} for {@link BitStructure}.
         *
         * If `src` is missing a property for a member with a defined {@link
         * Layout#property|property} the corresponding region of the packed
         * value is left unmodified.  Unused bits are also left unmodified. */
        encode(src, b, offset2 = 0) {
          const value = this.word.decode(b, offset2);
          this._packedSetValue(value);
          for (const fd of this.fields) {
            if (void 0 !== fd.property) {
              const fv = src[fd.property];
              if (void 0 !== fv) {
                fd.encode(fv);
              }
            }
          }
          return this.word.encode(this._packedGetValue(), b, offset2);
        }
        /** Register a new bitfield with a containing bit structure.  The
         * resulting bitfield is returned.
         *
         * @param {Number} bits - initializer for {@link BitField#bits|bits}.
         *
         * @param {string} property - initializer for {@link
         * Layout#property|property}.
         *
         * @return {BitField} */
        addField(bits, property) {
          const bf = new BitField(this, bits, property);
          this.fields.push(bf);
          return bf;
        }
        /** As with {@link BitStructure#addField|addField} for single-bit
         * fields with `boolean` value representation.
         *
         * @param {string} property - initializer for {@link
         * Layout#property|property}.
         *
         * @return {Boolean} */
        // `Boolean` conflicts with the native primitive type
        // eslint-disable-next-line @typescript-eslint/ban-types
        addBoolean(property) {
          const bf = new Boolean2(this, property);
          this.fields.push(bf);
          return bf;
        }
        /**
         * Get access to the bit field for a given property.
         *
         * @param {String} property - the bit field of interest.
         *
         * @return {BitField} - the field associated with `property`, or
         * undefined if there is no such property.
         */
        fieldFor(property) {
          if ("string" !== typeof property) {
            throw new TypeError("property must be string");
          }
          for (const fd of this.fields) {
            if (fd.property === property) {
              return fd;
            }
          }
          return void 0;
        }
      };
      exports.BitStructure = BitStructure;
      var BitField = class {
        constructor(container, bits, property) {
          if (!(container instanceof BitStructure)) {
            throw new TypeError("container must be a BitStructure");
          }
          if (!Number.isInteger(bits) || 0 >= bits) {
            throw new TypeError("bits must be positive integer");
          }
          const totalBits = 8 * container.span;
          const usedBits = container.fields.reduce((sum, fd) => sum + fd.bits, 0);
          if (bits + usedBits > totalBits) {
            throw new Error("bits too long for span remainder (" + (totalBits - usedBits) + " of " + totalBits + " remain)");
          }
          this.container = container;
          this.bits = bits;
          this.valueMask = (1 << bits) - 1;
          if (32 === bits) {
            this.valueMask = 4294967295;
          }
          this.start = usedBits;
          if (this.container.msb) {
            this.start = totalBits - usedBits - bits;
          }
          this.wordMask = fixBitwiseResult(this.valueMask << this.start);
          this.property = property;
        }
        /** Store a value into the corresponding subsequence of the containing
         * bit field. */
        decode(b, offset2) {
          const word = this.container._packedGetValue();
          const wordValue = fixBitwiseResult(word & this.wordMask);
          const value = wordValue >>> this.start;
          return value;
        }
        /** Store a value into the corresponding subsequence of the containing
         * bit field.
         *
         * **NOTE** This is not a specialization of {@link
         * Layout#encode|Layout.encode} and there is no return value. */
        encode(value) {
          if ("number" !== typeof value || !Number.isInteger(value) || value !== fixBitwiseResult(value & this.valueMask)) {
            throw new TypeError(nameWithProperty2("BitField.encode", this) + " value must be integer not exceeding " + this.valueMask);
          }
          const word = this.container._packedGetValue();
          const wordValue = fixBitwiseResult(value << this.start);
          this.container._packedSetValue(fixBitwiseResult(word & ~this.wordMask) | wordValue);
        }
      };
      exports.BitField = BitField;
      var Boolean2 = class extends BitField {
        constructor(container, property) {
          super(container, 1, property);
        }
        /** Override {@link BitField#decode|decode} for {@link Boolean|Boolean}.
         *
         * @returns {boolean} */
        decode(b, offset2) {
          return !!super.decode(b, offset2);
        }
        /** @override */
        encode(value) {
          if ("boolean" === typeof value) {
            value = +value;
          }
          super.encode(value);
        }
      };
      exports.Boolean = Boolean2;
      var Blob2 = class extends Layout2 {
        constructor(length, property) {
          if (!(length instanceof ExternalLayout2 && length.isCount() || Number.isInteger(length) && 0 <= length)) {
            throw new TypeError("length must be positive integer or an unsigned integer ExternalLayout");
          }
          let span = -1;
          if (!(length instanceof ExternalLayout2)) {
            span = length;
          }
          super(span, property);
          this.length = length;
        }
        /** @override */
        getSpan(b, offset2) {
          let span = this.span;
          if (0 > span) {
            span = this.length.decode(b, offset2);
          }
          return span;
        }
        /** @override */
        decode(b, offset2 = 0) {
          let span = this.span;
          if (0 > span) {
            span = this.length.decode(b, offset2);
          }
          return uint8ArrayToBuffer(b).slice(offset2, offset2 + span);
        }
        /** Implement {@link Layout#encode|encode} for {@link Blob}.
         *
         * **NOTE** If {@link Layout#count|count} is an instance of {@link
         * ExternalLayout} then the length of `src` will be encoded as the
         * count after `src` is encoded. */
        encode(src, b, offset2) {
          let span = this.length;
          if (this.length instanceof ExternalLayout2) {
            span = src.length;
          }
          if (!(src instanceof Uint8Array && span === src.length)) {
            throw new TypeError(nameWithProperty2("Blob.encode", this) + " requires (length " + span + ") Uint8Array as src");
          }
          if (offset2 + span > b.length) {
            throw new RangeError("encoding overruns Uint8Array");
          }
          const srcBuffer = uint8ArrayToBuffer(src);
          uint8ArrayToBuffer(b).write(srcBuffer.toString("hex"), offset2, span, "hex");
          if (this.length instanceof ExternalLayout2) {
            this.length.encode(span, b, offset2);
          }
          return span;
        }
      };
      exports.Blob = Blob2;
      var CString = class extends Layout2 {
        constructor(property) {
          super(-1, property);
        }
        /** @override */
        getSpan(b, offset2 = 0) {
          checkUint8Array(b);
          let idx = offset2;
          while (idx < b.length && 0 !== b[idx]) {
            idx += 1;
          }
          return 1 + idx - offset2;
        }
        /** @override */
        decode(b, offset2 = 0) {
          const span = this.getSpan(b, offset2);
          return uint8ArrayToBuffer(b).slice(offset2, offset2 + span - 1).toString("utf-8");
        }
        /** @override */
        encode(src, b, offset2 = 0) {
          if ("string" !== typeof src) {
            src = String(src);
          }
          const srcb = buffer_1.Buffer.from(src, "utf8");
          const span = srcb.length;
          if (offset2 + span > b.length) {
            throw new RangeError("encoding overruns Buffer");
          }
          const buffer = uint8ArrayToBuffer(b);
          srcb.copy(buffer, offset2);
          buffer[offset2 + span] = 0;
          return span + 1;
        }
      };
      exports.CString = CString;
      var UTF8 = class extends Layout2 {
        constructor(maxSpan, property) {
          if ("string" === typeof maxSpan && void 0 === property) {
            property = maxSpan;
            maxSpan = void 0;
          }
          if (void 0 === maxSpan) {
            maxSpan = -1;
          } else if (!Number.isInteger(maxSpan)) {
            throw new TypeError("maxSpan must be an integer");
          }
          super(-1, property);
          this.maxSpan = maxSpan;
        }
        /** @override */
        getSpan(b, offset2 = 0) {
          checkUint8Array(b);
          return b.length - offset2;
        }
        /** @override */
        decode(b, offset2 = 0) {
          const span = this.getSpan(b, offset2);
          if (0 <= this.maxSpan && this.maxSpan < span) {
            throw new RangeError("text length exceeds maxSpan");
          }
          return uint8ArrayToBuffer(b).slice(offset2, offset2 + span).toString("utf-8");
        }
        /** @override */
        encode(src, b, offset2 = 0) {
          if ("string" !== typeof src) {
            src = String(src);
          }
          const srcb = buffer_1.Buffer.from(src, "utf8");
          const span = srcb.length;
          if (0 <= this.maxSpan && this.maxSpan < span) {
            throw new RangeError("text length exceeds maxSpan");
          }
          if (offset2 + span > b.length) {
            throw new RangeError("encoding overruns Buffer");
          }
          srcb.copy(uint8ArrayToBuffer(b), offset2);
          return span;
        }
      };
      exports.UTF8 = UTF8;
      var Constant = class extends Layout2 {
        constructor(value, property) {
          super(0, property);
          this.value = value;
        }
        /** @override */
        decode(b, offset2) {
          return this.value;
        }
        /** @override */
        encode(src, b, offset2) {
          return 0;
        }
      };
      exports.Constant = Constant;
      exports.greedy = ((elementSpan, property) => new GreedyCount(elementSpan, property));
      exports.offset = ((layout, offset2, property) => new OffsetLayout2(layout, offset2, property));
      exports.u8 = ((property) => new UInt2(1, property));
      exports.u16 = ((property) => new UInt2(2, property));
      exports.u24 = ((property) => new UInt2(3, property));
      exports.u32 = ((property) => new UInt2(4, property));
      exports.u40 = ((property) => new UInt2(5, property));
      exports.u48 = ((property) => new UInt2(6, property));
      exports.nu64 = ((property) => new NearUInt642(property));
      exports.u16be = ((property) => new UIntBE2(2, property));
      exports.u24be = ((property) => new UIntBE2(3, property));
      exports.u32be = ((property) => new UIntBE2(4, property));
      exports.u40be = ((property) => new UIntBE2(5, property));
      exports.u48be = ((property) => new UIntBE2(6, property));
      exports.nu64be = ((property) => new NearUInt64BE(property));
      exports.s8 = ((property) => new Int(1, property));
      exports.s16 = ((property) => new Int(2, property));
      exports.s24 = ((property) => new Int(3, property));
      exports.s32 = ((property) => new Int(4, property));
      exports.s40 = ((property) => new Int(5, property));
      exports.s48 = ((property) => new Int(6, property));
      exports.ns64 = ((property) => new NearInt642(property));
      exports.s16be = ((property) => new IntBE(2, property));
      exports.s24be = ((property) => new IntBE(3, property));
      exports.s32be = ((property) => new IntBE(4, property));
      exports.s40be = ((property) => new IntBE(5, property));
      exports.s48be = ((property) => new IntBE(6, property));
      exports.ns64be = ((property) => new NearInt64BE(property));
      exports.f32 = ((property) => new Float(property));
      exports.f32be = ((property) => new FloatBE(property));
      exports.f64 = ((property) => new Double(property));
      exports.f64be = ((property) => new DoubleBE(property));
      exports.struct = ((fields, property, decodePrefixes) => new Structure2(fields, property, decodePrefixes));
      exports.bits = ((word, msb, property) => new BitStructure(word, msb, property));
      exports.seq = ((elementLayout, count, property) => new Sequence(elementLayout, count, property));
      exports.union = ((discr, defaultLayout, property) => new Union2(discr, defaultLayout, property));
      exports.unionLayoutDiscriminator = ((layout, property) => new UnionLayoutDiscriminator2(layout, property));
      exports.blob = ((length, property) => new Blob2(length, property));
      exports.cstr = ((property) => new CString(property));
      exports.utf8 = ((maxSpan, property) => new UTF8(maxSpan, property));
      exports.constant = ((value, property) => new Constant(value, property));
    }
  });

  // node_modules/@solana/web3.js/node_modules/@solana/errors/dist/index.browser.cjs
  var require_index_browser = __commonJS({
    "node_modules/@solana/web3.js/node_modules/@solana/errors/dist/index.browser.cjs"(exports) {
      "use strict";
      var SOLANA_ERROR__BLOCK_HEIGHT_EXCEEDED = 1;
      var SOLANA_ERROR__INVALID_NONCE = 2;
      var SOLANA_ERROR__NONCE_ACCOUNT_NOT_FOUND = 3;
      var SOLANA_ERROR__BLOCKHASH_STRING_LENGTH_OUT_OF_RANGE = 4;
      var SOLANA_ERROR__INVALID_BLOCKHASH_BYTE_LENGTH = 5;
      var SOLANA_ERROR__LAMPORTS_OUT_OF_RANGE = 6;
      var SOLANA_ERROR__MALFORMED_BIGINT_STRING = 7;
      var SOLANA_ERROR__MALFORMED_NUMBER_STRING = 8;
      var SOLANA_ERROR__TIMESTAMP_OUT_OF_RANGE = 9;
      var SOLANA_ERROR__MALFORMED_JSON_RPC_ERROR = 10;
      var SOLANA_ERROR__JSON_RPC__PARSE_ERROR = -32700;
      var SOLANA_ERROR__JSON_RPC__INTERNAL_ERROR = -32603;
      var SOLANA_ERROR__JSON_RPC__INVALID_PARAMS = -32602;
      var SOLANA_ERROR__JSON_RPC__METHOD_NOT_FOUND = -32601;
      var SOLANA_ERROR__JSON_RPC__INVALID_REQUEST = -32600;
      var SOLANA_ERROR__JSON_RPC__SERVER_ERROR_MIN_CONTEXT_SLOT_NOT_REACHED = -32016;
      var SOLANA_ERROR__JSON_RPC__SERVER_ERROR_UNSUPPORTED_TRANSACTION_VERSION = -32015;
      var SOLANA_ERROR__JSON_RPC__SERVER_ERROR_BLOCK_STATUS_NOT_AVAILABLE_YET = -32014;
      var SOLANA_ERROR__JSON_RPC__SERVER_ERROR_TRANSACTION_SIGNATURE_LEN_MISMATCH = -32013;
      var SOLANA_ERROR__JSON_RPC__SCAN_ERROR = -32012;
      var SOLANA_ERROR__JSON_RPC__SERVER_ERROR_TRANSACTION_HISTORY_NOT_AVAILABLE = -32011;
      var SOLANA_ERROR__JSON_RPC__SERVER_ERROR_KEY_EXCLUDED_FROM_SECONDARY_INDEX = -32010;
      var SOLANA_ERROR__JSON_RPC__SERVER_ERROR_LONG_TERM_STORAGE_SLOT_SKIPPED = -32009;
      var SOLANA_ERROR__JSON_RPC__SERVER_ERROR_NO_SNAPSHOT = -32008;
      var SOLANA_ERROR__JSON_RPC__SERVER_ERROR_SLOT_SKIPPED = -32007;
      var SOLANA_ERROR__JSON_RPC__SERVER_ERROR_TRANSACTION_PRECOMPILE_VERIFICATION_FAILURE = -32006;
      var SOLANA_ERROR__JSON_RPC__SERVER_ERROR_NODE_UNHEALTHY = -32005;
      var SOLANA_ERROR__JSON_RPC__SERVER_ERROR_BLOCK_NOT_AVAILABLE = -32004;
      var SOLANA_ERROR__JSON_RPC__SERVER_ERROR_TRANSACTION_SIGNATURE_VERIFICATION_FAILURE = -32003;
      var SOLANA_ERROR__JSON_RPC__SERVER_ERROR_SEND_TRANSACTION_PREFLIGHT_FAILURE = -32002;
      var SOLANA_ERROR__JSON_RPC__SERVER_ERROR_BLOCK_CLEANED_UP = -32001;
      var SOLANA_ERROR__ADDRESSES__INVALID_BYTE_LENGTH = 28e5;
      var SOLANA_ERROR__ADDRESSES__STRING_LENGTH_OUT_OF_RANGE = 2800001;
      var SOLANA_ERROR__ADDRESSES__INVALID_BASE58_ENCODED_ADDRESS = 2800002;
      var SOLANA_ERROR__ADDRESSES__INVALID_ED25519_PUBLIC_KEY = 2800003;
      var SOLANA_ERROR__ADDRESSES__MALFORMED_PDA = 2800004;
      var SOLANA_ERROR__ADDRESSES__PDA_BUMP_SEED_OUT_OF_RANGE = 2800005;
      var SOLANA_ERROR__ADDRESSES__MAX_NUMBER_OF_PDA_SEEDS_EXCEEDED = 2800006;
      var SOLANA_ERROR__ADDRESSES__MAX_PDA_SEED_LENGTH_EXCEEDED = 2800007;
      var SOLANA_ERROR__ADDRESSES__INVALID_SEEDS_POINT_ON_CURVE = 2800008;
      var SOLANA_ERROR__ADDRESSES__FAILED_TO_FIND_VIABLE_PDA_BUMP_SEED = 2800009;
      var SOLANA_ERROR__ADDRESSES__PDA_ENDS_WITH_PDA_MARKER = 2800010;
      var SOLANA_ERROR__ADDRESSES__INVALID_OFF_CURVE_ADDRESS = 2800011;
      var SOLANA_ERROR__ACCOUNTS__ACCOUNT_NOT_FOUND = 323e4;
      var SOLANA_ERROR__ACCOUNTS__ONE_OR_MORE_ACCOUNTS_NOT_FOUND = 32300001;
      var SOLANA_ERROR__ACCOUNTS__FAILED_TO_DECODE_ACCOUNT = 3230002;
      var SOLANA_ERROR__ACCOUNTS__EXPECTED_DECODED_ACCOUNT = 3230003;
      var SOLANA_ERROR__ACCOUNTS__EXPECTED_ALL_ACCOUNTS_TO_BE_DECODED = 3230004;
      var SOLANA_ERROR__SUBTLE_CRYPTO__DISALLOWED_IN_INSECURE_CONTEXT = 361e4;
      var SOLANA_ERROR__SUBTLE_CRYPTO__DIGEST_UNIMPLEMENTED = 3610001;
      var SOLANA_ERROR__SUBTLE_CRYPTO__ED25519_ALGORITHM_UNIMPLEMENTED = 3610002;
      var SOLANA_ERROR__SUBTLE_CRYPTO__EXPORT_FUNCTION_UNIMPLEMENTED = 3610003;
      var SOLANA_ERROR__SUBTLE_CRYPTO__GENERATE_FUNCTION_UNIMPLEMENTED = 3610004;
      var SOLANA_ERROR__SUBTLE_CRYPTO__SIGN_FUNCTION_UNIMPLEMENTED = 3610005;
      var SOLANA_ERROR__SUBTLE_CRYPTO__VERIFY_FUNCTION_UNIMPLEMENTED = 3610006;
      var SOLANA_ERROR__SUBTLE_CRYPTO__CANNOT_EXPORT_NON_EXTRACTABLE_KEY = 3610007;
      var SOLANA_ERROR__CRYPTO__RANDOM_VALUES_FUNCTION_UNIMPLEMENTED = 3611e3;
      var SOLANA_ERROR__KEYS__INVALID_KEY_PAIR_BYTE_LENGTH = 3704e3;
      var SOLANA_ERROR__KEYS__INVALID_PRIVATE_KEY_BYTE_LENGTH = 3704001;
      var SOLANA_ERROR__KEYS__INVALID_SIGNATURE_BYTE_LENGTH = 3704002;
      var SOLANA_ERROR__KEYS__SIGNATURE_STRING_LENGTH_OUT_OF_RANGE = 3704003;
      var SOLANA_ERROR__KEYS__PUBLIC_KEY_MUST_MATCH_PRIVATE_KEY = 3704004;
      var SOLANA_ERROR__INSTRUCTION__EXPECTED_TO_HAVE_ACCOUNTS = 4128e3;
      var SOLANA_ERROR__INSTRUCTION__EXPECTED_TO_HAVE_DATA = 4128001;
      var SOLANA_ERROR__INSTRUCTION__PROGRAM_ID_MISMATCH = 4128002;
      var SOLANA_ERROR__INSTRUCTION_ERROR__UNKNOWN = 4615e3;
      var SOLANA_ERROR__INSTRUCTION_ERROR__GENERIC_ERROR = 4615001;
      var SOLANA_ERROR__INSTRUCTION_ERROR__INVALID_ARGUMENT = 4615002;
      var SOLANA_ERROR__INSTRUCTION_ERROR__INVALID_INSTRUCTION_DATA = 4615003;
      var SOLANA_ERROR__INSTRUCTION_ERROR__INVALID_ACCOUNT_DATA = 4615004;
      var SOLANA_ERROR__INSTRUCTION_ERROR__ACCOUNT_DATA_TOO_SMALL = 4615005;
      var SOLANA_ERROR__INSTRUCTION_ERROR__INSUFFICIENT_FUNDS = 4615006;
      var SOLANA_ERROR__INSTRUCTION_ERROR__INCORRECT_PROGRAM_ID = 4615007;
      var SOLANA_ERROR__INSTRUCTION_ERROR__MISSING_REQUIRED_SIGNATURE = 4615008;
      var SOLANA_ERROR__INSTRUCTION_ERROR__ACCOUNT_ALREADY_INITIALIZED = 4615009;
      var SOLANA_ERROR__INSTRUCTION_ERROR__UNINITIALIZED_ACCOUNT = 4615010;
      var SOLANA_ERROR__INSTRUCTION_ERROR__UNBALANCED_INSTRUCTION = 4615011;
      var SOLANA_ERROR__INSTRUCTION_ERROR__MODIFIED_PROGRAM_ID = 4615012;
      var SOLANA_ERROR__INSTRUCTION_ERROR__EXTERNAL_ACCOUNT_LAMPORT_SPEND = 4615013;
      var SOLANA_ERROR__INSTRUCTION_ERROR__EXTERNAL_ACCOUNT_DATA_MODIFIED = 4615014;
      var SOLANA_ERROR__INSTRUCTION_ERROR__READONLY_LAMPORT_CHANGE = 4615015;
      var SOLANA_ERROR__INSTRUCTION_ERROR__READONLY_DATA_MODIFIED = 4615016;
      var SOLANA_ERROR__INSTRUCTION_ERROR__DUPLICATE_ACCOUNT_INDEX = 4615017;
      var SOLANA_ERROR__INSTRUCTION_ERROR__EXECUTABLE_MODIFIED = 4615018;
      var SOLANA_ERROR__INSTRUCTION_ERROR__RENT_EPOCH_MODIFIED = 4615019;
      var SOLANA_ERROR__INSTRUCTION_ERROR__NOT_ENOUGH_ACCOUNT_KEYS = 4615020;
      var SOLANA_ERROR__INSTRUCTION_ERROR__ACCOUNT_DATA_SIZE_CHANGED = 4615021;
      var SOLANA_ERROR__INSTRUCTION_ERROR__ACCOUNT_NOT_EXECUTABLE = 4615022;
      var SOLANA_ERROR__INSTRUCTION_ERROR__ACCOUNT_BORROW_FAILED = 4615023;
      var SOLANA_ERROR__INSTRUCTION_ERROR__ACCOUNT_BORROW_OUTSTANDING = 4615024;
      var SOLANA_ERROR__INSTRUCTION_ERROR__DUPLICATE_ACCOUNT_OUT_OF_SYNC = 4615025;
      var SOLANA_ERROR__INSTRUCTION_ERROR__CUSTOM = 4615026;
      var SOLANA_ERROR__INSTRUCTION_ERROR__INVALID_ERROR = 4615027;
      var SOLANA_ERROR__INSTRUCTION_ERROR__EXECUTABLE_DATA_MODIFIED = 4615028;
      var SOLANA_ERROR__INSTRUCTION_ERROR__EXECUTABLE_LAMPORT_CHANGE = 4615029;
      var SOLANA_ERROR__INSTRUCTION_ERROR__EXECUTABLE_ACCOUNT_NOT_RENT_EXEMPT = 4615030;
      var SOLANA_ERROR__INSTRUCTION_ERROR__UNSUPPORTED_PROGRAM_ID = 4615031;
      var SOLANA_ERROR__INSTRUCTION_ERROR__CALL_DEPTH = 4615032;
      var SOLANA_ERROR__INSTRUCTION_ERROR__MISSING_ACCOUNT = 4615033;
      var SOLANA_ERROR__INSTRUCTION_ERROR__REENTRANCY_NOT_ALLOWED = 4615034;
      var SOLANA_ERROR__INSTRUCTION_ERROR__MAX_SEED_LENGTH_EXCEEDED = 4615035;
      var SOLANA_ERROR__INSTRUCTION_ERROR__INVALID_SEEDS = 4615036;
      var SOLANA_ERROR__INSTRUCTION_ERROR__INVALID_REALLOC = 4615037;
      var SOLANA_ERROR__INSTRUCTION_ERROR__COMPUTATIONAL_BUDGET_EXCEEDED = 4615038;
      var SOLANA_ERROR__INSTRUCTION_ERROR__PRIVILEGE_ESCALATION = 4615039;
      var SOLANA_ERROR__INSTRUCTION_ERROR__PROGRAM_ENVIRONMENT_SETUP_FAILURE = 4615040;
      var SOLANA_ERROR__INSTRUCTION_ERROR__PROGRAM_FAILED_TO_COMPLETE = 4615041;
      var SOLANA_ERROR__INSTRUCTION_ERROR__PROGRAM_FAILED_TO_COMPILE = 4615042;
      var SOLANA_ERROR__INSTRUCTION_ERROR__IMMUTABLE = 4615043;
      var SOLANA_ERROR__INSTRUCTION_ERROR__INCORRECT_AUTHORITY = 4615044;
      var SOLANA_ERROR__INSTRUCTION_ERROR__BORSH_IO_ERROR = 4615045;
      var SOLANA_ERROR__INSTRUCTION_ERROR__ACCOUNT_NOT_RENT_EXEMPT = 4615046;
      var SOLANA_ERROR__INSTRUCTION_ERROR__INVALID_ACCOUNT_OWNER = 4615047;
      var SOLANA_ERROR__INSTRUCTION_ERROR__ARITHMETIC_OVERFLOW = 4615048;
      var SOLANA_ERROR__INSTRUCTION_ERROR__UNSUPPORTED_SYSVAR = 4615049;
      var SOLANA_ERROR__INSTRUCTION_ERROR__ILLEGAL_OWNER = 4615050;
      var SOLANA_ERROR__INSTRUCTION_ERROR__MAX_ACCOUNTS_DATA_ALLOCATIONS_EXCEEDED = 4615051;
      var SOLANA_ERROR__INSTRUCTION_ERROR__MAX_ACCOUNTS_EXCEEDED = 4615052;
      var SOLANA_ERROR__INSTRUCTION_ERROR__MAX_INSTRUCTION_TRACE_LENGTH_EXCEEDED = 4615053;
      var SOLANA_ERROR__INSTRUCTION_ERROR__BUILTIN_PROGRAMS_MUST_CONSUME_COMPUTE_UNITS = 4615054;
      var SOLANA_ERROR__SIGNER__ADDRESS_CANNOT_HAVE_MULTIPLE_SIGNERS = 5508e3;
      var SOLANA_ERROR__SIGNER__EXPECTED_KEY_PAIR_SIGNER = 5508001;
      var SOLANA_ERROR__SIGNER__EXPECTED_MESSAGE_SIGNER = 5508002;
      var SOLANA_ERROR__SIGNER__EXPECTED_MESSAGE_MODIFYING_SIGNER = 5508003;
      var SOLANA_ERROR__SIGNER__EXPECTED_MESSAGE_PARTIAL_SIGNER = 5508004;
      var SOLANA_ERROR__SIGNER__EXPECTED_TRANSACTION_SIGNER = 5508005;
      var SOLANA_ERROR__SIGNER__EXPECTED_TRANSACTION_MODIFYING_SIGNER = 5508006;
      var SOLANA_ERROR__SIGNER__EXPECTED_TRANSACTION_PARTIAL_SIGNER = 5508007;
      var SOLANA_ERROR__SIGNER__EXPECTED_TRANSACTION_SENDING_SIGNER = 5508008;
      var SOLANA_ERROR__SIGNER__TRANSACTION_CANNOT_HAVE_MULTIPLE_SENDING_SIGNERS = 5508009;
      var SOLANA_ERROR__SIGNER__TRANSACTION_SENDING_SIGNER_MISSING = 5508010;
      var SOLANA_ERROR__SIGNER__WALLET_MULTISIGN_UNIMPLEMENTED = 5508011;
      var SOLANA_ERROR__TRANSACTION__INVOKED_PROGRAMS_CANNOT_PAY_FEES = 5663e3;
      var SOLANA_ERROR__TRANSACTION__INVOKED_PROGRAMS_MUST_NOT_BE_WRITABLE = 5663001;
      var SOLANA_ERROR__TRANSACTION__EXPECTED_BLOCKHASH_LIFETIME = 5663002;
      var SOLANA_ERROR__TRANSACTION__EXPECTED_NONCE_LIFETIME = 5663003;
      var SOLANA_ERROR__TRANSACTION__VERSION_NUMBER_OUT_OF_RANGE = 5663004;
      var SOLANA_ERROR__TRANSACTION__FAILED_TO_DECOMPILE_ADDRESS_LOOKUP_TABLE_CONTENTS_MISSING = 5663005;
      var SOLANA_ERROR__TRANSACTION__FAILED_TO_DECOMPILE_ADDRESS_LOOKUP_TABLE_INDEX_OUT_OF_RANGE = 5663006;
      var SOLANA_ERROR__TRANSACTION__FAILED_TO_DECOMPILE_INSTRUCTION_PROGRAM_ADDRESS_NOT_FOUND = 5663007;
      var SOLANA_ERROR__TRANSACTION__FAILED_TO_DECOMPILE_FEE_PAYER_MISSING = 5663008;
      var SOLANA_ERROR__TRANSACTION__SIGNATURES_MISSING = 5663009;
      var SOLANA_ERROR__TRANSACTION__ADDRESS_MISSING = 5663010;
      var SOLANA_ERROR__TRANSACTION__FEE_PAYER_MISSING = 5663011;
      var SOLANA_ERROR__TRANSACTION__FEE_PAYER_SIGNATURE_MISSING = 5663012;
      var SOLANA_ERROR__TRANSACTION__INVALID_NONCE_TRANSACTION_INSTRUCTIONS_MISSING = 5663013;
      var SOLANA_ERROR__TRANSACTION__INVALID_NONCE_TRANSACTION_FIRST_INSTRUCTION_MUST_BE_ADVANCE_NONCE = 5663014;
      var SOLANA_ERROR__TRANSACTION__ADDRESSES_CANNOT_SIGN_TRANSACTION = 5663015;
      var SOLANA_ERROR__TRANSACTION__CANNOT_ENCODE_WITH_EMPTY_SIGNATURES = 5663016;
      var SOLANA_ERROR__TRANSACTION__MESSAGE_SIGNATURES_MISMATCH = 5663017;
      var SOLANA_ERROR__TRANSACTION__FAILED_TO_ESTIMATE_COMPUTE_LIMIT = 5663018;
      var SOLANA_ERROR__TRANSACTION__FAILED_WHEN_SIMULATING_TO_ESTIMATE_COMPUTE_LIMIT = 5663019;
      var SOLANA_ERROR__TRANSACTION__EXCEEDS_SIZE_LIMIT = 5663020;
      var SOLANA_ERROR__TRANSACTION_ERROR__UNKNOWN = 705e4;
      var SOLANA_ERROR__TRANSACTION_ERROR__ACCOUNT_IN_USE = 7050001;
      var SOLANA_ERROR__TRANSACTION_ERROR__ACCOUNT_LOADED_TWICE = 7050002;
      var SOLANA_ERROR__TRANSACTION_ERROR__ACCOUNT_NOT_FOUND = 7050003;
      var SOLANA_ERROR__TRANSACTION_ERROR__PROGRAM_ACCOUNT_NOT_FOUND = 7050004;
      var SOLANA_ERROR__TRANSACTION_ERROR__INSUFFICIENT_FUNDS_FOR_FEE = 7050005;
      var SOLANA_ERROR__TRANSACTION_ERROR__INVALID_ACCOUNT_FOR_FEE = 7050006;
      var SOLANA_ERROR__TRANSACTION_ERROR__ALREADY_PROCESSED = 7050007;
      var SOLANA_ERROR__TRANSACTION_ERROR__BLOCKHASH_NOT_FOUND = 7050008;
      var SOLANA_ERROR__TRANSACTION_ERROR__CALL_CHAIN_TOO_DEEP = 7050009;
      var SOLANA_ERROR__TRANSACTION_ERROR__MISSING_SIGNATURE_FOR_FEE = 7050010;
      var SOLANA_ERROR__TRANSACTION_ERROR__INVALID_ACCOUNT_INDEX = 7050011;
      var SOLANA_ERROR__TRANSACTION_ERROR__SIGNATURE_FAILURE = 7050012;
      var SOLANA_ERROR__TRANSACTION_ERROR__INVALID_PROGRAM_FOR_EXECUTION = 7050013;
      var SOLANA_ERROR__TRANSACTION_ERROR__SANITIZE_FAILURE = 7050014;
      var SOLANA_ERROR__TRANSACTION_ERROR__CLUSTER_MAINTENANCE = 7050015;
      var SOLANA_ERROR__TRANSACTION_ERROR__ACCOUNT_BORROW_OUTSTANDING = 7050016;
      var SOLANA_ERROR__TRANSACTION_ERROR__WOULD_EXCEED_MAX_BLOCK_COST_LIMIT = 7050017;
      var SOLANA_ERROR__TRANSACTION_ERROR__UNSUPPORTED_VERSION = 7050018;
      var SOLANA_ERROR__TRANSACTION_ERROR__INVALID_WRITABLE_ACCOUNT = 7050019;
      var SOLANA_ERROR__TRANSACTION_ERROR__WOULD_EXCEED_MAX_ACCOUNT_COST_LIMIT = 7050020;
      var SOLANA_ERROR__TRANSACTION_ERROR__WOULD_EXCEED_ACCOUNT_DATA_BLOCK_LIMIT = 7050021;
      var SOLANA_ERROR__TRANSACTION_ERROR__TOO_MANY_ACCOUNT_LOCKS = 7050022;
      var SOLANA_ERROR__TRANSACTION_ERROR__ADDRESS_LOOKUP_TABLE_NOT_FOUND = 7050023;
      var SOLANA_ERROR__TRANSACTION_ERROR__INVALID_ADDRESS_LOOKUP_TABLE_OWNER = 7050024;
      var SOLANA_ERROR__TRANSACTION_ERROR__INVALID_ADDRESS_LOOKUP_TABLE_DATA = 7050025;
      var SOLANA_ERROR__TRANSACTION_ERROR__INVALID_ADDRESS_LOOKUP_TABLE_INDEX = 7050026;
      var SOLANA_ERROR__TRANSACTION_ERROR__INVALID_RENT_PAYING_ACCOUNT = 7050027;
      var SOLANA_ERROR__TRANSACTION_ERROR__WOULD_EXCEED_MAX_VOTE_COST_LIMIT = 7050028;
      var SOLANA_ERROR__TRANSACTION_ERROR__WOULD_EXCEED_ACCOUNT_DATA_TOTAL_LIMIT = 7050029;
      var SOLANA_ERROR__TRANSACTION_ERROR__DUPLICATE_INSTRUCTION = 7050030;
      var SOLANA_ERROR__TRANSACTION_ERROR__INSUFFICIENT_FUNDS_FOR_RENT = 7050031;
      var SOLANA_ERROR__TRANSACTION_ERROR__MAX_LOADED_ACCOUNTS_DATA_SIZE_EXCEEDED = 7050032;
      var SOLANA_ERROR__TRANSACTION_ERROR__INVALID_LOADED_ACCOUNTS_DATA_SIZE_LIMIT = 7050033;
      var SOLANA_ERROR__TRANSACTION_ERROR__RESANITIZATION_NEEDED = 7050034;
      var SOLANA_ERROR__TRANSACTION_ERROR__PROGRAM_EXECUTION_TEMPORARILY_RESTRICTED = 7050035;
      var SOLANA_ERROR__TRANSACTION_ERROR__UNBALANCED_TRANSACTION = 7050036;
      var SOLANA_ERROR__CODECS__CANNOT_DECODE_EMPTY_BYTE_ARRAY = 8078e3;
      var SOLANA_ERROR__CODECS__INVALID_BYTE_LENGTH = 8078001;
      var SOLANA_ERROR__CODECS__EXPECTED_FIXED_LENGTH = 8078002;
      var SOLANA_ERROR__CODECS__EXPECTED_VARIABLE_LENGTH = 8078003;
      var SOLANA_ERROR__CODECS__ENCODER_DECODER_SIZE_COMPATIBILITY_MISMATCH = 8078004;
      var SOLANA_ERROR__CODECS__ENCODER_DECODER_FIXED_SIZE_MISMATCH = 8078005;
      var SOLANA_ERROR__CODECS__ENCODER_DECODER_MAX_SIZE_MISMATCH = 8078006;
      var SOLANA_ERROR__CODECS__INVALID_NUMBER_OF_ITEMS = 8078007;
      var SOLANA_ERROR__CODECS__ENUM_DISCRIMINATOR_OUT_OF_RANGE = 8078008;
      var SOLANA_ERROR__CODECS__INVALID_DISCRIMINATED_UNION_VARIANT = 8078009;
      var SOLANA_ERROR__CODECS__INVALID_ENUM_VARIANT = 8078010;
      var SOLANA_ERROR__CODECS__NUMBER_OUT_OF_RANGE = 8078011;
      var SOLANA_ERROR__CODECS__INVALID_STRING_FOR_BASE = 8078012;
      var SOLANA_ERROR__CODECS__EXPECTED_POSITIVE_BYTE_LENGTH = 8078013;
      var SOLANA_ERROR__CODECS__OFFSET_OUT_OF_RANGE = 8078014;
      var SOLANA_ERROR__CODECS__INVALID_LITERAL_UNION_VARIANT = 8078015;
      var SOLANA_ERROR__CODECS__LITERAL_UNION_DISCRIMINATOR_OUT_OF_RANGE = 8078016;
      var SOLANA_ERROR__CODECS__UNION_VARIANT_OUT_OF_RANGE = 8078017;
      var SOLANA_ERROR__CODECS__INVALID_CONSTANT = 8078018;
      var SOLANA_ERROR__CODECS__EXPECTED_ZERO_VALUE_TO_MATCH_ITEM_FIXED_SIZE = 8078019;
      var SOLANA_ERROR__CODECS__ENCODED_BYTES_MUST_NOT_INCLUDE_SENTINEL = 8078020;
      var SOLANA_ERROR__CODECS__SENTINEL_MISSING_IN_DECODED_BYTES = 8078021;
      var SOLANA_ERROR__CODECS__CANNOT_USE_LEXICAL_VALUES_AS_ENUM_DISCRIMINATORS = 8078022;
      var SOLANA_ERROR__RPC__INTEGER_OVERFLOW = 81e5;
      var SOLANA_ERROR__RPC__TRANSPORT_HTTP_HEADER_FORBIDDEN = 8100001;
      var SOLANA_ERROR__RPC__TRANSPORT_HTTP_ERROR = 8100002;
      var SOLANA_ERROR__RPC__API_PLAN_MISSING_FOR_RPC_METHOD = 8100003;
      var SOLANA_ERROR__RPC_SUBSCRIPTIONS__CANNOT_CREATE_SUBSCRIPTION_PLAN = 819e4;
      var SOLANA_ERROR__RPC_SUBSCRIPTIONS__EXPECTED_SERVER_SUBSCRIPTION_ID = 8190001;
      var SOLANA_ERROR__RPC_SUBSCRIPTIONS__CHANNEL_CLOSED_BEFORE_MESSAGE_BUFFERED = 8190002;
      var SOLANA_ERROR__RPC_SUBSCRIPTIONS__CHANNEL_CONNECTION_CLOSED = 8190003;
      var SOLANA_ERROR__RPC_SUBSCRIPTIONS__CHANNEL_FAILED_TO_CONNECT = 8190004;
      var SOLANA_ERROR__INVARIANT_VIOLATION__SUBSCRIPTION_ITERATOR_STATE_MISSING = 99e5;
      var SOLANA_ERROR__INVARIANT_VIOLATION__SUBSCRIPTION_ITERATOR_MUST_NOT_POLL_BEFORE_RESOLVING_EXISTING_MESSAGE_PROMISE = 9900001;
      var SOLANA_ERROR__INVARIANT_VIOLATION__CACHED_ABORTABLE_ITERABLE_CACHE_ENTRY_MISSING = 9900002;
      var SOLANA_ERROR__INVARIANT_VIOLATION__SWITCH_MUST_BE_EXHAUSTIVE = 9900003;
      var SOLANA_ERROR__INVARIANT_VIOLATION__DATA_PUBLISHER_CHANNEL_UNIMPLEMENTED = 9900004;
      var SolanaErrorMessages = {
        [SOLANA_ERROR__ACCOUNTS__ACCOUNT_NOT_FOUND]: "Account not found at address: $address",
        [SOLANA_ERROR__ACCOUNTS__EXPECTED_ALL_ACCOUNTS_TO_BE_DECODED]: "Not all accounts were decoded. Encoded accounts found at addresses: $addresses.",
        [SOLANA_ERROR__ACCOUNTS__EXPECTED_DECODED_ACCOUNT]: "Expected decoded account at address: $address",
        [SOLANA_ERROR__ACCOUNTS__FAILED_TO_DECODE_ACCOUNT]: "Failed to decode account data at address: $address",
        [SOLANA_ERROR__ACCOUNTS__ONE_OR_MORE_ACCOUNTS_NOT_FOUND]: "Accounts not found at addresses: $addresses",
        [SOLANA_ERROR__ADDRESSES__FAILED_TO_FIND_VIABLE_PDA_BUMP_SEED]: "Unable to find a viable program address bump seed.",
        [SOLANA_ERROR__ADDRESSES__INVALID_BASE58_ENCODED_ADDRESS]: "$putativeAddress is not a base58-encoded address.",
        [SOLANA_ERROR__ADDRESSES__INVALID_BYTE_LENGTH]: "Expected base58 encoded address to decode to a byte array of length 32. Actual length: $actualLength.",
        [SOLANA_ERROR__ADDRESSES__INVALID_ED25519_PUBLIC_KEY]: "The `CryptoKey` must be an `Ed25519` public key.",
        [SOLANA_ERROR__ADDRESSES__INVALID_OFF_CURVE_ADDRESS]: "$putativeOffCurveAddress is not a base58-encoded off-curve address.",
        [SOLANA_ERROR__ADDRESSES__INVALID_SEEDS_POINT_ON_CURVE]: "Invalid seeds; point must fall off the Ed25519 curve.",
        [SOLANA_ERROR__ADDRESSES__MALFORMED_PDA]: "Expected given program derived address to have the following format: [Address, ProgramDerivedAddressBump].",
        [SOLANA_ERROR__ADDRESSES__MAX_NUMBER_OF_PDA_SEEDS_EXCEEDED]: "A maximum of $maxSeeds seeds, including the bump seed, may be supplied when creating an address. Received: $actual.",
        [SOLANA_ERROR__ADDRESSES__MAX_PDA_SEED_LENGTH_EXCEEDED]: "The seed at index $index with length $actual exceeds the maximum length of $maxSeedLength bytes.",
        [SOLANA_ERROR__ADDRESSES__PDA_BUMP_SEED_OUT_OF_RANGE]: "Expected program derived address bump to be in the range [0, 255], got: $bump.",
        [SOLANA_ERROR__ADDRESSES__PDA_ENDS_WITH_PDA_MARKER]: "Program address cannot end with PDA marker.",
        [SOLANA_ERROR__ADDRESSES__STRING_LENGTH_OUT_OF_RANGE]: "Expected base58-encoded address string of length in the range [32, 44]. Actual length: $actualLength.",
        [SOLANA_ERROR__BLOCKHASH_STRING_LENGTH_OUT_OF_RANGE]: "Expected base58-encoded blockash string of length in the range [32, 44]. Actual length: $actualLength.",
        [SOLANA_ERROR__BLOCK_HEIGHT_EXCEEDED]: "The network has progressed past the last block for which this transaction could have been committed.",
        [SOLANA_ERROR__CODECS__CANNOT_DECODE_EMPTY_BYTE_ARRAY]: "Codec [$codecDescription] cannot decode empty byte arrays.",
        [SOLANA_ERROR__CODECS__CANNOT_USE_LEXICAL_VALUES_AS_ENUM_DISCRIMINATORS]: "Enum codec cannot use lexical values [$stringValues] as discriminators. Either remove all lexical values or set `useValuesAsDiscriminators` to `false`.",
        [SOLANA_ERROR__CODECS__ENCODED_BYTES_MUST_NOT_INCLUDE_SENTINEL]: "Sentinel [$hexSentinel] must not be present in encoded bytes [$hexEncodedBytes].",
        [SOLANA_ERROR__CODECS__ENCODER_DECODER_FIXED_SIZE_MISMATCH]: "Encoder and decoder must have the same fixed size, got [$encoderFixedSize] and [$decoderFixedSize].",
        [SOLANA_ERROR__CODECS__ENCODER_DECODER_MAX_SIZE_MISMATCH]: "Encoder and decoder must have the same max size, got [$encoderMaxSize] and [$decoderMaxSize].",
        [SOLANA_ERROR__CODECS__ENCODER_DECODER_SIZE_COMPATIBILITY_MISMATCH]: "Encoder and decoder must either both be fixed-size or variable-size.",
        [SOLANA_ERROR__CODECS__ENUM_DISCRIMINATOR_OUT_OF_RANGE]: "Enum discriminator out of range. Expected a number in [$formattedValidDiscriminators], got $discriminator.",
        [SOLANA_ERROR__CODECS__EXPECTED_FIXED_LENGTH]: "Expected a fixed-size codec, got a variable-size one.",
        [SOLANA_ERROR__CODECS__EXPECTED_POSITIVE_BYTE_LENGTH]: "Codec [$codecDescription] expected a positive byte length, got $bytesLength.",
        [SOLANA_ERROR__CODECS__EXPECTED_VARIABLE_LENGTH]: "Expected a variable-size codec, got a fixed-size one.",
        [SOLANA_ERROR__CODECS__EXPECTED_ZERO_VALUE_TO_MATCH_ITEM_FIXED_SIZE]: "Codec [$codecDescription] expected zero-value [$hexZeroValue] to have the same size as the provided fixed-size item [$expectedSize bytes].",
        [SOLANA_ERROR__CODECS__INVALID_BYTE_LENGTH]: "Codec [$codecDescription] expected $expected bytes, got $bytesLength.",
        [SOLANA_ERROR__CODECS__INVALID_CONSTANT]: "Expected byte array constant [$hexConstant] to be present in data [$hexData] at offset [$offset].",
        [SOLANA_ERROR__CODECS__INVALID_DISCRIMINATED_UNION_VARIANT]: "Invalid discriminated union variant. Expected one of [$variants], got $value.",
        [SOLANA_ERROR__CODECS__INVALID_ENUM_VARIANT]: "Invalid enum variant. Expected one of [$stringValues] or a number in [$formattedNumericalValues], got $variant.",
        [SOLANA_ERROR__CODECS__INVALID_LITERAL_UNION_VARIANT]: "Invalid literal union variant. Expected one of [$variants], got $value.",
        [SOLANA_ERROR__CODECS__INVALID_NUMBER_OF_ITEMS]: "Expected [$codecDescription] to have $expected items, got $actual.",
        [SOLANA_ERROR__CODECS__INVALID_STRING_FOR_BASE]: "Invalid value $value for base $base with alphabet $alphabet.",
        [SOLANA_ERROR__CODECS__LITERAL_UNION_DISCRIMINATOR_OUT_OF_RANGE]: "Literal union discriminator out of range. Expected a number between $minRange and $maxRange, got $discriminator.",
        [SOLANA_ERROR__CODECS__NUMBER_OUT_OF_RANGE]: "Codec [$codecDescription] expected number to be in the range [$min, $max], got $value.",
        [SOLANA_ERROR__CODECS__OFFSET_OUT_OF_RANGE]: "Codec [$codecDescription] expected offset to be in the range [0, $bytesLength], got $offset.",
        [SOLANA_ERROR__CODECS__SENTINEL_MISSING_IN_DECODED_BYTES]: "Expected sentinel [$hexSentinel] to be present in decoded bytes [$hexDecodedBytes].",
        [SOLANA_ERROR__CODECS__UNION_VARIANT_OUT_OF_RANGE]: "Union variant out of range. Expected an index between $minRange and $maxRange, got $variant.",
        [SOLANA_ERROR__CRYPTO__RANDOM_VALUES_FUNCTION_UNIMPLEMENTED]: "No random values implementation could be found.",
        [SOLANA_ERROR__INSTRUCTION_ERROR__ACCOUNT_ALREADY_INITIALIZED]: "instruction requires an uninitialized account",
        [SOLANA_ERROR__INSTRUCTION_ERROR__ACCOUNT_BORROW_FAILED]: "instruction tries to borrow reference for an account which is already borrowed",
        [SOLANA_ERROR__INSTRUCTION_ERROR__ACCOUNT_BORROW_OUTSTANDING]: "instruction left account with an outstanding borrowed reference",
        [SOLANA_ERROR__INSTRUCTION_ERROR__ACCOUNT_DATA_SIZE_CHANGED]: "program other than the account's owner changed the size of the account data",
        [SOLANA_ERROR__INSTRUCTION_ERROR__ACCOUNT_DATA_TOO_SMALL]: "account data too small for instruction",
        [SOLANA_ERROR__INSTRUCTION_ERROR__ACCOUNT_NOT_EXECUTABLE]: "instruction expected an executable account",
        [SOLANA_ERROR__INSTRUCTION_ERROR__ACCOUNT_NOT_RENT_EXEMPT]: "An account does not have enough lamports to be rent-exempt",
        [SOLANA_ERROR__INSTRUCTION_ERROR__ARITHMETIC_OVERFLOW]: "Program arithmetic overflowed",
        [SOLANA_ERROR__INSTRUCTION_ERROR__BORSH_IO_ERROR]: "Failed to serialize or deserialize account data: $encodedData",
        [SOLANA_ERROR__INSTRUCTION_ERROR__BUILTIN_PROGRAMS_MUST_CONSUME_COMPUTE_UNITS]: "Builtin programs must consume compute units",
        [SOLANA_ERROR__INSTRUCTION_ERROR__CALL_DEPTH]: "Cross-program invocation call depth too deep",
        [SOLANA_ERROR__INSTRUCTION_ERROR__COMPUTATIONAL_BUDGET_EXCEEDED]: "Computational budget exceeded",
        [SOLANA_ERROR__INSTRUCTION_ERROR__CUSTOM]: "custom program error: #$code",
        [SOLANA_ERROR__INSTRUCTION_ERROR__DUPLICATE_ACCOUNT_INDEX]: "instruction contains duplicate accounts",
        [SOLANA_ERROR__INSTRUCTION_ERROR__DUPLICATE_ACCOUNT_OUT_OF_SYNC]: "instruction modifications of multiply-passed account differ",
        [SOLANA_ERROR__INSTRUCTION_ERROR__EXECUTABLE_ACCOUNT_NOT_RENT_EXEMPT]: "executable accounts must be rent exempt",
        [SOLANA_ERROR__INSTRUCTION_ERROR__EXECUTABLE_DATA_MODIFIED]: "instruction changed executable accounts data",
        [SOLANA_ERROR__INSTRUCTION_ERROR__EXECUTABLE_LAMPORT_CHANGE]: "instruction changed the balance of an executable account",
        [SOLANA_ERROR__INSTRUCTION_ERROR__EXECUTABLE_MODIFIED]: "instruction changed executable bit of an account",
        [SOLANA_ERROR__INSTRUCTION_ERROR__EXTERNAL_ACCOUNT_DATA_MODIFIED]: "instruction modified data of an account it does not own",
        [SOLANA_ERROR__INSTRUCTION_ERROR__EXTERNAL_ACCOUNT_LAMPORT_SPEND]: "instruction spent from the balance of an account it does not own",
        [SOLANA_ERROR__INSTRUCTION_ERROR__GENERIC_ERROR]: "generic instruction error",
        [SOLANA_ERROR__INSTRUCTION_ERROR__ILLEGAL_OWNER]: "Provided owner is not allowed",
        [SOLANA_ERROR__INSTRUCTION_ERROR__IMMUTABLE]: "Account is immutable",
        [SOLANA_ERROR__INSTRUCTION_ERROR__INCORRECT_AUTHORITY]: "Incorrect authority provided",
        [SOLANA_ERROR__INSTRUCTION_ERROR__INCORRECT_PROGRAM_ID]: "incorrect program id for instruction",
        [SOLANA_ERROR__INSTRUCTION_ERROR__INSUFFICIENT_FUNDS]: "insufficient funds for instruction",
        [SOLANA_ERROR__INSTRUCTION_ERROR__INVALID_ACCOUNT_DATA]: "invalid account data for instruction",
        [SOLANA_ERROR__INSTRUCTION_ERROR__INVALID_ACCOUNT_OWNER]: "Invalid account owner",
        [SOLANA_ERROR__INSTRUCTION_ERROR__INVALID_ARGUMENT]: "invalid program argument",
        [SOLANA_ERROR__INSTRUCTION_ERROR__INVALID_ERROR]: "program returned invalid error code",
        [SOLANA_ERROR__INSTRUCTION_ERROR__INVALID_INSTRUCTION_DATA]: "invalid instruction data",
        [SOLANA_ERROR__INSTRUCTION_ERROR__INVALID_REALLOC]: "Failed to reallocate account data",
        [SOLANA_ERROR__INSTRUCTION_ERROR__INVALID_SEEDS]: "Provided seeds do not result in a valid address",
        [SOLANA_ERROR__INSTRUCTION_ERROR__MAX_ACCOUNTS_DATA_ALLOCATIONS_EXCEEDED]: "Accounts data allocations exceeded the maximum allowed per transaction",
        [SOLANA_ERROR__INSTRUCTION_ERROR__MAX_ACCOUNTS_EXCEEDED]: "Max accounts exceeded",
        [SOLANA_ERROR__INSTRUCTION_ERROR__MAX_INSTRUCTION_TRACE_LENGTH_EXCEEDED]: "Max instruction trace length exceeded",
        [SOLANA_ERROR__INSTRUCTION_ERROR__MAX_SEED_LENGTH_EXCEEDED]: "Length of the seed is too long for address generation",
        [SOLANA_ERROR__INSTRUCTION_ERROR__MISSING_ACCOUNT]: "An account required by the instruction is missing",
        [SOLANA_ERROR__INSTRUCTION_ERROR__MISSING_REQUIRED_SIGNATURE]: "missing required signature for instruction",
        [SOLANA_ERROR__INSTRUCTION_ERROR__MODIFIED_PROGRAM_ID]: "instruction illegally modified the program id of an account",
        [SOLANA_ERROR__INSTRUCTION_ERROR__NOT_ENOUGH_ACCOUNT_KEYS]: "insufficient account keys for instruction",
        [SOLANA_ERROR__INSTRUCTION_ERROR__PRIVILEGE_ESCALATION]: "Cross-program invocation with unauthorized signer or writable account",
        [SOLANA_ERROR__INSTRUCTION_ERROR__PROGRAM_ENVIRONMENT_SETUP_FAILURE]: "Failed to create program execution environment",
        [SOLANA_ERROR__INSTRUCTION_ERROR__PROGRAM_FAILED_TO_COMPILE]: "Program failed to compile",
        [SOLANA_ERROR__INSTRUCTION_ERROR__PROGRAM_FAILED_TO_COMPLETE]: "Program failed to complete",
        [SOLANA_ERROR__INSTRUCTION_ERROR__READONLY_DATA_MODIFIED]: "instruction modified data of a read-only account",
        [SOLANA_ERROR__INSTRUCTION_ERROR__READONLY_LAMPORT_CHANGE]: "instruction changed the balance of a read-only account",
        [SOLANA_ERROR__INSTRUCTION_ERROR__REENTRANCY_NOT_ALLOWED]: "Cross-program invocation reentrancy not allowed for this instruction",
        [SOLANA_ERROR__INSTRUCTION_ERROR__RENT_EPOCH_MODIFIED]: "instruction modified rent epoch of an account",
        [SOLANA_ERROR__INSTRUCTION_ERROR__UNBALANCED_INSTRUCTION]: "sum of account balances before and after instruction do not match",
        [SOLANA_ERROR__INSTRUCTION_ERROR__UNINITIALIZED_ACCOUNT]: "instruction requires an initialized account",
        [SOLANA_ERROR__INSTRUCTION_ERROR__UNKNOWN]: "",
        [SOLANA_ERROR__INSTRUCTION_ERROR__UNSUPPORTED_PROGRAM_ID]: "Unsupported program id",
        [SOLANA_ERROR__INSTRUCTION_ERROR__UNSUPPORTED_SYSVAR]: "Unsupported sysvar",
        [SOLANA_ERROR__INSTRUCTION__EXPECTED_TO_HAVE_ACCOUNTS]: "The instruction does not have any accounts.",
        [SOLANA_ERROR__INSTRUCTION__EXPECTED_TO_HAVE_DATA]: "The instruction does not have any data.",
        [SOLANA_ERROR__INSTRUCTION__PROGRAM_ID_MISMATCH]: "Expected instruction to have progress address $expectedProgramAddress, got $actualProgramAddress.",
        [SOLANA_ERROR__INVALID_BLOCKHASH_BYTE_LENGTH]: "Expected base58 encoded blockhash to decode to a byte array of length 32. Actual length: $actualLength.",
        [SOLANA_ERROR__INVALID_NONCE]: "The nonce `$expectedNonceValue` is no longer valid. It has advanced to `$actualNonceValue`",
        [SOLANA_ERROR__INVARIANT_VIOLATION__CACHED_ABORTABLE_ITERABLE_CACHE_ENTRY_MISSING]: "Invariant violation: Found no abortable iterable cache entry for key `$cacheKey`. It should be impossible to hit this error; please file an issue at https://sola.na/web3invariant",
        [SOLANA_ERROR__INVARIANT_VIOLATION__DATA_PUBLISHER_CHANNEL_UNIMPLEMENTED]: "Invariant violation: This data publisher does not publish to the channel named `$channelName`. Supported channels include $supportedChannelNames.",
        [SOLANA_ERROR__INVARIANT_VIOLATION__SUBSCRIPTION_ITERATOR_MUST_NOT_POLL_BEFORE_RESOLVING_EXISTING_MESSAGE_PROMISE]: "Invariant violation: WebSocket message iterator state is corrupt; iterated without first resolving existing message promise. It should be impossible to hit this error; please file an issue at https://sola.na/web3invariant",
        [SOLANA_ERROR__INVARIANT_VIOLATION__SUBSCRIPTION_ITERATOR_STATE_MISSING]: "Invariant violation: WebSocket message iterator is missing state storage. It should be impossible to hit this error; please file an issue at https://sola.na/web3invariant",
        [SOLANA_ERROR__INVARIANT_VIOLATION__SWITCH_MUST_BE_EXHAUSTIVE]: "Invariant violation: Switch statement non-exhaustive. Received unexpected value `$unexpectedValue`. It should be impossible to hit this error; please file an issue at https://sola.na/web3invariant",
        [SOLANA_ERROR__JSON_RPC__INTERNAL_ERROR]: "JSON-RPC error: Internal JSON-RPC error ($__serverMessage)",
        [SOLANA_ERROR__JSON_RPC__INVALID_PARAMS]: "JSON-RPC error: Invalid method parameter(s) ($__serverMessage)",
        [SOLANA_ERROR__JSON_RPC__INVALID_REQUEST]: "JSON-RPC error: The JSON sent is not a valid `Request` object ($__serverMessage)",
        [SOLANA_ERROR__JSON_RPC__METHOD_NOT_FOUND]: "JSON-RPC error: The method does not exist / is not available ($__serverMessage)",
        [SOLANA_ERROR__JSON_RPC__PARSE_ERROR]: "JSON-RPC error: An error occurred on the server while parsing the JSON text ($__serverMessage)",
        [SOLANA_ERROR__JSON_RPC__SCAN_ERROR]: "$__serverMessage",
        [SOLANA_ERROR__JSON_RPC__SERVER_ERROR_BLOCK_CLEANED_UP]: "$__serverMessage",
        [SOLANA_ERROR__JSON_RPC__SERVER_ERROR_BLOCK_NOT_AVAILABLE]: "$__serverMessage",
        [SOLANA_ERROR__JSON_RPC__SERVER_ERROR_BLOCK_STATUS_NOT_AVAILABLE_YET]: "$__serverMessage",
        [SOLANA_ERROR__JSON_RPC__SERVER_ERROR_KEY_EXCLUDED_FROM_SECONDARY_INDEX]: "$__serverMessage",
        [SOLANA_ERROR__JSON_RPC__SERVER_ERROR_LONG_TERM_STORAGE_SLOT_SKIPPED]: "$__serverMessage",
        [SOLANA_ERROR__JSON_RPC__SERVER_ERROR_MIN_CONTEXT_SLOT_NOT_REACHED]: "Minimum context slot has not been reached",
        [SOLANA_ERROR__JSON_RPC__SERVER_ERROR_NODE_UNHEALTHY]: "Node is unhealthy; behind by $numSlotsBehind slots",
        [SOLANA_ERROR__JSON_RPC__SERVER_ERROR_NO_SNAPSHOT]: "No snapshot",
        [SOLANA_ERROR__JSON_RPC__SERVER_ERROR_SEND_TRANSACTION_PREFLIGHT_FAILURE]: "Transaction simulation failed",
        [SOLANA_ERROR__JSON_RPC__SERVER_ERROR_SLOT_SKIPPED]: "$__serverMessage",
        [SOLANA_ERROR__JSON_RPC__SERVER_ERROR_TRANSACTION_HISTORY_NOT_AVAILABLE]: "Transaction history is not available from this node",
        [SOLANA_ERROR__JSON_RPC__SERVER_ERROR_TRANSACTION_PRECOMPILE_VERIFICATION_FAILURE]: "$__serverMessage",
        [SOLANA_ERROR__JSON_RPC__SERVER_ERROR_TRANSACTION_SIGNATURE_LEN_MISMATCH]: "Transaction signature length mismatch",
        [SOLANA_ERROR__JSON_RPC__SERVER_ERROR_TRANSACTION_SIGNATURE_VERIFICATION_FAILURE]: "Transaction signature verification failure",
        [SOLANA_ERROR__JSON_RPC__SERVER_ERROR_UNSUPPORTED_TRANSACTION_VERSION]: "$__serverMessage",
        [SOLANA_ERROR__KEYS__INVALID_KEY_PAIR_BYTE_LENGTH]: "Key pair bytes must be of length 64, got $byteLength.",
        [SOLANA_ERROR__KEYS__INVALID_PRIVATE_KEY_BYTE_LENGTH]: "Expected private key bytes with length 32. Actual length: $actualLength.",
        [SOLANA_ERROR__KEYS__INVALID_SIGNATURE_BYTE_LENGTH]: "Expected base58-encoded signature to decode to a byte array of length 64. Actual length: $actualLength.",
        [SOLANA_ERROR__KEYS__PUBLIC_KEY_MUST_MATCH_PRIVATE_KEY]: "The provided private key does not match the provided public key.",
        [SOLANA_ERROR__KEYS__SIGNATURE_STRING_LENGTH_OUT_OF_RANGE]: "Expected base58-encoded signature string of length in the range [64, 88]. Actual length: $actualLength.",
        [SOLANA_ERROR__LAMPORTS_OUT_OF_RANGE]: "Lamports value must be in the range [0, 2e64-1]",
        [SOLANA_ERROR__MALFORMED_BIGINT_STRING]: "`$value` cannot be parsed as a `BigInt`",
        [SOLANA_ERROR__MALFORMED_JSON_RPC_ERROR]: "$message",
        [SOLANA_ERROR__MALFORMED_NUMBER_STRING]: "`$value` cannot be parsed as a `Number`",
        [SOLANA_ERROR__NONCE_ACCOUNT_NOT_FOUND]: "No nonce account could be found at address `$nonceAccountAddress`",
        [SOLANA_ERROR__RPC_SUBSCRIPTIONS__CANNOT_CREATE_SUBSCRIPTION_PLAN]: "The notification name must end in 'Notifications' and the API must supply a subscription plan creator function for the notification '$notificationName'.",
        [SOLANA_ERROR__RPC_SUBSCRIPTIONS__CHANNEL_CLOSED_BEFORE_MESSAGE_BUFFERED]: "WebSocket was closed before payload could be added to the send buffer",
        [SOLANA_ERROR__RPC_SUBSCRIPTIONS__CHANNEL_CONNECTION_CLOSED]: "WebSocket connection closed",
        [SOLANA_ERROR__RPC_SUBSCRIPTIONS__CHANNEL_FAILED_TO_CONNECT]: "WebSocket failed to connect",
        [SOLANA_ERROR__RPC_SUBSCRIPTIONS__EXPECTED_SERVER_SUBSCRIPTION_ID]: "Failed to obtain a subscription id from the server",
        [SOLANA_ERROR__RPC__API_PLAN_MISSING_FOR_RPC_METHOD]: "Could not find an API plan for RPC method: `$method`",
        [SOLANA_ERROR__RPC__INTEGER_OVERFLOW]: "The $argumentLabel argument to the `$methodName` RPC method$optionalPathLabel was `$value`. This number is unsafe for use with the Solana JSON-RPC because it exceeds `Number.MAX_SAFE_INTEGER`.",
        [SOLANA_ERROR__RPC__TRANSPORT_HTTP_ERROR]: "HTTP error ($statusCode): $message",
        [SOLANA_ERROR__RPC__TRANSPORT_HTTP_HEADER_FORBIDDEN]: "HTTP header(s) forbidden: $headers. Learn more at https://developer.mozilla.org/en-US/docs/Glossary/Forbidden_header_name.",
        [SOLANA_ERROR__SIGNER__ADDRESS_CANNOT_HAVE_MULTIPLE_SIGNERS]: "Multiple distinct signers were identified for address `$address`. Please ensure that you are using the same signer instance for each address.",
        [SOLANA_ERROR__SIGNER__EXPECTED_KEY_PAIR_SIGNER]: "The provided value does not implement the `KeyPairSigner` interface",
        [SOLANA_ERROR__SIGNER__EXPECTED_MESSAGE_MODIFYING_SIGNER]: "The provided value does not implement the `MessageModifyingSigner` interface",
        [SOLANA_ERROR__SIGNER__EXPECTED_MESSAGE_PARTIAL_SIGNER]: "The provided value does not implement the `MessagePartialSigner` interface",
        [SOLANA_ERROR__SIGNER__EXPECTED_MESSAGE_SIGNER]: "The provided value does not implement any of the `MessageSigner` interfaces",
        [SOLANA_ERROR__SIGNER__EXPECTED_TRANSACTION_MODIFYING_SIGNER]: "The provided value does not implement the `TransactionModifyingSigner` interface",
        [SOLANA_ERROR__SIGNER__EXPECTED_TRANSACTION_PARTIAL_SIGNER]: "The provided value does not implement the `TransactionPartialSigner` interface",
        [SOLANA_ERROR__SIGNER__EXPECTED_TRANSACTION_SENDING_SIGNER]: "The provided value does not implement the `TransactionSendingSigner` interface",
        [SOLANA_ERROR__SIGNER__EXPECTED_TRANSACTION_SIGNER]: "The provided value does not implement any of the `TransactionSigner` interfaces",
        [SOLANA_ERROR__SIGNER__TRANSACTION_CANNOT_HAVE_MULTIPLE_SENDING_SIGNERS]: "More than one `TransactionSendingSigner` was identified.",
        [SOLANA_ERROR__SIGNER__TRANSACTION_SENDING_SIGNER_MISSING]: "No `TransactionSendingSigner` was identified. Please provide a valid `TransactionWithSingleSendingSigner` transaction.",
        [SOLANA_ERROR__SIGNER__WALLET_MULTISIGN_UNIMPLEMENTED]: "Wallet account signers do not support signing multiple messages/transactions in a single operation",
        [SOLANA_ERROR__SUBTLE_CRYPTO__CANNOT_EXPORT_NON_EXTRACTABLE_KEY]: "Cannot export a non-extractable key.",
        [SOLANA_ERROR__SUBTLE_CRYPTO__DIGEST_UNIMPLEMENTED]: "No digest implementation could be found.",
        [SOLANA_ERROR__SUBTLE_CRYPTO__DISALLOWED_IN_INSECURE_CONTEXT]: "Cryptographic operations are only allowed in secure browser contexts. Read more here: https://developer.mozilla.org/en-US/docs/Web/Security/Secure_Contexts.",
        [SOLANA_ERROR__SUBTLE_CRYPTO__ED25519_ALGORITHM_UNIMPLEMENTED]: "This runtime does not support the generation of Ed25519 key pairs.\n\nInstall @solana/webcrypto-ed25519-polyfill and call its `install` function before generating keys in environments that do not support Ed25519.\n\nFor a list of runtimes that currently support Ed25519 operations, visit https://github.com/WICG/webcrypto-secure-curves/issues/20.",
        [SOLANA_ERROR__SUBTLE_CRYPTO__EXPORT_FUNCTION_UNIMPLEMENTED]: "No signature verification implementation could be found.",
        [SOLANA_ERROR__SUBTLE_CRYPTO__GENERATE_FUNCTION_UNIMPLEMENTED]: "No key generation implementation could be found.",
        [SOLANA_ERROR__SUBTLE_CRYPTO__SIGN_FUNCTION_UNIMPLEMENTED]: "No signing implementation could be found.",
        [SOLANA_ERROR__SUBTLE_CRYPTO__VERIFY_FUNCTION_UNIMPLEMENTED]: "No key export implementation could be found.",
        [SOLANA_ERROR__TIMESTAMP_OUT_OF_RANGE]: "Timestamp value must be in the range [-(2n ** 63n), (2n ** 63n) - 1]. `$value` given",
        [SOLANA_ERROR__TRANSACTION_ERROR__ACCOUNT_BORROW_OUTSTANDING]: "Transaction processing left an account with an outstanding borrowed reference",
        [SOLANA_ERROR__TRANSACTION_ERROR__ACCOUNT_IN_USE]: "Account in use",
        [SOLANA_ERROR__TRANSACTION_ERROR__ACCOUNT_LOADED_TWICE]: "Account loaded twice",
        [SOLANA_ERROR__TRANSACTION_ERROR__ACCOUNT_NOT_FOUND]: "Attempt to debit an account but found no record of a prior credit.",
        [SOLANA_ERROR__TRANSACTION_ERROR__ADDRESS_LOOKUP_TABLE_NOT_FOUND]: "Transaction loads an address table account that doesn't exist",
        [SOLANA_ERROR__TRANSACTION_ERROR__ALREADY_PROCESSED]: "This transaction has already been processed",
        [SOLANA_ERROR__TRANSACTION_ERROR__BLOCKHASH_NOT_FOUND]: "Blockhash not found",
        [SOLANA_ERROR__TRANSACTION_ERROR__CALL_CHAIN_TOO_DEEP]: "Loader call chain is too deep",
        [SOLANA_ERROR__TRANSACTION_ERROR__CLUSTER_MAINTENANCE]: "Transactions are currently disabled due to cluster maintenance",
        [SOLANA_ERROR__TRANSACTION_ERROR__DUPLICATE_INSTRUCTION]: "Transaction contains a duplicate instruction ($index) that is not allowed",
        [SOLANA_ERROR__TRANSACTION_ERROR__INSUFFICIENT_FUNDS_FOR_FEE]: "Insufficient funds for fee",
        [SOLANA_ERROR__TRANSACTION_ERROR__INSUFFICIENT_FUNDS_FOR_RENT]: "Transaction results in an account ($accountIndex) with insufficient funds for rent",
        [SOLANA_ERROR__TRANSACTION_ERROR__INVALID_ACCOUNT_FOR_FEE]: "This account may not be used to pay transaction fees",
        [SOLANA_ERROR__TRANSACTION_ERROR__INVALID_ACCOUNT_INDEX]: "Transaction contains an invalid account reference",
        [SOLANA_ERROR__TRANSACTION_ERROR__INVALID_ADDRESS_LOOKUP_TABLE_DATA]: "Transaction loads an address table account with invalid data",
        [SOLANA_ERROR__TRANSACTION_ERROR__INVALID_ADDRESS_LOOKUP_TABLE_INDEX]: "Transaction address table lookup uses an invalid index",
        [SOLANA_ERROR__TRANSACTION_ERROR__INVALID_ADDRESS_LOOKUP_TABLE_OWNER]: "Transaction loads an address table account with an invalid owner",
        [SOLANA_ERROR__TRANSACTION_ERROR__INVALID_LOADED_ACCOUNTS_DATA_SIZE_LIMIT]: "LoadedAccountsDataSizeLimit set for transaction must be greater than 0.",
        [SOLANA_ERROR__TRANSACTION_ERROR__INVALID_PROGRAM_FOR_EXECUTION]: "This program may not be used for executing instructions",
        [SOLANA_ERROR__TRANSACTION_ERROR__INVALID_RENT_PAYING_ACCOUNT]: "Transaction leaves an account with a lower balance than rent-exempt minimum",
        [SOLANA_ERROR__TRANSACTION_ERROR__INVALID_WRITABLE_ACCOUNT]: "Transaction loads a writable account that cannot be written",
        [SOLANA_ERROR__TRANSACTION_ERROR__MAX_LOADED_ACCOUNTS_DATA_SIZE_EXCEEDED]: "Transaction exceeded max loaded accounts data size cap",
        [SOLANA_ERROR__TRANSACTION_ERROR__MISSING_SIGNATURE_FOR_FEE]: "Transaction requires a fee but has no signature present",
        [SOLANA_ERROR__TRANSACTION_ERROR__PROGRAM_ACCOUNT_NOT_FOUND]: "Attempt to load a program that does not exist",
        [SOLANA_ERROR__TRANSACTION_ERROR__PROGRAM_EXECUTION_TEMPORARILY_RESTRICTED]: "Execution of the program referenced by account at index $accountIndex is temporarily restricted.",
        [SOLANA_ERROR__TRANSACTION_ERROR__RESANITIZATION_NEEDED]: "ResanitizationNeeded",
        [SOLANA_ERROR__TRANSACTION_ERROR__SANITIZE_FAILURE]: "Transaction failed to sanitize accounts offsets correctly",
        [SOLANA_ERROR__TRANSACTION_ERROR__SIGNATURE_FAILURE]: "Transaction did not pass signature verification",
        [SOLANA_ERROR__TRANSACTION_ERROR__TOO_MANY_ACCOUNT_LOCKS]: "Transaction locked too many accounts",
        [SOLANA_ERROR__TRANSACTION_ERROR__UNBALANCED_TRANSACTION]: "Sum of account balances before and after transaction do not match",
        [SOLANA_ERROR__TRANSACTION_ERROR__UNKNOWN]: "The transaction failed with the error `$errorName`",
        [SOLANA_ERROR__TRANSACTION_ERROR__UNSUPPORTED_VERSION]: "Transaction version is unsupported",
        [SOLANA_ERROR__TRANSACTION_ERROR__WOULD_EXCEED_ACCOUNT_DATA_BLOCK_LIMIT]: "Transaction would exceed account data limit within the block",
        [SOLANA_ERROR__TRANSACTION_ERROR__WOULD_EXCEED_ACCOUNT_DATA_TOTAL_LIMIT]: "Transaction would exceed total account data limit",
        [SOLANA_ERROR__TRANSACTION_ERROR__WOULD_EXCEED_MAX_ACCOUNT_COST_LIMIT]: "Transaction would exceed max account limit within the block",
        [SOLANA_ERROR__TRANSACTION_ERROR__WOULD_EXCEED_MAX_BLOCK_COST_LIMIT]: "Transaction would exceed max Block Cost Limit",
        [SOLANA_ERROR__TRANSACTION_ERROR__WOULD_EXCEED_MAX_VOTE_COST_LIMIT]: "Transaction would exceed max Vote Cost Limit",
        [SOLANA_ERROR__TRANSACTION__ADDRESSES_CANNOT_SIGN_TRANSACTION]: "Attempted to sign a transaction with an address that is not a signer for it",
        [SOLANA_ERROR__TRANSACTION__ADDRESS_MISSING]: "Transaction is missing an address at index: $index.",
        [SOLANA_ERROR__TRANSACTION__CANNOT_ENCODE_WITH_EMPTY_SIGNATURES]: "Transaction has no expected signers therefore it cannot be encoded",
        [SOLANA_ERROR__TRANSACTION__EXCEEDS_SIZE_LIMIT]: "Transaction size $transactionSize exceeds limit of $transactionSizeLimit bytes",
        [SOLANA_ERROR__TRANSACTION__EXPECTED_BLOCKHASH_LIFETIME]: "Transaction does not have a blockhash lifetime",
        [SOLANA_ERROR__TRANSACTION__EXPECTED_NONCE_LIFETIME]: "Transaction is not a durable nonce transaction",
        [SOLANA_ERROR__TRANSACTION__FAILED_TO_DECOMPILE_ADDRESS_LOOKUP_TABLE_CONTENTS_MISSING]: "Contents of these address lookup tables unknown: $lookupTableAddresses",
        [SOLANA_ERROR__TRANSACTION__FAILED_TO_DECOMPILE_ADDRESS_LOOKUP_TABLE_INDEX_OUT_OF_RANGE]: "Lookup of address at index $highestRequestedIndex failed for lookup table `$lookupTableAddress`. Highest known index is $highestKnownIndex. The lookup table may have been extended since its contents were retrieved",
        [SOLANA_ERROR__TRANSACTION__FAILED_TO_DECOMPILE_FEE_PAYER_MISSING]: "No fee payer set in CompiledTransaction",
        [SOLANA_ERROR__TRANSACTION__FAILED_TO_DECOMPILE_INSTRUCTION_PROGRAM_ADDRESS_NOT_FOUND]: "Could not find program address at index $index",
        [SOLANA_ERROR__TRANSACTION__FAILED_TO_ESTIMATE_COMPUTE_LIMIT]: "Failed to estimate the compute unit consumption for this transaction message. This is likely because simulating the transaction failed. Inspect the `cause` property of this error to learn more",
        [SOLANA_ERROR__TRANSACTION__FAILED_WHEN_SIMULATING_TO_ESTIMATE_COMPUTE_LIMIT]: "Transaction failed when it was simulated in order to estimate the compute unit consumption. The compute unit estimate provided is for a transaction that failed when simulated and may not be representative of the compute units this transaction would consume if successful. Inspect the `cause` property of this error to learn more",
        [SOLANA_ERROR__TRANSACTION__FEE_PAYER_MISSING]: "Transaction is missing a fee payer.",
        [SOLANA_ERROR__TRANSACTION__FEE_PAYER_SIGNATURE_MISSING]: "Could not determine this transaction's signature. Make sure that the transaction has been signed by its fee payer.",
        [SOLANA_ERROR__TRANSACTION__INVALID_NONCE_TRANSACTION_FIRST_INSTRUCTION_MUST_BE_ADVANCE_NONCE]: "Transaction first instruction is not advance nonce account instruction.",
        [SOLANA_ERROR__TRANSACTION__INVALID_NONCE_TRANSACTION_INSTRUCTIONS_MISSING]: "Transaction with no instructions cannot be durable nonce transaction.",
        [SOLANA_ERROR__TRANSACTION__INVOKED_PROGRAMS_CANNOT_PAY_FEES]: "This transaction includes an address (`$programAddress`) which is both invoked and set as the fee payer. Program addresses may not pay fees",
        [SOLANA_ERROR__TRANSACTION__INVOKED_PROGRAMS_MUST_NOT_BE_WRITABLE]: "This transaction includes an address (`$programAddress`) which is both invoked and marked writable. Program addresses may not be writable",
        [SOLANA_ERROR__TRANSACTION__MESSAGE_SIGNATURES_MISMATCH]: "The transaction message expected the transaction to have $signerAddressesLength signatures, got $signaturesLength.",
        [SOLANA_ERROR__TRANSACTION__SIGNATURES_MISSING]: "Transaction is missing signatures for addresses: $addresses.",
        [SOLANA_ERROR__TRANSACTION__VERSION_NUMBER_OUT_OF_RANGE]: "Transaction version must be in the range [0, 127]. `$actualVersion` given"
      };
      var START_INDEX = "i";
      var TYPE2 = "t";
      function getHumanReadableErrorMessage(code, context = {}) {
        const messageFormatString = SolanaErrorMessages[code];
        if (messageFormatString.length === 0) {
          return "";
        }
        let state;
        function commitStateUpTo(endIndex) {
          if (state[TYPE2] === 2) {
            const variableName = messageFormatString.slice(state[START_INDEX] + 1, endIndex);
            fragments.push(
              variableName in context ? (
                // eslint-disable-next-line @typescript-eslint/restrict-template-expressions
                `${context[variableName]}`
              ) : `$${variableName}`
            );
          } else if (state[TYPE2] === 1) {
            fragments.push(messageFormatString.slice(state[START_INDEX], endIndex));
          }
        }
        const fragments = [];
        messageFormatString.split("").forEach((char, ii) => {
          if (ii === 0) {
            state = {
              [START_INDEX]: 0,
              [TYPE2]: messageFormatString[0] === "\\" ? 0 : messageFormatString[0] === "$" ? 2 : 1
              /* Text */
            };
            return;
          }
          let nextState;
          switch (state[TYPE2]) {
            case 0:
              nextState = {
                [START_INDEX]: ii,
                [TYPE2]: 1
                /* Text */
              };
              break;
            case 1:
              if (char === "\\") {
                nextState = {
                  [START_INDEX]: ii,
                  [TYPE2]: 0
                  /* EscapeSequence */
                };
              } else if (char === "$") {
                nextState = {
                  [START_INDEX]: ii,
                  [TYPE2]: 2
                  /* Variable */
                };
              }
              break;
            case 2:
              if (char === "\\") {
                nextState = {
                  [START_INDEX]: ii,
                  [TYPE2]: 0
                  /* EscapeSequence */
                };
              } else if (char === "$") {
                nextState = {
                  [START_INDEX]: ii,
                  [TYPE2]: 2
                  /* Variable */
                };
              } else if (!char.match(/\w/)) {
                nextState = {
                  [START_INDEX]: ii,
                  [TYPE2]: 1
                  /* Text */
                };
              }
              break;
          }
          if (nextState) {
            if (state !== nextState) {
              commitStateUpTo(ii);
            }
            state = nextState;
          }
        });
        commitStateUpTo();
        return fragments.join("");
      }
      function getErrorMessage(code, context = {}) {
        if (true) {
          return getHumanReadableErrorMessage(code, context);
        } else {
          let decodingAdviceMessage = `Solana error #${code}; Decode this error by running \`npx @solana/errors decode -- ${code}`;
          if (Object.keys(context).length) {
            decodingAdviceMessage += ` '${encodeContextObject(context)}'`;
          }
          return `${decodingAdviceMessage}\``;
        }
      }
      function isSolanaError(e, code) {
        const isSolanaError2 = e instanceof Error && e.name === "SolanaError";
        if (isSolanaError2) {
          if (code !== void 0) {
            return e.context.__code === code;
          }
          return true;
        }
        return false;
      }
      var SolanaError = class extends Error {
        constructor(...[code, contextAndErrorOptions]) {
          let context;
          let errorOptions;
          if (contextAndErrorOptions) {
            const { cause, ...contextRest } = contextAndErrorOptions;
            if (cause) {
              errorOptions = { cause };
            }
            if (Object.keys(contextRest).length > 0) {
              context = contextRest;
            }
          }
          const message = getErrorMessage(code, context);
          super(message, errorOptions);
          /**
           * Indicates the root cause of this {@link SolanaError}, if any.
           *
           * For example, a transaction error might have an instruction error as its root cause. In this
           * case, you will be able to access the instruction error on the transaction error as `cause`.
           */
          __publicField(this, "cause", this.cause);
          /**
           * Contains context that can assist in understanding or recovering from a {@link SolanaError}.
           */
          __publicField(this, "context");
          this.context = {
            __code: code,
            ...context
          };
          this.name = "SolanaError";
        }
      };
      function safeCaptureStackTrace(...args) {
        if ("captureStackTrace" in Error && typeof Error.captureStackTrace === "function") {
          Error.captureStackTrace(...args);
        }
      }
      function getSolanaErrorFromRpcError({ errorCodeBaseOffset, getErrorContext, orderedErrorNames, rpcEnumError }, constructorOpt) {
        let rpcErrorName;
        let rpcErrorContext;
        if (typeof rpcEnumError === "string") {
          rpcErrorName = rpcEnumError;
        } else {
          rpcErrorName = Object.keys(rpcEnumError)[0];
          rpcErrorContext = rpcEnumError[rpcErrorName];
        }
        const codeOffset = orderedErrorNames.indexOf(rpcErrorName);
        const errorCode = errorCodeBaseOffset + codeOffset;
        const errorContext = getErrorContext(errorCode, rpcErrorName, rpcErrorContext);
        const err2 = new SolanaError(errorCode, errorContext);
        safeCaptureStackTrace(err2, constructorOpt);
        return err2;
      }
      var ORDERED_ERROR_NAMES = [
        // Keep synced with RPC source: https://github.com/anza-xyz/agave/blob/master/sdk/program/src/instruction.rs
        // If this list ever gets too large, consider implementing a compression strategy like this:
        // https://gist.github.com/steveluscher/aaa7cbbb5433b1197983908a40860c47
        "GenericError",
        "InvalidArgument",
        "InvalidInstructionData",
        "InvalidAccountData",
        "AccountDataTooSmall",
        "InsufficientFunds",
        "IncorrectProgramId",
        "MissingRequiredSignature",
        "AccountAlreadyInitialized",
        "UninitializedAccount",
        "UnbalancedInstruction",
        "ModifiedProgramId",
        "ExternalAccountLamportSpend",
        "ExternalAccountDataModified",
        "ReadonlyLamportChange",
        "ReadonlyDataModified",
        "DuplicateAccountIndex",
        "ExecutableModified",
        "RentEpochModified",
        "NotEnoughAccountKeys",
        "AccountDataSizeChanged",
        "AccountNotExecutable",
        "AccountBorrowFailed",
        "AccountBorrowOutstanding",
        "DuplicateAccountOutOfSync",
        "Custom",
        "InvalidError",
        "ExecutableDataModified",
        "ExecutableLamportChange",
        "ExecutableAccountNotRentExempt",
        "UnsupportedProgramId",
        "CallDepth",
        "MissingAccount",
        "ReentrancyNotAllowed",
        "MaxSeedLengthExceeded",
        "InvalidSeeds",
        "InvalidRealloc",
        "ComputationalBudgetExceeded",
        "PrivilegeEscalation",
        "ProgramEnvironmentSetupFailure",
        "ProgramFailedToComplete",
        "ProgramFailedToCompile",
        "Immutable",
        "IncorrectAuthority",
        "BorshIoError",
        "AccountNotRentExempt",
        "InvalidAccountOwner",
        "ArithmeticOverflow",
        "UnsupportedSysvar",
        "IllegalOwner",
        "MaxAccountsDataAllocationsExceeded",
        "MaxAccountsExceeded",
        "MaxInstructionTraceLengthExceeded",
        "BuiltinProgramsMustConsumeComputeUnits"
      ];
      function getSolanaErrorFromInstructionError(index2, instructionError) {
        const numberIndex = Number(index2);
        return getSolanaErrorFromRpcError(
          {
            errorCodeBaseOffset: 4615001,
            getErrorContext(errorCode, rpcErrorName, rpcErrorContext) {
              if (errorCode === SOLANA_ERROR__INSTRUCTION_ERROR__UNKNOWN) {
                return {
                  errorName: rpcErrorName,
                  index: numberIndex,
                  ...rpcErrorContext !== void 0 ? { instructionErrorContext: rpcErrorContext } : null
                };
              } else if (errorCode === SOLANA_ERROR__INSTRUCTION_ERROR__CUSTOM) {
                return {
                  code: Number(rpcErrorContext),
                  index: numberIndex
                };
              } else if (errorCode === SOLANA_ERROR__INSTRUCTION_ERROR__BORSH_IO_ERROR) {
                return {
                  encodedData: rpcErrorContext,
                  index: numberIndex
                };
              }
              return { index: numberIndex };
            },
            orderedErrorNames: ORDERED_ERROR_NAMES,
            rpcEnumError: instructionError
          },
          getSolanaErrorFromInstructionError
        );
      }
      var ORDERED_ERROR_NAMES2 = [
        // Keep synced with RPC source: https://github.com/anza-xyz/agave/blob/master/sdk/src/transaction/error.rs
        // If this list ever gets too large, consider implementing a compression strategy like this:
        // https://gist.github.com/steveluscher/aaa7cbbb5433b1197983908a40860c47
        "AccountInUse",
        "AccountLoadedTwice",
        "AccountNotFound",
        "ProgramAccountNotFound",
        "InsufficientFundsForFee",
        "InvalidAccountForFee",
        "AlreadyProcessed",
        "BlockhashNotFound",
        // `InstructionError` intentionally omitted; delegated to `getSolanaErrorFromInstructionError`
        "CallChainTooDeep",
        "MissingSignatureForFee",
        "InvalidAccountIndex",
        "SignatureFailure",
        "InvalidProgramForExecution",
        "SanitizeFailure",
        "ClusterMaintenance",
        "AccountBorrowOutstanding",
        "WouldExceedMaxBlockCostLimit",
        "UnsupportedVersion",
        "InvalidWritableAccount",
        "WouldExceedMaxAccountCostLimit",
        "WouldExceedAccountDataBlockLimit",
        "TooManyAccountLocks",
        "AddressLookupTableNotFound",
        "InvalidAddressLookupTableOwner",
        "InvalidAddressLookupTableData",
        "InvalidAddressLookupTableIndex",
        "InvalidRentPayingAccount",
        "WouldExceedMaxVoteCostLimit",
        "WouldExceedAccountDataTotalLimit",
        "DuplicateInstruction",
        "InsufficientFundsForRent",
        "MaxLoadedAccountsDataSizeExceeded",
        "InvalidLoadedAccountsDataSizeLimit",
        "ResanitizationNeeded",
        "ProgramExecutionTemporarilyRestricted",
        "UnbalancedTransaction"
      ];
      function getSolanaErrorFromTransactionError(transactionError) {
        if (typeof transactionError === "object" && "InstructionError" in transactionError) {
          return getSolanaErrorFromInstructionError(
            ...transactionError.InstructionError
          );
        }
        return getSolanaErrorFromRpcError(
          {
            errorCodeBaseOffset: 7050001,
            getErrorContext(errorCode, rpcErrorName, rpcErrorContext) {
              if (errorCode === SOLANA_ERROR__TRANSACTION_ERROR__UNKNOWN) {
                return {
                  errorName: rpcErrorName,
                  ...rpcErrorContext !== void 0 ? { transactionErrorContext: rpcErrorContext } : null
                };
              } else if (errorCode === SOLANA_ERROR__TRANSACTION_ERROR__DUPLICATE_INSTRUCTION) {
                return {
                  index: Number(rpcErrorContext)
                };
              } else if (errorCode === SOLANA_ERROR__TRANSACTION_ERROR__INSUFFICIENT_FUNDS_FOR_RENT || errorCode === SOLANA_ERROR__TRANSACTION_ERROR__PROGRAM_EXECUTION_TEMPORARILY_RESTRICTED) {
                return {
                  accountIndex: Number(rpcErrorContext.account_index)
                };
              }
            },
            orderedErrorNames: ORDERED_ERROR_NAMES2,
            rpcEnumError: transactionError
          },
          getSolanaErrorFromTransactionError
        );
      }
      function getSolanaErrorFromJsonRpcError(putativeErrorResponse) {
        let out;
        if (isRpcErrorResponse(putativeErrorResponse)) {
          const { code: rawCode, data, message } = putativeErrorResponse;
          const code = Number(rawCode);
          if (code === SOLANA_ERROR__JSON_RPC__SERVER_ERROR_SEND_TRANSACTION_PREFLIGHT_FAILURE) {
            const { err: err2, ...preflightErrorContext } = data;
            const causeObject = err2 ? { cause: getSolanaErrorFromTransactionError(err2) } : null;
            out = new SolanaError(SOLANA_ERROR__JSON_RPC__SERVER_ERROR_SEND_TRANSACTION_PREFLIGHT_FAILURE, {
              ...preflightErrorContext,
              ...causeObject
            });
          } else {
            let errorContext;
            switch (code) {
              case SOLANA_ERROR__JSON_RPC__INTERNAL_ERROR:
              case SOLANA_ERROR__JSON_RPC__INVALID_PARAMS:
              case SOLANA_ERROR__JSON_RPC__INVALID_REQUEST:
              case SOLANA_ERROR__JSON_RPC__METHOD_NOT_FOUND:
              case SOLANA_ERROR__JSON_RPC__PARSE_ERROR:
              case SOLANA_ERROR__JSON_RPC__SCAN_ERROR:
              case SOLANA_ERROR__JSON_RPC__SERVER_ERROR_BLOCK_CLEANED_UP:
              case SOLANA_ERROR__JSON_RPC__SERVER_ERROR_BLOCK_NOT_AVAILABLE:
              case SOLANA_ERROR__JSON_RPC__SERVER_ERROR_BLOCK_STATUS_NOT_AVAILABLE_YET:
              case SOLANA_ERROR__JSON_RPC__SERVER_ERROR_KEY_EXCLUDED_FROM_SECONDARY_INDEX:
              case SOLANA_ERROR__JSON_RPC__SERVER_ERROR_LONG_TERM_STORAGE_SLOT_SKIPPED:
              case SOLANA_ERROR__JSON_RPC__SERVER_ERROR_SLOT_SKIPPED:
              case SOLANA_ERROR__JSON_RPC__SERVER_ERROR_TRANSACTION_PRECOMPILE_VERIFICATION_FAILURE:
              case SOLANA_ERROR__JSON_RPC__SERVER_ERROR_UNSUPPORTED_TRANSACTION_VERSION:
                errorContext = { __serverMessage: message };
                break;
              default:
                if (typeof data === "object" && !Array.isArray(data)) {
                  errorContext = data;
                }
            }
            out = new SolanaError(code, errorContext);
          }
        } else {
          const message = typeof putativeErrorResponse === "object" && putativeErrorResponse !== null && "message" in putativeErrorResponse && typeof putativeErrorResponse.message === "string" ? putativeErrorResponse.message : "Malformed JSON-RPC error with no message attribute";
          out = new SolanaError(SOLANA_ERROR__MALFORMED_JSON_RPC_ERROR, { error: putativeErrorResponse, message });
        }
        safeCaptureStackTrace(out, getSolanaErrorFromJsonRpcError);
        return out;
      }
      function isRpcErrorResponse(value) {
        return typeof value === "object" && value !== null && "code" in value && "message" in value && (typeof value.code === "number" || typeof value.code === "bigint") && typeof value.message === "string";
      }
      exports.SOLANA_ERROR__ACCOUNTS__ACCOUNT_NOT_FOUND = SOLANA_ERROR__ACCOUNTS__ACCOUNT_NOT_FOUND;
      exports.SOLANA_ERROR__ACCOUNTS__EXPECTED_ALL_ACCOUNTS_TO_BE_DECODED = SOLANA_ERROR__ACCOUNTS__EXPECTED_ALL_ACCOUNTS_TO_BE_DECODED;
      exports.SOLANA_ERROR__ACCOUNTS__EXPECTED_DECODED_ACCOUNT = SOLANA_ERROR__ACCOUNTS__EXPECTED_DECODED_ACCOUNT;
      exports.SOLANA_ERROR__ACCOUNTS__FAILED_TO_DECODE_ACCOUNT = SOLANA_ERROR__ACCOUNTS__FAILED_TO_DECODE_ACCOUNT;
      exports.SOLANA_ERROR__ACCOUNTS__ONE_OR_MORE_ACCOUNTS_NOT_FOUND = SOLANA_ERROR__ACCOUNTS__ONE_OR_MORE_ACCOUNTS_NOT_FOUND;
      exports.SOLANA_ERROR__ADDRESSES__FAILED_TO_FIND_VIABLE_PDA_BUMP_SEED = SOLANA_ERROR__ADDRESSES__FAILED_TO_FIND_VIABLE_PDA_BUMP_SEED;
      exports.SOLANA_ERROR__ADDRESSES__INVALID_BASE58_ENCODED_ADDRESS = SOLANA_ERROR__ADDRESSES__INVALID_BASE58_ENCODED_ADDRESS;
      exports.SOLANA_ERROR__ADDRESSES__INVALID_BYTE_LENGTH = SOLANA_ERROR__ADDRESSES__INVALID_BYTE_LENGTH;
      exports.SOLANA_ERROR__ADDRESSES__INVALID_ED25519_PUBLIC_KEY = SOLANA_ERROR__ADDRESSES__INVALID_ED25519_PUBLIC_KEY;
      exports.SOLANA_ERROR__ADDRESSES__INVALID_OFF_CURVE_ADDRESS = SOLANA_ERROR__ADDRESSES__INVALID_OFF_CURVE_ADDRESS;
      exports.SOLANA_ERROR__ADDRESSES__INVALID_SEEDS_POINT_ON_CURVE = SOLANA_ERROR__ADDRESSES__INVALID_SEEDS_POINT_ON_CURVE;
      exports.SOLANA_ERROR__ADDRESSES__MALFORMED_PDA = SOLANA_ERROR__ADDRESSES__MALFORMED_PDA;
      exports.SOLANA_ERROR__ADDRESSES__MAX_NUMBER_OF_PDA_SEEDS_EXCEEDED = SOLANA_ERROR__ADDRESSES__MAX_NUMBER_OF_PDA_SEEDS_EXCEEDED;
      exports.SOLANA_ERROR__ADDRESSES__MAX_PDA_SEED_LENGTH_EXCEEDED = SOLANA_ERROR__ADDRESSES__MAX_PDA_SEED_LENGTH_EXCEEDED;
      exports.SOLANA_ERROR__ADDRESSES__PDA_BUMP_SEED_OUT_OF_RANGE = SOLANA_ERROR__ADDRESSES__PDA_BUMP_SEED_OUT_OF_RANGE;
      exports.SOLANA_ERROR__ADDRESSES__PDA_ENDS_WITH_PDA_MARKER = SOLANA_ERROR__ADDRESSES__PDA_ENDS_WITH_PDA_MARKER;
      exports.SOLANA_ERROR__ADDRESSES__STRING_LENGTH_OUT_OF_RANGE = SOLANA_ERROR__ADDRESSES__STRING_LENGTH_OUT_OF_RANGE;
      exports.SOLANA_ERROR__BLOCKHASH_STRING_LENGTH_OUT_OF_RANGE = SOLANA_ERROR__BLOCKHASH_STRING_LENGTH_OUT_OF_RANGE;
      exports.SOLANA_ERROR__BLOCK_HEIGHT_EXCEEDED = SOLANA_ERROR__BLOCK_HEIGHT_EXCEEDED;
      exports.SOLANA_ERROR__CODECS__CANNOT_DECODE_EMPTY_BYTE_ARRAY = SOLANA_ERROR__CODECS__CANNOT_DECODE_EMPTY_BYTE_ARRAY;
      exports.SOLANA_ERROR__CODECS__CANNOT_USE_LEXICAL_VALUES_AS_ENUM_DISCRIMINATORS = SOLANA_ERROR__CODECS__CANNOT_USE_LEXICAL_VALUES_AS_ENUM_DISCRIMINATORS;
      exports.SOLANA_ERROR__CODECS__ENCODED_BYTES_MUST_NOT_INCLUDE_SENTINEL = SOLANA_ERROR__CODECS__ENCODED_BYTES_MUST_NOT_INCLUDE_SENTINEL;
      exports.SOLANA_ERROR__CODECS__ENCODER_DECODER_FIXED_SIZE_MISMATCH = SOLANA_ERROR__CODECS__ENCODER_DECODER_FIXED_SIZE_MISMATCH;
      exports.SOLANA_ERROR__CODECS__ENCODER_DECODER_MAX_SIZE_MISMATCH = SOLANA_ERROR__CODECS__ENCODER_DECODER_MAX_SIZE_MISMATCH;
      exports.SOLANA_ERROR__CODECS__ENCODER_DECODER_SIZE_COMPATIBILITY_MISMATCH = SOLANA_ERROR__CODECS__ENCODER_DECODER_SIZE_COMPATIBILITY_MISMATCH;
      exports.SOLANA_ERROR__CODECS__ENUM_DISCRIMINATOR_OUT_OF_RANGE = SOLANA_ERROR__CODECS__ENUM_DISCRIMINATOR_OUT_OF_RANGE;
      exports.SOLANA_ERROR__CODECS__EXPECTED_FIXED_LENGTH = SOLANA_ERROR__CODECS__EXPECTED_FIXED_LENGTH;
      exports.SOLANA_ERROR__CODECS__EXPECTED_POSITIVE_BYTE_LENGTH = SOLANA_ERROR__CODECS__EXPECTED_POSITIVE_BYTE_LENGTH;
      exports.SOLANA_ERROR__CODECS__EXPECTED_VARIABLE_LENGTH = SOLANA_ERROR__CODECS__EXPECTED_VARIABLE_LENGTH;
      exports.SOLANA_ERROR__CODECS__EXPECTED_ZERO_VALUE_TO_MATCH_ITEM_FIXED_SIZE = SOLANA_ERROR__CODECS__EXPECTED_ZERO_VALUE_TO_MATCH_ITEM_FIXED_SIZE;
      exports.SOLANA_ERROR__CODECS__INVALID_BYTE_LENGTH = SOLANA_ERROR__CODECS__INVALID_BYTE_LENGTH;
      exports.SOLANA_ERROR__CODECS__INVALID_CONSTANT = SOLANA_ERROR__CODECS__INVALID_CONSTANT;
      exports.SOLANA_ERROR__CODECS__INVALID_DISCRIMINATED_UNION_VARIANT = SOLANA_ERROR__CODECS__INVALID_DISCRIMINATED_UNION_VARIANT;
      exports.SOLANA_ERROR__CODECS__INVALID_ENUM_VARIANT = SOLANA_ERROR__CODECS__INVALID_ENUM_VARIANT;
      exports.SOLANA_ERROR__CODECS__INVALID_LITERAL_UNION_VARIANT = SOLANA_ERROR__CODECS__INVALID_LITERAL_UNION_VARIANT;
      exports.SOLANA_ERROR__CODECS__INVALID_NUMBER_OF_ITEMS = SOLANA_ERROR__CODECS__INVALID_NUMBER_OF_ITEMS;
      exports.SOLANA_ERROR__CODECS__INVALID_STRING_FOR_BASE = SOLANA_ERROR__CODECS__INVALID_STRING_FOR_BASE;
      exports.SOLANA_ERROR__CODECS__LITERAL_UNION_DISCRIMINATOR_OUT_OF_RANGE = SOLANA_ERROR__CODECS__LITERAL_UNION_DISCRIMINATOR_OUT_OF_RANGE;
      exports.SOLANA_ERROR__CODECS__NUMBER_OUT_OF_RANGE = SOLANA_ERROR__CODECS__NUMBER_OUT_OF_RANGE;
      exports.SOLANA_ERROR__CODECS__OFFSET_OUT_OF_RANGE = SOLANA_ERROR__CODECS__OFFSET_OUT_OF_RANGE;
      exports.SOLANA_ERROR__CODECS__SENTINEL_MISSING_IN_DECODED_BYTES = SOLANA_ERROR__CODECS__SENTINEL_MISSING_IN_DECODED_BYTES;
      exports.SOLANA_ERROR__CODECS__UNION_VARIANT_OUT_OF_RANGE = SOLANA_ERROR__CODECS__UNION_VARIANT_OUT_OF_RANGE;
      exports.SOLANA_ERROR__CRYPTO__RANDOM_VALUES_FUNCTION_UNIMPLEMENTED = SOLANA_ERROR__CRYPTO__RANDOM_VALUES_FUNCTION_UNIMPLEMENTED;
      exports.SOLANA_ERROR__INSTRUCTION_ERROR__ACCOUNT_ALREADY_INITIALIZED = SOLANA_ERROR__INSTRUCTION_ERROR__ACCOUNT_ALREADY_INITIALIZED;
      exports.SOLANA_ERROR__INSTRUCTION_ERROR__ACCOUNT_BORROW_FAILED = SOLANA_ERROR__INSTRUCTION_ERROR__ACCOUNT_BORROW_FAILED;
      exports.SOLANA_ERROR__INSTRUCTION_ERROR__ACCOUNT_BORROW_OUTSTANDING = SOLANA_ERROR__INSTRUCTION_ERROR__ACCOUNT_BORROW_OUTSTANDING;
      exports.SOLANA_ERROR__INSTRUCTION_ERROR__ACCOUNT_DATA_SIZE_CHANGED = SOLANA_ERROR__INSTRUCTION_ERROR__ACCOUNT_DATA_SIZE_CHANGED;
      exports.SOLANA_ERROR__INSTRUCTION_ERROR__ACCOUNT_DATA_TOO_SMALL = SOLANA_ERROR__INSTRUCTION_ERROR__ACCOUNT_DATA_TOO_SMALL;
      exports.SOLANA_ERROR__INSTRUCTION_ERROR__ACCOUNT_NOT_EXECUTABLE = SOLANA_ERROR__INSTRUCTION_ERROR__ACCOUNT_NOT_EXECUTABLE;
      exports.SOLANA_ERROR__INSTRUCTION_ERROR__ACCOUNT_NOT_RENT_EXEMPT = SOLANA_ERROR__INSTRUCTION_ERROR__ACCOUNT_NOT_RENT_EXEMPT;
      exports.SOLANA_ERROR__INSTRUCTION_ERROR__ARITHMETIC_OVERFLOW = SOLANA_ERROR__INSTRUCTION_ERROR__ARITHMETIC_OVERFLOW;
      exports.SOLANA_ERROR__INSTRUCTION_ERROR__BORSH_IO_ERROR = SOLANA_ERROR__INSTRUCTION_ERROR__BORSH_IO_ERROR;
      exports.SOLANA_ERROR__INSTRUCTION_ERROR__BUILTIN_PROGRAMS_MUST_CONSUME_COMPUTE_UNITS = SOLANA_ERROR__INSTRUCTION_ERROR__BUILTIN_PROGRAMS_MUST_CONSUME_COMPUTE_UNITS;
      exports.SOLANA_ERROR__INSTRUCTION_ERROR__CALL_DEPTH = SOLANA_ERROR__INSTRUCTION_ERROR__CALL_DEPTH;
      exports.SOLANA_ERROR__INSTRUCTION_ERROR__COMPUTATIONAL_BUDGET_EXCEEDED = SOLANA_ERROR__INSTRUCTION_ERROR__COMPUTATIONAL_BUDGET_EXCEEDED;
      exports.SOLANA_ERROR__INSTRUCTION_ERROR__CUSTOM = SOLANA_ERROR__INSTRUCTION_ERROR__CUSTOM;
      exports.SOLANA_ERROR__INSTRUCTION_ERROR__DUPLICATE_ACCOUNT_INDEX = SOLANA_ERROR__INSTRUCTION_ERROR__DUPLICATE_ACCOUNT_INDEX;
      exports.SOLANA_ERROR__INSTRUCTION_ERROR__DUPLICATE_ACCOUNT_OUT_OF_SYNC = SOLANA_ERROR__INSTRUCTION_ERROR__DUPLICATE_ACCOUNT_OUT_OF_SYNC;
      exports.SOLANA_ERROR__INSTRUCTION_ERROR__EXECUTABLE_ACCOUNT_NOT_RENT_EXEMPT = SOLANA_ERROR__INSTRUCTION_ERROR__EXECUTABLE_ACCOUNT_NOT_RENT_EXEMPT;
      exports.SOLANA_ERROR__INSTRUCTION_ERROR__EXECUTABLE_DATA_MODIFIED = SOLANA_ERROR__INSTRUCTION_ERROR__EXECUTABLE_DATA_MODIFIED;
      exports.SOLANA_ERROR__INSTRUCTION_ERROR__EXECUTABLE_LAMPORT_CHANGE = SOLANA_ERROR__INSTRUCTION_ERROR__EXECUTABLE_LAMPORT_CHANGE;
      exports.SOLANA_ERROR__INSTRUCTION_ERROR__EXECUTABLE_MODIFIED = SOLANA_ERROR__INSTRUCTION_ERROR__EXECUTABLE_MODIFIED;
      exports.SOLANA_ERROR__INSTRUCTION_ERROR__EXTERNAL_ACCOUNT_DATA_MODIFIED = SOLANA_ERROR__INSTRUCTION_ERROR__EXTERNAL_ACCOUNT_DATA_MODIFIED;
      exports.SOLANA_ERROR__INSTRUCTION_ERROR__EXTERNAL_ACCOUNT_LAMPORT_SPEND = SOLANA_ERROR__INSTRUCTION_ERROR__EXTERNAL_ACCOUNT_LAMPORT_SPEND;
      exports.SOLANA_ERROR__INSTRUCTION_ERROR__GENERIC_ERROR = SOLANA_ERROR__INSTRUCTION_ERROR__GENERIC_ERROR;
      exports.SOLANA_ERROR__INSTRUCTION_ERROR__ILLEGAL_OWNER = SOLANA_ERROR__INSTRUCTION_ERROR__ILLEGAL_OWNER;
      exports.SOLANA_ERROR__INSTRUCTION_ERROR__IMMUTABLE = SOLANA_ERROR__INSTRUCTION_ERROR__IMMUTABLE;
      exports.SOLANA_ERROR__INSTRUCTION_ERROR__INCORRECT_AUTHORITY = SOLANA_ERROR__INSTRUCTION_ERROR__INCORRECT_AUTHORITY;
      exports.SOLANA_ERROR__INSTRUCTION_ERROR__INCORRECT_PROGRAM_ID = SOLANA_ERROR__INSTRUCTION_ERROR__INCORRECT_PROGRAM_ID;
      exports.SOLANA_ERROR__INSTRUCTION_ERROR__INSUFFICIENT_FUNDS = SOLANA_ERROR__INSTRUCTION_ERROR__INSUFFICIENT_FUNDS;
      exports.SOLANA_ERROR__INSTRUCTION_ERROR__INVALID_ACCOUNT_DATA = SOLANA_ERROR__INSTRUCTION_ERROR__INVALID_ACCOUNT_DATA;
      exports.SOLANA_ERROR__INSTRUCTION_ERROR__INVALID_ACCOUNT_OWNER = SOLANA_ERROR__INSTRUCTION_ERROR__INVALID_ACCOUNT_OWNER;
      exports.SOLANA_ERROR__INSTRUCTION_ERROR__INVALID_ARGUMENT = SOLANA_ERROR__INSTRUCTION_ERROR__INVALID_ARGUMENT;
      exports.SOLANA_ERROR__INSTRUCTION_ERROR__INVALID_ERROR = SOLANA_ERROR__INSTRUCTION_ERROR__INVALID_ERROR;
      exports.SOLANA_ERROR__INSTRUCTION_ERROR__INVALID_INSTRUCTION_DATA = SOLANA_ERROR__INSTRUCTION_ERROR__INVALID_INSTRUCTION_DATA;
      exports.SOLANA_ERROR__INSTRUCTION_ERROR__INVALID_REALLOC = SOLANA_ERROR__INSTRUCTION_ERROR__INVALID_REALLOC;
      exports.SOLANA_ERROR__INSTRUCTION_ERROR__INVALID_SEEDS = SOLANA_ERROR__INSTRUCTION_ERROR__INVALID_SEEDS;
      exports.SOLANA_ERROR__INSTRUCTION_ERROR__MAX_ACCOUNTS_DATA_ALLOCATIONS_EXCEEDED = SOLANA_ERROR__INSTRUCTION_ERROR__MAX_ACCOUNTS_DATA_ALLOCATIONS_EXCEEDED;
      exports.SOLANA_ERROR__INSTRUCTION_ERROR__MAX_ACCOUNTS_EXCEEDED = SOLANA_ERROR__INSTRUCTION_ERROR__MAX_ACCOUNTS_EXCEEDED;
      exports.SOLANA_ERROR__INSTRUCTION_ERROR__MAX_INSTRUCTION_TRACE_LENGTH_EXCEEDED = SOLANA_ERROR__INSTRUCTION_ERROR__MAX_INSTRUCTION_TRACE_LENGTH_EXCEEDED;
      exports.SOLANA_ERROR__INSTRUCTION_ERROR__MAX_SEED_LENGTH_EXCEEDED = SOLANA_ERROR__INSTRUCTION_ERROR__MAX_SEED_LENGTH_EXCEEDED;
      exports.SOLANA_ERROR__INSTRUCTION_ERROR__MISSING_ACCOUNT = SOLANA_ERROR__INSTRUCTION_ERROR__MISSING_ACCOUNT;
      exports.SOLANA_ERROR__INSTRUCTION_ERROR__MISSING_REQUIRED_SIGNATURE = SOLANA_ERROR__INSTRUCTION_ERROR__MISSING_REQUIRED_SIGNATURE;
      exports.SOLANA_ERROR__INSTRUCTION_ERROR__MODIFIED_PROGRAM_ID = SOLANA_ERROR__INSTRUCTION_ERROR__MODIFIED_PROGRAM_ID;
      exports.SOLANA_ERROR__INSTRUCTION_ERROR__NOT_ENOUGH_ACCOUNT_KEYS = SOLANA_ERROR__INSTRUCTION_ERROR__NOT_ENOUGH_ACCOUNT_KEYS;
      exports.SOLANA_ERROR__INSTRUCTION_ERROR__PRIVILEGE_ESCALATION = SOLANA_ERROR__INSTRUCTION_ERROR__PRIVILEGE_ESCALATION;
      exports.SOLANA_ERROR__INSTRUCTION_ERROR__PROGRAM_ENVIRONMENT_SETUP_FAILURE = SOLANA_ERROR__INSTRUCTION_ERROR__PROGRAM_ENVIRONMENT_SETUP_FAILURE;
      exports.SOLANA_ERROR__INSTRUCTION_ERROR__PROGRAM_FAILED_TO_COMPILE = SOLANA_ERROR__INSTRUCTION_ERROR__PROGRAM_FAILED_TO_COMPILE;
      exports.SOLANA_ERROR__INSTRUCTION_ERROR__PROGRAM_FAILED_TO_COMPLETE = SOLANA_ERROR__INSTRUCTION_ERROR__PROGRAM_FAILED_TO_COMPLETE;
      exports.SOLANA_ERROR__INSTRUCTION_ERROR__READONLY_DATA_MODIFIED = SOLANA_ERROR__INSTRUCTION_ERROR__READONLY_DATA_MODIFIED;
      exports.SOLANA_ERROR__INSTRUCTION_ERROR__READONLY_LAMPORT_CHANGE = SOLANA_ERROR__INSTRUCTION_ERROR__READONLY_LAMPORT_CHANGE;
      exports.SOLANA_ERROR__INSTRUCTION_ERROR__REENTRANCY_NOT_ALLOWED = SOLANA_ERROR__INSTRUCTION_ERROR__REENTRANCY_NOT_ALLOWED;
      exports.SOLANA_ERROR__INSTRUCTION_ERROR__RENT_EPOCH_MODIFIED = SOLANA_ERROR__INSTRUCTION_ERROR__RENT_EPOCH_MODIFIED;
      exports.SOLANA_ERROR__INSTRUCTION_ERROR__UNBALANCED_INSTRUCTION = SOLANA_ERROR__INSTRUCTION_ERROR__UNBALANCED_INSTRUCTION;
      exports.SOLANA_ERROR__INSTRUCTION_ERROR__UNINITIALIZED_ACCOUNT = SOLANA_ERROR__INSTRUCTION_ERROR__UNINITIALIZED_ACCOUNT;
      exports.SOLANA_ERROR__INSTRUCTION_ERROR__UNKNOWN = SOLANA_ERROR__INSTRUCTION_ERROR__UNKNOWN;
      exports.SOLANA_ERROR__INSTRUCTION_ERROR__UNSUPPORTED_PROGRAM_ID = SOLANA_ERROR__INSTRUCTION_ERROR__UNSUPPORTED_PROGRAM_ID;
      exports.SOLANA_ERROR__INSTRUCTION_ERROR__UNSUPPORTED_SYSVAR = SOLANA_ERROR__INSTRUCTION_ERROR__UNSUPPORTED_SYSVAR;
      exports.SOLANA_ERROR__INSTRUCTION__EXPECTED_TO_HAVE_ACCOUNTS = SOLANA_ERROR__INSTRUCTION__EXPECTED_TO_HAVE_ACCOUNTS;
      exports.SOLANA_ERROR__INSTRUCTION__EXPECTED_TO_HAVE_DATA = SOLANA_ERROR__INSTRUCTION__EXPECTED_TO_HAVE_DATA;
      exports.SOLANA_ERROR__INSTRUCTION__PROGRAM_ID_MISMATCH = SOLANA_ERROR__INSTRUCTION__PROGRAM_ID_MISMATCH;
      exports.SOLANA_ERROR__INVALID_BLOCKHASH_BYTE_LENGTH = SOLANA_ERROR__INVALID_BLOCKHASH_BYTE_LENGTH;
      exports.SOLANA_ERROR__INVALID_NONCE = SOLANA_ERROR__INVALID_NONCE;
      exports.SOLANA_ERROR__INVARIANT_VIOLATION__CACHED_ABORTABLE_ITERABLE_CACHE_ENTRY_MISSING = SOLANA_ERROR__INVARIANT_VIOLATION__CACHED_ABORTABLE_ITERABLE_CACHE_ENTRY_MISSING;
      exports.SOLANA_ERROR__INVARIANT_VIOLATION__DATA_PUBLISHER_CHANNEL_UNIMPLEMENTED = SOLANA_ERROR__INVARIANT_VIOLATION__DATA_PUBLISHER_CHANNEL_UNIMPLEMENTED;
      exports.SOLANA_ERROR__INVARIANT_VIOLATION__SUBSCRIPTION_ITERATOR_MUST_NOT_POLL_BEFORE_RESOLVING_EXISTING_MESSAGE_PROMISE = SOLANA_ERROR__INVARIANT_VIOLATION__SUBSCRIPTION_ITERATOR_MUST_NOT_POLL_BEFORE_RESOLVING_EXISTING_MESSAGE_PROMISE;
      exports.SOLANA_ERROR__INVARIANT_VIOLATION__SUBSCRIPTION_ITERATOR_STATE_MISSING = SOLANA_ERROR__INVARIANT_VIOLATION__SUBSCRIPTION_ITERATOR_STATE_MISSING;
      exports.SOLANA_ERROR__INVARIANT_VIOLATION__SWITCH_MUST_BE_EXHAUSTIVE = SOLANA_ERROR__INVARIANT_VIOLATION__SWITCH_MUST_BE_EXHAUSTIVE;
      exports.SOLANA_ERROR__JSON_RPC__INTERNAL_ERROR = SOLANA_ERROR__JSON_RPC__INTERNAL_ERROR;
      exports.SOLANA_ERROR__JSON_RPC__INVALID_PARAMS = SOLANA_ERROR__JSON_RPC__INVALID_PARAMS;
      exports.SOLANA_ERROR__JSON_RPC__INVALID_REQUEST = SOLANA_ERROR__JSON_RPC__INVALID_REQUEST;
      exports.SOLANA_ERROR__JSON_RPC__METHOD_NOT_FOUND = SOLANA_ERROR__JSON_RPC__METHOD_NOT_FOUND;
      exports.SOLANA_ERROR__JSON_RPC__PARSE_ERROR = SOLANA_ERROR__JSON_RPC__PARSE_ERROR;
      exports.SOLANA_ERROR__JSON_RPC__SCAN_ERROR = SOLANA_ERROR__JSON_RPC__SCAN_ERROR;
      exports.SOLANA_ERROR__JSON_RPC__SERVER_ERROR_BLOCK_CLEANED_UP = SOLANA_ERROR__JSON_RPC__SERVER_ERROR_BLOCK_CLEANED_UP;
      exports.SOLANA_ERROR__JSON_RPC__SERVER_ERROR_BLOCK_NOT_AVAILABLE = SOLANA_ERROR__JSON_RPC__SERVER_ERROR_BLOCK_NOT_AVAILABLE;
      exports.SOLANA_ERROR__JSON_RPC__SERVER_ERROR_BLOCK_STATUS_NOT_AVAILABLE_YET = SOLANA_ERROR__JSON_RPC__SERVER_ERROR_BLOCK_STATUS_NOT_AVAILABLE_YET;
      exports.SOLANA_ERROR__JSON_RPC__SERVER_ERROR_KEY_EXCLUDED_FROM_SECONDARY_INDEX = SOLANA_ERROR__JSON_RPC__SERVER_ERROR_KEY_EXCLUDED_FROM_SECONDARY_INDEX;
      exports.SOLANA_ERROR__JSON_RPC__SERVER_ERROR_LONG_TERM_STORAGE_SLOT_SKIPPED = SOLANA_ERROR__JSON_RPC__SERVER_ERROR_LONG_TERM_STORAGE_SLOT_SKIPPED;
      exports.SOLANA_ERROR__JSON_RPC__SERVER_ERROR_MIN_CONTEXT_SLOT_NOT_REACHED = SOLANA_ERROR__JSON_RPC__SERVER_ERROR_MIN_CONTEXT_SLOT_NOT_REACHED;
      exports.SOLANA_ERROR__JSON_RPC__SERVER_ERROR_NODE_UNHEALTHY = SOLANA_ERROR__JSON_RPC__SERVER_ERROR_NODE_UNHEALTHY;
      exports.SOLANA_ERROR__JSON_RPC__SERVER_ERROR_NO_SNAPSHOT = SOLANA_ERROR__JSON_RPC__SERVER_ERROR_NO_SNAPSHOT;
      exports.SOLANA_ERROR__JSON_RPC__SERVER_ERROR_SEND_TRANSACTION_PREFLIGHT_FAILURE = SOLANA_ERROR__JSON_RPC__SERVER_ERROR_SEND_TRANSACTION_PREFLIGHT_FAILURE;
      exports.SOLANA_ERROR__JSON_RPC__SERVER_ERROR_SLOT_SKIPPED = SOLANA_ERROR__JSON_RPC__SERVER_ERROR_SLOT_SKIPPED;
      exports.SOLANA_ERROR__JSON_RPC__SERVER_ERROR_TRANSACTION_HISTORY_NOT_AVAILABLE = SOLANA_ERROR__JSON_RPC__SERVER_ERROR_TRANSACTION_HISTORY_NOT_AVAILABLE;
      exports.SOLANA_ERROR__JSON_RPC__SERVER_ERROR_TRANSACTION_PRECOMPILE_VERIFICATION_FAILURE = SOLANA_ERROR__JSON_RPC__SERVER_ERROR_TRANSACTION_PRECOMPILE_VERIFICATION_FAILURE;
      exports.SOLANA_ERROR__JSON_RPC__SERVER_ERROR_TRANSACTION_SIGNATURE_LEN_MISMATCH = SOLANA_ERROR__JSON_RPC__SERVER_ERROR_TRANSACTION_SIGNATURE_LEN_MISMATCH;
      exports.SOLANA_ERROR__JSON_RPC__SERVER_ERROR_TRANSACTION_SIGNATURE_VERIFICATION_FAILURE = SOLANA_ERROR__JSON_RPC__SERVER_ERROR_TRANSACTION_SIGNATURE_VERIFICATION_FAILURE;
      exports.SOLANA_ERROR__JSON_RPC__SERVER_ERROR_UNSUPPORTED_TRANSACTION_VERSION = SOLANA_ERROR__JSON_RPC__SERVER_ERROR_UNSUPPORTED_TRANSACTION_VERSION;
      exports.SOLANA_ERROR__KEYS__INVALID_KEY_PAIR_BYTE_LENGTH = SOLANA_ERROR__KEYS__INVALID_KEY_PAIR_BYTE_LENGTH;
      exports.SOLANA_ERROR__KEYS__INVALID_PRIVATE_KEY_BYTE_LENGTH = SOLANA_ERROR__KEYS__INVALID_PRIVATE_KEY_BYTE_LENGTH;
      exports.SOLANA_ERROR__KEYS__INVALID_SIGNATURE_BYTE_LENGTH = SOLANA_ERROR__KEYS__INVALID_SIGNATURE_BYTE_LENGTH;
      exports.SOLANA_ERROR__KEYS__PUBLIC_KEY_MUST_MATCH_PRIVATE_KEY = SOLANA_ERROR__KEYS__PUBLIC_KEY_MUST_MATCH_PRIVATE_KEY;
      exports.SOLANA_ERROR__KEYS__SIGNATURE_STRING_LENGTH_OUT_OF_RANGE = SOLANA_ERROR__KEYS__SIGNATURE_STRING_LENGTH_OUT_OF_RANGE;
      exports.SOLANA_ERROR__LAMPORTS_OUT_OF_RANGE = SOLANA_ERROR__LAMPORTS_OUT_OF_RANGE;
      exports.SOLANA_ERROR__MALFORMED_BIGINT_STRING = SOLANA_ERROR__MALFORMED_BIGINT_STRING;
      exports.SOLANA_ERROR__MALFORMED_JSON_RPC_ERROR = SOLANA_ERROR__MALFORMED_JSON_RPC_ERROR;
      exports.SOLANA_ERROR__MALFORMED_NUMBER_STRING = SOLANA_ERROR__MALFORMED_NUMBER_STRING;
      exports.SOLANA_ERROR__NONCE_ACCOUNT_NOT_FOUND = SOLANA_ERROR__NONCE_ACCOUNT_NOT_FOUND;
      exports.SOLANA_ERROR__RPC_SUBSCRIPTIONS__CANNOT_CREATE_SUBSCRIPTION_PLAN = SOLANA_ERROR__RPC_SUBSCRIPTIONS__CANNOT_CREATE_SUBSCRIPTION_PLAN;
      exports.SOLANA_ERROR__RPC_SUBSCRIPTIONS__CHANNEL_CLOSED_BEFORE_MESSAGE_BUFFERED = SOLANA_ERROR__RPC_SUBSCRIPTIONS__CHANNEL_CLOSED_BEFORE_MESSAGE_BUFFERED;
      exports.SOLANA_ERROR__RPC_SUBSCRIPTIONS__CHANNEL_CONNECTION_CLOSED = SOLANA_ERROR__RPC_SUBSCRIPTIONS__CHANNEL_CONNECTION_CLOSED;
      exports.SOLANA_ERROR__RPC_SUBSCRIPTIONS__CHANNEL_FAILED_TO_CONNECT = SOLANA_ERROR__RPC_SUBSCRIPTIONS__CHANNEL_FAILED_TO_CONNECT;
      exports.SOLANA_ERROR__RPC_SUBSCRIPTIONS__EXPECTED_SERVER_SUBSCRIPTION_ID = SOLANA_ERROR__RPC_SUBSCRIPTIONS__EXPECTED_SERVER_SUBSCRIPTION_ID;
      exports.SOLANA_ERROR__RPC__API_PLAN_MISSING_FOR_RPC_METHOD = SOLANA_ERROR__RPC__API_PLAN_MISSING_FOR_RPC_METHOD;
      exports.SOLANA_ERROR__RPC__INTEGER_OVERFLOW = SOLANA_ERROR__RPC__INTEGER_OVERFLOW;
      exports.SOLANA_ERROR__RPC__TRANSPORT_HTTP_ERROR = SOLANA_ERROR__RPC__TRANSPORT_HTTP_ERROR;
      exports.SOLANA_ERROR__RPC__TRANSPORT_HTTP_HEADER_FORBIDDEN = SOLANA_ERROR__RPC__TRANSPORT_HTTP_HEADER_FORBIDDEN;
      exports.SOLANA_ERROR__SIGNER__ADDRESS_CANNOT_HAVE_MULTIPLE_SIGNERS = SOLANA_ERROR__SIGNER__ADDRESS_CANNOT_HAVE_MULTIPLE_SIGNERS;
      exports.SOLANA_ERROR__SIGNER__EXPECTED_KEY_PAIR_SIGNER = SOLANA_ERROR__SIGNER__EXPECTED_KEY_PAIR_SIGNER;
      exports.SOLANA_ERROR__SIGNER__EXPECTED_MESSAGE_MODIFYING_SIGNER = SOLANA_ERROR__SIGNER__EXPECTED_MESSAGE_MODIFYING_SIGNER;
      exports.SOLANA_ERROR__SIGNER__EXPECTED_MESSAGE_PARTIAL_SIGNER = SOLANA_ERROR__SIGNER__EXPECTED_MESSAGE_PARTIAL_SIGNER;
      exports.SOLANA_ERROR__SIGNER__EXPECTED_MESSAGE_SIGNER = SOLANA_ERROR__SIGNER__EXPECTED_MESSAGE_SIGNER;
      exports.SOLANA_ERROR__SIGNER__EXPECTED_TRANSACTION_MODIFYING_SIGNER = SOLANA_ERROR__SIGNER__EXPECTED_TRANSACTION_MODIFYING_SIGNER;
      exports.SOLANA_ERROR__SIGNER__EXPECTED_TRANSACTION_PARTIAL_SIGNER = SOLANA_ERROR__SIGNER__EXPECTED_TRANSACTION_PARTIAL_SIGNER;
      exports.SOLANA_ERROR__SIGNER__EXPECTED_TRANSACTION_SENDING_SIGNER = SOLANA_ERROR__SIGNER__EXPECTED_TRANSACTION_SENDING_SIGNER;
      exports.SOLANA_ERROR__SIGNER__EXPECTED_TRANSACTION_SIGNER = SOLANA_ERROR__SIGNER__EXPECTED_TRANSACTION_SIGNER;
      exports.SOLANA_ERROR__SIGNER__TRANSACTION_CANNOT_HAVE_MULTIPLE_SENDING_SIGNERS = SOLANA_ERROR__SIGNER__TRANSACTION_CANNOT_HAVE_MULTIPLE_SENDING_SIGNERS;
      exports.SOLANA_ERROR__SIGNER__TRANSACTION_SENDING_SIGNER_MISSING = SOLANA_ERROR__SIGNER__TRANSACTION_SENDING_SIGNER_MISSING;
      exports.SOLANA_ERROR__SIGNER__WALLET_MULTISIGN_UNIMPLEMENTED = SOLANA_ERROR__SIGNER__WALLET_MULTISIGN_UNIMPLEMENTED;
      exports.SOLANA_ERROR__SUBTLE_CRYPTO__CANNOT_EXPORT_NON_EXTRACTABLE_KEY = SOLANA_ERROR__SUBTLE_CRYPTO__CANNOT_EXPORT_NON_EXTRACTABLE_KEY;
      exports.SOLANA_ERROR__SUBTLE_CRYPTO__DIGEST_UNIMPLEMENTED = SOLANA_ERROR__SUBTLE_CRYPTO__DIGEST_UNIMPLEMENTED;
      exports.SOLANA_ERROR__SUBTLE_CRYPTO__DISALLOWED_IN_INSECURE_CONTEXT = SOLANA_ERROR__SUBTLE_CRYPTO__DISALLOWED_IN_INSECURE_CONTEXT;
      exports.SOLANA_ERROR__SUBTLE_CRYPTO__ED25519_ALGORITHM_UNIMPLEMENTED = SOLANA_ERROR__SUBTLE_CRYPTO__ED25519_ALGORITHM_UNIMPLEMENTED;
      exports.SOLANA_ERROR__SUBTLE_CRYPTO__EXPORT_FUNCTION_UNIMPLEMENTED = SOLANA_ERROR__SUBTLE_CRYPTO__EXPORT_FUNCTION_UNIMPLEMENTED;
      exports.SOLANA_ERROR__SUBTLE_CRYPTO__GENERATE_FUNCTION_UNIMPLEMENTED = SOLANA_ERROR__SUBTLE_CRYPTO__GENERATE_FUNCTION_UNIMPLEMENTED;
      exports.SOLANA_ERROR__SUBTLE_CRYPTO__SIGN_FUNCTION_UNIMPLEMENTED = SOLANA_ERROR__SUBTLE_CRYPTO__SIGN_FUNCTION_UNIMPLEMENTED;
      exports.SOLANA_ERROR__SUBTLE_CRYPTO__VERIFY_FUNCTION_UNIMPLEMENTED = SOLANA_ERROR__SUBTLE_CRYPTO__VERIFY_FUNCTION_UNIMPLEMENTED;
      exports.SOLANA_ERROR__TIMESTAMP_OUT_OF_RANGE = SOLANA_ERROR__TIMESTAMP_OUT_OF_RANGE;
      exports.SOLANA_ERROR__TRANSACTION_ERROR__ACCOUNT_BORROW_OUTSTANDING = SOLANA_ERROR__TRANSACTION_ERROR__ACCOUNT_BORROW_OUTSTANDING;
      exports.SOLANA_ERROR__TRANSACTION_ERROR__ACCOUNT_IN_USE = SOLANA_ERROR__TRANSACTION_ERROR__ACCOUNT_IN_USE;
      exports.SOLANA_ERROR__TRANSACTION_ERROR__ACCOUNT_LOADED_TWICE = SOLANA_ERROR__TRANSACTION_ERROR__ACCOUNT_LOADED_TWICE;
      exports.SOLANA_ERROR__TRANSACTION_ERROR__ACCOUNT_NOT_FOUND = SOLANA_ERROR__TRANSACTION_ERROR__ACCOUNT_NOT_FOUND;
      exports.SOLANA_ERROR__TRANSACTION_ERROR__ADDRESS_LOOKUP_TABLE_NOT_FOUND = SOLANA_ERROR__TRANSACTION_ERROR__ADDRESS_LOOKUP_TABLE_NOT_FOUND;
      exports.SOLANA_ERROR__TRANSACTION_ERROR__ALREADY_PROCESSED = SOLANA_ERROR__TRANSACTION_ERROR__ALREADY_PROCESSED;
      exports.SOLANA_ERROR__TRANSACTION_ERROR__BLOCKHASH_NOT_FOUND = SOLANA_ERROR__TRANSACTION_ERROR__BLOCKHASH_NOT_FOUND;
      exports.SOLANA_ERROR__TRANSACTION_ERROR__CALL_CHAIN_TOO_DEEP = SOLANA_ERROR__TRANSACTION_ERROR__CALL_CHAIN_TOO_DEEP;
      exports.SOLANA_ERROR__TRANSACTION_ERROR__CLUSTER_MAINTENANCE = SOLANA_ERROR__TRANSACTION_ERROR__CLUSTER_MAINTENANCE;
      exports.SOLANA_ERROR__TRANSACTION_ERROR__DUPLICATE_INSTRUCTION = SOLANA_ERROR__TRANSACTION_ERROR__DUPLICATE_INSTRUCTION;
      exports.SOLANA_ERROR__TRANSACTION_ERROR__INSUFFICIENT_FUNDS_FOR_FEE = SOLANA_ERROR__TRANSACTION_ERROR__INSUFFICIENT_FUNDS_FOR_FEE;
      exports.SOLANA_ERROR__TRANSACTION_ERROR__INSUFFICIENT_FUNDS_FOR_RENT = SOLANA_ERROR__TRANSACTION_ERROR__INSUFFICIENT_FUNDS_FOR_RENT;
      exports.SOLANA_ERROR__TRANSACTION_ERROR__INVALID_ACCOUNT_FOR_FEE = SOLANA_ERROR__TRANSACTION_ERROR__INVALID_ACCOUNT_FOR_FEE;
      exports.SOLANA_ERROR__TRANSACTION_ERROR__INVALID_ACCOUNT_INDEX = SOLANA_ERROR__TRANSACTION_ERROR__INVALID_ACCOUNT_INDEX;
      exports.SOLANA_ERROR__TRANSACTION_ERROR__INVALID_ADDRESS_LOOKUP_TABLE_DATA = SOLANA_ERROR__TRANSACTION_ERROR__INVALID_ADDRESS_LOOKUP_TABLE_DATA;
      exports.SOLANA_ERROR__TRANSACTION_ERROR__INVALID_ADDRESS_LOOKUP_TABLE_INDEX = SOLANA_ERROR__TRANSACTION_ERROR__INVALID_ADDRESS_LOOKUP_TABLE_INDEX;
      exports.SOLANA_ERROR__TRANSACTION_ERROR__INVALID_ADDRESS_LOOKUP_TABLE_OWNER = SOLANA_ERROR__TRANSACTION_ERROR__INVALID_ADDRESS_LOOKUP_TABLE_OWNER;
      exports.SOLANA_ERROR__TRANSACTION_ERROR__INVALID_LOADED_ACCOUNTS_DATA_SIZE_LIMIT = SOLANA_ERROR__TRANSACTION_ERROR__INVALID_LOADED_ACCOUNTS_DATA_SIZE_LIMIT;
      exports.SOLANA_ERROR__TRANSACTION_ERROR__INVALID_PROGRAM_FOR_EXECUTION = SOLANA_ERROR__TRANSACTION_ERROR__INVALID_PROGRAM_FOR_EXECUTION;
      exports.SOLANA_ERROR__TRANSACTION_ERROR__INVALID_RENT_PAYING_ACCOUNT = SOLANA_ERROR__TRANSACTION_ERROR__INVALID_RENT_PAYING_ACCOUNT;
      exports.SOLANA_ERROR__TRANSACTION_ERROR__INVALID_WRITABLE_ACCOUNT = SOLANA_ERROR__TRANSACTION_ERROR__INVALID_WRITABLE_ACCOUNT;
      exports.SOLANA_ERROR__TRANSACTION_ERROR__MAX_LOADED_ACCOUNTS_DATA_SIZE_EXCEEDED = SOLANA_ERROR__TRANSACTION_ERROR__MAX_LOADED_ACCOUNTS_DATA_SIZE_EXCEEDED;
      exports.SOLANA_ERROR__TRANSACTION_ERROR__MISSING_SIGNATURE_FOR_FEE = SOLANA_ERROR__TRANSACTION_ERROR__MISSING_SIGNATURE_FOR_FEE;
      exports.SOLANA_ERROR__TRANSACTION_ERROR__PROGRAM_ACCOUNT_NOT_FOUND = SOLANA_ERROR__TRANSACTION_ERROR__PROGRAM_ACCOUNT_NOT_FOUND;
      exports.SOLANA_ERROR__TRANSACTION_ERROR__PROGRAM_EXECUTION_TEMPORARILY_RESTRICTED = SOLANA_ERROR__TRANSACTION_ERROR__PROGRAM_EXECUTION_TEMPORARILY_RESTRICTED;
      exports.SOLANA_ERROR__TRANSACTION_ERROR__RESANITIZATION_NEEDED = SOLANA_ERROR__TRANSACTION_ERROR__RESANITIZATION_NEEDED;
      exports.SOLANA_ERROR__TRANSACTION_ERROR__SANITIZE_FAILURE = SOLANA_ERROR__TRANSACTION_ERROR__SANITIZE_FAILURE;
      exports.SOLANA_ERROR__TRANSACTION_ERROR__SIGNATURE_FAILURE = SOLANA_ERROR__TRANSACTION_ERROR__SIGNATURE_FAILURE;
      exports.SOLANA_ERROR__TRANSACTION_ERROR__TOO_MANY_ACCOUNT_LOCKS = SOLANA_ERROR__TRANSACTION_ERROR__TOO_MANY_ACCOUNT_LOCKS;
      exports.SOLANA_ERROR__TRANSACTION_ERROR__UNBALANCED_TRANSACTION = SOLANA_ERROR__TRANSACTION_ERROR__UNBALANCED_TRANSACTION;
      exports.SOLANA_ERROR__TRANSACTION_ERROR__UNKNOWN = SOLANA_ERROR__TRANSACTION_ERROR__UNKNOWN;
      exports.SOLANA_ERROR__TRANSACTION_ERROR__UNSUPPORTED_VERSION = SOLANA_ERROR__TRANSACTION_ERROR__UNSUPPORTED_VERSION;
      exports.SOLANA_ERROR__TRANSACTION_ERROR__WOULD_EXCEED_ACCOUNT_DATA_BLOCK_LIMIT = SOLANA_ERROR__TRANSACTION_ERROR__WOULD_EXCEED_ACCOUNT_DATA_BLOCK_LIMIT;
      exports.SOLANA_ERROR__TRANSACTION_ERROR__WOULD_EXCEED_ACCOUNT_DATA_TOTAL_LIMIT = SOLANA_ERROR__TRANSACTION_ERROR__WOULD_EXCEED_ACCOUNT_DATA_TOTAL_LIMIT;
      exports.SOLANA_ERROR__TRANSACTION_ERROR__WOULD_EXCEED_MAX_ACCOUNT_COST_LIMIT = SOLANA_ERROR__TRANSACTION_ERROR__WOULD_EXCEED_MAX_ACCOUNT_COST_LIMIT;
      exports.SOLANA_ERROR__TRANSACTION_ERROR__WOULD_EXCEED_MAX_BLOCK_COST_LIMIT = SOLANA_ERROR__TRANSACTION_ERROR__WOULD_EXCEED_MAX_BLOCK_COST_LIMIT;
      exports.SOLANA_ERROR__TRANSACTION_ERROR__WOULD_EXCEED_MAX_VOTE_COST_LIMIT = SOLANA_ERROR__TRANSACTION_ERROR__WOULD_EXCEED_MAX_VOTE_COST_LIMIT;
      exports.SOLANA_ERROR__TRANSACTION__ADDRESSES_CANNOT_SIGN_TRANSACTION = SOLANA_ERROR__TRANSACTION__ADDRESSES_CANNOT_SIGN_TRANSACTION;
      exports.SOLANA_ERROR__TRANSACTION__ADDRESS_MISSING = SOLANA_ERROR__TRANSACTION__ADDRESS_MISSING;
      exports.SOLANA_ERROR__TRANSACTION__CANNOT_ENCODE_WITH_EMPTY_SIGNATURES = SOLANA_ERROR__TRANSACTION__CANNOT_ENCODE_WITH_EMPTY_SIGNATURES;
      exports.SOLANA_ERROR__TRANSACTION__EXCEEDS_SIZE_LIMIT = SOLANA_ERROR__TRANSACTION__EXCEEDS_SIZE_LIMIT;
      exports.SOLANA_ERROR__TRANSACTION__EXPECTED_BLOCKHASH_LIFETIME = SOLANA_ERROR__TRANSACTION__EXPECTED_BLOCKHASH_LIFETIME;
      exports.SOLANA_ERROR__TRANSACTION__EXPECTED_NONCE_LIFETIME = SOLANA_ERROR__TRANSACTION__EXPECTED_NONCE_LIFETIME;
      exports.SOLANA_ERROR__TRANSACTION__FAILED_TO_DECOMPILE_ADDRESS_LOOKUP_TABLE_CONTENTS_MISSING = SOLANA_ERROR__TRANSACTION__FAILED_TO_DECOMPILE_ADDRESS_LOOKUP_TABLE_CONTENTS_MISSING;
      exports.SOLANA_ERROR__TRANSACTION__FAILED_TO_DECOMPILE_ADDRESS_LOOKUP_TABLE_INDEX_OUT_OF_RANGE = SOLANA_ERROR__TRANSACTION__FAILED_TO_DECOMPILE_ADDRESS_LOOKUP_TABLE_INDEX_OUT_OF_RANGE;
      exports.SOLANA_ERROR__TRANSACTION__FAILED_TO_DECOMPILE_FEE_PAYER_MISSING = SOLANA_ERROR__TRANSACTION__FAILED_TO_DECOMPILE_FEE_PAYER_MISSING;
      exports.SOLANA_ERROR__TRANSACTION__FAILED_TO_DECOMPILE_INSTRUCTION_PROGRAM_ADDRESS_NOT_FOUND = SOLANA_ERROR__TRANSACTION__FAILED_TO_DECOMPILE_INSTRUCTION_PROGRAM_ADDRESS_NOT_FOUND;
      exports.SOLANA_ERROR__TRANSACTION__FAILED_TO_ESTIMATE_COMPUTE_LIMIT = SOLANA_ERROR__TRANSACTION__FAILED_TO_ESTIMATE_COMPUTE_LIMIT;
      exports.SOLANA_ERROR__TRANSACTION__FAILED_WHEN_SIMULATING_TO_ESTIMATE_COMPUTE_LIMIT = SOLANA_ERROR__TRANSACTION__FAILED_WHEN_SIMULATING_TO_ESTIMATE_COMPUTE_LIMIT;
      exports.SOLANA_ERROR__TRANSACTION__FEE_PAYER_MISSING = SOLANA_ERROR__TRANSACTION__FEE_PAYER_MISSING;
      exports.SOLANA_ERROR__TRANSACTION__FEE_PAYER_SIGNATURE_MISSING = SOLANA_ERROR__TRANSACTION__FEE_PAYER_SIGNATURE_MISSING;
      exports.SOLANA_ERROR__TRANSACTION__INVALID_NONCE_TRANSACTION_FIRST_INSTRUCTION_MUST_BE_ADVANCE_NONCE = SOLANA_ERROR__TRANSACTION__INVALID_NONCE_TRANSACTION_FIRST_INSTRUCTION_MUST_BE_ADVANCE_NONCE;
      exports.SOLANA_ERROR__TRANSACTION__INVALID_NONCE_TRANSACTION_INSTRUCTIONS_MISSING = SOLANA_ERROR__TRANSACTION__INVALID_NONCE_TRANSACTION_INSTRUCTIONS_MISSING;
      exports.SOLANA_ERROR__TRANSACTION__INVOKED_PROGRAMS_CANNOT_PAY_FEES = SOLANA_ERROR__TRANSACTION__INVOKED_PROGRAMS_CANNOT_PAY_FEES;
      exports.SOLANA_ERROR__TRANSACTION__INVOKED_PROGRAMS_MUST_NOT_BE_WRITABLE = SOLANA_ERROR__TRANSACTION__INVOKED_PROGRAMS_MUST_NOT_BE_WRITABLE;
      exports.SOLANA_ERROR__TRANSACTION__MESSAGE_SIGNATURES_MISMATCH = SOLANA_ERROR__TRANSACTION__MESSAGE_SIGNATURES_MISMATCH;
      exports.SOLANA_ERROR__TRANSACTION__SIGNATURES_MISSING = SOLANA_ERROR__TRANSACTION__SIGNATURES_MISSING;
      exports.SOLANA_ERROR__TRANSACTION__VERSION_NUMBER_OUT_OF_RANGE = SOLANA_ERROR__TRANSACTION__VERSION_NUMBER_OUT_OF_RANGE;
      exports.SolanaError = SolanaError;
      exports.getSolanaErrorFromInstructionError = getSolanaErrorFromInstructionError;
      exports.getSolanaErrorFromJsonRpcError = getSolanaErrorFromJsonRpcError;
      exports.getSolanaErrorFromTransactionError = getSolanaErrorFromTransactionError;
      exports.isSolanaError = isSolanaError;
      exports.safeCaptureStackTrace = safeCaptureStackTrace;
    }
  });

  // node_modules/@solana/web3.js/node_modules/@solana/codecs-core/dist/index.browser.cjs
  var require_index_browser2 = __commonJS({
    "node_modules/@solana/web3.js/node_modules/@solana/codecs-core/dist/index.browser.cjs"(exports) {
      "use strict";
      var errors = require_index_browser();
      var mergeBytes = (byteArrays) => {
        const nonEmptyByteArrays = byteArrays.filter((arr) => arr.length);
        if (nonEmptyByteArrays.length === 0) {
          return byteArrays.length ? byteArrays[0] : new Uint8Array();
        }
        if (nonEmptyByteArrays.length === 1) {
          return nonEmptyByteArrays[0];
        }
        const totalLength = nonEmptyByteArrays.reduce((total, arr) => total + arr.length, 0);
        const result = new Uint8Array(totalLength);
        let offset2 = 0;
        nonEmptyByteArrays.forEach((arr) => {
          result.set(arr, offset2);
          offset2 += arr.length;
        });
        return result;
      };
      var padBytes = (bytes, length) => {
        if (bytes.length >= length) return bytes;
        const paddedBytes = new Uint8Array(length).fill(0);
        paddedBytes.set(bytes);
        return paddedBytes;
      };
      var fixBytes = (bytes, length) => padBytes(bytes.length <= length ? bytes : bytes.slice(0, length), length);
      function containsBytes(data, bytes, offset2) {
        const slice = offset2 === 0 && data.length === bytes.length ? data : data.slice(offset2, offset2 + bytes.length);
        if (slice.length !== bytes.length) return false;
        return bytes.every((b, i) => b === slice[i]);
      }
      function getEncodedSize(value, encoder) {
        return "fixedSize" in encoder ? encoder.fixedSize : encoder.getSizeFromValue(value);
      }
      function createEncoder(encoder) {
        return Object.freeze({
          ...encoder,
          encode: (value) => {
            const bytes = new Uint8Array(getEncodedSize(value, encoder));
            encoder.write(value, bytes, 0);
            return bytes;
          }
        });
      }
      function createDecoder(decoder) {
        return Object.freeze({
          ...decoder,
          decode: (bytes, offset2 = 0) => decoder.read(bytes, offset2)[0]
        });
      }
      function createCodec(codec) {
        return Object.freeze({
          ...codec,
          decode: (bytes, offset2 = 0) => codec.read(bytes, offset2)[0],
          encode: (value) => {
            const bytes = new Uint8Array(getEncodedSize(value, codec));
            codec.write(value, bytes, 0);
            return bytes;
          }
        });
      }
      function isFixedSize(codec) {
        return "fixedSize" in codec && typeof codec.fixedSize === "number";
      }
      function assertIsFixedSize(codec) {
        if (!isFixedSize(codec)) {
          throw new errors.SolanaError(errors.SOLANA_ERROR__CODECS__EXPECTED_FIXED_LENGTH);
        }
      }
      function isVariableSize(codec) {
        return !isFixedSize(codec);
      }
      function assertIsVariableSize(codec) {
        if (!isVariableSize(codec)) {
          throw new errors.SolanaError(errors.SOLANA_ERROR__CODECS__EXPECTED_VARIABLE_LENGTH);
        }
      }
      function combineCodec(encoder, decoder) {
        if (isFixedSize(encoder) !== isFixedSize(decoder)) {
          throw new errors.SolanaError(errors.SOLANA_ERROR__CODECS__ENCODER_DECODER_SIZE_COMPATIBILITY_MISMATCH);
        }
        if (isFixedSize(encoder) && isFixedSize(decoder) && encoder.fixedSize !== decoder.fixedSize) {
          throw new errors.SolanaError(errors.SOLANA_ERROR__CODECS__ENCODER_DECODER_FIXED_SIZE_MISMATCH, {
            decoderFixedSize: decoder.fixedSize,
            encoderFixedSize: encoder.fixedSize
          });
        }
        if (!isFixedSize(encoder) && !isFixedSize(decoder) && encoder.maxSize !== decoder.maxSize) {
          throw new errors.SolanaError(errors.SOLANA_ERROR__CODECS__ENCODER_DECODER_MAX_SIZE_MISMATCH, {
            decoderMaxSize: decoder.maxSize,
            encoderMaxSize: encoder.maxSize
          });
        }
        return {
          ...decoder,
          ...encoder,
          decode: decoder.decode,
          encode: encoder.encode,
          read: decoder.read,
          write: encoder.write
        };
      }
      function addEncoderSentinel(encoder, sentinel) {
        const write = (value, bytes, offset2) => {
          const encoderBytes = encoder.encode(value);
          if (findSentinelIndex(encoderBytes, sentinel) >= 0) {
            throw new errors.SolanaError(errors.SOLANA_ERROR__CODECS__ENCODED_BYTES_MUST_NOT_INCLUDE_SENTINEL, {
              encodedBytes: encoderBytes,
              hexEncodedBytes: hexBytes(encoderBytes),
              hexSentinel: hexBytes(sentinel),
              sentinel
            });
          }
          bytes.set(encoderBytes, offset2);
          offset2 += encoderBytes.length;
          bytes.set(sentinel, offset2);
          offset2 += sentinel.length;
          return offset2;
        };
        if (isFixedSize(encoder)) {
          return createEncoder({ ...encoder, fixedSize: encoder.fixedSize + sentinel.length, write });
        }
        return createEncoder({
          ...encoder,
          ...encoder.maxSize != null ? { maxSize: encoder.maxSize + sentinel.length } : {},
          getSizeFromValue: (value) => encoder.getSizeFromValue(value) + sentinel.length,
          write
        });
      }
      function addDecoderSentinel(decoder, sentinel) {
        const read = (bytes, offset2) => {
          const candidateBytes = offset2 === 0 ? bytes : bytes.slice(offset2);
          const sentinelIndex = findSentinelIndex(candidateBytes, sentinel);
          if (sentinelIndex === -1) {
            throw new errors.SolanaError(errors.SOLANA_ERROR__CODECS__SENTINEL_MISSING_IN_DECODED_BYTES, {
              decodedBytes: candidateBytes,
              hexDecodedBytes: hexBytes(candidateBytes),
              hexSentinel: hexBytes(sentinel),
              sentinel
            });
          }
          const preSentinelBytes = candidateBytes.slice(0, sentinelIndex);
          return [decoder.decode(preSentinelBytes), offset2 + preSentinelBytes.length + sentinel.length];
        };
        if (isFixedSize(decoder)) {
          return createDecoder({ ...decoder, fixedSize: decoder.fixedSize + sentinel.length, read });
        }
        return createDecoder({
          ...decoder,
          ...decoder.maxSize != null ? { maxSize: decoder.maxSize + sentinel.length } : {},
          read
        });
      }
      function addCodecSentinel(codec, sentinel) {
        return combineCodec(addEncoderSentinel(codec, sentinel), addDecoderSentinel(codec, sentinel));
      }
      function findSentinelIndex(bytes, sentinel) {
        return bytes.findIndex((byte, index2, arr) => {
          if (sentinel.length === 1) return byte === sentinel[0];
          return containsBytes(arr, sentinel, index2);
        });
      }
      function hexBytes(bytes) {
        return bytes.reduce((str2, byte) => str2 + byte.toString(16).padStart(2, "0"), "");
      }
      function assertByteArrayIsNotEmptyForCodec(codecDescription, bytes, offset2 = 0) {
        if (bytes.length - offset2 <= 0) {
          throw new errors.SolanaError(errors.SOLANA_ERROR__CODECS__CANNOT_DECODE_EMPTY_BYTE_ARRAY, {
            codecDescription
          });
        }
      }
      function assertByteArrayHasEnoughBytesForCodec(codecDescription, expected, bytes, offset2 = 0) {
        const bytesLength = bytes.length - offset2;
        if (bytesLength < expected) {
          throw new errors.SolanaError(errors.SOLANA_ERROR__CODECS__INVALID_BYTE_LENGTH, {
            bytesLength,
            codecDescription,
            expected
          });
        }
      }
      function assertByteArrayOffsetIsNotOutOfRange(codecDescription, offset2, bytesLength) {
        if (offset2 < 0 || offset2 > bytesLength) {
          throw new errors.SolanaError(errors.SOLANA_ERROR__CODECS__OFFSET_OUT_OF_RANGE, {
            bytesLength,
            codecDescription,
            offset: offset2
          });
        }
      }
      function addEncoderSizePrefix(encoder, prefix) {
        const write = (value, bytes, offset2) => {
          const encoderBytes = encoder.encode(value);
          offset2 = prefix.write(encoderBytes.length, bytes, offset2);
          bytes.set(encoderBytes, offset2);
          return offset2 + encoderBytes.length;
        };
        if (isFixedSize(prefix) && isFixedSize(encoder)) {
          return createEncoder({ ...encoder, fixedSize: prefix.fixedSize + encoder.fixedSize, write });
        }
        const prefixMaxSize = isFixedSize(prefix) ? prefix.fixedSize : prefix.maxSize ?? null;
        const encoderMaxSize = isFixedSize(encoder) ? encoder.fixedSize : encoder.maxSize ?? null;
        const maxSize = prefixMaxSize !== null && encoderMaxSize !== null ? prefixMaxSize + encoderMaxSize : null;
        return createEncoder({
          ...encoder,
          ...maxSize !== null ? { maxSize } : {},
          getSizeFromValue: (value) => {
            const encoderSize = getEncodedSize(value, encoder);
            return getEncodedSize(encoderSize, prefix) + encoderSize;
          },
          write
        });
      }
      function addDecoderSizePrefix(decoder, prefix) {
        const read = (bytes, offset2) => {
          const [bigintSize, decoderOffset] = prefix.read(bytes, offset2);
          const size = Number(bigintSize);
          offset2 = decoderOffset;
          if (offset2 > 0 || bytes.length > size) {
            bytes = bytes.slice(offset2, offset2 + size);
          }
          assertByteArrayHasEnoughBytesForCodec("addDecoderSizePrefix", size, bytes);
          return [decoder.decode(bytes), offset2 + size];
        };
        if (isFixedSize(prefix) && isFixedSize(decoder)) {
          return createDecoder({ ...decoder, fixedSize: prefix.fixedSize + decoder.fixedSize, read });
        }
        const prefixMaxSize = isFixedSize(prefix) ? prefix.fixedSize : prefix.maxSize ?? null;
        const decoderMaxSize = isFixedSize(decoder) ? decoder.fixedSize : decoder.maxSize ?? null;
        const maxSize = prefixMaxSize !== null && decoderMaxSize !== null ? prefixMaxSize + decoderMaxSize : null;
        return createDecoder({ ...decoder, ...maxSize !== null ? { maxSize } : {}, read });
      }
      function addCodecSizePrefix(codec, prefix) {
        return combineCodec(addEncoderSizePrefix(codec, prefix), addDecoderSizePrefix(codec, prefix));
      }
      function fixEncoderSize(encoder, fixedBytes) {
        return createEncoder({
          fixedSize: fixedBytes,
          write: (value, bytes, offset2) => {
            const variableByteArray = encoder.encode(value);
            const fixedByteArray = variableByteArray.length > fixedBytes ? variableByteArray.slice(0, fixedBytes) : variableByteArray;
            bytes.set(fixedByteArray, offset2);
            return offset2 + fixedBytes;
          }
        });
      }
      function fixDecoderSize(decoder, fixedBytes) {
        return createDecoder({
          fixedSize: fixedBytes,
          read: (bytes, offset2) => {
            assertByteArrayHasEnoughBytesForCodec("fixCodecSize", fixedBytes, bytes, offset2);
            if (offset2 > 0 || bytes.length > fixedBytes) {
              bytes = bytes.slice(offset2, offset2 + fixedBytes);
            }
            if (isFixedSize(decoder)) {
              bytes = fixBytes(bytes, decoder.fixedSize);
            }
            const [value] = decoder.read(bytes, 0);
            return [value, offset2 + fixedBytes];
          }
        });
      }
      function fixCodecSize(codec, fixedBytes) {
        return combineCodec(fixEncoderSize(codec, fixedBytes), fixDecoderSize(codec, fixedBytes));
      }
      function offsetEncoder(encoder, config) {
        return createEncoder({
          ...encoder,
          write: (value, bytes, preOffset) => {
            const wrapBytes = (offset2) => modulo(offset2, bytes.length);
            const newPreOffset = config.preOffset ? config.preOffset({ bytes, preOffset, wrapBytes }) : preOffset;
            assertByteArrayOffsetIsNotOutOfRange("offsetEncoder", newPreOffset, bytes.length);
            const postOffset = encoder.write(value, bytes, newPreOffset);
            const newPostOffset = config.postOffset ? config.postOffset({ bytes, newPreOffset, postOffset, preOffset, wrapBytes }) : postOffset;
            assertByteArrayOffsetIsNotOutOfRange("offsetEncoder", newPostOffset, bytes.length);
            return newPostOffset;
          }
        });
      }
      function offsetDecoder(decoder, config) {
        return createDecoder({
          ...decoder,
          read: (bytes, preOffset) => {
            const wrapBytes = (offset2) => modulo(offset2, bytes.length);
            const newPreOffset = config.preOffset ? config.preOffset({ bytes, preOffset, wrapBytes }) : preOffset;
            assertByteArrayOffsetIsNotOutOfRange("offsetDecoder", newPreOffset, bytes.length);
            const [value, postOffset] = decoder.read(bytes, newPreOffset);
            const newPostOffset = config.postOffset ? config.postOffset({ bytes, newPreOffset, postOffset, preOffset, wrapBytes }) : postOffset;
            assertByteArrayOffsetIsNotOutOfRange("offsetDecoder", newPostOffset, bytes.length);
            return [value, newPostOffset];
          }
        });
      }
      function offsetCodec(codec, config) {
        return combineCodec(offsetEncoder(codec, config), offsetDecoder(codec, config));
      }
      function modulo(dividend, divisor) {
        if (divisor === 0) return 0;
        return (dividend % divisor + divisor) % divisor;
      }
      function resizeEncoder(encoder, resize) {
        if (isFixedSize(encoder)) {
          const fixedSize = resize(encoder.fixedSize);
          if (fixedSize < 0) {
            throw new errors.SolanaError(errors.SOLANA_ERROR__CODECS__EXPECTED_POSITIVE_BYTE_LENGTH, {
              bytesLength: fixedSize,
              codecDescription: "resizeEncoder"
            });
          }
          return createEncoder({ ...encoder, fixedSize });
        }
        return createEncoder({
          ...encoder,
          getSizeFromValue: (value) => {
            const newSize = resize(encoder.getSizeFromValue(value));
            if (newSize < 0) {
              throw new errors.SolanaError(errors.SOLANA_ERROR__CODECS__EXPECTED_POSITIVE_BYTE_LENGTH, {
                bytesLength: newSize,
                codecDescription: "resizeEncoder"
              });
            }
            return newSize;
          }
        });
      }
      function resizeDecoder(decoder, resize) {
        if (isFixedSize(decoder)) {
          const fixedSize = resize(decoder.fixedSize);
          if (fixedSize < 0) {
            throw new errors.SolanaError(errors.SOLANA_ERROR__CODECS__EXPECTED_POSITIVE_BYTE_LENGTH, {
              bytesLength: fixedSize,
              codecDescription: "resizeDecoder"
            });
          }
          return createDecoder({ ...decoder, fixedSize });
        }
        return decoder;
      }
      function resizeCodec(codec, resize) {
        return combineCodec(resizeEncoder(codec, resize), resizeDecoder(codec, resize));
      }
      function padLeftEncoder(encoder, offset2) {
        return offsetEncoder(
          resizeEncoder(encoder, (size) => size + offset2),
          { preOffset: ({ preOffset }) => preOffset + offset2 }
        );
      }
      function padRightEncoder(encoder, offset2) {
        return offsetEncoder(
          resizeEncoder(encoder, (size) => size + offset2),
          { postOffset: ({ postOffset }) => postOffset + offset2 }
        );
      }
      function padLeftDecoder(decoder, offset2) {
        return offsetDecoder(
          resizeDecoder(decoder, (size) => size + offset2),
          { preOffset: ({ preOffset }) => preOffset + offset2 }
        );
      }
      function padRightDecoder(decoder, offset2) {
        return offsetDecoder(
          resizeDecoder(decoder, (size) => size + offset2),
          { postOffset: ({ postOffset }) => postOffset + offset2 }
        );
      }
      function padLeftCodec(codec, offset2) {
        return combineCodec(padLeftEncoder(codec, offset2), padLeftDecoder(codec, offset2));
      }
      function padRightCodec(codec, offset2) {
        return combineCodec(padRightEncoder(codec, offset2), padRightDecoder(codec, offset2));
      }
      function copySourceToTargetInReverse(source, target_WILL_MUTATE, sourceOffset, sourceLength, targetOffset = 0) {
        while (sourceOffset < --sourceLength) {
          const leftValue = source[sourceOffset];
          target_WILL_MUTATE[sourceOffset + targetOffset] = source[sourceLength];
          target_WILL_MUTATE[sourceLength + targetOffset] = leftValue;
          sourceOffset++;
        }
        if (sourceOffset === sourceLength) {
          target_WILL_MUTATE[sourceOffset + targetOffset] = source[sourceOffset];
        }
      }
      function reverseEncoder(encoder) {
        assertIsFixedSize(encoder);
        return createEncoder({
          ...encoder,
          write: (value, bytes, offset2) => {
            const newOffset = encoder.write(value, bytes, offset2);
            copySourceToTargetInReverse(
              bytes,
              bytes,
              offset2,
              offset2 + encoder.fixedSize
            );
            return newOffset;
          }
        });
      }
      function reverseDecoder(decoder) {
        assertIsFixedSize(decoder);
        return createDecoder({
          ...decoder,
          read: (bytes, offset2) => {
            const reversedBytes = bytes.slice();
            copySourceToTargetInReverse(
              bytes,
              reversedBytes,
              offset2,
              offset2 + decoder.fixedSize
            );
            return decoder.read(reversedBytes, offset2);
          }
        });
      }
      function reverseCodec(codec) {
        return combineCodec(reverseEncoder(codec), reverseDecoder(codec));
      }
      function transformEncoder(encoder, unmap) {
        return createEncoder({
          ...isVariableSize(encoder) ? { ...encoder, getSizeFromValue: (value) => encoder.getSizeFromValue(unmap(value)) } : encoder,
          write: (value, bytes, offset2) => encoder.write(unmap(value), bytes, offset2)
        });
      }
      function transformDecoder(decoder, map) {
        return createDecoder({
          ...decoder,
          read: (bytes, offset2) => {
            const [value, newOffset] = decoder.read(bytes, offset2);
            return [map(value, bytes, offset2), newOffset];
          }
        });
      }
      function transformCodec(codec, unmap, map) {
        return createCodec({
          ...transformEncoder(codec, unmap),
          read: map ? transformDecoder(codec, map).read : codec.read
        });
      }
      exports.addCodecSentinel = addCodecSentinel;
      exports.addCodecSizePrefix = addCodecSizePrefix;
      exports.addDecoderSentinel = addDecoderSentinel;
      exports.addDecoderSizePrefix = addDecoderSizePrefix;
      exports.addEncoderSentinel = addEncoderSentinel;
      exports.addEncoderSizePrefix = addEncoderSizePrefix;
      exports.assertByteArrayHasEnoughBytesForCodec = assertByteArrayHasEnoughBytesForCodec;
      exports.assertByteArrayIsNotEmptyForCodec = assertByteArrayIsNotEmptyForCodec;
      exports.assertByteArrayOffsetIsNotOutOfRange = assertByteArrayOffsetIsNotOutOfRange;
      exports.assertIsFixedSize = assertIsFixedSize;
      exports.assertIsVariableSize = assertIsVariableSize;
      exports.combineCodec = combineCodec;
      exports.containsBytes = containsBytes;
      exports.createCodec = createCodec;
      exports.createDecoder = createDecoder;
      exports.createEncoder = createEncoder;
      exports.fixBytes = fixBytes;
      exports.fixCodecSize = fixCodecSize;
      exports.fixDecoderSize = fixDecoderSize;
      exports.fixEncoderSize = fixEncoderSize;
      exports.getEncodedSize = getEncodedSize;
      exports.isFixedSize = isFixedSize;
      exports.isVariableSize = isVariableSize;
      exports.mergeBytes = mergeBytes;
      exports.offsetCodec = offsetCodec;
      exports.offsetDecoder = offsetDecoder;
      exports.offsetEncoder = offsetEncoder;
      exports.padBytes = padBytes;
      exports.padLeftCodec = padLeftCodec;
      exports.padLeftDecoder = padLeftDecoder;
      exports.padLeftEncoder = padLeftEncoder;
      exports.padRightCodec = padRightCodec;
      exports.padRightDecoder = padRightDecoder;
      exports.padRightEncoder = padRightEncoder;
      exports.resizeCodec = resizeCodec;
      exports.resizeDecoder = resizeDecoder;
      exports.resizeEncoder = resizeEncoder;
      exports.reverseCodec = reverseCodec;
      exports.reverseDecoder = reverseDecoder;
      exports.reverseEncoder = reverseEncoder;
      exports.transformCodec = transformCodec;
      exports.transformDecoder = transformDecoder;
      exports.transformEncoder = transformEncoder;
    }
  });

  // node_modules/@solana/web3.js/node_modules/@solana/codecs-numbers/dist/index.browser.cjs
  var require_index_browser3 = __commonJS({
    "node_modules/@solana/web3.js/node_modules/@solana/codecs-numbers/dist/index.browser.cjs"(exports) {
      "use strict";
      var errors = require_index_browser();
      var codecsCore = require_index_browser2();
      function assertNumberIsBetweenForCodec(codecDescription, min, max, value) {
        if (value < min || value > max) {
          throw new errors.SolanaError(errors.SOLANA_ERROR__CODECS__NUMBER_OUT_OF_RANGE, {
            codecDescription,
            max,
            min,
            value
          });
        }
      }
      var Endian = /* @__PURE__ */ ((Endian2) => {
        Endian2[Endian2["Little"] = 0] = "Little";
        Endian2[Endian2["Big"] = 1] = "Big";
        return Endian2;
      })(Endian || {});
      function isLittleEndian(config) {
        return config?.endian === 1 ? false : true;
      }
      function numberEncoderFactory(input) {
        return codecsCore.createEncoder({
          fixedSize: input.size,
          write(value, bytes, offset2) {
            if (input.range) {
              assertNumberIsBetweenForCodec(input.name, input.range[0], input.range[1], value);
            }
            const arrayBuffer = new ArrayBuffer(input.size);
            input.set(new DataView(arrayBuffer), value, isLittleEndian(input.config));
            bytes.set(new Uint8Array(arrayBuffer), offset2);
            return offset2 + input.size;
          }
        });
      }
      function numberDecoderFactory(input) {
        return codecsCore.createDecoder({
          fixedSize: input.size,
          read(bytes, offset2 = 0) {
            codecsCore.assertByteArrayIsNotEmptyForCodec(input.name, bytes, offset2);
            codecsCore.assertByteArrayHasEnoughBytesForCodec(input.name, input.size, bytes, offset2);
            const view = new DataView(toArrayBuffer(bytes, offset2, input.size));
            return [input.get(view, isLittleEndian(input.config)), offset2 + input.size];
          }
        });
      }
      function toArrayBuffer(bytes, offset2, length) {
        const bytesOffset = bytes.byteOffset + (offset2 ?? 0);
        const bytesLength = length ?? bytes.byteLength;
        return bytes.buffer.slice(bytesOffset, bytesOffset + bytesLength);
      }
      var getF32Encoder = (config = {}) => numberEncoderFactory({
        config,
        name: "f32",
        set: (view, value, le) => view.setFloat32(0, Number(value), le),
        size: 4
      });
      var getF32Decoder = (config = {}) => numberDecoderFactory({
        config,
        get: (view, le) => view.getFloat32(0, le),
        name: "f32",
        size: 4
      });
      var getF32Codec = (config = {}) => codecsCore.combineCodec(getF32Encoder(config), getF32Decoder(config));
      var getF64Encoder = (config = {}) => numberEncoderFactory({
        config,
        name: "f64",
        set: (view, value, le) => view.setFloat64(0, Number(value), le),
        size: 8
      });
      var getF64Decoder = (config = {}) => numberDecoderFactory({
        config,
        get: (view, le) => view.getFloat64(0, le),
        name: "f64",
        size: 8
      });
      var getF64Codec = (config = {}) => codecsCore.combineCodec(getF64Encoder(config), getF64Decoder(config));
      var getI128Encoder = (config = {}) => numberEncoderFactory({
        config,
        name: "i128",
        range: [-BigInt("0x7fffffffffffffffffffffffffffffff") - 1n, BigInt("0x7fffffffffffffffffffffffffffffff")],
        set: (view, value, le) => {
          const leftOffset = le ? 8 : 0;
          const rightOffset = le ? 0 : 8;
          const rightMask = 0xffffffffffffffffn;
          view.setBigInt64(leftOffset, BigInt(value) >> 64n, le);
          view.setBigUint64(rightOffset, BigInt(value) & rightMask, le);
        },
        size: 16
      });
      var getI128Decoder = (config = {}) => numberDecoderFactory({
        config,
        get: (view, le) => {
          const leftOffset = le ? 8 : 0;
          const rightOffset = le ? 0 : 8;
          const left = view.getBigInt64(leftOffset, le);
          const right = view.getBigUint64(rightOffset, le);
          return (left << 64n) + right;
        },
        name: "i128",
        size: 16
      });
      var getI128Codec = (config = {}) => codecsCore.combineCodec(getI128Encoder(config), getI128Decoder(config));
      var getI16Encoder = (config = {}) => numberEncoderFactory({
        config,
        name: "i16",
        range: [-Number("0x7fff") - 1, Number("0x7fff")],
        set: (view, value, le) => view.setInt16(0, Number(value), le),
        size: 2
      });
      var getI16Decoder = (config = {}) => numberDecoderFactory({
        config,
        get: (view, le) => view.getInt16(0, le),
        name: "i16",
        size: 2
      });
      var getI16Codec = (config = {}) => codecsCore.combineCodec(getI16Encoder(config), getI16Decoder(config));
      var getI32Encoder = (config = {}) => numberEncoderFactory({
        config,
        name: "i32",
        range: [-Number("0x7fffffff") - 1, Number("0x7fffffff")],
        set: (view, value, le) => view.setInt32(0, Number(value), le),
        size: 4
      });
      var getI32Decoder = (config = {}) => numberDecoderFactory({
        config,
        get: (view, le) => view.getInt32(0, le),
        name: "i32",
        size: 4
      });
      var getI32Codec = (config = {}) => codecsCore.combineCodec(getI32Encoder(config), getI32Decoder(config));
      var getI64Encoder = (config = {}) => numberEncoderFactory({
        config,
        name: "i64",
        range: [-BigInt("0x7fffffffffffffff") - 1n, BigInt("0x7fffffffffffffff")],
        set: (view, value, le) => view.setBigInt64(0, BigInt(value), le),
        size: 8
      });
      var getI64Decoder = (config = {}) => numberDecoderFactory({
        config,
        get: (view, le) => view.getBigInt64(0, le),
        name: "i64",
        size: 8
      });
      var getI64Codec = (config = {}) => codecsCore.combineCodec(getI64Encoder(config), getI64Decoder(config));
      var getI8Encoder = () => numberEncoderFactory({
        name: "i8",
        range: [-Number("0x7f") - 1, Number("0x7f")],
        set: (view, value) => view.setInt8(0, Number(value)),
        size: 1
      });
      var getI8Decoder = () => numberDecoderFactory({
        get: (view) => view.getInt8(0),
        name: "i8",
        size: 1
      });
      var getI8Codec = () => codecsCore.combineCodec(getI8Encoder(), getI8Decoder());
      var getShortU16Encoder = () => codecsCore.createEncoder({
        getSizeFromValue: (value) => {
          if (value <= 127) return 1;
          if (value <= 16383) return 2;
          return 3;
        },
        maxSize: 3,
        write: (value, bytes, offset2) => {
          assertNumberIsBetweenForCodec("shortU16", 0, 65535, value);
          const shortU16Bytes = [0];
          for (let ii = 0; ; ii += 1) {
            const alignedValue = Number(value) >> ii * 7;
            if (alignedValue === 0) {
              break;
            }
            const nextSevenBits = 127 & alignedValue;
            shortU16Bytes[ii] = nextSevenBits;
            if (ii > 0) {
              shortU16Bytes[ii - 1] |= 128;
            }
          }
          bytes.set(shortU16Bytes, offset2);
          return offset2 + shortU16Bytes.length;
        }
      });
      var getShortU16Decoder = () => codecsCore.createDecoder({
        maxSize: 3,
        read: (bytes, offset2) => {
          let value = 0;
          let byteCount = 0;
          while (++byteCount) {
            const byteIndex = byteCount - 1;
            const currentByte = bytes[offset2 + byteIndex];
            const nextSevenBits = 127 & currentByte;
            value |= nextSevenBits << byteIndex * 7;
            if ((currentByte & 128) === 0) {
              break;
            }
          }
          return [value, offset2 + byteCount];
        }
      });
      var getShortU16Codec = () => codecsCore.combineCodec(getShortU16Encoder(), getShortU16Decoder());
      var getU128Encoder = (config = {}) => numberEncoderFactory({
        config,
        name: "u128",
        range: [0n, BigInt("0xffffffffffffffffffffffffffffffff")],
        set: (view, value, le) => {
          const leftOffset = le ? 8 : 0;
          const rightOffset = le ? 0 : 8;
          const rightMask = 0xffffffffffffffffn;
          view.setBigUint64(leftOffset, BigInt(value) >> 64n, le);
          view.setBigUint64(rightOffset, BigInt(value) & rightMask, le);
        },
        size: 16
      });
      var getU128Decoder = (config = {}) => numberDecoderFactory({
        config,
        get: (view, le) => {
          const leftOffset = le ? 8 : 0;
          const rightOffset = le ? 0 : 8;
          const left = view.getBigUint64(leftOffset, le);
          const right = view.getBigUint64(rightOffset, le);
          return (left << 64n) + right;
        },
        name: "u128",
        size: 16
      });
      var getU128Codec = (config = {}) => codecsCore.combineCodec(getU128Encoder(config), getU128Decoder(config));
      var getU16Encoder = (config = {}) => numberEncoderFactory({
        config,
        name: "u16",
        range: [0, Number("0xffff")],
        set: (view, value, le) => view.setUint16(0, Number(value), le),
        size: 2
      });
      var getU16Decoder = (config = {}) => numberDecoderFactory({
        config,
        get: (view, le) => view.getUint16(0, le),
        name: "u16",
        size: 2
      });
      var getU16Codec = (config = {}) => codecsCore.combineCodec(getU16Encoder(config), getU16Decoder(config));
      var getU32Encoder = (config = {}) => numberEncoderFactory({
        config,
        name: "u32",
        range: [0, Number("0xffffffff")],
        set: (view, value, le) => view.setUint32(0, Number(value), le),
        size: 4
      });
      var getU32Decoder = (config = {}) => numberDecoderFactory({
        config,
        get: (view, le) => view.getUint32(0, le),
        name: "u32",
        size: 4
      });
      var getU32Codec = (config = {}) => codecsCore.combineCodec(getU32Encoder(config), getU32Decoder(config));
      var getU64Encoder = (config = {}) => numberEncoderFactory({
        config,
        name: "u64",
        range: [0n, BigInt("0xffffffffffffffff")],
        set: (view, value, le) => view.setBigUint64(0, BigInt(value), le),
        size: 8
      });
      var getU64Decoder = (config = {}) => numberDecoderFactory({
        config,
        get: (view, le) => view.getBigUint64(0, le),
        name: "u64",
        size: 8
      });
      var getU64Codec = (config = {}) => codecsCore.combineCodec(getU64Encoder(config), getU64Decoder(config));
      var getU8Encoder = () => numberEncoderFactory({
        name: "u8",
        range: [0, Number("0xff")],
        set: (view, value) => view.setUint8(0, Number(value)),
        size: 1
      });
      var getU8Decoder = () => numberDecoderFactory({
        get: (view) => view.getUint8(0),
        name: "u8",
        size: 1
      });
      var getU8Codec = () => codecsCore.combineCodec(getU8Encoder(), getU8Decoder());
      exports.Endian = Endian;
      exports.assertNumberIsBetweenForCodec = assertNumberIsBetweenForCodec;
      exports.getF32Codec = getF32Codec;
      exports.getF32Decoder = getF32Decoder;
      exports.getF32Encoder = getF32Encoder;
      exports.getF64Codec = getF64Codec;
      exports.getF64Decoder = getF64Decoder;
      exports.getF64Encoder = getF64Encoder;
      exports.getI128Codec = getI128Codec;
      exports.getI128Decoder = getI128Decoder;
      exports.getI128Encoder = getI128Encoder;
      exports.getI16Codec = getI16Codec;
      exports.getI16Decoder = getI16Decoder;
      exports.getI16Encoder = getI16Encoder;
      exports.getI32Codec = getI32Codec;
      exports.getI32Decoder = getI32Decoder;
      exports.getI32Encoder = getI32Encoder;
      exports.getI64Codec = getI64Codec;
      exports.getI64Decoder = getI64Decoder;
      exports.getI64Encoder = getI64Encoder;
      exports.getI8Codec = getI8Codec;
      exports.getI8Decoder = getI8Decoder;
      exports.getI8Encoder = getI8Encoder;
      exports.getShortU16Codec = getShortU16Codec;
      exports.getShortU16Decoder = getShortU16Decoder;
      exports.getShortU16Encoder = getShortU16Encoder;
      exports.getU128Codec = getU128Codec;
      exports.getU128Decoder = getU128Decoder;
      exports.getU128Encoder = getU128Encoder;
      exports.getU16Codec = getU16Codec;
      exports.getU16Decoder = getU16Decoder;
      exports.getU16Encoder = getU16Encoder;
      exports.getU32Codec = getU32Codec;
      exports.getU32Decoder = getU32Decoder;
      exports.getU32Encoder = getU32Encoder;
      exports.getU64Codec = getU64Codec;
      exports.getU64Decoder = getU64Decoder;
      exports.getU64Encoder = getU64Encoder;
      exports.getU8Codec = getU8Codec;
      exports.getU8Decoder = getU8Decoder;
      exports.getU8Encoder = getU8Encoder;
    }
  });

  // node_modules/superstruct/dist/index.cjs
  var require_dist = __commonJS({
    "node_modules/superstruct/dist/index.cjs"(exports, module) {
      (function(global2, factory) {
        typeof exports === "object" && typeof module !== "undefined" ? factory(exports) : typeof define === "function" && define.amd ? define(["exports"], factory) : (global2 = typeof globalThis !== "undefined" ? globalThis : global2 || self, factory(global2.Superstruct = {}));
      })(exports, (function(exports2) {
        "use strict";
        class StructError2 extends TypeError {
          constructor(failure, failures) {
            let cached;
            const { message, explanation, ...rest } = failure;
            const { path } = failure;
            const msg = path.length === 0 ? message : `At path: ${path.join(".")} -- ${message}`;
            super(explanation ?? msg);
            if (explanation != null)
              this.cause = msg;
            Object.assign(this, rest);
            this.name = this.constructor.name;
            this.failures = () => {
              return cached ?? (cached = [failure, ...failures()]);
            };
          }
        }
        function isIterable2(x) {
          return isObject2(x) && typeof x[Symbol.iterator] === "function";
        }
        function isObject2(x) {
          return typeof x === "object" && x != null;
        }
        function isNonArrayObject(x) {
          return isObject2(x) && !Array.isArray(x);
        }
        function isPlainObject(x) {
          if (Object.prototype.toString.call(x) !== "[object Object]") {
            return false;
          }
          const prototype = Object.getPrototypeOf(x);
          return prototype === null || prototype === Object.prototype;
        }
        function print2(value) {
          if (typeof value === "symbol") {
            return value.toString();
          }
          return typeof value === "string" ? JSON.stringify(value) : `${value}`;
        }
        function shiftIterator2(input) {
          const { done, value } = input.next();
          return done ? void 0 : value;
        }
        function toFailure2(result, context, struct4, value) {
          if (result === true) {
            return;
          } else if (result === false) {
            result = {};
          } else if (typeof result === "string") {
            result = { message: result };
          }
          const { path, branch } = context;
          const { type: type3 } = struct4;
          const { refinement, message = `Expected a value of type \`${type3}\`${refinement ? ` with refinement \`${refinement}\`` : ""}, but received: \`${print2(value)}\`` } = result;
          return {
            value,
            type: type3,
            refinement,
            key: path[path.length - 1],
            path,
            branch,
            ...result,
            message
          };
        }
        function* toFailures2(result, context, struct4, value) {
          if (!isIterable2(result)) {
            result = [result];
          }
          for (const r of result) {
            const failure = toFailure2(r, context, struct4, value);
            if (failure) {
              yield failure;
            }
          }
        }
        function* run2(value, struct4, options = {}) {
          const { path = [], branch = [value], coerce: coerce3 = false, mask: mask3 = false } = options;
          const ctx = { path, branch, mask: mask3 };
          if (coerce3) {
            value = struct4.coercer(value, ctx);
          }
          let status = "valid";
          for (const failure of struct4.validator(value, ctx)) {
            failure.explanation = options.message;
            status = "not_valid";
            yield [failure, void 0];
          }
          for (let [k, v, s] of struct4.entries(value, ctx)) {
            const ts = run2(v, s, {
              path: k === void 0 ? path : [...path, k],
              branch: k === void 0 ? branch : [...branch, v],
              coerce: coerce3,
              mask: mask3,
              message: options.message
            });
            for (const t of ts) {
              if (t[0]) {
                status = t[0].refinement != null ? "not_refined" : "not_valid";
                yield [t[0], void 0];
              } else if (coerce3) {
                v = t[1];
                if (k === void 0) {
                  value = v;
                } else if (value instanceof Map) {
                  value.set(k, v);
                } else if (value instanceof Set) {
                  value.add(v);
                } else if (isObject2(value)) {
                  if (v !== void 0 || k in value)
                    value[k] = v;
                }
              }
            }
          }
          if (status !== "not_valid") {
            for (const failure of struct4.refiner(value, ctx)) {
              failure.explanation = options.message;
              status = "not_refined";
              yield [failure, void 0];
            }
          }
          if (status === "valid") {
            yield [void 0, value];
          }
        }
        class Struct2 {
          constructor(props) {
            const { type: type3, schema, validator, refiner, coercer = (value) => value, entries = function* () {
            } } = props;
            this.type = type3;
            this.schema = schema;
            this.entries = entries;
            this.coercer = coercer;
            if (validator) {
              this.validator = (value, context) => {
                const result = validator(value, context);
                return toFailures2(result, context, this, value);
              };
            } else {
              this.validator = () => [];
            }
            if (refiner) {
              this.refiner = (value, context) => {
                const result = refiner(value, context);
                return toFailures2(result, context, this, value);
              };
            } else {
              this.refiner = () => [];
            }
          }
          /**
           * Assert that a value passes the struct's validation, throwing if it doesn't.
           */
          assert(value, message) {
            return assert2(value, this, message);
          }
          /**
           * Create a value with the struct's coercion logic, then validate it.
           */
          create(value, message) {
            return create2(value, this, message);
          }
          /**
           * Check if a value passes the struct's validation.
           */
          is(value) {
            return is2(value, this);
          }
          /**
           * Mask a value, coercing and validating it, but returning only the subset of
           * properties defined by the struct's schema. Masking applies recursively to
           * props of `object` structs only.
           */
          mask(value, message) {
            return mask2(value, this, message);
          }
          /**
           * Validate a value with the struct's validation logic, returning a tuple
           * representing the result.
           *
           * You may optionally pass `true` for the `coerce` argument to coerce
           * the value before attempting to validate it. If you do, the result will
           * contain the coerced result when successful. Also, `mask` will turn on
           * masking of the unknown `object` props recursively if passed.
           */
          validate(value, options = {}) {
            return validate3(value, this, options);
          }
        }
        function assert2(value, struct4, message) {
          const result = validate3(value, struct4, { message });
          if (result[0]) {
            throw result[0];
          }
        }
        function create2(value, struct4, message) {
          const result = validate3(value, struct4, { coerce: true, message });
          if (result[0]) {
            throw result[0];
          } else {
            return result[1];
          }
        }
        function mask2(value, struct4, message) {
          const result = validate3(value, struct4, { coerce: true, mask: true, message });
          if (result[0]) {
            throw result[0];
          } else {
            return result[1];
          }
        }
        function is2(value, struct4) {
          const result = validate3(value, struct4);
          return !result[0];
        }
        function validate3(value, struct4, options = {}) {
          const tuples = run2(value, struct4, options);
          const tuple2 = shiftIterator2(tuples);
          if (tuple2[0]) {
            const error = new StructError2(tuple2[0], function* () {
              for (const t of tuples) {
                if (t[0]) {
                  yield t[0];
                }
              }
            });
            return [error, void 0];
          } else {
            const v = tuple2[1];
            return [void 0, v];
          }
        }
        function assign2(...Structs) {
          const isType = Structs[0].type === "type";
          const schemas = Structs.map((s) => s.schema);
          const schema = Object.assign({}, ...schemas);
          return isType ? type2(schema) : object(schema);
        }
        function define3(name, validator) {
          return new Struct2({ type: name, schema: null, validator });
        }
        function deprecated(struct4, log) {
          return new Struct2({
            ...struct4,
            refiner: (value, ctx) => value === void 0 || struct4.refiner(value, ctx),
            validator(value, ctx) {
              if (value === void 0) {
                return true;
              } else {
                log(value, ctx);
                return struct4.validator(value, ctx);
              }
            }
          });
        }
        function dynamic(fn) {
          return new Struct2({
            type: "dynamic",
            schema: null,
            *entries(value, ctx) {
              const struct4 = fn(value, ctx);
              yield* struct4.entries(value, ctx);
            },
            validator(value, ctx) {
              const struct4 = fn(value, ctx);
              return struct4.validator(value, ctx);
            },
            coercer(value, ctx) {
              const struct4 = fn(value, ctx);
              return struct4.coercer(value, ctx);
            },
            refiner(value, ctx) {
              const struct4 = fn(value, ctx);
              return struct4.refiner(value, ctx);
            }
          });
        }
        function lazy(fn) {
          let struct4;
          return new Struct2({
            type: "lazy",
            schema: null,
            *entries(value, ctx) {
              struct4 ?? (struct4 = fn());
              yield* struct4.entries(value, ctx);
            },
            validator(value, ctx) {
              struct4 ?? (struct4 = fn());
              return struct4.validator(value, ctx);
            },
            coercer(value, ctx) {
              struct4 ?? (struct4 = fn());
              return struct4.coercer(value, ctx);
            },
            refiner(value, ctx) {
              struct4 ?? (struct4 = fn());
              return struct4.refiner(value, ctx);
            }
          });
        }
        function omit(struct4, keys) {
          const { schema } = struct4;
          const subschema = { ...schema };
          for (const key of keys) {
            delete subschema[key];
          }
          switch (struct4.type) {
            case "type":
              return type2(subschema);
            default:
              return object(subschema);
          }
        }
        function partial(struct4) {
          const isStruct = struct4 instanceof Struct2;
          const schema = isStruct ? { ...struct4.schema } : { ...struct4 };
          for (const key in schema) {
            schema[key] = optional2(schema[key]);
          }
          if (isStruct && struct4.type === "type") {
            return type2(schema);
          }
          return object(schema);
        }
        function pick(struct4, keys) {
          const { schema } = struct4;
          const subschema = {};
          for (const key of keys) {
            subschema[key] = schema[key];
          }
          switch (struct4.type) {
            case "type":
              return type2(subschema);
            default:
              return object(subschema);
          }
        }
        function struct3(name, validator) {
          console.warn("superstruct@0.11 - The `struct` helper has been renamed to `define`.");
          return define3(name, validator);
        }
        function any2() {
          return define3("any", () => true);
        }
        function array3(Element) {
          return new Struct2({
            type: "array",
            schema: Element,
            *entries(value) {
              if (Element && Array.isArray(value)) {
                for (const [i, v] of value.entries()) {
                  yield [i, v, Element];
                }
              }
            },
            coercer(value) {
              return Array.isArray(value) ? value.slice() : value;
            },
            validator(value) {
              return Array.isArray(value) || `Expected an array value, but received: ${print2(value)}`;
            }
          });
        }
        function bigint() {
          return define3("bigint", (value) => {
            return typeof value === "bigint";
          });
        }
        function boolean2() {
          return define3("boolean", (value) => {
            return typeof value === "boolean";
          });
        }
        function date() {
          return define3("date", (value) => {
            return value instanceof Date && !isNaN(value.getTime()) || `Expected a valid \`Date\` object, but received: ${print2(value)}`;
          });
        }
        function enums(values) {
          const schema = {};
          const description = values.map((v) => print2(v)).join();
          for (const key of values) {
            schema[key] = key;
          }
          return new Struct2({
            type: "enums",
            schema,
            validator(value) {
              return values.includes(value) || `Expected one of \`${description}\`, but received: ${print2(value)}`;
            }
          });
        }
        function func() {
          return define3("func", (value) => {
            return typeof value === "function" || `Expected a function, but received: ${print2(value)}`;
          });
        }
        function instance(Class) {
          return define3("instance", (value) => {
            return value instanceof Class || `Expected a \`${Class.name}\` instance, but received: ${print2(value)}`;
          });
        }
        function integer() {
          return define3("integer", (value) => {
            return typeof value === "number" && !isNaN(value) && Number.isInteger(value) || `Expected an integer, but received: ${print2(value)}`;
          });
        }
        function intersection(Structs) {
          return new Struct2({
            type: "intersection",
            schema: null,
            *entries(value, ctx) {
              for (const S of Structs) {
                yield* S.entries(value, ctx);
              }
            },
            *validator(value, ctx) {
              for (const S of Structs) {
                yield* S.validator(value, ctx);
              }
            },
            *refiner(value, ctx) {
              for (const S of Structs) {
                yield* S.refiner(value, ctx);
              }
            }
          });
        }
        function literal2(constant) {
          const description = print2(constant);
          const t = typeof constant;
          return new Struct2({
            type: "literal",
            schema: t === "string" || t === "number" || t === "boolean" ? constant : null,
            validator(value) {
              return value === constant || `Expected the literal \`${description}\`, but received: ${print2(value)}`;
            }
          });
        }
        function map(Key, Value) {
          return new Struct2({
            type: "map",
            schema: null,
            *entries(value) {
              if (Key && Value && value instanceof Map) {
                for (const [k, v] of value.entries()) {
                  yield [k, k, Key];
                  yield [k, v, Value];
                }
              }
            },
            coercer(value) {
              return value instanceof Map ? new Map(value) : value;
            },
            validator(value) {
              return value instanceof Map || `Expected a \`Map\` object, but received: ${print2(value)}`;
            }
          });
        }
        function never() {
          return define3("never", () => false);
        }
        function nullable2(struct4) {
          return new Struct2({
            ...struct4,
            validator: (value, ctx) => value === null || struct4.validator(value, ctx),
            refiner: (value, ctx) => value === null || struct4.refiner(value, ctx)
          });
        }
        function number2() {
          return define3("number", (value) => {
            return typeof value === "number" && !isNaN(value) || `Expected a number, but received: ${print2(value)}`;
          });
        }
        function object(schema) {
          const knowns = schema ? Object.keys(schema) : [];
          const Never = never();
          return new Struct2({
            type: "object",
            schema: schema ? schema : null,
            *entries(value) {
              if (schema && isObject2(value)) {
                const unknowns = new Set(Object.keys(value));
                for (const key of knowns) {
                  unknowns.delete(key);
                  yield [key, value[key], schema[key]];
                }
                for (const key of unknowns) {
                  yield [key, value[key], Never];
                }
              }
            },
            validator(value) {
              return isNonArrayObject(value) || `Expected an object, but received: ${print2(value)}`;
            },
            coercer(value, ctx) {
              if (!isNonArrayObject(value)) {
                return value;
              }
              const coerced = { ...value };
              if (ctx.mask && schema) {
                for (const key in coerced) {
                  if (schema[key] === void 0) {
                    delete coerced[key];
                  }
                }
              }
              return coerced;
            }
          });
        }
        function optional2(struct4) {
          return new Struct2({
            ...struct4,
            validator: (value, ctx) => value === void 0 || struct4.validator(value, ctx),
            refiner: (value, ctx) => value === void 0 || struct4.refiner(value, ctx)
          });
        }
        function record(Key, Value) {
          return new Struct2({
            type: "record",
            schema: null,
            *entries(value) {
              if (isObject2(value)) {
                for (const k in value) {
                  const v = value[k];
                  yield [k, k, Key];
                  yield [k, v, Value];
                }
              }
            },
            validator(value) {
              return isNonArrayObject(value) || `Expected an object, but received: ${print2(value)}`;
            },
            coercer(value) {
              return isNonArrayObject(value) ? { ...value } : value;
            }
          });
        }
        function regexp() {
          return define3("regexp", (value) => {
            return value instanceof RegExp;
          });
        }
        function set2(Element) {
          return new Struct2({
            type: "set",
            schema: null,
            *entries(value) {
              if (Element && value instanceof Set) {
                for (const v of value) {
                  yield [v, v, Element];
                }
              }
            },
            coercer(value) {
              return value instanceof Set ? new Set(value) : value;
            },
            validator(value) {
              return value instanceof Set || `Expected a \`Set\` object, but received: ${print2(value)}`;
            }
          });
        }
        function string2() {
          return define3("string", (value) => {
            return typeof value === "string" || `Expected a string, but received: ${print2(value)}`;
          });
        }
        function tuple(Structs) {
          const Never = never();
          return new Struct2({
            type: "tuple",
            schema: null,
            *entries(value) {
              if (Array.isArray(value)) {
                const length = Math.max(Structs.length, value.length);
                for (let i = 0; i < length; i++) {
                  yield [i, value[i], Structs[i] || Never];
                }
              }
            },
            validator(value) {
              return Array.isArray(value) || `Expected an array, but received: ${print2(value)}`;
            },
            coercer(value) {
              return Array.isArray(value) ? value.slice() : value;
            }
          });
        }
        function type2(schema) {
          const keys = Object.keys(schema);
          return new Struct2({
            type: "type",
            schema,
            *entries(value) {
              if (isObject2(value)) {
                for (const k of keys) {
                  yield [k, value[k], schema[k]];
                }
              }
            },
            validator(value) {
              return isNonArrayObject(value) || `Expected an object, but received: ${print2(value)}`;
            },
            coercer(value) {
              return isNonArrayObject(value) ? { ...value } : value;
            }
          });
        }
        function union2(Structs) {
          const description = Structs.map((s) => s.type).join(" | ");
          return new Struct2({
            type: "union",
            schema: null,
            coercer(value, ctx) {
              for (const S of Structs) {
                const [error, coerced] = S.validate(value, {
                  coerce: true,
                  mask: ctx.mask
                });
                if (!error) {
                  return coerced;
                }
              }
              return value;
            },
            validator(value, ctx) {
              const failures = [];
              for (const S of Structs) {
                const [...tuples] = run2(value, S, ctx);
                const [first] = tuples;
                if (!first[0]) {
                  return [];
                } else {
                  for (const [failure] of tuples) {
                    if (failure) {
                      failures.push(failure);
                    }
                  }
                }
              }
              return [
                `Expected the value to satisfy a union of \`${description}\`, but received: ${print2(value)}`,
                ...failures
              ];
            }
          });
        }
        function unknown2() {
          return define3("unknown", () => true);
        }
        function coerce2(struct4, condition, coercer) {
          return new Struct2({
            ...struct4,
            coercer: (value, ctx) => {
              return is2(value, condition) ? struct4.coercer(coercer(value, ctx), ctx) : struct4.coercer(value, ctx);
            }
          });
        }
        function defaulted(struct4, fallback, options = {}) {
          return coerce2(struct4, unknown2(), (x) => {
            const f2 = typeof fallback === "function" ? fallback() : fallback;
            if (x === void 0) {
              return f2;
            }
            if (!options.strict && isPlainObject(x) && isPlainObject(f2)) {
              const ret = { ...x };
              let changed = false;
              for (const key in f2) {
                if (ret[key] === void 0) {
                  ret[key] = f2[key];
                  changed = true;
                }
              }
              if (changed) {
                return ret;
              }
            }
            return x;
          });
        }
        function trimmed(struct4) {
          return coerce2(struct4, string2(), (x) => x.trim());
        }
        function empty(struct4) {
          return refine(struct4, "empty", (value) => {
            const size2 = getSize(value);
            return size2 === 0 || `Expected an empty ${struct4.type} but received one with a size of \`${size2}\``;
          });
        }
        function getSize(value) {
          if (value instanceof Map || value instanceof Set) {
            return value.size;
          } else {
            return value.length;
          }
        }
        function max(struct4, threshold, options = {}) {
          const { exclusive } = options;
          return refine(struct4, "max", (value) => {
            return exclusive ? value < threshold : value <= threshold || `Expected a ${struct4.type} less than ${exclusive ? "" : "or equal to "}${threshold} but received \`${value}\``;
          });
        }
        function min(struct4, threshold, options = {}) {
          const { exclusive } = options;
          return refine(struct4, "min", (value) => {
            return exclusive ? value > threshold : value >= threshold || `Expected a ${struct4.type} greater than ${exclusive ? "" : "or equal to "}${threshold} but received \`${value}\``;
          });
        }
        function nonempty(struct4) {
          return refine(struct4, "nonempty", (value) => {
            const size2 = getSize(value);
            return size2 > 0 || `Expected a nonempty ${struct4.type} but received an empty one`;
          });
        }
        function pattern(struct4, regexp2) {
          return refine(struct4, "pattern", (value) => {
            return regexp2.test(value) || `Expected a ${struct4.type} matching \`/${regexp2.source}/\` but received "${value}"`;
          });
        }
        function size(struct4, min2, max2 = min2) {
          const expected = `Expected a ${struct4.type}`;
          const of = min2 === max2 ? `of \`${min2}\`` : `between \`${min2}\` and \`${max2}\``;
          return refine(struct4, "size", (value) => {
            if (typeof value === "number" || value instanceof Date) {
              return min2 <= value && value <= max2 || `${expected} ${of} but received \`${value}\``;
            } else if (value instanceof Map || value instanceof Set) {
              const { size: size2 } = value;
              return min2 <= size2 && size2 <= max2 || `${expected} with a size ${of} but received one with a size of \`${size2}\``;
            } else {
              const { length } = value;
              return min2 <= length && length <= max2 || `${expected} with a length ${of} but received one with a length of \`${length}\``;
            }
          });
        }
        function refine(struct4, name, refiner) {
          return new Struct2({
            ...struct4,
            *refiner(value, ctx) {
              yield* struct4.refiner(value, ctx);
              const result = refiner(value, ctx);
              const failures = toFailures2(result, ctx, struct4, value);
              for (const failure of failures) {
                yield { ...failure, refinement: name };
              }
            }
          });
        }
        exports2.Struct = Struct2;
        exports2.StructError = StructError2;
        exports2.any = any2;
        exports2.array = array3;
        exports2.assert = assert2;
        exports2.assign = assign2;
        exports2.bigint = bigint;
        exports2.boolean = boolean2;
        exports2.coerce = coerce2;
        exports2.create = create2;
        exports2.date = date;
        exports2.defaulted = defaulted;
        exports2.define = define3;
        exports2.deprecated = deprecated;
        exports2.dynamic = dynamic;
        exports2.empty = empty;
        exports2.enums = enums;
        exports2.func = func;
        exports2.instance = instance;
        exports2.integer = integer;
        exports2.intersection = intersection;
        exports2.is = is2;
        exports2.lazy = lazy;
        exports2.literal = literal2;
        exports2.map = map;
        exports2.mask = mask2;
        exports2.max = max;
        exports2.min = min;
        exports2.never = never;
        exports2.nonempty = nonempty;
        exports2.nullable = nullable2;
        exports2.number = number2;
        exports2.object = object;
        exports2.omit = omit;
        exports2.optional = optional2;
        exports2.partial = partial;
        exports2.pattern = pattern;
        exports2.pick = pick;
        exports2.record = record;
        exports2.refine = refine;
        exports2.regexp = regexp;
        exports2.set = set2;
        exports2.size = size;
        exports2.string = string2;
        exports2.struct = struct3;
        exports2.trimmed = trimmed;
        exports2.tuple = tuple;
        exports2.type = type2;
        exports2.union = union2;
        exports2.unknown = unknown2;
        exports2.validate = validate3;
      }));
    }
  });

  // node_modules/uuid/dist/esm-browser/rng.js
  function rng() {
    if (!getRandomValues) {
      getRandomValues = typeof crypto !== "undefined" && crypto.getRandomValues && crypto.getRandomValues.bind(crypto) || typeof msCrypto !== "undefined" && typeof msCrypto.getRandomValues === "function" && msCrypto.getRandomValues.bind(msCrypto);
      if (!getRandomValues) {
        throw new Error("crypto.getRandomValues() not supported. See https://github.com/uuidjs/uuid#getrandomvalues-not-supported");
      }
    }
    return getRandomValues(rnds8);
  }
  var getRandomValues, rnds8;
  var init_rng = __esm({
    "node_modules/uuid/dist/esm-browser/rng.js"() {
      rnds8 = new Uint8Array(16);
    }
  });

  // node_modules/uuid/dist/esm-browser/regex.js
  var regex_default;
  var init_regex = __esm({
    "node_modules/uuid/dist/esm-browser/regex.js"() {
      regex_default = /^(?:[0-9a-f]{8}-[0-9a-f]{4}-[1-5][0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}|00000000-0000-0000-0000-000000000000)$/i;
    }
  });

  // node_modules/uuid/dist/esm-browser/validate.js
  function validate(uuid) {
    return typeof uuid === "string" && regex_default.test(uuid);
  }
  var validate_default;
  var init_validate = __esm({
    "node_modules/uuid/dist/esm-browser/validate.js"() {
      init_regex();
      validate_default = validate;
    }
  });

  // node_modules/uuid/dist/esm-browser/stringify.js
  function stringify(arr) {
    var offset2 = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 0;
    var uuid = (byteToHex[arr[offset2 + 0]] + byteToHex[arr[offset2 + 1]] + byteToHex[arr[offset2 + 2]] + byteToHex[arr[offset2 + 3]] + "-" + byteToHex[arr[offset2 + 4]] + byteToHex[arr[offset2 + 5]] + "-" + byteToHex[arr[offset2 + 6]] + byteToHex[arr[offset2 + 7]] + "-" + byteToHex[arr[offset2 + 8]] + byteToHex[arr[offset2 + 9]] + "-" + byteToHex[arr[offset2 + 10]] + byteToHex[arr[offset2 + 11]] + byteToHex[arr[offset2 + 12]] + byteToHex[arr[offset2 + 13]] + byteToHex[arr[offset2 + 14]] + byteToHex[arr[offset2 + 15]]).toLowerCase();
    if (!validate_default(uuid)) {
      throw TypeError("Stringified UUID is invalid");
    }
    return uuid;
  }
  var byteToHex, i, stringify_default;
  var init_stringify = __esm({
    "node_modules/uuid/dist/esm-browser/stringify.js"() {
      init_validate();
      byteToHex = [];
      for (i = 0; i < 256; ++i) {
        byteToHex.push((i + 256).toString(16).substr(1));
      }
      stringify_default = stringify;
    }
  });

  // node_modules/uuid/dist/esm-browser/v1.js
  function v1(options, buf, offset2) {
    var i = buf && offset2 || 0;
    var b = buf || new Array(16);
    options = options || {};
    var node = options.node || _nodeId;
    var clockseq = options.clockseq !== void 0 ? options.clockseq : _clockseq;
    if (node == null || clockseq == null) {
      var seedBytes = options.random || (options.rng || rng)();
      if (node == null) {
        node = _nodeId = [seedBytes[0] | 1, seedBytes[1], seedBytes[2], seedBytes[3], seedBytes[4], seedBytes[5]];
      }
      if (clockseq == null) {
        clockseq = _clockseq = (seedBytes[6] << 8 | seedBytes[7]) & 16383;
      }
    }
    var msecs = options.msecs !== void 0 ? options.msecs : Date.now();
    var nsecs = options.nsecs !== void 0 ? options.nsecs : _lastNSecs + 1;
    var dt = msecs - _lastMSecs + (nsecs - _lastNSecs) / 1e4;
    if (dt < 0 && options.clockseq === void 0) {
      clockseq = clockseq + 1 & 16383;
    }
    if ((dt < 0 || msecs > _lastMSecs) && options.nsecs === void 0) {
      nsecs = 0;
    }
    if (nsecs >= 1e4) {
      throw new Error("uuid.v1(): Can't create more than 10M uuids/sec");
    }
    _lastMSecs = msecs;
    _lastNSecs = nsecs;
    _clockseq = clockseq;
    msecs += 122192928e5;
    var tl = ((msecs & 268435455) * 1e4 + nsecs) % 4294967296;
    b[i++] = tl >>> 24 & 255;
    b[i++] = tl >>> 16 & 255;
    b[i++] = tl >>> 8 & 255;
    b[i++] = tl & 255;
    var tmh = msecs / 4294967296 * 1e4 & 268435455;
    b[i++] = tmh >>> 8 & 255;
    b[i++] = tmh & 255;
    b[i++] = tmh >>> 24 & 15 | 16;
    b[i++] = tmh >>> 16 & 255;
    b[i++] = clockseq >>> 8 | 128;
    b[i++] = clockseq & 255;
    for (var n = 0; n < 6; ++n) {
      b[i + n] = node[n];
    }
    return buf || stringify_default(b);
  }
  var _nodeId, _clockseq, _lastMSecs, _lastNSecs, v1_default;
  var init_v1 = __esm({
    "node_modules/uuid/dist/esm-browser/v1.js"() {
      init_rng();
      init_stringify();
      _lastMSecs = 0;
      _lastNSecs = 0;
      v1_default = v1;
    }
  });

  // node_modules/uuid/dist/esm-browser/parse.js
  function parse(uuid) {
    if (!validate_default(uuid)) {
      throw TypeError("Invalid UUID");
    }
    var v;
    var arr = new Uint8Array(16);
    arr[0] = (v = parseInt(uuid.slice(0, 8), 16)) >>> 24;
    arr[1] = v >>> 16 & 255;
    arr[2] = v >>> 8 & 255;
    arr[3] = v & 255;
    arr[4] = (v = parseInt(uuid.slice(9, 13), 16)) >>> 8;
    arr[5] = v & 255;
    arr[6] = (v = parseInt(uuid.slice(14, 18), 16)) >>> 8;
    arr[7] = v & 255;
    arr[8] = (v = parseInt(uuid.slice(19, 23), 16)) >>> 8;
    arr[9] = v & 255;
    arr[10] = (v = parseInt(uuid.slice(24, 36), 16)) / 1099511627776 & 255;
    arr[11] = v / 4294967296 & 255;
    arr[12] = v >>> 24 & 255;
    arr[13] = v >>> 16 & 255;
    arr[14] = v >>> 8 & 255;
    arr[15] = v & 255;
    return arr;
  }
  var parse_default;
  var init_parse = __esm({
    "node_modules/uuid/dist/esm-browser/parse.js"() {
      init_validate();
      parse_default = parse;
    }
  });

  // node_modules/uuid/dist/esm-browser/v35.js
  function stringToBytes(str2) {
    str2 = unescape(encodeURIComponent(str2));
    var bytes = [];
    for (var i = 0; i < str2.length; ++i) {
      bytes.push(str2.charCodeAt(i));
    }
    return bytes;
  }
  function v35_default(name, version2, hashfunc) {
    function generateUUID(value, namespace, buf, offset2) {
      if (typeof value === "string") {
        value = stringToBytes(value);
      }
      if (typeof namespace === "string") {
        namespace = parse_default(namespace);
      }
      if (namespace.length !== 16) {
        throw TypeError("Namespace must be array-like (16 iterable integer values, 0-255)");
      }
      var bytes = new Uint8Array(16 + value.length);
      bytes.set(namespace);
      bytes.set(value, namespace.length);
      bytes = hashfunc(bytes);
      bytes[6] = bytes[6] & 15 | version2;
      bytes[8] = bytes[8] & 63 | 128;
      if (buf) {
        offset2 = offset2 || 0;
        for (var i = 0; i < 16; ++i) {
          buf[offset2 + i] = bytes[i];
        }
        return buf;
      }
      return stringify_default(bytes);
    }
    try {
      generateUUID.name = name;
    } catch (err2) {
    }
    generateUUID.DNS = DNS;
    generateUUID.URL = URL;
    return generateUUID;
  }
  var DNS, URL;
  var init_v35 = __esm({
    "node_modules/uuid/dist/esm-browser/v35.js"() {
      init_stringify();
      init_parse();
      DNS = "6ba7b810-9dad-11d1-80b4-00c04fd430c8";
      URL = "6ba7b811-9dad-11d1-80b4-00c04fd430c8";
    }
  });

  // node_modules/uuid/dist/esm-browser/md5.js
  function md5(bytes) {
    if (typeof bytes === "string") {
      var msg = unescape(encodeURIComponent(bytes));
      bytes = new Uint8Array(msg.length);
      for (var i = 0; i < msg.length; ++i) {
        bytes[i] = msg.charCodeAt(i);
      }
    }
    return md5ToHexEncodedArray(wordsToMd5(bytesToWords(bytes), bytes.length * 8));
  }
  function md5ToHexEncodedArray(input) {
    var output = [];
    var length32 = input.length * 32;
    var hexTab = "0123456789abcdef";
    for (var i = 0; i < length32; i += 8) {
      var x = input[i >> 5] >>> i % 32 & 255;
      var hex2 = parseInt(hexTab.charAt(x >>> 4 & 15) + hexTab.charAt(x & 15), 16);
      output.push(hex2);
    }
    return output;
  }
  function getOutputLength(inputLength8) {
    return (inputLength8 + 64 >>> 9 << 4) + 14 + 1;
  }
  function wordsToMd5(x, len) {
    x[len >> 5] |= 128 << len % 32;
    x[getOutputLength(len) - 1] = len;
    var a = 1732584193;
    var b = -271733879;
    var c = -1732584194;
    var d = 271733878;
    for (var i = 0; i < x.length; i += 16) {
      var olda = a;
      var oldb = b;
      var oldc = c;
      var oldd = d;
      a = md5ff(a, b, c, d, x[i], 7, -680876936);
      d = md5ff(d, a, b, c, x[i + 1], 12, -389564586);
      c = md5ff(c, d, a, b, x[i + 2], 17, 606105819);
      b = md5ff(b, c, d, a, x[i + 3], 22, -1044525330);
      a = md5ff(a, b, c, d, x[i + 4], 7, -176418897);
      d = md5ff(d, a, b, c, x[i + 5], 12, 1200080426);
      c = md5ff(c, d, a, b, x[i + 6], 17, -1473231341);
      b = md5ff(b, c, d, a, x[i + 7], 22, -45705983);
      a = md5ff(a, b, c, d, x[i + 8], 7, 1770035416);
      d = md5ff(d, a, b, c, x[i + 9], 12, -1958414417);
      c = md5ff(c, d, a, b, x[i + 10], 17, -42063);
      b = md5ff(b, c, d, a, x[i + 11], 22, -1990404162);
      a = md5ff(a, b, c, d, x[i + 12], 7, 1804603682);
      d = md5ff(d, a, b, c, x[i + 13], 12, -40341101);
      c = md5ff(c, d, a, b, x[i + 14], 17, -1502002290);
      b = md5ff(b, c, d, a, x[i + 15], 22, 1236535329);
      a = md5gg(a, b, c, d, x[i + 1], 5, -165796510);
      d = md5gg(d, a, b, c, x[i + 6], 9, -1069501632);
      c = md5gg(c, d, a, b, x[i + 11], 14, 643717713);
      b = md5gg(b, c, d, a, x[i], 20, -373897302);
      a = md5gg(a, b, c, d, x[i + 5], 5, -701558691);
      d = md5gg(d, a, b, c, x[i + 10], 9, 38016083);
      c = md5gg(c, d, a, b, x[i + 15], 14, -660478335);
      b = md5gg(b, c, d, a, x[i + 4], 20, -405537848);
      a = md5gg(a, b, c, d, x[i + 9], 5, 568446438);
      d = md5gg(d, a, b, c, x[i + 14], 9, -1019803690);
      c = md5gg(c, d, a, b, x[i + 3], 14, -187363961);
      b = md5gg(b, c, d, a, x[i + 8], 20, 1163531501);
      a = md5gg(a, b, c, d, x[i + 13], 5, -1444681467);
      d = md5gg(d, a, b, c, x[i + 2], 9, -51403784);
      c = md5gg(c, d, a, b, x[i + 7], 14, 1735328473);
      b = md5gg(b, c, d, a, x[i + 12], 20, -1926607734);
      a = md5hh(a, b, c, d, x[i + 5], 4, -378558);
      d = md5hh(d, a, b, c, x[i + 8], 11, -2022574463);
      c = md5hh(c, d, a, b, x[i + 11], 16, 1839030562);
      b = md5hh(b, c, d, a, x[i + 14], 23, -35309556);
      a = md5hh(a, b, c, d, x[i + 1], 4, -1530992060);
      d = md5hh(d, a, b, c, x[i + 4], 11, 1272893353);
      c = md5hh(c, d, a, b, x[i + 7], 16, -155497632);
      b = md5hh(b, c, d, a, x[i + 10], 23, -1094730640);
      a = md5hh(a, b, c, d, x[i + 13], 4, 681279174);
      d = md5hh(d, a, b, c, x[i], 11, -358537222);
      c = md5hh(c, d, a, b, x[i + 3], 16, -722521979);
      b = md5hh(b, c, d, a, x[i + 6], 23, 76029189);
      a = md5hh(a, b, c, d, x[i + 9], 4, -640364487);
      d = md5hh(d, a, b, c, x[i + 12], 11, -421815835);
      c = md5hh(c, d, a, b, x[i + 15], 16, 530742520);
      b = md5hh(b, c, d, a, x[i + 2], 23, -995338651);
      a = md5ii(a, b, c, d, x[i], 6, -198630844);
      d = md5ii(d, a, b, c, x[i + 7], 10, 1126891415);
      c = md5ii(c, d, a, b, x[i + 14], 15, -1416354905);
      b = md5ii(b, c, d, a, x[i + 5], 21, -57434055);
      a = md5ii(a, b, c, d, x[i + 12], 6, 1700485571);
      d = md5ii(d, a, b, c, x[i + 3], 10, -1894986606);
      c = md5ii(c, d, a, b, x[i + 10], 15, -1051523);
      b = md5ii(b, c, d, a, x[i + 1], 21, -2054922799);
      a = md5ii(a, b, c, d, x[i + 8], 6, 1873313359);
      d = md5ii(d, a, b, c, x[i + 15], 10, -30611744);
      c = md5ii(c, d, a, b, x[i + 6], 15, -1560198380);
      b = md5ii(b, c, d, a, x[i + 13], 21, 1309151649);
      a = md5ii(a, b, c, d, x[i + 4], 6, -145523070);
      d = md5ii(d, a, b, c, x[i + 11], 10, -1120210379);
      c = md5ii(c, d, a, b, x[i + 2], 15, 718787259);
      b = md5ii(b, c, d, a, x[i + 9], 21, -343485551);
      a = safeAdd(a, olda);
      b = safeAdd(b, oldb);
      c = safeAdd(c, oldc);
      d = safeAdd(d, oldd);
    }
    return [a, b, c, d];
  }
  function bytesToWords(input) {
    if (input.length === 0) {
      return [];
    }
    var length8 = input.length * 8;
    var output = new Uint32Array(getOutputLength(length8));
    for (var i = 0; i < length8; i += 8) {
      output[i >> 5] |= (input[i / 8] & 255) << i % 32;
    }
    return output;
  }
  function safeAdd(x, y) {
    var lsw = (x & 65535) + (y & 65535);
    var msw = (x >> 16) + (y >> 16) + (lsw >> 16);
    return msw << 16 | lsw & 65535;
  }
  function bitRotateLeft(num, cnt) {
    return num << cnt | num >>> 32 - cnt;
  }
  function md5cmn(q, a, b, x, s, t) {
    return safeAdd(bitRotateLeft(safeAdd(safeAdd(a, q), safeAdd(x, t)), s), b);
  }
  function md5ff(a, b, c, d, x, s, t) {
    return md5cmn(b & c | ~b & d, a, b, x, s, t);
  }
  function md5gg(a, b, c, d, x, s, t) {
    return md5cmn(b & d | c & ~d, a, b, x, s, t);
  }
  function md5hh(a, b, c, d, x, s, t) {
    return md5cmn(b ^ c ^ d, a, b, x, s, t);
  }
  function md5ii(a, b, c, d, x, s, t) {
    return md5cmn(c ^ (b | ~d), a, b, x, s, t);
  }
  var md5_default;
  var init_md5 = __esm({
    "node_modules/uuid/dist/esm-browser/md5.js"() {
      md5_default = md5;
    }
  });

  // node_modules/uuid/dist/esm-browser/v3.js
  var v3, v3_default;
  var init_v3 = __esm({
    "node_modules/uuid/dist/esm-browser/v3.js"() {
      init_v35();
      init_md5();
      v3 = v35_default("v3", 48, md5_default);
      v3_default = v3;
    }
  });

  // node_modules/uuid/dist/esm-browser/v4.js
  function v4(options, buf, offset2) {
    options = options || {};
    var rnds = options.random || (options.rng || rng)();
    rnds[6] = rnds[6] & 15 | 64;
    rnds[8] = rnds[8] & 63 | 128;
    if (buf) {
      offset2 = offset2 || 0;
      for (var i = 0; i < 16; ++i) {
        buf[offset2 + i] = rnds[i];
      }
      return buf;
    }
    return stringify_default(rnds);
  }
  var v4_default;
  var init_v4 = __esm({
    "node_modules/uuid/dist/esm-browser/v4.js"() {
      init_rng();
      init_stringify();
      v4_default = v4;
    }
  });

  // node_modules/uuid/dist/esm-browser/sha1.js
  function f(s, x, y, z) {
    switch (s) {
      case 0:
        return x & y ^ ~x & z;
      case 1:
        return x ^ y ^ z;
      case 2:
        return x & y ^ x & z ^ y & z;
      case 3:
        return x ^ y ^ z;
    }
  }
  function ROTL(x, n) {
    return x << n | x >>> 32 - n;
  }
  function sha1(bytes) {
    var K = [1518500249, 1859775393, 2400959708, 3395469782];
    var H = [1732584193, 4023233417, 2562383102, 271733878, 3285377520];
    if (typeof bytes === "string") {
      var msg = unescape(encodeURIComponent(bytes));
      bytes = [];
      for (var i = 0; i < msg.length; ++i) {
        bytes.push(msg.charCodeAt(i));
      }
    } else if (!Array.isArray(bytes)) {
      bytes = Array.prototype.slice.call(bytes);
    }
    bytes.push(128);
    var l = bytes.length / 4 + 2;
    var N = Math.ceil(l / 16);
    var M = new Array(N);
    for (var _i = 0; _i < N; ++_i) {
      var arr = new Uint32Array(16);
      for (var j = 0; j < 16; ++j) {
        arr[j] = bytes[_i * 64 + j * 4] << 24 | bytes[_i * 64 + j * 4 + 1] << 16 | bytes[_i * 64 + j * 4 + 2] << 8 | bytes[_i * 64 + j * 4 + 3];
      }
      M[_i] = arr;
    }
    M[N - 1][14] = (bytes.length - 1) * 8 / Math.pow(2, 32);
    M[N - 1][14] = Math.floor(M[N - 1][14]);
    M[N - 1][15] = (bytes.length - 1) * 8 & 4294967295;
    for (var _i2 = 0; _i2 < N; ++_i2) {
      var W = new Uint32Array(80);
      for (var t = 0; t < 16; ++t) {
        W[t] = M[_i2][t];
      }
      for (var _t = 16; _t < 80; ++_t) {
        W[_t] = ROTL(W[_t - 3] ^ W[_t - 8] ^ W[_t - 14] ^ W[_t - 16], 1);
      }
      var a = H[0];
      var b = H[1];
      var c = H[2];
      var d = H[3];
      var e = H[4];
      for (var _t2 = 0; _t2 < 80; ++_t2) {
        var s = Math.floor(_t2 / 20);
        var T = ROTL(a, 5) + f(s, b, c, d) + e + K[s] + W[_t2] >>> 0;
        e = d;
        d = c;
        c = ROTL(b, 30) >>> 0;
        b = a;
        a = T;
      }
      H[0] = H[0] + a >>> 0;
      H[1] = H[1] + b >>> 0;
      H[2] = H[2] + c >>> 0;
      H[3] = H[3] + d >>> 0;
      H[4] = H[4] + e >>> 0;
    }
    return [H[0] >> 24 & 255, H[0] >> 16 & 255, H[0] >> 8 & 255, H[0] & 255, H[1] >> 24 & 255, H[1] >> 16 & 255, H[1] >> 8 & 255, H[1] & 255, H[2] >> 24 & 255, H[2] >> 16 & 255, H[2] >> 8 & 255, H[2] & 255, H[3] >> 24 & 255, H[3] >> 16 & 255, H[3] >> 8 & 255, H[3] & 255, H[4] >> 24 & 255, H[4] >> 16 & 255, H[4] >> 8 & 255, H[4] & 255];
  }
  var sha1_default;
  var init_sha1 = __esm({
    "node_modules/uuid/dist/esm-browser/sha1.js"() {
      sha1_default = sha1;
    }
  });

  // node_modules/uuid/dist/esm-browser/v5.js
  var v5, v5_default;
  var init_v5 = __esm({
    "node_modules/uuid/dist/esm-browser/v5.js"() {
      init_v35();
      init_sha1();
      v5 = v35_default("v5", 80, sha1_default);
      v5_default = v5;
    }
  });

  // node_modules/uuid/dist/esm-browser/nil.js
  var nil_default;
  var init_nil = __esm({
    "node_modules/uuid/dist/esm-browser/nil.js"() {
      nil_default = "00000000-0000-0000-0000-000000000000";
    }
  });

  // node_modules/uuid/dist/esm-browser/version.js
  function version(uuid) {
    if (!validate_default(uuid)) {
      throw TypeError("Invalid UUID");
    }
    return parseInt(uuid.substr(14, 1), 16);
  }
  var version_default;
  var init_version = __esm({
    "node_modules/uuid/dist/esm-browser/version.js"() {
      init_validate();
      version_default = version;
    }
  });

  // node_modules/uuid/dist/esm-browser/index.js
  var esm_browser_exports = {};
  __export(esm_browser_exports, {
    NIL: () => nil_default,
    parse: () => parse_default,
    stringify: () => stringify_default,
    v1: () => v1_default,
    v3: () => v3_default,
    v4: () => v4_default,
    v5: () => v5_default,
    validate: () => validate_default,
    version: () => version_default
  });
  var init_esm_browser = __esm({
    "node_modules/uuid/dist/esm-browser/index.js"() {
      init_v1();
      init_v3();
      init_v4();
      init_v5();
      init_nil();
      init_version();
      init_validate();
      init_stringify();
      init_parse();
    }
  });

  // node_modules/jayson/lib/generateRequest.js
  var require_generateRequest = __commonJS({
    "node_modules/jayson/lib/generateRequest.js"(exports, module) {
      "use strict";
      var uuid = (init_esm_browser(), __toCommonJS(esm_browser_exports)).v4;
      var generateRequest = function(method, params, id, options) {
        if (typeof method !== "string") {
          throw new TypeError(method + " must be a string");
        }
        options = options || {};
        const version2 = typeof options.version === "number" ? options.version : 2;
        if (version2 !== 1 && version2 !== 2) {
          throw new TypeError(version2 + " must be 1 or 2");
        }
        const request = {
          method
        };
        if (version2 === 2) {
          request.jsonrpc = "2.0";
        }
        if (params) {
          if (typeof params !== "object" && !Array.isArray(params)) {
            throw new TypeError(params + " must be an object, array or omitted");
          }
          request.params = params;
        }
        if (typeof id === "undefined") {
          const generator = typeof options.generator === "function" ? options.generator : function() {
            return uuid();
          };
          request.id = generator(request, options);
        } else if (version2 === 2 && id === null) {
          if (options.notificationIdNull) {
            request.id = null;
          }
        } else {
          request.id = id;
        }
        return request;
      };
      module.exports = generateRequest;
    }
  });

  // node_modules/jayson/lib/client/browser/index.js
  var require_browser = __commonJS({
    "node_modules/jayson/lib/client/browser/index.js"(exports, module) {
      "use strict";
      var uuid = (init_esm_browser(), __toCommonJS(esm_browser_exports)).v4;
      var generateRequest = require_generateRequest();
      var ClientBrowser = function(callServer, options) {
        if (!(this instanceof ClientBrowser)) {
          return new ClientBrowser(callServer, options);
        }
        if (!options) {
          options = {};
        }
        this.options = {
          reviver: typeof options.reviver !== "undefined" ? options.reviver : null,
          replacer: typeof options.replacer !== "undefined" ? options.replacer : null,
          generator: typeof options.generator !== "undefined" ? options.generator : function() {
            return uuid();
          },
          version: typeof options.version !== "undefined" ? options.version : 2,
          notificationIdNull: typeof options.notificationIdNull === "boolean" ? options.notificationIdNull : false
        };
        this.callServer = callServer;
      };
      module.exports = ClientBrowser;
      ClientBrowser.prototype.request = function(method, params, id, callback) {
        const self2 = this;
        let request = null;
        const isBatch = Array.isArray(method) && typeof params === "function";
        if (this.options.version === 1 && isBatch) {
          throw new TypeError("JSON-RPC 1.0 does not support batching");
        }
        const isRaw = !isBatch && method && typeof method === "object" && typeof params === "function";
        if (isBatch || isRaw) {
          callback = params;
          request = method;
        } else {
          if (typeof id === "function") {
            callback = id;
            id = void 0;
          }
          const hasCallback = typeof callback === "function";
          try {
            request = generateRequest(method, params, id, {
              generator: this.options.generator,
              version: this.options.version,
              notificationIdNull: this.options.notificationIdNull
            });
          } catch (err2) {
            if (hasCallback) {
              return callback(err2);
            }
            throw err2;
          }
          if (!hasCallback) {
            return request;
          }
        }
        let message;
        try {
          message = JSON.stringify(request, this.options.replacer);
        } catch (err2) {
          return callback(err2);
        }
        this.callServer(message, function(err2, response) {
          self2._parseResponse(err2, response, callback);
        });
        return request;
      };
      ClientBrowser.prototype._parseResponse = function(err2, responseText, callback) {
        if (err2) {
          callback(err2);
          return;
        }
        if (!responseText) {
          return callback();
        }
        let response;
        try {
          response = JSON.parse(responseText, this.options.reviver);
        } catch (err3) {
          return callback(err3);
        }
        if (callback.length === 3) {
          if (Array.isArray(response)) {
            const isError = function(res) {
              return typeof res.error !== "undefined";
            };
            const isNotError = function(res) {
              return !isError(res);
            };
            return callback(null, response.filter(isError), response.filter(isNotError));
          } else {
            return callback(null, response.error, response.result);
          }
        }
        callback(null, response);
      };
    }
  });

  // node_modules/eventemitter3/index.js
  var require_eventemitter3 = __commonJS({
    "node_modules/eventemitter3/index.js"(exports, module) {
      "use strict";
      var has = Object.prototype.hasOwnProperty;
      var prefix = "~";
      function Events() {
      }
      if (Object.create) {
        Events.prototype = /* @__PURE__ */ Object.create(null);
        if (!new Events().__proto__) prefix = false;
      }
      function EE(fn, context, once) {
        this.fn = fn;
        this.context = context;
        this.once = once || false;
      }
      function addListener(emitter, event, fn, context, once) {
        if (typeof fn !== "function") {
          throw new TypeError("The listener must be a function");
        }
        var listener = new EE(fn, context || emitter, once), evt = prefix ? prefix + event : event;
        if (!emitter._events[evt]) emitter._events[evt] = listener, emitter._eventsCount++;
        else if (!emitter._events[evt].fn) emitter._events[evt].push(listener);
        else emitter._events[evt] = [emitter._events[evt], listener];
        return emitter;
      }
      function clearEvent(emitter, evt) {
        if (--emitter._eventsCount === 0) emitter._events = new Events();
        else delete emitter._events[evt];
      }
      function EventEmitter2() {
        this._events = new Events();
        this._eventsCount = 0;
      }
      EventEmitter2.prototype.eventNames = function eventNames() {
        var names = [], events, name;
        if (this._eventsCount === 0) return names;
        for (name in events = this._events) {
          if (has.call(events, name)) names.push(prefix ? name.slice(1) : name);
        }
        if (Object.getOwnPropertySymbols) {
          return names.concat(Object.getOwnPropertySymbols(events));
        }
        return names;
      };
      EventEmitter2.prototype.listeners = function listeners(event) {
        var evt = prefix ? prefix + event : event, handlers = this._events[evt];
        if (!handlers) return [];
        if (handlers.fn) return [handlers.fn];
        for (var i = 0, l = handlers.length, ee = new Array(l); i < l; i++) {
          ee[i] = handlers[i].fn;
        }
        return ee;
      };
      EventEmitter2.prototype.listenerCount = function listenerCount(event) {
        var evt = prefix ? prefix + event : event, listeners = this._events[evt];
        if (!listeners) return 0;
        if (listeners.fn) return 1;
        return listeners.length;
      };
      EventEmitter2.prototype.emit = function emit(event, a1, a2, a3, a4, a5) {
        var evt = prefix ? prefix + event : event;
        if (!this._events[evt]) return false;
        var listeners = this._events[evt], len = arguments.length, args, i;
        if (listeners.fn) {
          if (listeners.once) this.removeListener(event, listeners.fn, void 0, true);
          switch (len) {
            case 1:
              return listeners.fn.call(listeners.context), true;
            case 2:
              return listeners.fn.call(listeners.context, a1), true;
            case 3:
              return listeners.fn.call(listeners.context, a1, a2), true;
            case 4:
              return listeners.fn.call(listeners.context, a1, a2, a3), true;
            case 5:
              return listeners.fn.call(listeners.context, a1, a2, a3, a4), true;
            case 6:
              return listeners.fn.call(listeners.context, a1, a2, a3, a4, a5), true;
          }
          for (i = 1, args = new Array(len - 1); i < len; i++) {
            args[i - 1] = arguments[i];
          }
          listeners.fn.apply(listeners.context, args);
        } else {
          var length = listeners.length, j;
          for (i = 0; i < length; i++) {
            if (listeners[i].once) this.removeListener(event, listeners[i].fn, void 0, true);
            switch (len) {
              case 1:
                listeners[i].fn.call(listeners[i].context);
                break;
              case 2:
                listeners[i].fn.call(listeners[i].context, a1);
                break;
              case 3:
                listeners[i].fn.call(listeners[i].context, a1, a2);
                break;
              case 4:
                listeners[i].fn.call(listeners[i].context, a1, a2, a3);
                break;
              default:
                if (!args) for (j = 1, args = new Array(len - 1); j < len; j++) {
                  args[j - 1] = arguments[j];
                }
                listeners[i].fn.apply(listeners[i].context, args);
            }
          }
        }
        return true;
      };
      EventEmitter2.prototype.on = function on(event, fn, context) {
        return addListener(this, event, fn, context, false);
      };
      EventEmitter2.prototype.once = function once(event, fn, context) {
        return addListener(this, event, fn, context, true);
      };
      EventEmitter2.prototype.removeListener = function removeListener(event, fn, context, once) {
        var evt = prefix ? prefix + event : event;
        if (!this._events[evt]) return this;
        if (!fn) {
          clearEvent(this, evt);
          return this;
        }
        var listeners = this._events[evt];
        if (listeners.fn) {
          if (listeners.fn === fn && (!once || listeners.once) && (!context || listeners.context === context)) {
            clearEvent(this, evt);
          }
        } else {
          for (var i = 0, events = [], length = listeners.length; i < length; i++) {
            if (listeners[i].fn !== fn || once && !listeners[i].once || context && listeners[i].context !== context) {
              events.push(listeners[i]);
            }
          }
          if (events.length) this._events[evt] = events.length === 1 ? events[0] : events;
          else clearEvent(this, evt);
        }
        return this;
      };
      EventEmitter2.prototype.removeAllListeners = function removeAllListeners(event) {
        var evt;
        if (event) {
          evt = prefix ? prefix + event : event;
          if (this._events[evt]) clearEvent(this, evt);
        } else {
          this._events = new Events();
          this._eventsCount = 0;
        }
        return this;
      };
      EventEmitter2.prototype.off = EventEmitter2.prototype.removeListener;
      EventEmitter2.prototype.addListener = EventEmitter2.prototype.on;
      EventEmitter2.prefixed = prefix;
      EventEmitter2.EventEmitter = EventEmitter2;
      if ("undefined" !== typeof module) {
        module.exports = EventEmitter2;
      }
    }
  });

  // node_modules/rpc-websockets/dist/index.browser.cjs
  var require_index_browser4 = __commonJS({
    "node_modules/rpc-websockets/dist/index.browser.cjs"(exports) {
      "use strict";
      var buffer = require_buffer();
      var eventemitter3 = require_eventemitter3();
      var WebSocketBrowserImpl = class extends eventemitter3.EventEmitter {
        /** Instantiate a WebSocket class
        * @constructor
        * @param {String} address - url to a websocket server
        * @param {(Object)} options - websocket options
        * @param {(String|Array)} protocols - a list of protocols
        * @return {WebSocketBrowserImpl} - returns a WebSocket instance
        */
        constructor(address, options, protocols) {
          super();
          __publicField(this, "socket");
          this.socket = new window.WebSocket(address, protocols);
          this.socket.onopen = () => this.emit("open");
          this.socket.onmessage = (event) => this.emit("message", event.data);
          this.socket.onerror = (error) => this.emit("error", error);
          this.socket.onclose = (event) => {
            this.emit("close", event.code, event.reason);
          };
        }
        /**
        * Sends data through a websocket connection
        * @method
        * @param {(String|Object)} data - data to be sent via websocket
        * @param {Object} optionsOrCallback - ws options
        * @param {Function} callback - a callback called once the data is sent
        * @return {Undefined}
        */
        send(data, optionsOrCallback, callback) {
          const cb = callback || optionsOrCallback;
          try {
            this.socket.send(data);
            cb();
          } catch (error) {
            cb(error);
          }
        }
        /**
        * Closes an underlying socket
        * @method
        * @param {Number} code - status code explaining why the connection is being closed
        * @param {String} reason - a description why the connection is closing
        * @return {Undefined}
        * @throws {Error}
        */
        close(code, reason) {
          this.socket.close(code, reason);
        }
        addEventListener(type2, listener, options) {
          this.socket.addEventListener(type2, listener, options);
        }
      };
      function WebSocket(address, options) {
        return new WebSocketBrowserImpl(address, options);
      }
      var DefaultDataPack = class {
        encode(value) {
          return JSON.stringify(value);
        }
        decode(value) {
          return JSON.parse(value);
        }
      };
      var CommonClient = class extends eventemitter3.EventEmitter {
        /**
        * Instantiate a Client class.
        * @constructor
        * @param {webSocketFactory} webSocketFactory - factory method for WebSocket
        * @param {String} address - url to a websocket server
        * @param {Object} options - ws options object with reconnect parameters
        * @param {Function} generate_request_id - custom generation request Id
        * @param {DataPack} dataPack - data pack contains encoder and decoder
        * @return {CommonClient}
        */
        constructor(webSocketFactory, address = "ws://localhost:8080", {
          autoconnect = true,
          reconnect = true,
          reconnect_interval = 1e3,
          max_reconnects = 5,
          ...rest_options
        } = {}, generate_request_id, dataPack) {
          super();
          __publicField(this, "address");
          __publicField(this, "rpc_id");
          __publicField(this, "queue");
          __publicField(this, "options");
          __publicField(this, "autoconnect");
          __publicField(this, "ready");
          __publicField(this, "reconnect");
          __publicField(this, "reconnect_timer_id");
          __publicField(this, "reconnect_interval");
          __publicField(this, "max_reconnects");
          __publicField(this, "rest_options");
          __publicField(this, "current_reconnects");
          __publicField(this, "generate_request_id");
          __publicField(this, "socket");
          __publicField(this, "webSocketFactory");
          __publicField(this, "dataPack");
          this.webSocketFactory = webSocketFactory;
          this.queue = {};
          this.rpc_id = 0;
          this.address = address;
          this.autoconnect = autoconnect;
          this.ready = false;
          this.reconnect = reconnect;
          this.reconnect_timer_id = void 0;
          this.reconnect_interval = reconnect_interval;
          this.max_reconnects = max_reconnects;
          this.rest_options = rest_options;
          this.current_reconnects = 0;
          this.generate_request_id = generate_request_id || (() => typeof this.rpc_id === "number" ? ++this.rpc_id : Number(this.rpc_id) + 1);
          if (!dataPack) this.dataPack = new DefaultDataPack();
          else this.dataPack = dataPack;
          if (this.autoconnect)
            this._connect(this.address, {
              autoconnect: this.autoconnect,
              reconnect: this.reconnect,
              reconnect_interval: this.reconnect_interval,
              max_reconnects: this.max_reconnects,
              ...this.rest_options
            });
        }
        /**
        * Connects to a defined server if not connected already.
        * @method
        * @return {Undefined}
        */
        connect() {
          if (this.socket) return;
          this._connect(this.address, {
            autoconnect: this.autoconnect,
            reconnect: this.reconnect,
            reconnect_interval: this.reconnect_interval,
            max_reconnects: this.max_reconnects,
            ...this.rest_options
          });
        }
        /**
        * Calls a registered RPC method on server.
        * @method
        * @param {String} method - RPC method name
        * @param {Object|Array} params - optional method parameters
        * @param {Number} timeout - RPC reply timeout value
        * @param {Object} ws_opts - options passed to ws
        * @return {Promise}
        */
        call(method, params, timeout, ws_opts) {
          if (!ws_opts && "object" === typeof timeout) {
            ws_opts = timeout;
            timeout = null;
          }
          return new Promise((resolve, reject) => {
            if (!this.ready) return reject(new Error("socket not ready"));
            const rpc_id = this.generate_request_id(method, params);
            const message = {
              jsonrpc: "2.0",
              method,
              params: params || void 0,
              id: rpc_id
            };
            this.socket.send(this.dataPack.encode(message), ws_opts, (error) => {
              if (error) return reject(error);
              this.queue[rpc_id] = { promise: [resolve, reject] };
              if (timeout) {
                this.queue[rpc_id].timeout = setTimeout(() => {
                  delete this.queue[rpc_id];
                  reject(new Error("reply timeout"));
                }, timeout);
              }
            });
          });
        }
        /**
        * Logins with the other side of the connection.
        * @method
        * @param {Object} params - Login credentials object
        * @return {Promise}
        */
        async login(params) {
          const resp = await this.call("rpc.login", params);
          if (!resp) throw new Error("authentication failed");
          return resp;
        }
        /**
        * Fetches a list of client's methods registered on server.
        * @method
        * @return {Array}
        */
        async listMethods() {
          return await this.call("__listMethods");
        }
        /**
        * Sends a JSON-RPC 2.0 notification to server.
        * @method
        * @param {String} method - RPC method name
        * @param {Object} params - optional method parameters
        * @return {Promise}
        */
        notify(method, params) {
          return new Promise((resolve, reject) => {
            if (!this.ready) return reject(new Error("socket not ready"));
            const message = {
              jsonrpc: "2.0",
              method,
              params
            };
            this.socket.send(this.dataPack.encode(message), (error) => {
              if (error) return reject(error);
              resolve();
            });
          });
        }
        /**
        * Subscribes for a defined event.
        * @method
        * @param {String|Array} event - event name
        * @return {Undefined}
        * @throws {Error}
        */
        async subscribe(event) {
          if (typeof event === "string") event = [event];
          const result = await this.call("rpc.on", event);
          if (typeof event === "string" && result[event] !== "ok")
            throw new Error(
              "Failed subscribing to an event '" + event + "' with: " + result[event]
            );
          return result;
        }
        /**
        * Unsubscribes from a defined event.
        * @method
        * @param {String|Array} event - event name
        * @return {Undefined}
        * @throws {Error}
        */
        async unsubscribe(event) {
          if (typeof event === "string") event = [event];
          const result = await this.call("rpc.off", event);
          if (typeof event === "string" && result[event] !== "ok")
            throw new Error("Failed unsubscribing from an event with: " + result);
          return result;
        }
        /**
        * Closes a WebSocket connection gracefully.
        * @method
        * @param {Number} code - socket close code
        * @param {String} data - optional data to be sent before closing
        * @return {Undefined}
        */
        close(code, data) {
          if (this.socket) this.socket.close(code || 1e3, data);
        }
        /**
        * Enable / disable automatic reconnection.
        * @method
        * @param {Boolean} reconnect - enable / disable reconnection
        * @return {Undefined}
        */
        setAutoReconnect(reconnect) {
          this.reconnect = reconnect;
        }
        /**
        * Set the interval between reconnection attempts.
        * @method
        * @param {Number} interval - reconnection interval in milliseconds
        * @return {Undefined}
        */
        setReconnectInterval(interval) {
          this.reconnect_interval = interval;
        }
        /**
        * Set the maximum number of reconnection attempts.
        * @method
        * @param {Number} max_reconnects - maximum reconnection attempts
        * @return {Undefined}
        */
        setMaxReconnects(max_reconnects) {
          this.max_reconnects = max_reconnects;
        }
        /**
        * Get the current number of reconnection attempts made.
        * @method
        * @return {Number} current reconnection attempts
        */
        getCurrentReconnects() {
          return this.current_reconnects;
        }
        /**
        * Get the maximum number of reconnection attempts.
        * @method
        * @return {Number} maximum reconnection attempts
        */
        getMaxReconnects() {
          return this.max_reconnects;
        }
        /**
        * Check if the client is currently attempting to reconnect.
        * @method
        * @return {Boolean} true if reconnection is in progress
        */
        isReconnecting() {
          return this.reconnect_timer_id !== void 0;
        }
        /**
        * Check if the client will attempt to reconnect on the next close event.
        * @method
        * @return {Boolean} true if reconnection will be attempted
        */
        willReconnect() {
          return this.reconnect && (this.max_reconnects === 0 || this.current_reconnects < this.max_reconnects);
        }
        /**
        * Connection/Message handler.
        * @method
        * @private
        * @param {String} address - WebSocket API address
        * @param {Object} options - ws options object
        * @return {Undefined}
        */
        _connect(address, options) {
          clearTimeout(this.reconnect_timer_id);
          this.socket = this.webSocketFactory(address, options);
          this.socket.addEventListener("open", () => {
            this.ready = true;
            this.emit("open");
            this.current_reconnects = 0;
          });
          this.socket.addEventListener("message", ({ data: message }) => {
            if (message instanceof ArrayBuffer)
              message = buffer.Buffer.from(message).toString();
            try {
              message = this.dataPack.decode(message);
            } catch (error) {
              return;
            }
            if (message.notification && this.listeners(message.notification).length) {
              if (!Object.keys(message.params).length)
                return this.emit(message.notification);
              const args = [message.notification];
              if (message.params.constructor === Object) args.push(message.params);
              else
                for (let i = 0; i < message.params.length; i++)
                  args.push(message.params[i]);
              return Promise.resolve().then(() => {
                this.emit.apply(this, args);
              });
            }
            if (!this.queue[message.id]) {
              if (message.method) {
                return Promise.resolve().then(() => {
                  this.emit(message.method, message?.params);
                });
              }
              return;
            }
            if ("error" in message === "result" in message)
              this.queue[message.id].promise[1](
                new Error(
                  'Server response malformed. Response must include either "result" or "error", but not both.'
                )
              );
            if (this.queue[message.id].timeout)
              clearTimeout(this.queue[message.id].timeout);
            if (message.error) this.queue[message.id].promise[1](message.error);
            else this.queue[message.id].promise[0](message.result);
            delete this.queue[message.id];
          });
          this.socket.addEventListener("error", (error) => this.emit("error", error));
          this.socket.addEventListener("close", ({ code, reason }) => {
            if (this.ready)
              setTimeout(() => this.emit("close", code, reason), 0);
            this.ready = false;
            this.socket = void 0;
            if (code === 1e3) return;
            this.current_reconnects++;
            if (this.reconnect && (this.max_reconnects > this.current_reconnects || this.max_reconnects === 0))
              this.reconnect_timer_id = setTimeout(
                () => this._connect(address, options),
                this.reconnect_interval
              );
            else if (this.reconnect && this.max_reconnects > 0 && this.current_reconnects >= this.max_reconnects) {
              setTimeout(() => this.emit("max_reconnects_reached", code, reason), 1);
            }
          });
        }
      };
      var Client = class extends CommonClient {
        constructor(address = "ws://localhost:8080", {
          autoconnect = true,
          reconnect = true,
          reconnect_interval = 1e3,
          max_reconnects = 5
        } = {}, generate_request_id) {
          super(
            WebSocket,
            address,
            {
              autoconnect,
              reconnect,
              reconnect_interval,
              max_reconnects
            },
            generate_request_id
          );
        }
      };
      exports.Client = Client;
      exports.CommonClient = CommonClient;
      exports.DefaultDataPack = DefaultDataPack;
      exports.WebSocket = WebSocket;
    }
  });

  // node_modules/@noble/hashes/sha3.js
  var require_sha3 = __commonJS({
    "node_modules/@noble/hashes/sha3.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.shake256 = exports.shake128 = exports.keccak_512 = exports.keccak_384 = exports.keccak_256 = exports.keccak_224 = exports.sha3_512 = exports.sha3_384 = exports.sha3_256 = exports.sha3_224 = exports.Keccak = void 0;
      exports.keccakP = keccakP;
      var _u64_ts_1 = require_u64();
      var utils_ts_1 = require_utils();
      var _0n = BigInt(0);
      var _1n = BigInt(1);
      var _2n = BigInt(2);
      var _7n = BigInt(7);
      var _256n = BigInt(256);
      var _0x71n = BigInt(113);
      var SHA3_PI = [];
      var SHA3_ROTL = [];
      var _SHA3_IOTA = [];
      for (let round = 0, R = _1n, x = 1, y = 0; round < 24; round++) {
        [x, y] = [y, (2 * x + 3 * y) % 5];
        SHA3_PI.push(2 * (5 * y + x));
        SHA3_ROTL.push((round + 1) * (round + 2) / 2 % 64);
        let t = _0n;
        for (let j = 0; j < 7; j++) {
          R = (R << _1n ^ (R >> _7n) * _0x71n) % _256n;
          if (R & _2n)
            t ^= _1n << (_1n << /* @__PURE__ */ BigInt(j)) - _1n;
        }
        _SHA3_IOTA.push(t);
      }
      var IOTAS = (0, _u64_ts_1.split)(_SHA3_IOTA, true);
      var SHA3_IOTA_H = IOTAS[0];
      var SHA3_IOTA_L = IOTAS[1];
      var rotlH = (h, l, s) => s > 32 ? (0, _u64_ts_1.rotlBH)(h, l, s) : (0, _u64_ts_1.rotlSH)(h, l, s);
      var rotlL = (h, l, s) => s > 32 ? (0, _u64_ts_1.rotlBL)(h, l, s) : (0, _u64_ts_1.rotlSL)(h, l, s);
      function keccakP(s, rounds = 24) {
        const B = new Uint32Array(5 * 2);
        for (let round = 24 - rounds; round < 24; round++) {
          for (let x = 0; x < 10; x++)
            B[x] = s[x] ^ s[x + 10] ^ s[x + 20] ^ s[x + 30] ^ s[x + 40];
          for (let x = 0; x < 10; x += 2) {
            const idx1 = (x + 8) % 10;
            const idx0 = (x + 2) % 10;
            const B0 = B[idx0];
            const B1 = B[idx0 + 1];
            const Th = rotlH(B0, B1, 1) ^ B[idx1];
            const Tl = rotlL(B0, B1, 1) ^ B[idx1 + 1];
            for (let y = 0; y < 50; y += 10) {
              s[x + y] ^= Th;
              s[x + y + 1] ^= Tl;
            }
          }
          let curH = s[2];
          let curL = s[3];
          for (let t = 0; t < 24; t++) {
            const shift = SHA3_ROTL[t];
            const Th = rotlH(curH, curL, shift);
            const Tl = rotlL(curH, curL, shift);
            const PI = SHA3_PI[t];
            curH = s[PI];
            curL = s[PI + 1];
            s[PI] = Th;
            s[PI + 1] = Tl;
          }
          for (let y = 0; y < 50; y += 10) {
            for (let x = 0; x < 10; x++)
              B[x] = s[y + x];
            for (let x = 0; x < 10; x++)
              s[y + x] ^= ~B[(x + 2) % 10] & B[(x + 4) % 10];
          }
          s[0] ^= SHA3_IOTA_H[round];
          s[1] ^= SHA3_IOTA_L[round];
        }
        (0, utils_ts_1.clean)(B);
      }
      var Keccak = class _Keccak extends utils_ts_1.Hash {
        // NOTE: we accept arguments in bytes instead of bits here.
        constructor(blockLen, suffix, outputLen, enableXOF = false, rounds = 24) {
          super();
          this.pos = 0;
          this.posOut = 0;
          this.finished = false;
          this.destroyed = false;
          this.enableXOF = false;
          this.blockLen = blockLen;
          this.suffix = suffix;
          this.outputLen = outputLen;
          this.enableXOF = enableXOF;
          this.rounds = rounds;
          (0, utils_ts_1.anumber)(outputLen);
          if (!(0 < blockLen && blockLen < 200))
            throw new Error("only keccak-f1600 function is supported");
          this.state = new Uint8Array(200);
          this.state32 = (0, utils_ts_1.u32)(this.state);
        }
        clone() {
          return this._cloneInto();
        }
        keccak() {
          (0, utils_ts_1.swap32IfBE)(this.state32);
          keccakP(this.state32, this.rounds);
          (0, utils_ts_1.swap32IfBE)(this.state32);
          this.posOut = 0;
          this.pos = 0;
        }
        update(data) {
          (0, utils_ts_1.aexists)(this);
          data = (0, utils_ts_1.toBytes)(data);
          (0, utils_ts_1.abytes)(data);
          const { blockLen, state } = this;
          const len = data.length;
          for (let pos = 0; pos < len; ) {
            const take = Math.min(blockLen - this.pos, len - pos);
            for (let i = 0; i < take; i++)
              state[this.pos++] ^= data[pos++];
            if (this.pos === blockLen)
              this.keccak();
          }
          return this;
        }
        finish() {
          if (this.finished)
            return;
          this.finished = true;
          const { state, suffix, pos, blockLen } = this;
          state[pos] ^= suffix;
          if ((suffix & 128) !== 0 && pos === blockLen - 1)
            this.keccak();
          state[blockLen - 1] ^= 128;
          this.keccak();
        }
        writeInto(out) {
          (0, utils_ts_1.aexists)(this, false);
          (0, utils_ts_1.abytes)(out);
          this.finish();
          const bufferOut = this.state;
          const { blockLen } = this;
          for (let pos = 0, len = out.length; pos < len; ) {
            if (this.posOut >= blockLen)
              this.keccak();
            const take = Math.min(blockLen - this.posOut, len - pos);
            out.set(bufferOut.subarray(this.posOut, this.posOut + take), pos);
            this.posOut += take;
            pos += take;
          }
          return out;
        }
        xofInto(out) {
          if (!this.enableXOF)
            throw new Error("XOF is not possible for this instance");
          return this.writeInto(out);
        }
        xof(bytes) {
          (0, utils_ts_1.anumber)(bytes);
          return this.xofInto(new Uint8Array(bytes));
        }
        digestInto(out) {
          (0, utils_ts_1.aoutput)(out, this);
          if (this.finished)
            throw new Error("digest() was already called");
          this.writeInto(out);
          this.destroy();
          return out;
        }
        digest() {
          return this.digestInto(new Uint8Array(this.outputLen));
        }
        destroy() {
          this.destroyed = true;
          (0, utils_ts_1.clean)(this.state);
        }
        _cloneInto(to) {
          const { blockLen, suffix, outputLen, rounds, enableXOF } = this;
          to || (to = new _Keccak(blockLen, suffix, outputLen, enableXOF, rounds));
          to.state32.set(this.state32);
          to.pos = this.pos;
          to.posOut = this.posOut;
          to.finished = this.finished;
          to.rounds = rounds;
          to.suffix = suffix;
          to.outputLen = outputLen;
          to.enableXOF = enableXOF;
          to.destroyed = this.destroyed;
          return to;
        }
      };
      exports.Keccak = Keccak;
      var gen = (suffix, blockLen, outputLen) => (0, utils_ts_1.createHasher)(() => new Keccak(blockLen, suffix, outputLen));
      exports.sha3_224 = (() => gen(6, 144, 224 / 8))();
      exports.sha3_256 = (() => gen(6, 136, 256 / 8))();
      exports.sha3_384 = (() => gen(6, 104, 384 / 8))();
      exports.sha3_512 = (() => gen(6, 72, 512 / 8))();
      exports.keccak_224 = (() => gen(1, 144, 224 / 8))();
      exports.keccak_256 = (() => gen(1, 136, 256 / 8))();
      exports.keccak_384 = (() => gen(1, 104, 384 / 8))();
      exports.keccak_512 = (() => gen(1, 72, 512 / 8))();
      var genShake = (suffix, blockLen, outputLen) => (0, utils_ts_1.createXOFer)((opts = {}) => new Keccak(blockLen, suffix, opts.dkLen === void 0 ? outputLen : opts.dkLen, true));
      exports.shake128 = (() => genShake(31, 168, 128 / 8))();
      exports.shake256 = (() => genShake(31, 136, 256 / 8))();
    }
  });

  // node_modules/@noble/hashes/hmac.js
  var require_hmac = __commonJS({
    "node_modules/@noble/hashes/hmac.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.hmac = exports.HMAC = void 0;
      var utils_ts_1 = require_utils();
      var HMAC = class extends utils_ts_1.Hash {
        constructor(hash2, _key) {
          super();
          this.finished = false;
          this.destroyed = false;
          (0, utils_ts_1.ahash)(hash2);
          const key = (0, utils_ts_1.toBytes)(_key);
          this.iHash = hash2.create();
          if (typeof this.iHash.update !== "function")
            throw new Error("Expected instance of class which extends utils.Hash");
          this.blockLen = this.iHash.blockLen;
          this.outputLen = this.iHash.outputLen;
          const blockLen = this.blockLen;
          const pad = new Uint8Array(blockLen);
          pad.set(key.length > blockLen ? hash2.create().update(key).digest() : key);
          for (let i = 0; i < pad.length; i++)
            pad[i] ^= 54;
          this.iHash.update(pad);
          this.oHash = hash2.create();
          for (let i = 0; i < pad.length; i++)
            pad[i] ^= 54 ^ 92;
          this.oHash.update(pad);
          (0, utils_ts_1.clean)(pad);
        }
        update(buf) {
          (0, utils_ts_1.aexists)(this);
          this.iHash.update(buf);
          return this;
        }
        digestInto(out) {
          (0, utils_ts_1.aexists)(this);
          (0, utils_ts_1.abytes)(out, this.outputLen);
          this.finished = true;
          this.iHash.digestInto(out);
          this.oHash.update(out);
          this.oHash.digestInto(out);
          this.destroy();
        }
        digest() {
          const out = new Uint8Array(this.oHash.outputLen);
          this.digestInto(out);
          return out;
        }
        _cloneInto(to) {
          to || (to = Object.create(Object.getPrototypeOf(this), {}));
          const { oHash, iHash, finished, destroyed, blockLen, outputLen } = this;
          to = to;
          to.finished = finished;
          to.destroyed = destroyed;
          to.blockLen = blockLen;
          to.outputLen = outputLen;
          to.oHash = oHash._cloneInto(to.oHash);
          to.iHash = iHash._cloneInto(to.iHash);
          return to;
        }
        clone() {
          return this._cloneInto();
        }
        destroy() {
          this.destroyed = true;
          this.oHash.destroy();
          this.iHash.destroy();
        }
      };
      exports.HMAC = HMAC;
      var hmac = (hash2, key, message) => new HMAC(hash2, key).update(message).digest();
      exports.hmac = hmac;
      exports.hmac.create = (hash2, key) => new HMAC(hash2, key);
    }
  });

  // node_modules/@noble/curves/abstract/weierstrass.js
  var require_weierstrass = __commonJS({
    "node_modules/@noble/curves/abstract/weierstrass.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.DER = exports.DERErr = void 0;
      exports._splitEndoScalar = _splitEndoScalar;
      exports._normFnElement = _normFnElement;
      exports.weierstrassN = weierstrassN;
      exports.SWUFpSqrtRatio = SWUFpSqrtRatio;
      exports.mapToCurveSimpleSWU = mapToCurveSimpleSWU;
      exports.ecdh = ecdh;
      exports.ecdsa = ecdsa;
      exports.weierstrassPoints = weierstrassPoints;
      exports._legacyHelperEquat = _legacyHelperEquat;
      exports.weierstrass = weierstrass;
      var hmac_js_1 = require_hmac();
      var utils_1 = require_utils();
      var utils_ts_1 = require_utils2();
      var curve_ts_1 = require_curve();
      var modular_ts_1 = require_modular();
      var divNearest = (num, den) => (num + (num >= 0 ? den : -den) / _2n) / den;
      function _splitEndoScalar(k, basis, n) {
        const [[a1, b1], [a2, b2]] = basis;
        const c1 = divNearest(b2 * k, n);
        const c2 = divNearest(-b1 * k, n);
        let k1 = k - c1 * a1 - c2 * a2;
        let k2 = -c1 * b1 - c2 * b2;
        const k1neg = k1 < _0n;
        const k2neg = k2 < _0n;
        if (k1neg)
          k1 = -k1;
        if (k2neg)
          k2 = -k2;
        const MAX_NUM = (0, utils_ts_1.bitMask)(Math.ceil((0, utils_ts_1.bitLen)(n) / 2)) + _1n;
        if (k1 < _0n || k1 >= MAX_NUM || k2 < _0n || k2 >= MAX_NUM) {
          throw new Error("splitScalar (endomorphism): failed, k=" + k);
        }
        return { k1neg, k1, k2neg, k2 };
      }
      function validateSigFormat(format) {
        if (!["compact", "recovered", "der"].includes(format))
          throw new Error('Signature format must be "compact", "recovered", or "der"');
        return format;
      }
      function validateSigOpts(opts, def) {
        const optsn = {};
        for (let optName of Object.keys(def)) {
          optsn[optName] = opts[optName] === void 0 ? def[optName] : opts[optName];
        }
        (0, utils_ts_1._abool2)(optsn.lowS, "lowS");
        (0, utils_ts_1._abool2)(optsn.prehash, "prehash");
        if (optsn.format !== void 0)
          validateSigFormat(optsn.format);
        return optsn;
      }
      var DERErr = class extends Error {
        constructor(m = "") {
          super(m);
        }
      };
      exports.DERErr = DERErr;
      exports.DER = {
        // asn.1 DER encoding utils
        Err: DERErr,
        // Basic building block is TLV (Tag-Length-Value)
        _tlv: {
          encode: (tag, data) => {
            const { Err: E } = exports.DER;
            if (tag < 0 || tag > 256)
              throw new E("tlv.encode: wrong tag");
            if (data.length & 1)
              throw new E("tlv.encode: unpadded data");
            const dataLen = data.length / 2;
            const len = (0, utils_ts_1.numberToHexUnpadded)(dataLen);
            if (len.length / 2 & 128)
              throw new E("tlv.encode: long form length too big");
            const lenLen = dataLen > 127 ? (0, utils_ts_1.numberToHexUnpadded)(len.length / 2 | 128) : "";
            const t = (0, utils_ts_1.numberToHexUnpadded)(tag);
            return t + lenLen + len + data;
          },
          // v - value, l - left bytes (unparsed)
          decode(tag, data) {
            const { Err: E } = exports.DER;
            let pos = 0;
            if (tag < 0 || tag > 256)
              throw new E("tlv.encode: wrong tag");
            if (data.length < 2 || data[pos++] !== tag)
              throw new E("tlv.decode: wrong tlv");
            const first = data[pos++];
            const isLong = !!(first & 128);
            let length = 0;
            if (!isLong)
              length = first;
            else {
              const lenLen = first & 127;
              if (!lenLen)
                throw new E("tlv.decode(long): indefinite length not supported");
              if (lenLen > 4)
                throw new E("tlv.decode(long): byte length is too big");
              const lengthBytes = data.subarray(pos, pos + lenLen);
              if (lengthBytes.length !== lenLen)
                throw new E("tlv.decode: length bytes not complete");
              if (lengthBytes[0] === 0)
                throw new E("tlv.decode(long): zero leftmost byte");
              for (const b of lengthBytes)
                length = length << 8 | b;
              pos += lenLen;
              if (length < 128)
                throw new E("tlv.decode(long): not minimal encoding");
            }
            const v = data.subarray(pos, pos + length);
            if (v.length !== length)
              throw new E("tlv.decode: wrong value length");
            return { v, l: data.subarray(pos + length) };
          }
        },
        // https://crypto.stackexchange.com/a/57734 Leftmost bit of first byte is 'negative' flag,
        // since we always use positive integers here. It must always be empty:
        // - add zero byte if exists
        // - if next byte doesn't have a flag, leading zero is not allowed (minimal encoding)
        _int: {
          encode(num) {
            const { Err: E } = exports.DER;
            if (num < _0n)
              throw new E("integer: negative integers are not allowed");
            let hex2 = (0, utils_ts_1.numberToHexUnpadded)(num);
            if (Number.parseInt(hex2[0], 16) & 8)
              hex2 = "00" + hex2;
            if (hex2.length & 1)
              throw new E("unexpected DER parsing assertion: unpadded hex");
            return hex2;
          },
          decode(data) {
            const { Err: E } = exports.DER;
            if (data[0] & 128)
              throw new E("invalid signature integer: negative");
            if (data[0] === 0 && !(data[1] & 128))
              throw new E("invalid signature integer: unnecessary leading zero");
            return (0, utils_ts_1.bytesToNumberBE)(data);
          }
        },
        toSig(hex2) {
          const { Err: E, _int: int, _tlv: tlv } = exports.DER;
          const data = (0, utils_ts_1.ensureBytes)("signature", hex2);
          const { v: seqBytes, l: seqLeftBytes } = tlv.decode(48, data);
          if (seqLeftBytes.length)
            throw new E("invalid signature: left bytes after parsing");
          const { v: rBytes, l: rLeftBytes } = tlv.decode(2, seqBytes);
          const { v: sBytes, l: sLeftBytes } = tlv.decode(2, rLeftBytes);
          if (sLeftBytes.length)
            throw new E("invalid signature: left bytes after parsing");
          return { r: int.decode(rBytes), s: int.decode(sBytes) };
        },
        hexFromSig(sig) {
          const { _tlv: tlv, _int: int } = exports.DER;
          const rs = tlv.encode(2, int.encode(sig.r));
          const ss = tlv.encode(2, int.encode(sig.s));
          const seq = rs + ss;
          return tlv.encode(48, seq);
        }
      };
      var _0n = BigInt(0);
      var _1n = BigInt(1);
      var _2n = BigInt(2);
      var _3n = BigInt(3);
      var _4n = BigInt(4);
      function _normFnElement(Fn, key) {
        const { BYTES: expected } = Fn;
        let num;
        if (typeof key === "bigint") {
          num = key;
        } else {
          let bytes = (0, utils_ts_1.ensureBytes)("private key", key);
          try {
            num = Fn.fromBytes(bytes);
          } catch (error) {
            throw new Error(`invalid private key: expected ui8a of size ${expected}, got ${typeof key}`);
          }
        }
        if (!Fn.isValidNot0(num))
          throw new Error("invalid private key: out of range [1..N-1]");
        return num;
      }
      function weierstrassN(params, extraOpts = {}) {
        const validated = (0, curve_ts_1._createCurveFields)("weierstrass", params, extraOpts);
        const { Fp, Fn } = validated;
        let CURVE = validated.CURVE;
        const { h: cofactor, n: CURVE_ORDER } = CURVE;
        (0, utils_ts_1._validateObject)(extraOpts, {}, {
          allowInfinityPoint: "boolean",
          clearCofactor: "function",
          isTorsionFree: "function",
          fromBytes: "function",
          toBytes: "function",
          endo: "object",
          wrapPrivateKey: "boolean"
        });
        const { endo } = extraOpts;
        if (endo) {
          if (!Fp.is0(CURVE.a) || typeof endo.beta !== "bigint" || !Array.isArray(endo.basises)) {
            throw new Error('invalid endo: expected "beta": bigint and "basises": array');
          }
        }
        const lengths = getWLengths(Fp, Fn);
        function assertCompressionIsSupported() {
          if (!Fp.isOdd)
            throw new Error("compression is not supported: Field does not have .isOdd()");
        }
        function pointToBytes(_c, point, isCompressed) {
          const { x, y } = point.toAffine();
          const bx = Fp.toBytes(x);
          (0, utils_ts_1._abool2)(isCompressed, "isCompressed");
          if (isCompressed) {
            assertCompressionIsSupported();
            const hasEvenY = !Fp.isOdd(y);
            return (0, utils_ts_1.concatBytes)(pprefix(hasEvenY), bx);
          } else {
            return (0, utils_ts_1.concatBytes)(Uint8Array.of(4), bx, Fp.toBytes(y));
          }
        }
        function pointFromBytes(bytes) {
          (0, utils_ts_1._abytes2)(bytes, void 0, "Point");
          const { publicKey: comp, publicKeyUncompressed: uncomp } = lengths;
          const length = bytes.length;
          const head = bytes[0];
          const tail = bytes.subarray(1);
          if (length === comp && (head === 2 || head === 3)) {
            const x = Fp.fromBytes(tail);
            if (!Fp.isValid(x))
              throw new Error("bad point: is not on curve, wrong x");
            const y2 = weierstrassEquation(x);
            let y;
            try {
              y = Fp.sqrt(y2);
            } catch (sqrtError) {
              const err2 = sqrtError instanceof Error ? ": " + sqrtError.message : "";
              throw new Error("bad point: is not on curve, sqrt error" + err2);
            }
            assertCompressionIsSupported();
            const isYOdd = Fp.isOdd(y);
            const isHeadOdd = (head & 1) === 1;
            if (isHeadOdd !== isYOdd)
              y = Fp.neg(y);
            return { x, y };
          } else if (length === uncomp && head === 4) {
            const L = Fp.BYTES;
            const x = Fp.fromBytes(tail.subarray(0, L));
            const y = Fp.fromBytes(tail.subarray(L, L * 2));
            if (!isValidXY(x, y))
              throw new Error("bad point: is not on curve");
            return { x, y };
          } else {
            throw new Error(`bad point: got length ${length}, expected compressed=${comp} or uncompressed=${uncomp}`);
          }
        }
        const encodePoint = extraOpts.toBytes || pointToBytes;
        const decodePoint = extraOpts.fromBytes || pointFromBytes;
        function weierstrassEquation(x) {
          const x2 = Fp.sqr(x);
          const x3 = Fp.mul(x2, x);
          return Fp.add(Fp.add(x3, Fp.mul(x, CURVE.a)), CURVE.b);
        }
        function isValidXY(x, y) {
          const left = Fp.sqr(y);
          const right = weierstrassEquation(x);
          return Fp.eql(left, right);
        }
        if (!isValidXY(CURVE.Gx, CURVE.Gy))
          throw new Error("bad curve params: generator point");
        const _4a3 = Fp.mul(Fp.pow(CURVE.a, _3n), _4n);
        const _27b2 = Fp.mul(Fp.sqr(CURVE.b), BigInt(27));
        if (Fp.is0(Fp.add(_4a3, _27b2)))
          throw new Error("bad curve params: a or b");
        function acoord(title, n, banZero = false) {
          if (!Fp.isValid(n) || banZero && Fp.is0(n))
            throw new Error(`bad point coordinate ${title}`);
          return n;
        }
        function aprjpoint(other) {
          if (!(other instanceof Point))
            throw new Error("ProjectivePoint expected");
        }
        function splitEndoScalarN(k) {
          if (!endo || !endo.basises)
            throw new Error("no endo");
          return _splitEndoScalar(k, endo.basises, Fn.ORDER);
        }
        const toAffineMemo = (0, utils_ts_1.memoized)((p, iz) => {
          const { X, Y, Z } = p;
          if (Fp.eql(Z, Fp.ONE))
            return { x: X, y: Y };
          const is0 = p.is0();
          if (iz == null)
            iz = is0 ? Fp.ONE : Fp.inv(Z);
          const x = Fp.mul(X, iz);
          const y = Fp.mul(Y, iz);
          const zz = Fp.mul(Z, iz);
          if (is0)
            return { x: Fp.ZERO, y: Fp.ZERO };
          if (!Fp.eql(zz, Fp.ONE))
            throw new Error("invZ was invalid");
          return { x, y };
        });
        const assertValidMemo = (0, utils_ts_1.memoized)((p) => {
          if (p.is0()) {
            if (extraOpts.allowInfinityPoint && !Fp.is0(p.Y))
              return;
            throw new Error("bad point: ZERO");
          }
          const { x, y } = p.toAffine();
          if (!Fp.isValid(x) || !Fp.isValid(y))
            throw new Error("bad point: x or y not field elements");
          if (!isValidXY(x, y))
            throw new Error("bad point: equation left != right");
          if (!p.isTorsionFree())
            throw new Error("bad point: not in prime-order subgroup");
          return true;
        });
        function finishEndo(endoBeta, k1p, k2p, k1neg, k2neg) {
          k2p = new Point(Fp.mul(k2p.X, endoBeta), k2p.Y, k2p.Z);
          k1p = (0, curve_ts_1.negateCt)(k1neg, k1p);
          k2p = (0, curve_ts_1.negateCt)(k2neg, k2p);
          return k1p.add(k2p);
        }
        class Point {
          /** Does NOT validate if the point is valid. Use `.assertValidity()`. */
          constructor(X, Y, Z) {
            this.X = acoord("x", X);
            this.Y = acoord("y", Y, true);
            this.Z = acoord("z", Z);
            Object.freeze(this);
          }
          static CURVE() {
            return CURVE;
          }
          /** Does NOT validate if the point is valid. Use `.assertValidity()`. */
          static fromAffine(p) {
            const { x, y } = p || {};
            if (!p || !Fp.isValid(x) || !Fp.isValid(y))
              throw new Error("invalid affine point");
            if (p instanceof Point)
              throw new Error("projective point not allowed");
            if (Fp.is0(x) && Fp.is0(y))
              return Point.ZERO;
            return new Point(x, y, Fp.ONE);
          }
          static fromBytes(bytes) {
            const P = Point.fromAffine(decodePoint((0, utils_ts_1._abytes2)(bytes, void 0, "point")));
            P.assertValidity();
            return P;
          }
          static fromHex(hex2) {
            return Point.fromBytes((0, utils_ts_1.ensureBytes)("pointHex", hex2));
          }
          get x() {
            return this.toAffine().x;
          }
          get y() {
            return this.toAffine().y;
          }
          /**
           *
           * @param windowSize
           * @param isLazy true will defer table computation until the first multiplication
           * @returns
           */
          precompute(windowSize = 8, isLazy = true) {
            wnaf.createCache(this, windowSize);
            if (!isLazy)
              this.multiply(_3n);
            return this;
          }
          // TODO: return `this`
          /** A point on curve is valid if it conforms to equation. */
          assertValidity() {
            assertValidMemo(this);
          }
          hasEvenY() {
            const { y } = this.toAffine();
            if (!Fp.isOdd)
              throw new Error("Field doesn't support isOdd");
            return !Fp.isOdd(y);
          }
          /** Compare one point to another. */
          equals(other) {
            aprjpoint(other);
            const { X: X1, Y: Y1, Z: Z1 } = this;
            const { X: X2, Y: Y2, Z: Z2 } = other;
            const U1 = Fp.eql(Fp.mul(X1, Z2), Fp.mul(X2, Z1));
            const U2 = Fp.eql(Fp.mul(Y1, Z2), Fp.mul(Y2, Z1));
            return U1 && U2;
          }
          /** Flips point to one corresponding to (x, -y) in Affine coordinates. */
          negate() {
            return new Point(this.X, Fp.neg(this.Y), this.Z);
          }
          // Renes-Costello-Batina exception-free doubling formula.
          // There is 30% faster Jacobian formula, but it is not complete.
          // https://eprint.iacr.org/2015/1060, algorithm 3
          // Cost: 8M + 3S + 3*a + 2*b3 + 15add.
          double() {
            const { a, b } = CURVE;
            const b3 = Fp.mul(b, _3n);
            const { X: X1, Y: Y1, Z: Z1 } = this;
            let X3 = Fp.ZERO, Y3 = Fp.ZERO, Z3 = Fp.ZERO;
            let t0 = Fp.mul(X1, X1);
            let t1 = Fp.mul(Y1, Y1);
            let t2 = Fp.mul(Z1, Z1);
            let t3 = Fp.mul(X1, Y1);
            t3 = Fp.add(t3, t3);
            Z3 = Fp.mul(X1, Z1);
            Z3 = Fp.add(Z3, Z3);
            X3 = Fp.mul(a, Z3);
            Y3 = Fp.mul(b3, t2);
            Y3 = Fp.add(X3, Y3);
            X3 = Fp.sub(t1, Y3);
            Y3 = Fp.add(t1, Y3);
            Y3 = Fp.mul(X3, Y3);
            X3 = Fp.mul(t3, X3);
            Z3 = Fp.mul(b3, Z3);
            t2 = Fp.mul(a, t2);
            t3 = Fp.sub(t0, t2);
            t3 = Fp.mul(a, t3);
            t3 = Fp.add(t3, Z3);
            Z3 = Fp.add(t0, t0);
            t0 = Fp.add(Z3, t0);
            t0 = Fp.add(t0, t2);
            t0 = Fp.mul(t0, t3);
            Y3 = Fp.add(Y3, t0);
            t2 = Fp.mul(Y1, Z1);
            t2 = Fp.add(t2, t2);
            t0 = Fp.mul(t2, t3);
            X3 = Fp.sub(X3, t0);
            Z3 = Fp.mul(t2, t1);
            Z3 = Fp.add(Z3, Z3);
            Z3 = Fp.add(Z3, Z3);
            return new Point(X3, Y3, Z3);
          }
          // Renes-Costello-Batina exception-free addition formula.
          // There is 30% faster Jacobian formula, but it is not complete.
          // https://eprint.iacr.org/2015/1060, algorithm 1
          // Cost: 12M + 0S + 3*a + 3*b3 + 23add.
          add(other) {
            aprjpoint(other);
            const { X: X1, Y: Y1, Z: Z1 } = this;
            const { X: X2, Y: Y2, Z: Z2 } = other;
            let X3 = Fp.ZERO, Y3 = Fp.ZERO, Z3 = Fp.ZERO;
            const a = CURVE.a;
            const b3 = Fp.mul(CURVE.b, _3n);
            let t0 = Fp.mul(X1, X2);
            let t1 = Fp.mul(Y1, Y2);
            let t2 = Fp.mul(Z1, Z2);
            let t3 = Fp.add(X1, Y1);
            let t4 = Fp.add(X2, Y2);
            t3 = Fp.mul(t3, t4);
            t4 = Fp.add(t0, t1);
            t3 = Fp.sub(t3, t4);
            t4 = Fp.add(X1, Z1);
            let t5 = Fp.add(X2, Z2);
            t4 = Fp.mul(t4, t5);
            t5 = Fp.add(t0, t2);
            t4 = Fp.sub(t4, t5);
            t5 = Fp.add(Y1, Z1);
            X3 = Fp.add(Y2, Z2);
            t5 = Fp.mul(t5, X3);
            X3 = Fp.add(t1, t2);
            t5 = Fp.sub(t5, X3);
            Z3 = Fp.mul(a, t4);
            X3 = Fp.mul(b3, t2);
            Z3 = Fp.add(X3, Z3);
            X3 = Fp.sub(t1, Z3);
            Z3 = Fp.add(t1, Z3);
            Y3 = Fp.mul(X3, Z3);
            t1 = Fp.add(t0, t0);
            t1 = Fp.add(t1, t0);
            t2 = Fp.mul(a, t2);
            t4 = Fp.mul(b3, t4);
            t1 = Fp.add(t1, t2);
            t2 = Fp.sub(t0, t2);
            t2 = Fp.mul(a, t2);
            t4 = Fp.add(t4, t2);
            t0 = Fp.mul(t1, t4);
            Y3 = Fp.add(Y3, t0);
            t0 = Fp.mul(t5, t4);
            X3 = Fp.mul(t3, X3);
            X3 = Fp.sub(X3, t0);
            t0 = Fp.mul(t3, t1);
            Z3 = Fp.mul(t5, Z3);
            Z3 = Fp.add(Z3, t0);
            return new Point(X3, Y3, Z3);
          }
          subtract(other) {
            return this.add(other.negate());
          }
          is0() {
            return this.equals(Point.ZERO);
          }
          /**
           * Constant time multiplication.
           * Uses wNAF method. Windowed method may be 10% faster,
           * but takes 2x longer to generate and consumes 2x memory.
           * Uses precomputes when available.
           * Uses endomorphism for Koblitz curves.
           * @param scalar by which the point would be multiplied
           * @returns New point
           */
          multiply(scalar) {
            const { endo: endo2 } = extraOpts;
            if (!Fn.isValidNot0(scalar))
              throw new Error("invalid scalar: out of range");
            let point, fake;
            const mul = (n) => wnaf.cached(this, n, (p) => (0, curve_ts_1.normalizeZ)(Point, p));
            if (endo2) {
              const { k1neg, k1, k2neg, k2 } = splitEndoScalarN(scalar);
              const { p: k1p, f: k1f } = mul(k1);
              const { p: k2p, f: k2f } = mul(k2);
              fake = k1f.add(k2f);
              point = finishEndo(endo2.beta, k1p, k2p, k1neg, k2neg);
            } else {
              const { p, f: f2 } = mul(scalar);
              point = p;
              fake = f2;
            }
            return (0, curve_ts_1.normalizeZ)(Point, [point, fake])[0];
          }
          /**
           * Non-constant-time multiplication. Uses double-and-add algorithm.
           * It's faster, but should only be used when you don't care about
           * an exposed secret key e.g. sig verification, which works over *public* keys.
           */
          multiplyUnsafe(sc) {
            const { endo: endo2 } = extraOpts;
            const p = this;
            if (!Fn.isValid(sc))
              throw new Error("invalid scalar: out of range");
            if (sc === _0n || p.is0())
              return Point.ZERO;
            if (sc === _1n)
              return p;
            if (wnaf.hasCache(this))
              return this.multiply(sc);
            if (endo2) {
              const { k1neg, k1, k2neg, k2 } = splitEndoScalarN(sc);
              const { p1, p2 } = (0, curve_ts_1.mulEndoUnsafe)(Point, p, k1, k2);
              return finishEndo(endo2.beta, p1, p2, k1neg, k2neg);
            } else {
              return wnaf.unsafe(p, sc);
            }
          }
          multiplyAndAddUnsafe(Q, a, b) {
            const sum = this.multiplyUnsafe(a).add(Q.multiplyUnsafe(b));
            return sum.is0() ? void 0 : sum;
          }
          /**
           * Converts Projective point to affine (x, y) coordinates.
           * @param invertedZ Z^-1 (inverted zero) - optional, precomputation is useful for invertBatch
           */
          toAffine(invertedZ) {
            return toAffineMemo(this, invertedZ);
          }
          /**
           * Checks whether Point is free of torsion elements (is in prime subgroup).
           * Always torsion-free for cofactor=1 curves.
           */
          isTorsionFree() {
            const { isTorsionFree } = extraOpts;
            if (cofactor === _1n)
              return true;
            if (isTorsionFree)
              return isTorsionFree(Point, this);
            return wnaf.unsafe(this, CURVE_ORDER).is0();
          }
          clearCofactor() {
            const { clearCofactor } = extraOpts;
            if (cofactor === _1n)
              return this;
            if (clearCofactor)
              return clearCofactor(Point, this);
            return this.multiplyUnsafe(cofactor);
          }
          isSmallOrder() {
            return this.multiplyUnsafe(cofactor).is0();
          }
          toBytes(isCompressed = true) {
            (0, utils_ts_1._abool2)(isCompressed, "isCompressed");
            this.assertValidity();
            return encodePoint(Point, this, isCompressed);
          }
          toHex(isCompressed = true) {
            return (0, utils_ts_1.bytesToHex)(this.toBytes(isCompressed));
          }
          toString() {
            return `<Point ${this.is0() ? "ZERO" : this.toHex()}>`;
          }
          // TODO: remove
          get px() {
            return this.X;
          }
          get py() {
            return this.X;
          }
          get pz() {
            return this.Z;
          }
          toRawBytes(isCompressed = true) {
            return this.toBytes(isCompressed);
          }
          _setWindowSize(windowSize) {
            this.precompute(windowSize);
          }
          static normalizeZ(points) {
            return (0, curve_ts_1.normalizeZ)(Point, points);
          }
          static msm(points, scalars) {
            return (0, curve_ts_1.pippenger)(Point, Fn, points, scalars);
          }
          static fromPrivateKey(privateKey) {
            return Point.BASE.multiply(_normFnElement(Fn, privateKey));
          }
        }
        Point.BASE = new Point(CURVE.Gx, CURVE.Gy, Fp.ONE);
        Point.ZERO = new Point(Fp.ZERO, Fp.ONE, Fp.ZERO);
        Point.Fp = Fp;
        Point.Fn = Fn;
        const bits = Fn.BITS;
        const wnaf = new curve_ts_1.wNAF(Point, extraOpts.endo ? Math.ceil(bits / 2) : bits);
        Point.BASE.precompute(8);
        return Point;
      }
      function pprefix(hasEvenY) {
        return Uint8Array.of(hasEvenY ? 2 : 3);
      }
      function SWUFpSqrtRatio(Fp, Z) {
        const q = Fp.ORDER;
        let l = _0n;
        for (let o = q - _1n; o % _2n === _0n; o /= _2n)
          l += _1n;
        const c1 = l;
        const _2n_pow_c1_1 = _2n << c1 - _1n - _1n;
        const _2n_pow_c1 = _2n_pow_c1_1 * _2n;
        const c2 = (q - _1n) / _2n_pow_c1;
        const c3 = (c2 - _1n) / _2n;
        const c4 = _2n_pow_c1 - _1n;
        const c5 = _2n_pow_c1_1;
        const c6 = Fp.pow(Z, c2);
        const c7 = Fp.pow(Z, (c2 + _1n) / _2n);
        let sqrtRatio = (u, v) => {
          let tv1 = c6;
          let tv2 = Fp.pow(v, c4);
          let tv3 = Fp.sqr(tv2);
          tv3 = Fp.mul(tv3, v);
          let tv5 = Fp.mul(u, tv3);
          tv5 = Fp.pow(tv5, c3);
          tv5 = Fp.mul(tv5, tv2);
          tv2 = Fp.mul(tv5, v);
          tv3 = Fp.mul(tv5, u);
          let tv4 = Fp.mul(tv3, tv2);
          tv5 = Fp.pow(tv4, c5);
          let isQR = Fp.eql(tv5, Fp.ONE);
          tv2 = Fp.mul(tv3, c7);
          tv5 = Fp.mul(tv4, tv1);
          tv3 = Fp.cmov(tv2, tv3, isQR);
          tv4 = Fp.cmov(tv5, tv4, isQR);
          for (let i = c1; i > _1n; i--) {
            let tv52 = i - _2n;
            tv52 = _2n << tv52 - _1n;
            let tvv5 = Fp.pow(tv4, tv52);
            const e1 = Fp.eql(tvv5, Fp.ONE);
            tv2 = Fp.mul(tv3, tv1);
            tv1 = Fp.mul(tv1, tv1);
            tvv5 = Fp.mul(tv4, tv1);
            tv3 = Fp.cmov(tv2, tv3, e1);
            tv4 = Fp.cmov(tvv5, tv4, e1);
          }
          return { isValid: isQR, value: tv3 };
        };
        if (Fp.ORDER % _4n === _3n) {
          const c12 = (Fp.ORDER - _3n) / _4n;
          const c22 = Fp.sqrt(Fp.neg(Z));
          sqrtRatio = (u, v) => {
            let tv1 = Fp.sqr(v);
            const tv2 = Fp.mul(u, v);
            tv1 = Fp.mul(tv1, tv2);
            let y1 = Fp.pow(tv1, c12);
            y1 = Fp.mul(y1, tv2);
            const y2 = Fp.mul(y1, c22);
            const tv3 = Fp.mul(Fp.sqr(y1), v);
            const isQR = Fp.eql(tv3, u);
            let y = Fp.cmov(y2, y1, isQR);
            return { isValid: isQR, value: y };
          };
        }
        return sqrtRatio;
      }
      function mapToCurveSimpleSWU(Fp, opts) {
        (0, modular_ts_1.validateField)(Fp);
        const { A, B, Z } = opts;
        if (!Fp.isValid(A) || !Fp.isValid(B) || !Fp.isValid(Z))
          throw new Error("mapToCurveSimpleSWU: invalid opts");
        const sqrtRatio = SWUFpSqrtRatio(Fp, Z);
        if (!Fp.isOdd)
          throw new Error("Field does not have .isOdd()");
        return (u) => {
          let tv1, tv2, tv3, tv4, tv5, tv6, x, y;
          tv1 = Fp.sqr(u);
          tv1 = Fp.mul(tv1, Z);
          tv2 = Fp.sqr(tv1);
          tv2 = Fp.add(tv2, tv1);
          tv3 = Fp.add(tv2, Fp.ONE);
          tv3 = Fp.mul(tv3, B);
          tv4 = Fp.cmov(Z, Fp.neg(tv2), !Fp.eql(tv2, Fp.ZERO));
          tv4 = Fp.mul(tv4, A);
          tv2 = Fp.sqr(tv3);
          tv6 = Fp.sqr(tv4);
          tv5 = Fp.mul(tv6, A);
          tv2 = Fp.add(tv2, tv5);
          tv2 = Fp.mul(tv2, tv3);
          tv6 = Fp.mul(tv6, tv4);
          tv5 = Fp.mul(tv6, B);
          tv2 = Fp.add(tv2, tv5);
          x = Fp.mul(tv1, tv3);
          const { isValid, value } = sqrtRatio(tv2, tv6);
          y = Fp.mul(tv1, u);
          y = Fp.mul(y, value);
          x = Fp.cmov(x, tv3, isValid);
          y = Fp.cmov(y, value, isValid);
          const e1 = Fp.isOdd(u) === Fp.isOdd(y);
          y = Fp.cmov(Fp.neg(y), y, e1);
          const tv4_inv = (0, modular_ts_1.FpInvertBatch)(Fp, [tv4], true)[0];
          x = Fp.mul(x, tv4_inv);
          return { x, y };
        };
      }
      function getWLengths(Fp, Fn) {
        return {
          secretKey: Fn.BYTES,
          publicKey: 1 + Fp.BYTES,
          publicKeyUncompressed: 1 + 2 * Fp.BYTES,
          publicKeyHasPrefix: true,
          signature: 2 * Fn.BYTES
        };
      }
      function ecdh(Point, ecdhOpts = {}) {
        const { Fn } = Point;
        const randomBytes_ = ecdhOpts.randomBytes || utils_ts_1.randomBytes;
        const lengths = Object.assign(getWLengths(Point.Fp, Fn), { seed: (0, modular_ts_1.getMinHashLength)(Fn.ORDER) });
        function isValidSecretKey(secretKey) {
          try {
            return !!_normFnElement(Fn, secretKey);
          } catch (error) {
            return false;
          }
        }
        function isValidPublicKey(publicKey3, isCompressed) {
          const { publicKey: comp, publicKeyUncompressed } = lengths;
          try {
            const l = publicKey3.length;
            if (isCompressed === true && l !== comp)
              return false;
            if (isCompressed === false && l !== publicKeyUncompressed)
              return false;
            return !!Point.fromBytes(publicKey3);
          } catch (error) {
            return false;
          }
        }
        function randomSecretKey(seed2 = randomBytes_(lengths.seed)) {
          return (0, modular_ts_1.mapHashToField)((0, utils_ts_1._abytes2)(seed2, lengths.seed, "seed"), Fn.ORDER);
        }
        function getPublicKey(secretKey, isCompressed = true) {
          return Point.BASE.multiply(_normFnElement(Fn, secretKey)).toBytes(isCompressed);
        }
        function keygen(seed2) {
          const secretKey = randomSecretKey(seed2);
          return { secretKey, publicKey: getPublicKey(secretKey) };
        }
        function isProbPub(item) {
          if (typeof item === "bigint")
            return false;
          if (item instanceof Point)
            return true;
          const { secretKey, publicKey: publicKey3, publicKeyUncompressed } = lengths;
          if (Fn.allowedLengths || secretKey === publicKey3)
            return void 0;
          const l = (0, utils_ts_1.ensureBytes)("key", item).length;
          return l === publicKey3 || l === publicKeyUncompressed;
        }
        function getSharedSecret(secretKeyA, publicKeyB, isCompressed = true) {
          if (isProbPub(secretKeyA) === true)
            throw new Error("first arg must be private key");
          if (isProbPub(publicKeyB) === false)
            throw new Error("second arg must be public key");
          const s = _normFnElement(Fn, secretKeyA);
          const b = Point.fromHex(publicKeyB);
          return b.multiply(s).toBytes(isCompressed);
        }
        const utils = {
          isValidSecretKey,
          isValidPublicKey,
          randomSecretKey,
          // TODO: remove
          isValidPrivateKey: isValidSecretKey,
          randomPrivateKey: randomSecretKey,
          normPrivateKeyToScalar: (key) => _normFnElement(Fn, key),
          precompute(windowSize = 8, point = Point.BASE) {
            return point.precompute(windowSize, false);
          }
        };
        return Object.freeze({ getPublicKey, getSharedSecret, keygen, Point, utils, lengths });
      }
      function ecdsa(Point, hash2, ecdsaOpts = {}) {
        (0, utils_1.ahash)(hash2);
        (0, utils_ts_1._validateObject)(ecdsaOpts, {}, {
          hmac: "function",
          lowS: "boolean",
          randomBytes: "function",
          bits2int: "function",
          bits2int_modN: "function"
        });
        const randomBytes = ecdsaOpts.randomBytes || utils_ts_1.randomBytes;
        const hmac = ecdsaOpts.hmac || ((key, ...msgs) => (0, hmac_js_1.hmac)(hash2, key, (0, utils_ts_1.concatBytes)(...msgs)));
        const { Fp, Fn } = Point;
        const { ORDER: CURVE_ORDER, BITS: fnBits } = Fn;
        const { keygen, getPublicKey, getSharedSecret, utils, lengths } = ecdh(Point, ecdsaOpts);
        const defaultSigOpts = {
          prehash: false,
          lowS: typeof ecdsaOpts.lowS === "boolean" ? ecdsaOpts.lowS : false,
          format: void 0,
          //'compact' as ECDSASigFormat,
          extraEntropy: false
        };
        const defaultSigOpts_format = "compact";
        function isBiggerThanHalfOrder(number2) {
          const HALF = CURVE_ORDER >> _1n;
          return number2 > HALF;
        }
        function validateRS(title, num) {
          if (!Fn.isValidNot0(num))
            throw new Error(`invalid signature ${title}: out of range 1..Point.Fn.ORDER`);
          return num;
        }
        function validateSigLength(bytes, format) {
          validateSigFormat(format);
          const size = lengths.signature;
          const sizer = format === "compact" ? size : format === "recovered" ? size + 1 : void 0;
          return (0, utils_ts_1._abytes2)(bytes, sizer, `${format} signature`);
        }
        class Signature {
          constructor(r, s, recovery) {
            this.r = validateRS("r", r);
            this.s = validateRS("s", s);
            if (recovery != null)
              this.recovery = recovery;
            Object.freeze(this);
          }
          static fromBytes(bytes, format = defaultSigOpts_format) {
            validateSigLength(bytes, format);
            let recid;
            if (format === "der") {
              const { r: r2, s: s2 } = exports.DER.toSig((0, utils_ts_1._abytes2)(bytes));
              return new Signature(r2, s2);
            }
            if (format === "recovered") {
              recid = bytes[0];
              format = "compact";
              bytes = bytes.subarray(1);
            }
            const L = Fn.BYTES;
            const r = bytes.subarray(0, L);
            const s = bytes.subarray(L, L * 2);
            return new Signature(Fn.fromBytes(r), Fn.fromBytes(s), recid);
          }
          static fromHex(hex2, format) {
            return this.fromBytes((0, utils_ts_1.hexToBytes)(hex2), format);
          }
          addRecoveryBit(recovery) {
            return new Signature(this.r, this.s, recovery);
          }
          recoverPublicKey(messageHash) {
            const FIELD_ORDER = Fp.ORDER;
            const { r, s, recovery: rec } = this;
            if (rec == null || ![0, 1, 2, 3].includes(rec))
              throw new Error("recovery id invalid");
            const hasCofactor = CURVE_ORDER * _2n < FIELD_ORDER;
            if (hasCofactor && rec > 1)
              throw new Error("recovery id is ambiguous for h>1 curve");
            const radj = rec === 2 || rec === 3 ? r + CURVE_ORDER : r;
            if (!Fp.isValid(radj))
              throw new Error("recovery id 2 or 3 invalid");
            const x = Fp.toBytes(radj);
            const R = Point.fromBytes((0, utils_ts_1.concatBytes)(pprefix((rec & 1) === 0), x));
            const ir = Fn.inv(radj);
            const h = bits2int_modN((0, utils_ts_1.ensureBytes)("msgHash", messageHash));
            const u1 = Fn.create(-h * ir);
            const u2 = Fn.create(s * ir);
            const Q = Point.BASE.multiplyUnsafe(u1).add(R.multiplyUnsafe(u2));
            if (Q.is0())
              throw new Error("point at infinify");
            Q.assertValidity();
            return Q;
          }
          // Signatures should be low-s, to prevent malleability.
          hasHighS() {
            return isBiggerThanHalfOrder(this.s);
          }
          toBytes(format = defaultSigOpts_format) {
            validateSigFormat(format);
            if (format === "der")
              return (0, utils_ts_1.hexToBytes)(exports.DER.hexFromSig(this));
            const r = Fn.toBytes(this.r);
            const s = Fn.toBytes(this.s);
            if (format === "recovered") {
              if (this.recovery == null)
                throw new Error("recovery bit must be present");
              return (0, utils_ts_1.concatBytes)(Uint8Array.of(this.recovery), r, s);
            }
            return (0, utils_ts_1.concatBytes)(r, s);
          }
          toHex(format) {
            return (0, utils_ts_1.bytesToHex)(this.toBytes(format));
          }
          // TODO: remove
          assertValidity() {
          }
          static fromCompact(hex2) {
            return Signature.fromBytes((0, utils_ts_1.ensureBytes)("sig", hex2), "compact");
          }
          static fromDER(hex2) {
            return Signature.fromBytes((0, utils_ts_1.ensureBytes)("sig", hex2), "der");
          }
          normalizeS() {
            return this.hasHighS() ? new Signature(this.r, Fn.neg(this.s), this.recovery) : this;
          }
          toDERRawBytes() {
            return this.toBytes("der");
          }
          toDERHex() {
            return (0, utils_ts_1.bytesToHex)(this.toBytes("der"));
          }
          toCompactRawBytes() {
            return this.toBytes("compact");
          }
          toCompactHex() {
            return (0, utils_ts_1.bytesToHex)(this.toBytes("compact"));
          }
        }
        const bits2int = ecdsaOpts.bits2int || function bits2int_def(bytes) {
          if (bytes.length > 8192)
            throw new Error("input is too large");
          const num = (0, utils_ts_1.bytesToNumberBE)(bytes);
          const delta = bytes.length * 8 - fnBits;
          return delta > 0 ? num >> BigInt(delta) : num;
        };
        const bits2int_modN = ecdsaOpts.bits2int_modN || function bits2int_modN_def(bytes) {
          return Fn.create(bits2int(bytes));
        };
        const ORDER_MASK = (0, utils_ts_1.bitMask)(fnBits);
        function int2octets(num) {
          (0, utils_ts_1.aInRange)("num < 2^" + fnBits, num, _0n, ORDER_MASK);
          return Fn.toBytes(num);
        }
        function validateMsgAndHash(message, prehash) {
          (0, utils_ts_1._abytes2)(message, void 0, "message");
          return prehash ? (0, utils_ts_1._abytes2)(hash2(message), void 0, "prehashed message") : message;
        }
        function prepSig(message, privateKey, opts) {
          if (["recovered", "canonical"].some((k) => k in opts))
            throw new Error("sign() legacy options not supported");
          const { lowS, prehash, extraEntropy } = validateSigOpts(opts, defaultSigOpts);
          message = validateMsgAndHash(message, prehash);
          const h1int = bits2int_modN(message);
          const d = _normFnElement(Fn, privateKey);
          const seedArgs = [int2octets(d), int2octets(h1int)];
          if (extraEntropy != null && extraEntropy !== false) {
            const e = extraEntropy === true ? randomBytes(lengths.secretKey) : extraEntropy;
            seedArgs.push((0, utils_ts_1.ensureBytes)("extraEntropy", e));
          }
          const seed2 = (0, utils_ts_1.concatBytes)(...seedArgs);
          const m = h1int;
          function k2sig(kBytes) {
            const k = bits2int(kBytes);
            if (!Fn.isValidNot0(k))
              return;
            const ik = Fn.inv(k);
            const q = Point.BASE.multiply(k).toAffine();
            const r = Fn.create(q.x);
            if (r === _0n)
              return;
            const s = Fn.create(ik * Fn.create(m + r * d));
            if (s === _0n)
              return;
            let recovery = (q.x === r ? 0 : 2) | Number(q.y & _1n);
            let normS = s;
            if (lowS && isBiggerThanHalfOrder(s)) {
              normS = Fn.neg(s);
              recovery ^= 1;
            }
            return new Signature(r, normS, recovery);
          }
          return { seed: seed2, k2sig };
        }
        function sign(message, secretKey, opts = {}) {
          message = (0, utils_ts_1.ensureBytes)("message", message);
          const { seed: seed2, k2sig } = prepSig(message, secretKey, opts);
          const drbg = (0, utils_ts_1.createHmacDrbg)(hash2.outputLen, Fn.BYTES, hmac);
          const sig = drbg(seed2, k2sig);
          return sig;
        }
        function tryParsingSig(sg) {
          let sig = void 0;
          const isHex = typeof sg === "string" || (0, utils_ts_1.isBytes)(sg);
          const isObj = !isHex && sg !== null && typeof sg === "object" && typeof sg.r === "bigint" && typeof sg.s === "bigint";
          if (!isHex && !isObj)
            throw new Error("invalid signature, expected Uint8Array, hex string or Signature instance");
          if (isObj) {
            sig = new Signature(sg.r, sg.s);
          } else if (isHex) {
            try {
              sig = Signature.fromBytes((0, utils_ts_1.ensureBytes)("sig", sg), "der");
            } catch (derError) {
              if (!(derError instanceof exports.DER.Err))
                throw derError;
            }
            if (!sig) {
              try {
                sig = Signature.fromBytes((0, utils_ts_1.ensureBytes)("sig", sg), "compact");
              } catch (error) {
                return false;
              }
            }
          }
          if (!sig)
            return false;
          return sig;
        }
        function verify(signature, message, publicKey3, opts = {}) {
          const { lowS, prehash, format } = validateSigOpts(opts, defaultSigOpts);
          publicKey3 = (0, utils_ts_1.ensureBytes)("publicKey", publicKey3);
          message = validateMsgAndHash((0, utils_ts_1.ensureBytes)("message", message), prehash);
          if ("strict" in opts)
            throw new Error("options.strict was renamed to lowS");
          const sig = format === void 0 ? tryParsingSig(signature) : Signature.fromBytes((0, utils_ts_1.ensureBytes)("sig", signature), format);
          if (sig === false)
            return false;
          try {
            const P = Point.fromBytes(publicKey3);
            if (lowS && sig.hasHighS())
              return false;
            const { r, s } = sig;
            const h = bits2int_modN(message);
            const is2 = Fn.inv(s);
            const u1 = Fn.create(h * is2);
            const u2 = Fn.create(r * is2);
            const R = Point.BASE.multiplyUnsafe(u1).add(P.multiplyUnsafe(u2));
            if (R.is0())
              return false;
            const v = Fn.create(R.x);
            return v === r;
          } catch (e) {
            return false;
          }
        }
        function recoverPublicKey(signature, message, opts = {}) {
          const { prehash } = validateSigOpts(opts, defaultSigOpts);
          message = validateMsgAndHash(message, prehash);
          return Signature.fromBytes(signature, "recovered").recoverPublicKey(message).toBytes();
        }
        return Object.freeze({
          keygen,
          getPublicKey,
          getSharedSecret,
          utils,
          lengths,
          Point,
          sign,
          verify,
          recoverPublicKey,
          Signature,
          hash: hash2
        });
      }
      function weierstrassPoints(c) {
        const { CURVE, curveOpts } = _weierstrass_legacy_opts_to_new(c);
        const Point = weierstrassN(CURVE, curveOpts);
        return _weierstrass_new_output_to_legacy(c, Point);
      }
      function _weierstrass_legacy_opts_to_new(c) {
        const CURVE = {
          a: c.a,
          b: c.b,
          p: c.Fp.ORDER,
          n: c.n,
          h: c.h,
          Gx: c.Gx,
          Gy: c.Gy
        };
        const Fp = c.Fp;
        let allowedLengths = c.allowedPrivateKeyLengths ? Array.from(new Set(c.allowedPrivateKeyLengths.map((l) => Math.ceil(l / 2)))) : void 0;
        const Fn = (0, modular_ts_1.Field)(CURVE.n, {
          BITS: c.nBitLength,
          allowedLengths,
          modFromBytes: c.wrapPrivateKey
        });
        const curveOpts = {
          Fp,
          Fn,
          allowInfinityPoint: c.allowInfinityPoint,
          endo: c.endo,
          isTorsionFree: c.isTorsionFree,
          clearCofactor: c.clearCofactor,
          fromBytes: c.fromBytes,
          toBytes: c.toBytes
        };
        return { CURVE, curveOpts };
      }
      function _ecdsa_legacy_opts_to_new(c) {
        const { CURVE, curveOpts } = _weierstrass_legacy_opts_to_new(c);
        const ecdsaOpts = {
          hmac: c.hmac,
          randomBytes: c.randomBytes,
          lowS: c.lowS,
          bits2int: c.bits2int,
          bits2int_modN: c.bits2int_modN
        };
        return { CURVE, curveOpts, hash: c.hash, ecdsaOpts };
      }
      function _legacyHelperEquat(Fp, a, b) {
        function weierstrassEquation(x) {
          const x2 = Fp.sqr(x);
          const x3 = Fp.mul(x2, x);
          return Fp.add(Fp.add(x3, Fp.mul(x, a)), b);
        }
        return weierstrassEquation;
      }
      function _weierstrass_new_output_to_legacy(c, Point) {
        const { Fp, Fn } = Point;
        function isWithinCurveOrder(num) {
          return (0, utils_ts_1.inRange)(num, _1n, Fn.ORDER);
        }
        const weierstrassEquation = _legacyHelperEquat(Fp, c.a, c.b);
        return Object.assign({}, {
          CURVE: c,
          Point,
          ProjectivePoint: Point,
          normPrivateKeyToScalar: (key) => _normFnElement(Fn, key),
          weierstrassEquation,
          isWithinCurveOrder
        });
      }
      function _ecdsa_new_output_to_legacy(c, _ecdsa) {
        const Point = _ecdsa.Point;
        return Object.assign({}, _ecdsa, {
          ProjectivePoint: Point,
          CURVE: Object.assign({}, c, (0, modular_ts_1.nLength)(Point.Fn.ORDER, Point.Fn.BITS))
        });
      }
      function weierstrass(c) {
        const { CURVE, curveOpts, hash: hash2, ecdsaOpts } = _ecdsa_legacy_opts_to_new(c);
        const Point = weierstrassN(CURVE, curveOpts);
        const signs = ecdsa(Point, hash2, ecdsaOpts);
        return _ecdsa_new_output_to_legacy(c, signs);
      }
    }
  });

  // node_modules/@noble/curves/_shortw_utils.js
  var require_shortw_utils = __commonJS({
    "node_modules/@noble/curves/_shortw_utils.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.getHash = getHash;
      exports.createCurve = createCurve;
      var weierstrass_ts_1 = require_weierstrass();
      function getHash(hash2) {
        return { hash: hash2 };
      }
      function createCurve(curveDef, defHash) {
        const create2 = (hash2) => (0, weierstrass_ts_1.weierstrass)({ ...curveDef, hash: hash2 });
        return { ...create2(defHash), create: create2 };
      }
    }
  });

  // node_modules/@noble/curves/secp256k1.js
  var require_secp256k1 = __commonJS({
    "node_modules/@noble/curves/secp256k1.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.encodeToCurve = exports.hashToCurve = exports.secp256k1_hasher = exports.schnorr = exports.secp256k1 = void 0;
      var sha2_js_1 = require_sha2();
      var utils_js_1 = require_utils();
      var _shortw_utils_ts_1 = require_shortw_utils();
      var hash_to_curve_ts_1 = require_hash_to_curve();
      var modular_ts_1 = require_modular();
      var weierstrass_ts_1 = require_weierstrass();
      var utils_ts_1 = require_utils2();
      var secp256k1_CURVE = {
        p: BigInt("0xfffffffffffffffffffffffffffffffffffffffffffffffffffffffefffffc2f"),
        n: BigInt("0xfffffffffffffffffffffffffffffffebaaedce6af48a03bbfd25e8cd0364141"),
        h: BigInt(1),
        a: BigInt(0),
        b: BigInt(7),
        Gx: BigInt("0x79be667ef9dcbbac55a06295ce870b07029bfcdb2dce28d959f2815b16f81798"),
        Gy: BigInt("0x483ada7726a3c4655da4fbfc0e1108a8fd17b448a68554199c47d08ffb10d4b8")
      };
      var secp256k1_ENDO = {
        beta: BigInt("0x7ae96a2b657c07106e64479eac3434e99cf0497512f58995c1396c28719501ee"),
        basises: [
          [BigInt("0x3086d221a7d46bcde86c90e49284eb15"), -BigInt("0xe4437ed6010e88286f547fa90abfe4c3")],
          [BigInt("0x114ca50f7a8e2f3f657c1108d9d44cfd8"), BigInt("0x3086d221a7d46bcde86c90e49284eb15")]
        ]
      };
      var _0n = /* @__PURE__ */ BigInt(0);
      var _1n = /* @__PURE__ */ BigInt(1);
      var _2n = /* @__PURE__ */ BigInt(2);
      function sqrtMod(y) {
        const P = secp256k1_CURVE.p;
        const _3n = BigInt(3), _6n = BigInt(6), _11n = BigInt(11), _22n = BigInt(22);
        const _23n = BigInt(23), _44n = BigInt(44), _88n = BigInt(88);
        const b2 = y * y * y % P;
        const b3 = b2 * b2 * y % P;
        const b6 = (0, modular_ts_1.pow2)(b3, _3n, P) * b3 % P;
        const b9 = (0, modular_ts_1.pow2)(b6, _3n, P) * b3 % P;
        const b11 = (0, modular_ts_1.pow2)(b9, _2n, P) * b2 % P;
        const b22 = (0, modular_ts_1.pow2)(b11, _11n, P) * b11 % P;
        const b44 = (0, modular_ts_1.pow2)(b22, _22n, P) * b22 % P;
        const b88 = (0, modular_ts_1.pow2)(b44, _44n, P) * b44 % P;
        const b176 = (0, modular_ts_1.pow2)(b88, _88n, P) * b88 % P;
        const b220 = (0, modular_ts_1.pow2)(b176, _44n, P) * b44 % P;
        const b223 = (0, modular_ts_1.pow2)(b220, _3n, P) * b3 % P;
        const t1 = (0, modular_ts_1.pow2)(b223, _23n, P) * b22 % P;
        const t2 = (0, modular_ts_1.pow2)(t1, _6n, P) * b2 % P;
        const root = (0, modular_ts_1.pow2)(t2, _2n, P);
        if (!Fpk1.eql(Fpk1.sqr(root), y))
          throw new Error("Cannot find square root");
        return root;
      }
      var Fpk1 = (0, modular_ts_1.Field)(secp256k1_CURVE.p, { sqrt: sqrtMod });
      exports.secp256k1 = (0, _shortw_utils_ts_1.createCurve)({ ...secp256k1_CURVE, Fp: Fpk1, lowS: true, endo: secp256k1_ENDO }, sha2_js_1.sha256);
      var TAGGED_HASH_PREFIXES = {};
      function taggedHash(tag, ...messages2) {
        let tagP = TAGGED_HASH_PREFIXES[tag];
        if (tagP === void 0) {
          const tagH = (0, sha2_js_1.sha256)((0, utils_ts_1.utf8ToBytes)(tag));
          tagP = (0, utils_ts_1.concatBytes)(tagH, tagH);
          TAGGED_HASH_PREFIXES[tag] = tagP;
        }
        return (0, sha2_js_1.sha256)((0, utils_ts_1.concatBytes)(tagP, ...messages2));
      }
      var pointToBytes = (point) => point.toBytes(true).slice(1);
      var Pointk1 = /* @__PURE__ */ (() => exports.secp256k1.Point)();
      var hasEven = (y) => y % _2n === _0n;
      function schnorrGetExtPubKey(priv) {
        const { Fn, BASE } = Pointk1;
        const d_ = (0, weierstrass_ts_1._normFnElement)(Fn, priv);
        const p = BASE.multiply(d_);
        const scalar = hasEven(p.y) ? d_ : Fn.neg(d_);
        return { scalar, bytes: pointToBytes(p) };
      }
      function lift_x(x) {
        const Fp = Fpk1;
        if (!Fp.isValidNot0(x))
          throw new Error("invalid x: Fail if x \u2265 p");
        const xx = Fp.create(x * x);
        const c = Fp.create(xx * x + BigInt(7));
        let y = Fp.sqrt(c);
        if (!hasEven(y))
          y = Fp.neg(y);
        const p = Pointk1.fromAffine({ x, y });
        p.assertValidity();
        return p;
      }
      var num = utils_ts_1.bytesToNumberBE;
      function challenge(...args) {
        return Pointk1.Fn.create(num(taggedHash("BIP0340/challenge", ...args)));
      }
      function schnorrGetPublicKey(secretKey) {
        return schnorrGetExtPubKey(secretKey).bytes;
      }
      function schnorrSign(message, secretKey, auxRand = (0, utils_js_1.randomBytes)(32)) {
        const { Fn } = Pointk1;
        const m = (0, utils_ts_1.ensureBytes)("message", message);
        const { bytes: px, scalar: d } = schnorrGetExtPubKey(secretKey);
        const a = (0, utils_ts_1.ensureBytes)("auxRand", auxRand, 32);
        const t = Fn.toBytes(d ^ num(taggedHash("BIP0340/aux", a)));
        const rand = taggedHash("BIP0340/nonce", t, px, m);
        const { bytes: rx, scalar: k } = schnorrGetExtPubKey(rand);
        const e = challenge(rx, px, m);
        const sig = new Uint8Array(64);
        sig.set(rx, 0);
        sig.set(Fn.toBytes(Fn.create(k + e * d)), 32);
        if (!schnorrVerify(sig, m, px))
          throw new Error("sign: Invalid signature produced");
        return sig;
      }
      function schnorrVerify(signature, message, publicKey3) {
        const { Fn, BASE } = Pointk1;
        const sig = (0, utils_ts_1.ensureBytes)("signature", signature, 64);
        const m = (0, utils_ts_1.ensureBytes)("message", message);
        const pub = (0, utils_ts_1.ensureBytes)("publicKey", publicKey3, 32);
        try {
          const P = lift_x(num(pub));
          const r = num(sig.subarray(0, 32));
          if (!(0, utils_ts_1.inRange)(r, _1n, secp256k1_CURVE.p))
            return false;
          const s = num(sig.subarray(32, 64));
          if (!(0, utils_ts_1.inRange)(s, _1n, secp256k1_CURVE.n))
            return false;
          const e = challenge(Fn.toBytes(r), pointToBytes(P), m);
          const R = BASE.multiplyUnsafe(s).add(P.multiplyUnsafe(Fn.neg(e)));
          const { x, y } = R.toAffine();
          if (R.is0() || !hasEven(y) || x !== r)
            return false;
          return true;
        } catch (error) {
          return false;
        }
      }
      exports.schnorr = (() => {
        const size = 32;
        const seedLength = 48;
        const randomSecretKey = (seed2 = (0, utils_js_1.randomBytes)(seedLength)) => {
          return (0, modular_ts_1.mapHashToField)(seed2, secp256k1_CURVE.n);
        };
        exports.secp256k1.utils.randomSecretKey;
        function keygen(seed2) {
          const secretKey = randomSecretKey(seed2);
          return { secretKey, publicKey: schnorrGetPublicKey(secretKey) };
        }
        return {
          keygen,
          getPublicKey: schnorrGetPublicKey,
          sign: schnorrSign,
          verify: schnorrVerify,
          Point: Pointk1,
          utils: {
            randomSecretKey,
            randomPrivateKey: randomSecretKey,
            taggedHash,
            // TODO: remove
            lift_x,
            pointToBytes,
            numberToBytesBE: utils_ts_1.numberToBytesBE,
            bytesToNumberBE: utils_ts_1.bytesToNumberBE,
            mod: modular_ts_1.mod
          },
          lengths: {
            secretKey: size,
            publicKey: size,
            publicKeyHasPrefix: false,
            signature: size * 2,
            seed: seedLength
          }
        };
      })();
      var isoMap = /* @__PURE__ */ (() => (0, hash_to_curve_ts_1.isogenyMap)(Fpk1, [
        // xNum
        [
          "0x8e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38daaaaa8c7",
          "0x7d3d4c80bc321d5b9f315cea7fd44c5d595d2fc0bf63b92dfff1044f17c6581",
          "0x534c328d23f234e6e2a413deca25caece4506144037c40314ecbd0b53d9dd262",
          "0x8e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38daaaaa88c"
        ],
        // xDen
        [
          "0xd35771193d94918a9ca34ccbb7b640dd86cd409542f8487d9fe6b745781eb49b",
          "0xedadc6f64383dc1df7c4b2d51b54225406d36b641f5e41bbc52a56612a8c6d14",
          "0x0000000000000000000000000000000000000000000000000000000000000001"
          // LAST 1
        ],
        // yNum
        [
          "0x4bda12f684bda12f684bda12f684bda12f684bda12f684bda12f684b8e38e23c",
          "0xc75e0c32d5cb7c0fa9d0a54b12a0a6d5647ab046d686da6fdffc90fc201d71a3",
          "0x29a6194691f91a73715209ef6512e576722830a201be2018a765e85a9ecee931",
          "0x2f684bda12f684bda12f684bda12f684bda12f684bda12f684bda12f38e38d84"
        ],
        // yDen
        [
          "0xfffffffffffffffffffffffffffffffffffffffffffffffffffffffefffff93b",
          "0x7a06534bb8bdb49fd5e9e6632722c2989467c1bfc8e8d978dfb425d2685c2573",
          "0x6484aa716545ca2cf3a70c3fa8fe337e0a3d21162f0d6299a7bf8192bfd2a76f",
          "0x0000000000000000000000000000000000000000000000000000000000000001"
          // LAST 1
        ]
      ].map((i) => i.map((j) => BigInt(j)))))();
      var mapSWU = /* @__PURE__ */ (() => (0, weierstrass_ts_1.mapToCurveSimpleSWU)(Fpk1, {
        A: BigInt("0x3f8731abdd661adca08a5558f0f5d272e953d363cb6f0e5d405447c01a444533"),
        B: BigInt("1771"),
        Z: Fpk1.create(BigInt("-11"))
      }))();
      exports.secp256k1_hasher = (() => (0, hash_to_curve_ts_1.createHasher)(exports.secp256k1.Point, (scalars) => {
        const { x, y } = mapSWU(Fpk1.create(scalars[0]));
        return isoMap(x, y);
      }, {
        DST: "secp256k1_XMD:SHA-256_SSWU_RO_",
        encodeDST: "secp256k1_XMD:SHA-256_SSWU_NU_",
        p: Fpk1.ORDER,
        m: 1,
        k: 128,
        expand: "xmd",
        hash: sha2_js_1.sha256
      }))();
      exports.hashToCurve = (() => exports.secp256k1_hasher.hashToCurve)();
      exports.encodeToCurve = (() => exports.secp256k1_hasher.encodeToCurve)();
    }
  });

  // node_modules/@solana/web3.js/lib/index.browser.cjs.js
  var require_index_browser_cjs = __commonJS({
    "node_modules/@solana/web3.js/lib/index.browser.cjs.js"(exports) {
      "use strict";
      var buffer = require_buffer();
      var ed25519 = require_ed25519();
      var BN2 = require_bn();
      var bs582 = require_bs58();
      var sha2564 = require_sha256();
      var borsh2 = require_lib();
      var BufferLayout = require_Layout();
      var codecsNumbers = require_index_browser3();
      var superstruct = require_dist();
      var RpcClient = require_browser();
      var rpcWebsockets = require_index_browser4();
      var sha3 = require_sha3();
      var secp256k1 = require_secp256k1();
      function _interopDefaultCompat(e) {
        return e && typeof e === "object" && "default" in e ? e : { default: e };
      }
      function _interopNamespaceCompat(e) {
        if (e && typeof e === "object" && "default" in e) return e;
        var n = /* @__PURE__ */ Object.create(null);
        if (e) {
          Object.keys(e).forEach(function(k) {
            if (k !== "default") {
              var d = Object.getOwnPropertyDescriptor(e, k);
              Object.defineProperty(n, k, d.get ? d : {
                enumerable: true,
                get: function() {
                  return e[k];
                }
              });
            }
          });
        }
        n.default = e;
        return Object.freeze(n);
      }
      var BN__default = /* @__PURE__ */ _interopDefaultCompat(BN2);
      var bs58__default = /* @__PURE__ */ _interopDefaultCompat(bs582);
      var BufferLayout__namespace = /* @__PURE__ */ _interopNamespaceCompat(BufferLayout);
      var RpcClient__default = /* @__PURE__ */ _interopDefaultCompat(RpcClient);
      var generatePrivateKey = ed25519.ed25519.utils.randomPrivateKey;
      var generateKeypair = () => {
        const privateScalar = ed25519.ed25519.utils.randomPrivateKey();
        const publicKey4 = getPublicKey(privateScalar);
        const secretKey = new Uint8Array(64);
        secretKey.set(privateScalar);
        secretKey.set(publicKey4, 32);
        return {
          publicKey: publicKey4,
          secretKey
        };
      };
      var getPublicKey = ed25519.ed25519.getPublicKey;
      function isOnCurve(publicKey4) {
        try {
          ed25519.ed25519.ExtendedPoint.fromHex(publicKey4);
          return true;
        } catch {
          return false;
        }
      }
      var sign = (message, secretKey) => ed25519.ed25519.sign(message, secretKey.slice(0, 32));
      var verify = ed25519.ed25519.verify;
      var toBuffer = (arr) => {
        if (buffer.Buffer.isBuffer(arr)) {
          return arr;
        } else if (arr instanceof Uint8Array) {
          return buffer.Buffer.from(arr.buffer, arr.byteOffset, arr.byteLength);
        } else {
          return buffer.Buffer.from(arr);
        }
      };
      var Struct2 = class {
        constructor(properties) {
          Object.assign(this, properties);
        }
        encode() {
          return buffer.Buffer.from(borsh2.serialize(SOLANA_SCHEMA, this));
        }
        static decode(data) {
          return borsh2.deserialize(SOLANA_SCHEMA, this, data);
        }
        static decodeUnchecked(data) {
          return borsh2.deserializeUnchecked(SOLANA_SCHEMA, this, data);
        }
      };
      var Enum = class extends Struct2 {
        constructor(properties) {
          super(properties);
          this.enum = "";
          if (Object.keys(properties).length !== 1) {
            throw new Error("Enum can only take single value");
          }
          Object.keys(properties).map((key) => {
            this.enum = key;
          });
        }
      };
      var SOLANA_SCHEMA = /* @__PURE__ */ new Map();
      var _PublicKey;
      var MAX_SEED_LENGTH = 32;
      var PUBLIC_KEY_LENGTH = 32;
      function isPublicKeyData(value) {
        return value._bn !== void 0;
      }
      var uniquePublicKeyCounter = 1;
      var PublicKey2 = class _PublicKey2 extends Struct2 {
        /**
         * Create a new PublicKey object
         * @param value ed25519 public key as buffer or base-58 encoded string
         */
        constructor(value) {
          super({});
          this._bn = void 0;
          if (isPublicKeyData(value)) {
            this._bn = value._bn;
          } else {
            if (typeof value === "string") {
              const decoded = bs58__default.default.decode(value);
              if (decoded.length != PUBLIC_KEY_LENGTH) {
                throw new Error(`Invalid public key input`);
              }
              this._bn = new BN__default.default(decoded);
            } else {
              this._bn = new BN__default.default(value);
            }
            if (this._bn.byteLength() > PUBLIC_KEY_LENGTH) {
              throw new Error(`Invalid public key input`);
            }
          }
        }
        /**
         * Returns a unique PublicKey for tests and benchmarks using a counter
         */
        static unique() {
          const key = new _PublicKey2(uniquePublicKeyCounter);
          uniquePublicKeyCounter += 1;
          return new _PublicKey2(key.toBuffer());
        }
        /**
         * Default public key value. The base58-encoded string representation is all ones (as seen below)
         * The underlying BN number is 32 bytes that are all zeros
         */
        /**
         * Checks if two publicKeys are equal
         */
        equals(publicKey4) {
          return this._bn.eq(publicKey4._bn);
        }
        /**
         * Return the base-58 representation of the public key
         */
        toBase58() {
          return bs58__default.default.encode(this.toBytes());
        }
        toJSON() {
          return this.toBase58();
        }
        /**
         * Return the byte array representation of the public key in big endian
         */
        toBytes() {
          const buf = this.toBuffer();
          return new Uint8Array(buf.buffer, buf.byteOffset, buf.byteLength);
        }
        /**
         * Return the Buffer representation of the public key in big endian
         */
        toBuffer() {
          const b = this._bn.toArrayLike(buffer.Buffer);
          if (b.length === PUBLIC_KEY_LENGTH) {
            return b;
          }
          const zeroPad = buffer.Buffer.alloc(32);
          b.copy(zeroPad, 32 - b.length);
          return zeroPad;
        }
        get [Symbol.toStringTag]() {
          return `PublicKey(${this.toString()})`;
        }
        /**
         * Return the base-58 representation of the public key
         */
        toString() {
          return this.toBase58();
        }
        /**
         * Derive a public key from another key, a seed, and a program ID.
         * The program ID will also serve as the owner of the public key, giving
         * it permission to write data to the account.
         */
        /* eslint-disable require-await */
        static async createWithSeed(fromPublicKey, seed2, programId) {
          const buffer$1 = buffer.Buffer.concat([fromPublicKey.toBuffer(), buffer.Buffer.from(seed2), programId.toBuffer()]);
          const publicKeyBytes = sha2564.sha256(buffer$1);
          return new _PublicKey2(publicKeyBytes);
        }
        /**
         * Derive a program address from seeds and a program ID.
         */
        /* eslint-disable require-await */
        static createProgramAddressSync(seeds, programId) {
          let buffer$1 = buffer.Buffer.alloc(0);
          seeds.forEach(function(seed2) {
            if (seed2.length > MAX_SEED_LENGTH) {
              throw new TypeError(`Max seed length exceeded`);
            }
            buffer$1 = buffer.Buffer.concat([buffer$1, toBuffer(seed2)]);
          });
          buffer$1 = buffer.Buffer.concat([buffer$1, programId.toBuffer(), buffer.Buffer.from("ProgramDerivedAddress")]);
          const publicKeyBytes = sha2564.sha256(buffer$1);
          if (isOnCurve(publicKeyBytes)) {
            throw new Error(`Invalid seeds, address must fall off the curve`);
          }
          return new _PublicKey2(publicKeyBytes);
        }
        /**
         * Async version of createProgramAddressSync
         * For backwards compatibility
         *
         * @deprecated Use {@link createProgramAddressSync} instead
         */
        /* eslint-disable require-await */
        static async createProgramAddress(seeds, programId) {
          return this.createProgramAddressSync(seeds, programId);
        }
        /**
         * Find a valid program address
         *
         * Valid program addresses must fall off the ed25519 curve.  This function
         * iterates a nonce until it finds one that when combined with the seeds
         * results in a valid program address.
         */
        static findProgramAddressSync(seeds, programId) {
          let nonce = 255;
          let address;
          while (nonce != 0) {
            try {
              const seedsWithNonce = seeds.concat(buffer.Buffer.from([nonce]));
              address = this.createProgramAddressSync(seedsWithNonce, programId);
            } catch (err2) {
              if (err2 instanceof TypeError) {
                throw err2;
              }
              nonce--;
              continue;
            }
            return [address, nonce];
          }
          throw new Error(`Unable to find a viable program address nonce`);
        }
        /**
         * Async version of findProgramAddressSync
         * For backwards compatibility
         *
         * @deprecated Use {@link findProgramAddressSync} instead
         */
        static async findProgramAddress(seeds, programId) {
          return this.findProgramAddressSync(seeds, programId);
        }
        /**
         * Check that a pubkey is on the ed25519 curve.
         */
        static isOnCurve(pubkeyData) {
          const pubkey2 = new _PublicKey2(pubkeyData);
          return isOnCurve(pubkey2.toBytes());
        }
      };
      _PublicKey = PublicKey2;
      PublicKey2.default = new _PublicKey("11111111111111111111111111111111");
      SOLANA_SCHEMA.set(PublicKey2, {
        kind: "struct",
        fields: [["_bn", "u256"]]
      });
      var Account = class {
        /**
         * Create a new Account object
         *
         * If the secretKey parameter is not provided a new key pair is randomly
         * created for the account
         *
         * @param secretKey Secret key for the account
         */
        constructor(secretKey) {
          this._publicKey = void 0;
          this._secretKey = void 0;
          if (secretKey) {
            const secretKeyBuffer = toBuffer(secretKey);
            if (secretKey.length !== 64) {
              throw new Error("bad secret key size");
            }
            this._publicKey = secretKeyBuffer.slice(32, 64);
            this._secretKey = secretKeyBuffer.slice(0, 32);
          } else {
            this._secretKey = toBuffer(generatePrivateKey());
            this._publicKey = toBuffer(getPublicKey(this._secretKey));
          }
        }
        /**
         * The public key for this account
         */
        get publicKey() {
          return new PublicKey2(this._publicKey);
        }
        /**
         * The **unencrypted** secret key for this account. The first 32 bytes
         * is the private scalar and the last 32 bytes is the public key.
         * Read more: https://blog.mozilla.org/warner/2011/11/29/ed25519-keys/
         */
        get secretKey() {
          return buffer.Buffer.concat([this._secretKey, this._publicKey], 64);
        }
      };
      var BPF_LOADER_DEPRECATED_PROGRAM_ID = new PublicKey2("BPFLoader1111111111111111111111111111111111");
      var PACKET_DATA_SIZE = 1280 - 40 - 8;
      var VERSION_PREFIX_MASK = 127;
      var SIGNATURE_LENGTH_IN_BYTES = 64;
      var TransactionExpiredBlockheightExceededError = class extends Error {
        constructor(signature2) {
          super(`Signature ${signature2} has expired: block height exceeded.`);
          this.signature = void 0;
          this.signature = signature2;
        }
      };
      Object.defineProperty(TransactionExpiredBlockheightExceededError.prototype, "name", {
        value: "TransactionExpiredBlockheightExceededError"
      });
      var TransactionExpiredTimeoutError = class extends Error {
        constructor(signature2, timeoutSeconds) {
          super(`Transaction was not confirmed in ${timeoutSeconds.toFixed(2)} seconds. It is unknown if it succeeded or failed. Check signature ${signature2} using the Solana Explorer or CLI tools.`);
          this.signature = void 0;
          this.signature = signature2;
        }
      };
      Object.defineProperty(TransactionExpiredTimeoutError.prototype, "name", {
        value: "TransactionExpiredTimeoutError"
      });
      var TransactionExpiredNonceInvalidError = class extends Error {
        constructor(signature2) {
          super(`Signature ${signature2} has expired: the nonce is no longer valid.`);
          this.signature = void 0;
          this.signature = signature2;
        }
      };
      Object.defineProperty(TransactionExpiredNonceInvalidError.prototype, "name", {
        value: "TransactionExpiredNonceInvalidError"
      });
      var MessageAccountKeys = class {
        constructor(staticAccountKeys, accountKeysFromLookups) {
          this.staticAccountKeys = void 0;
          this.accountKeysFromLookups = void 0;
          this.staticAccountKeys = staticAccountKeys;
          this.accountKeysFromLookups = accountKeysFromLookups;
        }
        keySegments() {
          const keySegments = [this.staticAccountKeys];
          if (this.accountKeysFromLookups) {
            keySegments.push(this.accountKeysFromLookups.writable);
            keySegments.push(this.accountKeysFromLookups.readonly);
          }
          return keySegments;
        }
        get(index2) {
          for (const keySegment of this.keySegments()) {
            if (index2 < keySegment.length) {
              return keySegment[index2];
            } else {
              index2 -= keySegment.length;
            }
          }
          return;
        }
        get length() {
          return this.keySegments().flat().length;
        }
        compileInstructions(instructions) {
          const U8_MAX = 255;
          if (this.length > U8_MAX + 1) {
            throw new Error("Account index overflow encountered during compilation");
          }
          const keyIndexMap = /* @__PURE__ */ new Map();
          this.keySegments().flat().forEach((key, index2) => {
            keyIndexMap.set(key.toBase58(), index2);
          });
          const findKeyIndex = (key) => {
            const keyIndex = keyIndexMap.get(key.toBase58());
            if (keyIndex === void 0) throw new Error("Encountered an unknown instruction account key during compilation");
            return keyIndex;
          };
          return instructions.map((instruction) => {
            return {
              programIdIndex: findKeyIndex(instruction.programId),
              accountKeyIndexes: instruction.keys.map((meta) => findKeyIndex(meta.pubkey)),
              data: instruction.data
            };
          });
        }
      };
      var publicKey3 = (property = "publicKey") => {
        return BufferLayout__namespace.blob(32, property);
      };
      var signature = (property = "signature") => {
        return BufferLayout__namespace.blob(64, property);
      };
      var rustString = (property = "string") => {
        const rsl = BufferLayout__namespace.struct([BufferLayout__namespace.u32("length"), BufferLayout__namespace.u32("lengthPadding"), BufferLayout__namespace.blob(BufferLayout__namespace.offset(BufferLayout__namespace.u32(), -8), "chars")], property);
        const _decode = rsl.decode.bind(rsl);
        const _encode = rsl.encode.bind(rsl);
        const rslShim = rsl;
        rslShim.decode = (b, offset2) => {
          const data = _decode(b, offset2);
          return data["chars"].toString();
        };
        rslShim.encode = (str2, b, offset2) => {
          const data = {
            chars: buffer.Buffer.from(str2, "utf8")
          };
          return _encode(data, b, offset2);
        };
        rslShim.alloc = (str2) => {
          return BufferLayout__namespace.u32().span + BufferLayout__namespace.u32().span + buffer.Buffer.from(str2, "utf8").length;
        };
        return rslShim;
      };
      var authorized = (property = "authorized") => {
        return BufferLayout__namespace.struct([publicKey3("staker"), publicKey3("withdrawer")], property);
      };
      var lockup = (property = "lockup") => {
        return BufferLayout__namespace.struct([BufferLayout__namespace.ns64("unixTimestamp"), BufferLayout__namespace.ns64("epoch"), publicKey3("custodian")], property);
      };
      var voteInit = (property = "voteInit") => {
        return BufferLayout__namespace.struct([publicKey3("nodePubkey"), publicKey3("authorizedVoter"), publicKey3("authorizedWithdrawer"), BufferLayout__namespace.u8("commission")], property);
      };
      var voteAuthorizeWithSeedArgs = (property = "voteAuthorizeWithSeedArgs") => {
        return BufferLayout__namespace.struct([BufferLayout__namespace.u32("voteAuthorizationType"), publicKey3("currentAuthorityDerivedKeyOwnerPubkey"), rustString("currentAuthorityDerivedKeySeed"), publicKey3("newAuthorized")], property);
      };
      function getAlloc(type2, fields) {
        const getItemAlloc = (item) => {
          if (item.span >= 0) {
            return item.span;
          } else if (typeof item.alloc === "function") {
            return item.alloc(fields[item.property]);
          } else if ("count" in item && "elementLayout" in item) {
            const field = fields[item.property];
            if (Array.isArray(field)) {
              return field.length * getItemAlloc(item.elementLayout);
            }
          } else if ("fields" in item) {
            return getAlloc({
              layout: item
            }, fields[item.property]);
          }
          return 0;
        };
        let alloc = 0;
        type2.layout.fields.forEach((item) => {
          alloc += getItemAlloc(item);
        });
        return alloc;
      }
      function decodeLength(bytes) {
        let len = 0;
        let size = 0;
        for (; ; ) {
          let elem = bytes.shift();
          len |= (elem & 127) << size * 7;
          size += 1;
          if ((elem & 128) === 0) {
            break;
          }
        }
        return len;
      }
      function encodeLength(bytes, len) {
        let rem_len = len;
        for (; ; ) {
          let elem = rem_len & 127;
          rem_len >>= 7;
          if (rem_len == 0) {
            bytes.push(elem);
            break;
          } else {
            elem |= 128;
            bytes.push(elem);
          }
        }
      }
      function assert2(condition, message) {
        if (!condition) {
          throw new Error(message || "Assertion failed");
        }
      }
      var CompiledKeys = class _CompiledKeys {
        constructor(payer, keyMetaMap) {
          this.payer = void 0;
          this.keyMetaMap = void 0;
          this.payer = payer;
          this.keyMetaMap = keyMetaMap;
        }
        static compile(instructions, payer) {
          const keyMetaMap = /* @__PURE__ */ new Map();
          const getOrInsertDefault = (pubkey2) => {
            const address = pubkey2.toBase58();
            let keyMeta = keyMetaMap.get(address);
            if (keyMeta === void 0) {
              keyMeta = {
                isSigner: false,
                isWritable: false,
                isInvoked: false
              };
              keyMetaMap.set(address, keyMeta);
            }
            return keyMeta;
          };
          const payerKeyMeta = getOrInsertDefault(payer);
          payerKeyMeta.isSigner = true;
          payerKeyMeta.isWritable = true;
          for (const ix of instructions) {
            getOrInsertDefault(ix.programId).isInvoked = true;
            for (const accountMeta of ix.keys) {
              const keyMeta = getOrInsertDefault(accountMeta.pubkey);
              keyMeta.isSigner || (keyMeta.isSigner = accountMeta.isSigner);
              keyMeta.isWritable || (keyMeta.isWritable = accountMeta.isWritable);
            }
          }
          return new _CompiledKeys(payer, keyMetaMap);
        }
        getMessageComponents() {
          const mapEntries = [...this.keyMetaMap.entries()];
          assert2(mapEntries.length <= 256, "Max static account keys length exceeded");
          const writableSigners = mapEntries.filter(([, meta]) => meta.isSigner && meta.isWritable);
          const readonlySigners = mapEntries.filter(([, meta]) => meta.isSigner && !meta.isWritable);
          const writableNonSigners = mapEntries.filter(([, meta]) => !meta.isSigner && meta.isWritable);
          const readonlyNonSigners = mapEntries.filter(([, meta]) => !meta.isSigner && !meta.isWritable);
          const header = {
            numRequiredSignatures: writableSigners.length + readonlySigners.length,
            numReadonlySignedAccounts: readonlySigners.length,
            numReadonlyUnsignedAccounts: readonlyNonSigners.length
          };
          {
            assert2(writableSigners.length > 0, "Expected at least one writable signer key");
            const [payerAddress] = writableSigners[0];
            assert2(payerAddress === this.payer.toBase58(), "Expected first writable signer key to be the fee payer");
          }
          const staticAccountKeys = [...writableSigners.map(([address]) => new PublicKey2(address)), ...readonlySigners.map(([address]) => new PublicKey2(address)), ...writableNonSigners.map(([address]) => new PublicKey2(address)), ...readonlyNonSigners.map(([address]) => new PublicKey2(address))];
          return [header, staticAccountKeys];
        }
        extractTableLookup(lookupTable) {
          const [writableIndexes, drainedWritableKeys] = this.drainKeysFoundInLookupTable(lookupTable.state.addresses, (keyMeta) => !keyMeta.isSigner && !keyMeta.isInvoked && keyMeta.isWritable);
          const [readonlyIndexes, drainedReadonlyKeys] = this.drainKeysFoundInLookupTable(lookupTable.state.addresses, (keyMeta) => !keyMeta.isSigner && !keyMeta.isInvoked && !keyMeta.isWritable);
          if (writableIndexes.length === 0 && readonlyIndexes.length === 0) {
            return;
          }
          return [{
            accountKey: lookupTable.key,
            writableIndexes,
            readonlyIndexes
          }, {
            writable: drainedWritableKeys,
            readonly: drainedReadonlyKeys
          }];
        }
        /** @internal */
        drainKeysFoundInLookupTable(lookupTableEntries, keyMetaFilter) {
          const lookupTableIndexes = new Array();
          const drainedKeys = new Array();
          for (const [address, keyMeta] of this.keyMetaMap.entries()) {
            if (keyMetaFilter(keyMeta)) {
              const key = new PublicKey2(address);
              const lookupTableIndex = lookupTableEntries.findIndex((entry) => entry.equals(key));
              if (lookupTableIndex >= 0) {
                assert2(lookupTableIndex < 256, "Max lookup table index exceeded");
                lookupTableIndexes.push(lookupTableIndex);
                drainedKeys.push(key);
                this.keyMetaMap.delete(address);
              }
            }
          }
          return [lookupTableIndexes, drainedKeys];
        }
      };
      var END_OF_BUFFER_ERROR_MESSAGE = "Reached end of buffer unexpectedly";
      function guardedShift(byteArray) {
        if (byteArray.length === 0) {
          throw new Error(END_OF_BUFFER_ERROR_MESSAGE);
        }
        return byteArray.shift();
      }
      function guardedSplice(byteArray, ...args) {
        const [start] = args;
        if (args.length === 2 ? start + (args[1] ?? 0) > byteArray.length : start >= byteArray.length) {
          throw new Error(END_OF_BUFFER_ERROR_MESSAGE);
        }
        return byteArray.splice(...args);
      }
      var Message = class _Message {
        constructor(args) {
          this.header = void 0;
          this.accountKeys = void 0;
          this.recentBlockhash = void 0;
          this.instructions = void 0;
          this.indexToProgramIds = /* @__PURE__ */ new Map();
          this.header = args.header;
          this.accountKeys = args.accountKeys.map((account) => new PublicKey2(account));
          this.recentBlockhash = args.recentBlockhash;
          this.instructions = args.instructions;
          this.instructions.forEach((ix) => this.indexToProgramIds.set(ix.programIdIndex, this.accountKeys[ix.programIdIndex]));
        }
        get version() {
          return "legacy";
        }
        get staticAccountKeys() {
          return this.accountKeys;
        }
        get compiledInstructions() {
          return this.instructions.map((ix) => ({
            programIdIndex: ix.programIdIndex,
            accountKeyIndexes: ix.accounts,
            data: bs58__default.default.decode(ix.data)
          }));
        }
        get addressTableLookups() {
          return [];
        }
        getAccountKeys() {
          return new MessageAccountKeys(this.staticAccountKeys);
        }
        static compile(args) {
          const compiledKeys = CompiledKeys.compile(args.instructions, args.payerKey);
          const [header, staticAccountKeys] = compiledKeys.getMessageComponents();
          const accountKeys = new MessageAccountKeys(staticAccountKeys);
          const instructions = accountKeys.compileInstructions(args.instructions).map((ix) => ({
            programIdIndex: ix.programIdIndex,
            accounts: ix.accountKeyIndexes,
            data: bs58__default.default.encode(ix.data)
          }));
          return new _Message({
            header,
            accountKeys: staticAccountKeys,
            recentBlockhash: args.recentBlockhash,
            instructions
          });
        }
        isAccountSigner(index2) {
          return index2 < this.header.numRequiredSignatures;
        }
        isAccountWritable(index2) {
          const numSignedAccounts = this.header.numRequiredSignatures;
          if (index2 >= this.header.numRequiredSignatures) {
            const unsignedAccountIndex = index2 - numSignedAccounts;
            const numUnsignedAccounts = this.accountKeys.length - numSignedAccounts;
            const numWritableUnsignedAccounts = numUnsignedAccounts - this.header.numReadonlyUnsignedAccounts;
            return unsignedAccountIndex < numWritableUnsignedAccounts;
          } else {
            const numWritableSignedAccounts = numSignedAccounts - this.header.numReadonlySignedAccounts;
            return index2 < numWritableSignedAccounts;
          }
        }
        isProgramId(index2) {
          return this.indexToProgramIds.has(index2);
        }
        programIds() {
          return [...this.indexToProgramIds.values()];
        }
        nonProgramIds() {
          return this.accountKeys.filter((_, index2) => !this.isProgramId(index2));
        }
        serialize() {
          const numKeys = this.accountKeys.length;
          let keyCount = [];
          encodeLength(keyCount, numKeys);
          const instructions = this.instructions.map((instruction) => {
            const {
              accounts,
              programIdIndex
            } = instruction;
            const data = Array.from(bs58__default.default.decode(instruction.data));
            let keyIndicesCount = [];
            encodeLength(keyIndicesCount, accounts.length);
            let dataCount = [];
            encodeLength(dataCount, data.length);
            return {
              programIdIndex,
              keyIndicesCount: buffer.Buffer.from(keyIndicesCount),
              keyIndices: accounts,
              dataLength: buffer.Buffer.from(dataCount),
              data
            };
          });
          let instructionCount = [];
          encodeLength(instructionCount, instructions.length);
          let instructionBuffer = buffer.Buffer.alloc(PACKET_DATA_SIZE);
          buffer.Buffer.from(instructionCount).copy(instructionBuffer);
          let instructionBufferLength = instructionCount.length;
          instructions.forEach((instruction) => {
            const instructionLayout = BufferLayout__namespace.struct([BufferLayout__namespace.u8("programIdIndex"), BufferLayout__namespace.blob(instruction.keyIndicesCount.length, "keyIndicesCount"), BufferLayout__namespace.seq(BufferLayout__namespace.u8("keyIndex"), instruction.keyIndices.length, "keyIndices"), BufferLayout__namespace.blob(instruction.dataLength.length, "dataLength"), BufferLayout__namespace.seq(BufferLayout__namespace.u8("userdatum"), instruction.data.length, "data")]);
            const length2 = instructionLayout.encode(instruction, instructionBuffer, instructionBufferLength);
            instructionBufferLength += length2;
          });
          instructionBuffer = instructionBuffer.slice(0, instructionBufferLength);
          const signDataLayout = BufferLayout__namespace.struct([BufferLayout__namespace.blob(1, "numRequiredSignatures"), BufferLayout__namespace.blob(1, "numReadonlySignedAccounts"), BufferLayout__namespace.blob(1, "numReadonlyUnsignedAccounts"), BufferLayout__namespace.blob(keyCount.length, "keyCount"), BufferLayout__namespace.seq(publicKey3("key"), numKeys, "keys"), publicKey3("recentBlockhash")]);
          const transaction = {
            numRequiredSignatures: buffer.Buffer.from([this.header.numRequiredSignatures]),
            numReadonlySignedAccounts: buffer.Buffer.from([this.header.numReadonlySignedAccounts]),
            numReadonlyUnsignedAccounts: buffer.Buffer.from([this.header.numReadonlyUnsignedAccounts]),
            keyCount: buffer.Buffer.from(keyCount),
            keys: this.accountKeys.map((key) => toBuffer(key.toBytes())),
            recentBlockhash: bs58__default.default.decode(this.recentBlockhash)
          };
          let signData = buffer.Buffer.alloc(2048);
          const length = signDataLayout.encode(transaction, signData);
          instructionBuffer.copy(signData, length);
          return signData.slice(0, length + instructionBuffer.length);
        }
        /**
         * Decode a compiled message into a Message object.
         */
        static from(buffer$1) {
          let byteArray = [...buffer$1];
          const numRequiredSignatures = guardedShift(byteArray);
          if (numRequiredSignatures !== (numRequiredSignatures & VERSION_PREFIX_MASK)) {
            throw new Error("Versioned messages must be deserialized with VersionedMessage.deserialize()");
          }
          const numReadonlySignedAccounts = guardedShift(byteArray);
          const numReadonlyUnsignedAccounts = guardedShift(byteArray);
          const accountCount = decodeLength(byteArray);
          let accountKeys = [];
          for (let i = 0; i < accountCount; i++) {
            const account = guardedSplice(byteArray, 0, PUBLIC_KEY_LENGTH);
            accountKeys.push(new PublicKey2(buffer.Buffer.from(account)));
          }
          const recentBlockhash = guardedSplice(byteArray, 0, PUBLIC_KEY_LENGTH);
          const instructionCount = decodeLength(byteArray);
          let instructions = [];
          for (let i = 0; i < instructionCount; i++) {
            const programIdIndex = guardedShift(byteArray);
            const accountCount2 = decodeLength(byteArray);
            const accounts = guardedSplice(byteArray, 0, accountCount2);
            const dataLength = decodeLength(byteArray);
            const dataSlice = guardedSplice(byteArray, 0, dataLength);
            const data = bs58__default.default.encode(buffer.Buffer.from(dataSlice));
            instructions.push({
              programIdIndex,
              accounts,
              data
            });
          }
          const messageArgs = {
            header: {
              numRequiredSignatures,
              numReadonlySignedAccounts,
              numReadonlyUnsignedAccounts
            },
            recentBlockhash: bs58__default.default.encode(buffer.Buffer.from(recentBlockhash)),
            accountKeys,
            instructions
          };
          return new _Message(messageArgs);
        }
      };
      var MessageV0 = class _MessageV0 {
        constructor(args) {
          this.header = void 0;
          this.staticAccountKeys = void 0;
          this.recentBlockhash = void 0;
          this.compiledInstructions = void 0;
          this.addressTableLookups = void 0;
          this.header = args.header;
          this.staticAccountKeys = args.staticAccountKeys;
          this.recentBlockhash = args.recentBlockhash;
          this.compiledInstructions = args.compiledInstructions;
          this.addressTableLookups = args.addressTableLookups;
        }
        get version() {
          return 0;
        }
        get numAccountKeysFromLookups() {
          let count = 0;
          for (const lookup of this.addressTableLookups) {
            count += lookup.readonlyIndexes.length + lookup.writableIndexes.length;
          }
          return count;
        }
        getAccountKeys(args) {
          let accountKeysFromLookups;
          if (args && "accountKeysFromLookups" in args && args.accountKeysFromLookups) {
            if (this.numAccountKeysFromLookups != args.accountKeysFromLookups.writable.length + args.accountKeysFromLookups.readonly.length) {
              throw new Error("Failed to get account keys because of a mismatch in the number of account keys from lookups");
            }
            accountKeysFromLookups = args.accountKeysFromLookups;
          } else if (args && "addressLookupTableAccounts" in args && args.addressLookupTableAccounts) {
            accountKeysFromLookups = this.resolveAddressTableLookups(args.addressLookupTableAccounts);
          } else if (this.addressTableLookups.length > 0) {
            throw new Error("Failed to get account keys because address table lookups were not resolved");
          }
          return new MessageAccountKeys(this.staticAccountKeys, accountKeysFromLookups);
        }
        isAccountSigner(index2) {
          return index2 < this.header.numRequiredSignatures;
        }
        isAccountWritable(index2) {
          const numSignedAccounts = this.header.numRequiredSignatures;
          const numStaticAccountKeys = this.staticAccountKeys.length;
          if (index2 >= numStaticAccountKeys) {
            const lookupAccountKeysIndex = index2 - numStaticAccountKeys;
            const numWritableLookupAccountKeys = this.addressTableLookups.reduce((count, lookup) => count + lookup.writableIndexes.length, 0);
            return lookupAccountKeysIndex < numWritableLookupAccountKeys;
          } else if (index2 >= this.header.numRequiredSignatures) {
            const unsignedAccountIndex = index2 - numSignedAccounts;
            const numUnsignedAccounts = numStaticAccountKeys - numSignedAccounts;
            const numWritableUnsignedAccounts = numUnsignedAccounts - this.header.numReadonlyUnsignedAccounts;
            return unsignedAccountIndex < numWritableUnsignedAccounts;
          } else {
            const numWritableSignedAccounts = numSignedAccounts - this.header.numReadonlySignedAccounts;
            return index2 < numWritableSignedAccounts;
          }
        }
        resolveAddressTableLookups(addressLookupTableAccounts) {
          const accountKeysFromLookups = {
            writable: [],
            readonly: []
          };
          for (const tableLookup of this.addressTableLookups) {
            const tableAccount = addressLookupTableAccounts.find((account) => account.key.equals(tableLookup.accountKey));
            if (!tableAccount) {
              throw new Error(`Failed to find address lookup table account for table key ${tableLookup.accountKey.toBase58()}`);
            }
            for (const index2 of tableLookup.writableIndexes) {
              if (index2 < tableAccount.state.addresses.length) {
                accountKeysFromLookups.writable.push(tableAccount.state.addresses[index2]);
              } else {
                throw new Error(`Failed to find address for index ${index2} in address lookup table ${tableLookup.accountKey.toBase58()}`);
              }
            }
            for (const index2 of tableLookup.readonlyIndexes) {
              if (index2 < tableAccount.state.addresses.length) {
                accountKeysFromLookups.readonly.push(tableAccount.state.addresses[index2]);
              } else {
                throw new Error(`Failed to find address for index ${index2} in address lookup table ${tableLookup.accountKey.toBase58()}`);
              }
            }
          }
          return accountKeysFromLookups;
        }
        static compile(args) {
          const compiledKeys = CompiledKeys.compile(args.instructions, args.payerKey);
          const addressTableLookups = new Array();
          const accountKeysFromLookups = {
            writable: new Array(),
            readonly: new Array()
          };
          const lookupTableAccounts = args.addressLookupTableAccounts || [];
          for (const lookupTable of lookupTableAccounts) {
            const extractResult = compiledKeys.extractTableLookup(lookupTable);
            if (extractResult !== void 0) {
              const [addressTableLookup, {
                writable,
                readonly
              }] = extractResult;
              addressTableLookups.push(addressTableLookup);
              accountKeysFromLookups.writable.push(...writable);
              accountKeysFromLookups.readonly.push(...readonly);
            }
          }
          const [header, staticAccountKeys] = compiledKeys.getMessageComponents();
          const accountKeys = new MessageAccountKeys(staticAccountKeys, accountKeysFromLookups);
          const compiledInstructions = accountKeys.compileInstructions(args.instructions);
          return new _MessageV0({
            header,
            staticAccountKeys,
            recentBlockhash: args.recentBlockhash,
            compiledInstructions,
            addressTableLookups
          });
        }
        serialize() {
          const encodedStaticAccountKeysLength = Array();
          encodeLength(encodedStaticAccountKeysLength, this.staticAccountKeys.length);
          const serializedInstructions = this.serializeInstructions();
          const encodedInstructionsLength = Array();
          encodeLength(encodedInstructionsLength, this.compiledInstructions.length);
          const serializedAddressTableLookups = this.serializeAddressTableLookups();
          const encodedAddressTableLookupsLength = Array();
          encodeLength(encodedAddressTableLookupsLength, this.addressTableLookups.length);
          const messageLayout = BufferLayout__namespace.struct([BufferLayout__namespace.u8("prefix"), BufferLayout__namespace.struct([BufferLayout__namespace.u8("numRequiredSignatures"), BufferLayout__namespace.u8("numReadonlySignedAccounts"), BufferLayout__namespace.u8("numReadonlyUnsignedAccounts")], "header"), BufferLayout__namespace.blob(encodedStaticAccountKeysLength.length, "staticAccountKeysLength"), BufferLayout__namespace.seq(publicKey3(), this.staticAccountKeys.length, "staticAccountKeys"), publicKey3("recentBlockhash"), BufferLayout__namespace.blob(encodedInstructionsLength.length, "instructionsLength"), BufferLayout__namespace.blob(serializedInstructions.length, "serializedInstructions"), BufferLayout__namespace.blob(encodedAddressTableLookupsLength.length, "addressTableLookupsLength"), BufferLayout__namespace.blob(serializedAddressTableLookups.length, "serializedAddressTableLookups")]);
          const serializedMessage = new Uint8Array(PACKET_DATA_SIZE);
          const MESSAGE_VERSION_0_PREFIX = 1 << 7;
          const serializedMessageLength = messageLayout.encode({
            prefix: MESSAGE_VERSION_0_PREFIX,
            header: this.header,
            staticAccountKeysLength: new Uint8Array(encodedStaticAccountKeysLength),
            staticAccountKeys: this.staticAccountKeys.map((key) => key.toBytes()),
            recentBlockhash: bs58__default.default.decode(this.recentBlockhash),
            instructionsLength: new Uint8Array(encodedInstructionsLength),
            serializedInstructions,
            addressTableLookupsLength: new Uint8Array(encodedAddressTableLookupsLength),
            serializedAddressTableLookups
          }, serializedMessage);
          return serializedMessage.slice(0, serializedMessageLength);
        }
        serializeInstructions() {
          let serializedLength = 0;
          const serializedInstructions = new Uint8Array(PACKET_DATA_SIZE);
          for (const instruction of this.compiledInstructions) {
            const encodedAccountKeyIndexesLength = Array();
            encodeLength(encodedAccountKeyIndexesLength, instruction.accountKeyIndexes.length);
            const encodedDataLength = Array();
            encodeLength(encodedDataLength, instruction.data.length);
            const instructionLayout = BufferLayout__namespace.struct([BufferLayout__namespace.u8("programIdIndex"), BufferLayout__namespace.blob(encodedAccountKeyIndexesLength.length, "encodedAccountKeyIndexesLength"), BufferLayout__namespace.seq(BufferLayout__namespace.u8(), instruction.accountKeyIndexes.length, "accountKeyIndexes"), BufferLayout__namespace.blob(encodedDataLength.length, "encodedDataLength"), BufferLayout__namespace.blob(instruction.data.length, "data")]);
            serializedLength += instructionLayout.encode({
              programIdIndex: instruction.programIdIndex,
              encodedAccountKeyIndexesLength: new Uint8Array(encodedAccountKeyIndexesLength),
              accountKeyIndexes: instruction.accountKeyIndexes,
              encodedDataLength: new Uint8Array(encodedDataLength),
              data: instruction.data
            }, serializedInstructions, serializedLength);
          }
          return serializedInstructions.slice(0, serializedLength);
        }
        serializeAddressTableLookups() {
          let serializedLength = 0;
          const serializedAddressTableLookups = new Uint8Array(PACKET_DATA_SIZE);
          for (const lookup of this.addressTableLookups) {
            const encodedWritableIndexesLength = Array();
            encodeLength(encodedWritableIndexesLength, lookup.writableIndexes.length);
            const encodedReadonlyIndexesLength = Array();
            encodeLength(encodedReadonlyIndexesLength, lookup.readonlyIndexes.length);
            const addressTableLookupLayout = BufferLayout__namespace.struct([publicKey3("accountKey"), BufferLayout__namespace.blob(encodedWritableIndexesLength.length, "encodedWritableIndexesLength"), BufferLayout__namespace.seq(BufferLayout__namespace.u8(), lookup.writableIndexes.length, "writableIndexes"), BufferLayout__namespace.blob(encodedReadonlyIndexesLength.length, "encodedReadonlyIndexesLength"), BufferLayout__namespace.seq(BufferLayout__namespace.u8(), lookup.readonlyIndexes.length, "readonlyIndexes")]);
            serializedLength += addressTableLookupLayout.encode({
              accountKey: lookup.accountKey.toBytes(),
              encodedWritableIndexesLength: new Uint8Array(encodedWritableIndexesLength),
              writableIndexes: lookup.writableIndexes,
              encodedReadonlyIndexesLength: new Uint8Array(encodedReadonlyIndexesLength),
              readonlyIndexes: lookup.readonlyIndexes
            }, serializedAddressTableLookups, serializedLength);
          }
          return serializedAddressTableLookups.slice(0, serializedLength);
        }
        static deserialize(serializedMessage) {
          let byteArray = [...serializedMessage];
          const prefix = guardedShift(byteArray);
          const maskedPrefix = prefix & VERSION_PREFIX_MASK;
          assert2(prefix !== maskedPrefix, `Expected versioned message but received legacy message`);
          const version2 = maskedPrefix;
          assert2(version2 === 0, `Expected versioned message with version 0 but found version ${version2}`);
          const header = {
            numRequiredSignatures: guardedShift(byteArray),
            numReadonlySignedAccounts: guardedShift(byteArray),
            numReadonlyUnsignedAccounts: guardedShift(byteArray)
          };
          const staticAccountKeys = [];
          const staticAccountKeysLength = decodeLength(byteArray);
          for (let i = 0; i < staticAccountKeysLength; i++) {
            staticAccountKeys.push(new PublicKey2(guardedSplice(byteArray, 0, PUBLIC_KEY_LENGTH)));
          }
          const recentBlockhash = bs58__default.default.encode(guardedSplice(byteArray, 0, PUBLIC_KEY_LENGTH));
          const instructionCount = decodeLength(byteArray);
          const compiledInstructions = [];
          for (let i = 0; i < instructionCount; i++) {
            const programIdIndex = guardedShift(byteArray);
            const accountKeyIndexesLength = decodeLength(byteArray);
            const accountKeyIndexes = guardedSplice(byteArray, 0, accountKeyIndexesLength);
            const dataLength = decodeLength(byteArray);
            const data = new Uint8Array(guardedSplice(byteArray, 0, dataLength));
            compiledInstructions.push({
              programIdIndex,
              accountKeyIndexes,
              data
            });
          }
          const addressTableLookupsCount = decodeLength(byteArray);
          const addressTableLookups = [];
          for (let i = 0; i < addressTableLookupsCount; i++) {
            const accountKey = new PublicKey2(guardedSplice(byteArray, 0, PUBLIC_KEY_LENGTH));
            const writableIndexesLength = decodeLength(byteArray);
            const writableIndexes = guardedSplice(byteArray, 0, writableIndexesLength);
            const readonlyIndexesLength = decodeLength(byteArray);
            const readonlyIndexes = guardedSplice(byteArray, 0, readonlyIndexesLength);
            addressTableLookups.push({
              accountKey,
              writableIndexes,
              readonlyIndexes
            });
          }
          return new _MessageV0({
            header,
            staticAccountKeys,
            recentBlockhash,
            compiledInstructions,
            addressTableLookups
          });
        }
      };
      var VersionedMessage = {
        deserializeMessageVersion(serializedMessage) {
          const prefix = serializedMessage[0];
          const maskedPrefix = prefix & VERSION_PREFIX_MASK;
          if (maskedPrefix === prefix) {
            return "legacy";
          }
          return maskedPrefix;
        },
        deserialize: (serializedMessage) => {
          const version2 = VersionedMessage.deserializeMessageVersion(serializedMessage);
          if (version2 === "legacy") {
            return Message.from(serializedMessage);
          }
          if (version2 === 0) {
            return MessageV0.deserialize(serializedMessage);
          } else {
            throw new Error(`Transaction message version ${version2} deserialization is not supported`);
          }
        }
      };
      var TransactionStatus = /* @__PURE__ */ (function(TransactionStatus2) {
        TransactionStatus2[TransactionStatus2["BLOCKHEIGHT_EXCEEDED"] = 0] = "BLOCKHEIGHT_EXCEEDED";
        TransactionStatus2[TransactionStatus2["PROCESSED"] = 1] = "PROCESSED";
        TransactionStatus2[TransactionStatus2["TIMED_OUT"] = 2] = "TIMED_OUT";
        TransactionStatus2[TransactionStatus2["NONCE_INVALID"] = 3] = "NONCE_INVALID";
        return TransactionStatus2;
      })({});
      var DEFAULT_SIGNATURE = buffer.Buffer.alloc(SIGNATURE_LENGTH_IN_BYTES).fill(0);
      var TransactionInstruction2 = class {
        constructor(opts) {
          this.keys = void 0;
          this.programId = void 0;
          this.data = buffer.Buffer.alloc(0);
          this.programId = opts.programId;
          this.keys = opts.keys;
          if (opts.data) {
            this.data = opts.data;
          }
        }
        /**
         * @internal
         */
        toJSON() {
          return {
            keys: this.keys.map(({
              pubkey: pubkey2,
              isSigner,
              isWritable
            }) => ({
              pubkey: pubkey2.toJSON(),
              isSigner,
              isWritable
            })),
            programId: this.programId.toJSON(),
            data: [...this.data]
          };
        }
      };
      var Transaction2 = class _Transaction {
        /**
         * The first (payer) Transaction signature
         *
         * @returns {Buffer | null} Buffer of payer's signature
         */
        get signature() {
          if (this.signatures.length > 0) {
            return this.signatures[0].signature;
          }
          return null;
        }
        /**
         * The transaction fee payer
         */
        // Construct a transaction with a blockhash and lastValidBlockHeight
        // Construct a transaction using a durable nonce
        /**
         * @deprecated `TransactionCtorFields` has been deprecated and will be removed in a future version.
         * Please supply a `TransactionBlockhashCtor` instead.
         */
        /**
         * Construct an empty Transaction
         */
        constructor(opts) {
          this.signatures = [];
          this.feePayer = void 0;
          this.instructions = [];
          this.recentBlockhash = void 0;
          this.lastValidBlockHeight = void 0;
          this.nonceInfo = void 0;
          this.minNonceContextSlot = void 0;
          this._message = void 0;
          this._json = void 0;
          if (!opts) {
            return;
          }
          if (opts.feePayer) {
            this.feePayer = opts.feePayer;
          }
          if (opts.signatures) {
            this.signatures = opts.signatures;
          }
          if (Object.prototype.hasOwnProperty.call(opts, "nonceInfo")) {
            const {
              minContextSlot,
              nonceInfo
            } = opts;
            this.minNonceContextSlot = minContextSlot;
            this.nonceInfo = nonceInfo;
          } else if (Object.prototype.hasOwnProperty.call(opts, "lastValidBlockHeight")) {
            const {
              blockhash,
              lastValidBlockHeight
            } = opts;
            this.recentBlockhash = blockhash;
            this.lastValidBlockHeight = lastValidBlockHeight;
          } else {
            const {
              recentBlockhash,
              nonceInfo
            } = opts;
            if (nonceInfo) {
              this.nonceInfo = nonceInfo;
            }
            this.recentBlockhash = recentBlockhash;
          }
        }
        /**
         * @internal
         */
        toJSON() {
          return {
            recentBlockhash: this.recentBlockhash || null,
            feePayer: this.feePayer ? this.feePayer.toJSON() : null,
            nonceInfo: this.nonceInfo ? {
              nonce: this.nonceInfo.nonce,
              nonceInstruction: this.nonceInfo.nonceInstruction.toJSON()
            } : null,
            instructions: this.instructions.map((instruction) => instruction.toJSON()),
            signers: this.signatures.map(({
              publicKey: publicKey4
            }) => {
              return publicKey4.toJSON();
            })
          };
        }
        /**
         * Add one or more instructions to this Transaction
         *
         * @param {Array< Transaction | TransactionInstruction | TransactionInstructionCtorFields >} items - Instructions to add to the Transaction
         */
        add(...items) {
          if (items.length === 0) {
            throw new Error("No instructions");
          }
          items.forEach((item) => {
            if ("instructions" in item) {
              this.instructions = this.instructions.concat(item.instructions);
            } else if ("data" in item && "programId" in item && "keys" in item) {
              this.instructions.push(item);
            } else {
              this.instructions.push(new TransactionInstruction2(item));
            }
          });
          return this;
        }
        /**
         * Compile transaction data
         */
        compileMessage() {
          if (this._message && JSON.stringify(this.toJSON()) === JSON.stringify(this._json)) {
            return this._message;
          }
          let recentBlockhash;
          let instructions;
          if (this.nonceInfo) {
            recentBlockhash = this.nonceInfo.nonce;
            if (this.instructions[0] != this.nonceInfo.nonceInstruction) {
              instructions = [this.nonceInfo.nonceInstruction, ...this.instructions];
            } else {
              instructions = this.instructions;
            }
          } else {
            recentBlockhash = this.recentBlockhash;
            instructions = this.instructions;
          }
          if (!recentBlockhash) {
            throw new Error("Transaction recentBlockhash required");
          }
          if (instructions.length < 1) {
            console.warn("No instructions provided");
          }
          let feePayer;
          if (this.feePayer) {
            feePayer = this.feePayer;
          } else if (this.signatures.length > 0 && this.signatures[0].publicKey) {
            feePayer = this.signatures[0].publicKey;
          } else {
            throw new Error("Transaction fee payer required");
          }
          for (let i = 0; i < instructions.length; i++) {
            if (instructions[i].programId === void 0) {
              throw new Error(`Transaction instruction index ${i} has undefined program id`);
            }
          }
          const programIds = [];
          const accountMetas = [];
          instructions.forEach((instruction) => {
            instruction.keys.forEach((accountMeta) => {
              accountMetas.push({
                ...accountMeta
              });
            });
            const programId = instruction.programId.toString();
            if (!programIds.includes(programId)) {
              programIds.push(programId);
            }
          });
          programIds.forEach((programId) => {
            accountMetas.push({
              pubkey: new PublicKey2(programId),
              isSigner: false,
              isWritable: false
            });
          });
          const uniqueMetas = [];
          accountMetas.forEach((accountMeta) => {
            const pubkeyString = accountMeta.pubkey.toString();
            const uniqueIndex = uniqueMetas.findIndex((x) => {
              return x.pubkey.toString() === pubkeyString;
            });
            if (uniqueIndex > -1) {
              uniqueMetas[uniqueIndex].isWritable = uniqueMetas[uniqueIndex].isWritable || accountMeta.isWritable;
              uniqueMetas[uniqueIndex].isSigner = uniqueMetas[uniqueIndex].isSigner || accountMeta.isSigner;
            } else {
              uniqueMetas.push(accountMeta);
            }
          });
          uniqueMetas.sort(function(x, y) {
            if (x.isSigner !== y.isSigner) {
              return x.isSigner ? -1 : 1;
            }
            if (x.isWritable !== y.isWritable) {
              return x.isWritable ? -1 : 1;
            }
            const options = {
              localeMatcher: "best fit",
              usage: "sort",
              sensitivity: "variant",
              ignorePunctuation: false,
              numeric: false,
              caseFirst: "lower"
            };
            return x.pubkey.toBase58().localeCompare(y.pubkey.toBase58(), "en", options);
          });
          const feePayerIndex = uniqueMetas.findIndex((x) => {
            return x.pubkey.equals(feePayer);
          });
          if (feePayerIndex > -1) {
            const [payerMeta] = uniqueMetas.splice(feePayerIndex, 1);
            payerMeta.isSigner = true;
            payerMeta.isWritable = true;
            uniqueMetas.unshift(payerMeta);
          } else {
            uniqueMetas.unshift({
              pubkey: feePayer,
              isSigner: true,
              isWritable: true
            });
          }
          for (const signature2 of this.signatures) {
            const uniqueIndex = uniqueMetas.findIndex((x) => {
              return x.pubkey.equals(signature2.publicKey);
            });
            if (uniqueIndex > -1) {
              if (!uniqueMetas[uniqueIndex].isSigner) {
                uniqueMetas[uniqueIndex].isSigner = true;
                console.warn("Transaction references a signature that is unnecessary, only the fee payer and instruction signer accounts should sign a transaction. This behavior is deprecated and will throw an error in the next major version release.");
              }
            } else {
              throw new Error(`unknown signer: ${signature2.publicKey.toString()}`);
            }
          }
          let numRequiredSignatures = 0;
          let numReadonlySignedAccounts = 0;
          let numReadonlyUnsignedAccounts = 0;
          const signedKeys = [];
          const unsignedKeys = [];
          uniqueMetas.forEach(({
            pubkey: pubkey2,
            isSigner,
            isWritable
          }) => {
            if (isSigner) {
              signedKeys.push(pubkey2.toString());
              numRequiredSignatures += 1;
              if (!isWritable) {
                numReadonlySignedAccounts += 1;
              }
            } else {
              unsignedKeys.push(pubkey2.toString());
              if (!isWritable) {
                numReadonlyUnsignedAccounts += 1;
              }
            }
          });
          const accountKeys = signedKeys.concat(unsignedKeys);
          const compiledInstructions = instructions.map((instruction) => {
            const {
              data,
              programId
            } = instruction;
            return {
              programIdIndex: accountKeys.indexOf(programId.toString()),
              accounts: instruction.keys.map((meta) => accountKeys.indexOf(meta.pubkey.toString())),
              data: bs58__default.default.encode(data)
            };
          });
          compiledInstructions.forEach((instruction) => {
            assert2(instruction.programIdIndex >= 0);
            instruction.accounts.forEach((keyIndex) => assert2(keyIndex >= 0));
          });
          return new Message({
            header: {
              numRequiredSignatures,
              numReadonlySignedAccounts,
              numReadonlyUnsignedAccounts
            },
            accountKeys,
            recentBlockhash,
            instructions: compiledInstructions
          });
        }
        /**
         * @internal
         */
        _compile() {
          const message = this.compileMessage();
          const signedKeys = message.accountKeys.slice(0, message.header.numRequiredSignatures);
          if (this.signatures.length === signedKeys.length) {
            const valid = this.signatures.every((pair, index2) => {
              return signedKeys[index2].equals(pair.publicKey);
            });
            if (valid) return message;
          }
          this.signatures = signedKeys.map((publicKey4) => ({
            signature: null,
            publicKey: publicKey4
          }));
          return message;
        }
        /**
         * Get a buffer of the Transaction data that need to be covered by signatures
         */
        serializeMessage() {
          return this._compile().serialize();
        }
        /**
         * Get the estimated fee associated with a transaction
         *
         * @param {Connection} connection Connection to RPC Endpoint.
         *
         * @returns {Promise<number | null>} The estimated fee for the transaction
         */
        async getEstimatedFee(connection) {
          return (await connection.getFeeForMessage(this.compileMessage())).value;
        }
        /**
         * Specify the public keys which will be used to sign the Transaction.
         * The first signer will be used as the transaction fee payer account.
         *
         * Signatures can be added with either `partialSign` or `addSignature`
         *
         * @deprecated Deprecated since v0.84.0. Only the fee payer needs to be
         * specified and it can be set in the Transaction constructor or with the
         * `feePayer` property.
         */
        setSigners(...signers) {
          if (signers.length === 0) {
            throw new Error("No signers");
          }
          const seen = /* @__PURE__ */ new Set();
          this.signatures = signers.filter((publicKey4) => {
            const key = publicKey4.toString();
            if (seen.has(key)) {
              return false;
            } else {
              seen.add(key);
              return true;
            }
          }).map((publicKey4) => ({
            signature: null,
            publicKey: publicKey4
          }));
        }
        /**
         * Sign the Transaction with the specified signers. Multiple signatures may
         * be applied to a Transaction. The first signature is considered "primary"
         * and is used identify and confirm transactions.
         *
         * If the Transaction `feePayer` is not set, the first signer will be used
         * as the transaction fee payer account.
         *
         * Transaction fields should not be modified after the first call to `sign`,
         * as doing so may invalidate the signature and cause the Transaction to be
         * rejected.
         *
         * The Transaction must be assigned a valid `recentBlockhash` before invoking this method
         *
         * @param {Array<Signer>} signers Array of signers that will sign the transaction
         */
        sign(...signers) {
          if (signers.length === 0) {
            throw new Error("No signers");
          }
          const seen = /* @__PURE__ */ new Set();
          const uniqueSigners = [];
          for (const signer of signers) {
            const key = signer.publicKey.toString();
            if (seen.has(key)) {
              continue;
            } else {
              seen.add(key);
              uniqueSigners.push(signer);
            }
          }
          this.signatures = uniqueSigners.map((signer) => ({
            signature: null,
            publicKey: signer.publicKey
          }));
          const message = this._compile();
          this._partialSign(message, ...uniqueSigners);
        }
        /**
         * Partially sign a transaction with the specified accounts. All accounts must
         * correspond to either the fee payer or a signer account in the transaction
         * instructions.
         *
         * All the caveats from the `sign` method apply to `partialSign`
         *
         * @param {Array<Signer>} signers Array of signers that will sign the transaction
         */
        partialSign(...signers) {
          if (signers.length === 0) {
            throw new Error("No signers");
          }
          const seen = /* @__PURE__ */ new Set();
          const uniqueSigners = [];
          for (const signer of signers) {
            const key = signer.publicKey.toString();
            if (seen.has(key)) {
              continue;
            } else {
              seen.add(key);
              uniqueSigners.push(signer);
            }
          }
          const message = this._compile();
          this._partialSign(message, ...uniqueSigners);
        }
        /**
         * @internal
         */
        _partialSign(message, ...signers) {
          const signData = message.serialize();
          signers.forEach((signer) => {
            const signature2 = sign(signData, signer.secretKey);
            this._addSignature(signer.publicKey, toBuffer(signature2));
          });
        }
        /**
         * Add an externally created signature to a transaction. The public key
         * must correspond to either the fee payer or a signer account in the transaction
         * instructions.
         *
         * @param {PublicKey} pubkey Public key that will be added to the transaction.
         * @param {Buffer} signature An externally created signature to add to the transaction.
         */
        addSignature(pubkey2, signature2) {
          this._compile();
          this._addSignature(pubkey2, signature2);
        }
        /**
         * @internal
         */
        _addSignature(pubkey2, signature2) {
          assert2(signature2.length === 64);
          const index2 = this.signatures.findIndex((sigpair) => pubkey2.equals(sigpair.publicKey));
          if (index2 < 0) {
            throw new Error(`unknown signer: ${pubkey2.toString()}`);
          }
          this.signatures[index2].signature = buffer.Buffer.from(signature2);
        }
        /**
         * Verify signatures of a Transaction
         * Optional parameter specifies if we're expecting a fully signed Transaction or a partially signed one.
         * If no boolean is provided, we expect a fully signed Transaction by default.
         *
         * @param {boolean} [requireAllSignatures=true] Require a fully signed Transaction
         */
        verifySignatures(requireAllSignatures = true) {
          const signatureErrors = this._getMessageSignednessErrors(this.serializeMessage(), requireAllSignatures);
          return !signatureErrors;
        }
        /**
         * @internal
         */
        _getMessageSignednessErrors(message, requireAllSignatures) {
          const errors = {};
          for (const {
            signature: signature2,
            publicKey: publicKey4
          } of this.signatures) {
            if (signature2 === null) {
              if (requireAllSignatures) {
                (errors.missing || (errors.missing = [])).push(publicKey4);
              }
            } else {
              if (!verify(signature2, message, publicKey4.toBytes())) {
                (errors.invalid || (errors.invalid = [])).push(publicKey4);
              }
            }
          }
          return errors.invalid || errors.missing ? errors : void 0;
        }
        /**
         * Serialize the Transaction in the wire format.
         *
         * @param {Buffer} [config] Config of transaction.
         *
         * @returns {Buffer} Signature of transaction in wire format.
         */
        serialize(config) {
          const {
            requireAllSignatures,
            verifySignatures
          } = Object.assign({
            requireAllSignatures: true,
            verifySignatures: true
          }, config);
          const signData = this.serializeMessage();
          if (verifySignatures) {
            const sigErrors = this._getMessageSignednessErrors(signData, requireAllSignatures);
            if (sigErrors) {
              let errorMessage = "Signature verification failed.";
              if (sigErrors.invalid) {
                errorMessage += `
Invalid signature for public key${sigErrors.invalid.length === 1 ? "" : "(s)"} [\`${sigErrors.invalid.map((p) => p.toBase58()).join("`, `")}\`].`;
              }
              if (sigErrors.missing) {
                errorMessage += `
Missing signature for public key${sigErrors.missing.length === 1 ? "" : "(s)"} [\`${sigErrors.missing.map((p) => p.toBase58()).join("`, `")}\`].`;
              }
              throw new Error(errorMessage);
            }
          }
          return this._serialize(signData);
        }
        /**
         * @internal
         */
        _serialize(signData) {
          const {
            signatures
          } = this;
          const signatureCount = [];
          encodeLength(signatureCount, signatures.length);
          const transactionLength = signatureCount.length + signatures.length * 64 + signData.length;
          const wireTransaction = buffer.Buffer.alloc(transactionLength);
          assert2(signatures.length < 256);
          buffer.Buffer.from(signatureCount).copy(wireTransaction, 0);
          signatures.forEach(({
            signature: signature2
          }, index2) => {
            if (signature2 !== null) {
              assert2(signature2.length === 64, `signature has invalid length`);
              buffer.Buffer.from(signature2).copy(wireTransaction, signatureCount.length + index2 * 64);
            }
          });
          signData.copy(wireTransaction, signatureCount.length + signatures.length * 64);
          assert2(wireTransaction.length <= PACKET_DATA_SIZE, `Transaction too large: ${wireTransaction.length} > ${PACKET_DATA_SIZE}`);
          return wireTransaction;
        }
        /**
         * Deprecated method
         * @internal
         */
        get keys() {
          assert2(this.instructions.length === 1);
          return this.instructions[0].keys.map((keyObj) => keyObj.pubkey);
        }
        /**
         * Deprecated method
         * @internal
         */
        get programId() {
          assert2(this.instructions.length === 1);
          return this.instructions[0].programId;
        }
        /**
         * Deprecated method
         * @internal
         */
        get data() {
          assert2(this.instructions.length === 1);
          return this.instructions[0].data;
        }
        /**
         * Parse a wire transaction into a Transaction object.
         *
         * @param {Buffer | Uint8Array | Array<number>} buffer Signature of wire Transaction
         *
         * @returns {Transaction} Transaction associated with the signature
         */
        static from(buffer$1) {
          let byteArray = [...buffer$1];
          const signatureCount = decodeLength(byteArray);
          let signatures = [];
          for (let i = 0; i < signatureCount; i++) {
            const signature2 = guardedSplice(byteArray, 0, SIGNATURE_LENGTH_IN_BYTES);
            signatures.push(bs58__default.default.encode(buffer.Buffer.from(signature2)));
          }
          return _Transaction.populate(Message.from(byteArray), signatures);
        }
        /**
         * Populate Transaction object from message and signatures
         *
         * @param {Message} message Message of transaction
         * @param {Array<string>} signatures List of signatures to assign to the transaction
         *
         * @returns {Transaction} The populated Transaction
         */
        static populate(message, signatures = []) {
          const transaction = new _Transaction();
          transaction.recentBlockhash = message.recentBlockhash;
          if (message.header.numRequiredSignatures > 0) {
            transaction.feePayer = message.accountKeys[0];
          }
          signatures.forEach((signature2, index2) => {
            const sigPubkeyPair = {
              signature: signature2 == bs58__default.default.encode(DEFAULT_SIGNATURE) ? null : bs58__default.default.decode(signature2),
              publicKey: message.accountKeys[index2]
            };
            transaction.signatures.push(sigPubkeyPair);
          });
          message.instructions.forEach((instruction) => {
            const keys = instruction.accounts.map((account) => {
              const pubkey2 = message.accountKeys[account];
              return {
                pubkey: pubkey2,
                isSigner: transaction.signatures.some((keyObj) => keyObj.publicKey.toString() === pubkey2.toString()) || message.isAccountSigner(account),
                isWritable: message.isAccountWritable(account)
              };
            });
            transaction.instructions.push(new TransactionInstruction2({
              keys,
              programId: message.accountKeys[instruction.programIdIndex],
              data: bs58__default.default.decode(instruction.data)
            }));
          });
          transaction._message = message;
          transaction._json = transaction.toJSON();
          return transaction;
        }
      };
      var TransactionMessage = class _TransactionMessage {
        constructor(args) {
          this.payerKey = void 0;
          this.instructions = void 0;
          this.recentBlockhash = void 0;
          this.payerKey = args.payerKey;
          this.instructions = args.instructions;
          this.recentBlockhash = args.recentBlockhash;
        }
        static decompile(message, args) {
          const {
            header,
            compiledInstructions,
            recentBlockhash
          } = message;
          const {
            numRequiredSignatures,
            numReadonlySignedAccounts,
            numReadonlyUnsignedAccounts
          } = header;
          const numWritableSignedAccounts = numRequiredSignatures - numReadonlySignedAccounts;
          assert2(numWritableSignedAccounts > 0, "Message header is invalid");
          const numWritableUnsignedAccounts = message.staticAccountKeys.length - numRequiredSignatures - numReadonlyUnsignedAccounts;
          assert2(numWritableUnsignedAccounts >= 0, "Message header is invalid");
          const accountKeys = message.getAccountKeys(args);
          const payerKey = accountKeys.get(0);
          if (payerKey === void 0) {
            throw new Error("Failed to decompile message because no account keys were found");
          }
          const instructions = [];
          for (const compiledIx of compiledInstructions) {
            const keys = [];
            for (const keyIndex of compiledIx.accountKeyIndexes) {
              const pubkey2 = accountKeys.get(keyIndex);
              if (pubkey2 === void 0) {
                throw new Error(`Failed to find key for account key index ${keyIndex}`);
              }
              const isSigner = keyIndex < numRequiredSignatures;
              let isWritable;
              if (isSigner) {
                isWritable = keyIndex < numWritableSignedAccounts;
              } else if (keyIndex < accountKeys.staticAccountKeys.length) {
                isWritable = keyIndex - numRequiredSignatures < numWritableUnsignedAccounts;
              } else {
                isWritable = keyIndex - accountKeys.staticAccountKeys.length < // accountKeysFromLookups cannot be undefined because we already found a pubkey for this index above
                accountKeys.accountKeysFromLookups.writable.length;
              }
              keys.push({
                pubkey: pubkey2,
                isSigner: keyIndex < header.numRequiredSignatures,
                isWritable
              });
            }
            const programId = accountKeys.get(compiledIx.programIdIndex);
            if (programId === void 0) {
              throw new Error(`Failed to find program id for program id index ${compiledIx.programIdIndex}`);
            }
            instructions.push(new TransactionInstruction2({
              programId,
              data: toBuffer(compiledIx.data),
              keys
            }));
          }
          return new _TransactionMessage({
            payerKey,
            instructions,
            recentBlockhash
          });
        }
        compileToLegacyMessage() {
          return Message.compile({
            payerKey: this.payerKey,
            recentBlockhash: this.recentBlockhash,
            instructions: this.instructions
          });
        }
        compileToV0Message(addressLookupTableAccounts) {
          return MessageV0.compile({
            payerKey: this.payerKey,
            recentBlockhash: this.recentBlockhash,
            instructions: this.instructions,
            addressLookupTableAccounts
          });
        }
      };
      var VersionedTransaction = class _VersionedTransaction {
        get version() {
          return this.message.version;
        }
        constructor(message, signatures) {
          this.signatures = void 0;
          this.message = void 0;
          if (signatures !== void 0) {
            assert2(signatures.length === message.header.numRequiredSignatures, "Expected signatures length to be equal to the number of required signatures");
            this.signatures = signatures;
          } else {
            const defaultSignatures = [];
            for (let i = 0; i < message.header.numRequiredSignatures; i++) {
              defaultSignatures.push(new Uint8Array(SIGNATURE_LENGTH_IN_BYTES));
            }
            this.signatures = defaultSignatures;
          }
          this.message = message;
        }
        serialize() {
          const serializedMessage = this.message.serialize();
          const encodedSignaturesLength = Array();
          encodeLength(encodedSignaturesLength, this.signatures.length);
          const transactionLayout = BufferLayout__namespace.struct([BufferLayout__namespace.blob(encodedSignaturesLength.length, "encodedSignaturesLength"), BufferLayout__namespace.seq(signature(), this.signatures.length, "signatures"), BufferLayout__namespace.blob(serializedMessage.length, "serializedMessage")]);
          const serializedTransaction = new Uint8Array(2048);
          const serializedTransactionLength = transactionLayout.encode({
            encodedSignaturesLength: new Uint8Array(encodedSignaturesLength),
            signatures: this.signatures,
            serializedMessage
          }, serializedTransaction);
          return serializedTransaction.slice(0, serializedTransactionLength);
        }
        static deserialize(serializedTransaction) {
          let byteArray = [...serializedTransaction];
          const signatures = [];
          const signaturesLength = decodeLength(byteArray);
          for (let i = 0; i < signaturesLength; i++) {
            signatures.push(new Uint8Array(guardedSplice(byteArray, 0, SIGNATURE_LENGTH_IN_BYTES)));
          }
          const message = VersionedMessage.deserialize(new Uint8Array(byteArray));
          return new _VersionedTransaction(message, signatures);
        }
        sign(signers) {
          const messageData = this.message.serialize();
          const signerPubkeys = this.message.staticAccountKeys.slice(0, this.message.header.numRequiredSignatures);
          for (const signer of signers) {
            const signerIndex = signerPubkeys.findIndex((pubkey2) => pubkey2.equals(signer.publicKey));
            assert2(signerIndex >= 0, `Cannot sign with non signer key ${signer.publicKey.toBase58()}`);
            this.signatures[signerIndex] = sign(messageData, signer.secretKey);
          }
        }
        addSignature(publicKey4, signature2) {
          assert2(signature2.byteLength === 64, "Signature must be 64 bytes long");
          const signerPubkeys = this.message.staticAccountKeys.slice(0, this.message.header.numRequiredSignatures);
          const signerIndex = signerPubkeys.findIndex((pubkey2) => pubkey2.equals(publicKey4));
          assert2(signerIndex >= 0, `Can not add signature; \`${publicKey4.toBase58()}\` is not required to sign this transaction`);
          this.signatures[signerIndex] = signature2;
        }
      };
      var NUM_TICKS_PER_SECOND = 160;
      var DEFAULT_TICKS_PER_SLOT = 64;
      var NUM_SLOTS_PER_SECOND = NUM_TICKS_PER_SECOND / DEFAULT_TICKS_PER_SLOT;
      var MS_PER_SLOT = 1e3 / NUM_SLOTS_PER_SECOND;
      var SYSVAR_CLOCK_PUBKEY2 = new PublicKey2("SysvarC1ock11111111111111111111111111111111");
      var SYSVAR_EPOCH_SCHEDULE_PUBKEY = new PublicKey2("SysvarEpochSchedu1e111111111111111111111111");
      var SYSVAR_INSTRUCTIONS_PUBKEY = new PublicKey2("Sysvar1nstructions1111111111111111111111111");
      var SYSVAR_RECENT_BLOCKHASHES_PUBKEY = new PublicKey2("SysvarRecentB1ockHashes11111111111111111111");
      var SYSVAR_RENT_PUBKEY2 = new PublicKey2("SysvarRent111111111111111111111111111111111");
      var SYSVAR_REWARDS_PUBKEY = new PublicKey2("SysvarRewards111111111111111111111111111111");
      var SYSVAR_SLOT_HASHES_PUBKEY = new PublicKey2("SysvarS1otHashes111111111111111111111111111");
      var SYSVAR_SLOT_HISTORY_PUBKEY = new PublicKey2("SysvarS1otHistory11111111111111111111111111");
      var SYSVAR_STAKE_HISTORY_PUBKEY = new PublicKey2("SysvarStakeHistory1111111111111111111111111");
      var SendTransactionError2 = class extends Error {
        constructor({
          action,
          signature: signature2,
          transactionMessage,
          logs
        }) {
          const maybeLogsOutput = logs ? `Logs: 
${JSON.stringify(logs.slice(-10), null, 2)}. ` : "";
          const guideText = "\nCatch the `SendTransactionError` and call `getLogs()` on it for full details.";
          let message;
          switch (action) {
            case "send":
              message = `Transaction ${signature2} resulted in an error. 
${transactionMessage}. ` + maybeLogsOutput + guideText;
              break;
            case "simulate":
              message = `Simulation failed. 
Message: ${transactionMessage}. 
` + maybeLogsOutput + guideText;
              break;
            default: {
              message = `Unknown action '${/* @__PURE__ */ ((a) => a)(action)}'`;
            }
          }
          super(message);
          this.signature = void 0;
          this.transactionMessage = void 0;
          this.transactionLogs = void 0;
          this.signature = signature2;
          this.transactionMessage = transactionMessage;
          this.transactionLogs = logs ? logs : void 0;
        }
        get transactionError() {
          return {
            message: this.transactionMessage,
            logs: Array.isArray(this.transactionLogs) ? this.transactionLogs : void 0
          };
        }
        /* @deprecated Use `await getLogs()` instead */
        get logs() {
          const cachedLogs = this.transactionLogs;
          if (cachedLogs != null && typeof cachedLogs === "object" && "then" in cachedLogs) {
            return void 0;
          }
          return cachedLogs;
        }
        async getLogs(connection) {
          if (!Array.isArray(this.transactionLogs)) {
            this.transactionLogs = new Promise((resolve, reject) => {
              connection.getTransaction(this.signature).then((tx) => {
                if (tx && tx.meta && tx.meta.logMessages) {
                  const logs = tx.meta.logMessages;
                  this.transactionLogs = logs;
                  resolve(logs);
                } else {
                  reject(new Error("Log messages not found"));
                }
              }).catch(reject);
            });
          }
          return await this.transactionLogs;
        }
      };
      var SolanaJSONRPCErrorCode = {
        JSON_RPC_SERVER_ERROR_BLOCK_CLEANED_UP: -32001,
        JSON_RPC_SERVER_ERROR_SEND_TRANSACTION_PREFLIGHT_FAILURE: -32002,
        JSON_RPC_SERVER_ERROR_TRANSACTION_SIGNATURE_VERIFICATION_FAILURE: -32003,
        JSON_RPC_SERVER_ERROR_BLOCK_NOT_AVAILABLE: -32004,
        JSON_RPC_SERVER_ERROR_NODE_UNHEALTHY: -32005,
        JSON_RPC_SERVER_ERROR_TRANSACTION_PRECOMPILE_VERIFICATION_FAILURE: -32006,
        JSON_RPC_SERVER_ERROR_SLOT_SKIPPED: -32007,
        JSON_RPC_SERVER_ERROR_NO_SNAPSHOT: -32008,
        JSON_RPC_SERVER_ERROR_LONG_TERM_STORAGE_SLOT_SKIPPED: -32009,
        JSON_RPC_SERVER_ERROR_KEY_EXCLUDED_FROM_SECONDARY_INDEX: -32010,
        JSON_RPC_SERVER_ERROR_TRANSACTION_HISTORY_NOT_AVAILABLE: -32011,
        JSON_RPC_SCAN_ERROR: -32012,
        JSON_RPC_SERVER_ERROR_TRANSACTION_SIGNATURE_LEN_MISMATCH: -32013,
        JSON_RPC_SERVER_ERROR_BLOCK_STATUS_NOT_AVAILABLE_YET: -32014,
        JSON_RPC_SERVER_ERROR_UNSUPPORTED_TRANSACTION_VERSION: -32015,
        JSON_RPC_SERVER_ERROR_MIN_CONTEXT_SLOT_NOT_REACHED: -32016
      };
      var SolanaJSONRPCError = class extends Error {
        constructor({
          code,
          message,
          data
        }, customMessage) {
          super(customMessage != null ? `${customMessage}: ${message}` : message);
          this.code = void 0;
          this.data = void 0;
          this.code = code;
          this.data = data;
          this.name = "SolanaJSONRPCError";
        }
      };
      async function sendAndConfirmTransaction(connection, transaction, signers, options) {
        const sendOptions = options && {
          skipPreflight: options.skipPreflight,
          preflightCommitment: options.preflightCommitment || options.commitment,
          maxRetries: options.maxRetries,
          minContextSlot: options.minContextSlot
        };
        const signature2 = await connection.sendTransaction(transaction, signers, sendOptions);
        let status;
        if (transaction.recentBlockhash != null && transaction.lastValidBlockHeight != null) {
          status = (await connection.confirmTransaction({
            abortSignal: options?.abortSignal,
            signature: signature2,
            blockhash: transaction.recentBlockhash,
            lastValidBlockHeight: transaction.lastValidBlockHeight
          }, options && options.commitment)).value;
        } else if (transaction.minNonceContextSlot != null && transaction.nonceInfo != null) {
          const {
            nonceInstruction
          } = transaction.nonceInfo;
          const nonceAccountPubkey = nonceInstruction.keys[0].pubkey;
          status = (await connection.confirmTransaction({
            abortSignal: options?.abortSignal,
            minContextSlot: transaction.minNonceContextSlot,
            nonceAccountPubkey,
            nonceValue: transaction.nonceInfo.nonce,
            signature: signature2
          }, options && options.commitment)).value;
        } else {
          if (options?.abortSignal != null) {
            console.warn("sendAndConfirmTransaction(): A transaction with a deprecated confirmation strategy was supplied along with an `abortSignal`. Only transactions having `lastValidBlockHeight` or a combination of `nonceInfo` and `minNonceContextSlot` are abortable.");
          }
          status = (await connection.confirmTransaction(signature2, options && options.commitment)).value;
        }
        if (status.err) {
          if (signature2 != null) {
            throw new SendTransactionError2({
              action: "send",
              signature: signature2,
              transactionMessage: `Status: (${JSON.stringify(status)})`
            });
          }
          throw new Error(`Transaction ${signature2} failed (${JSON.stringify(status)})`);
        }
        return signature2;
      }
      function sleep(ms) {
        return new Promise((resolve) => setTimeout(resolve, ms));
      }
      function encodeData2(type2, fields) {
        const allocLength = type2.layout.span >= 0 ? type2.layout.span : getAlloc(type2, fields);
        const data = buffer.Buffer.alloc(allocLength);
        const layoutFields = Object.assign({
          instruction: type2.index
        }, fields);
        type2.layout.encode(layoutFields, data);
        return data;
      }
      function decodeData$1(type2, buffer2) {
        let data;
        try {
          data = type2.layout.decode(buffer2);
        } catch (err2) {
          throw new Error("invalid instruction; " + err2);
        }
        if (data.instruction !== type2.index) {
          throw new Error(`invalid instruction; instruction index mismatch ${data.instruction} != ${type2.index}`);
        }
        return data;
      }
      var FeeCalculatorLayout = BufferLayout__namespace.nu64("lamportsPerSignature");
      var NonceAccountLayout = BufferLayout__namespace.struct([BufferLayout__namespace.u32("version"), BufferLayout__namespace.u32("state"), publicKey3("authorizedPubkey"), publicKey3("nonce"), BufferLayout__namespace.struct([FeeCalculatorLayout], "feeCalculator")]);
      var NONCE_ACCOUNT_LENGTH2 = NonceAccountLayout.span;
      var NonceAccount = class _NonceAccount {
        /**
         * @internal
         */
        constructor(args) {
          this.authorizedPubkey = void 0;
          this.nonce = void 0;
          this.feeCalculator = void 0;
          this.authorizedPubkey = args.authorizedPubkey;
          this.nonce = args.nonce;
          this.feeCalculator = args.feeCalculator;
        }
        /**
         * Deserialize NonceAccount from the account data.
         *
         * @param buffer account data
         * @return NonceAccount
         */
        static fromAccountData(buffer2) {
          const nonceAccount = NonceAccountLayout.decode(toBuffer(buffer2), 0);
          return new _NonceAccount({
            authorizedPubkey: new PublicKey2(nonceAccount.authorizedPubkey),
            nonce: new PublicKey2(nonceAccount.nonce).toString(),
            feeCalculator: nonceAccount.feeCalculator
          });
        }
      };
      function u643(property) {
        const layout = BufferLayout.blob(8, property);
        const decode2 = layout.decode.bind(layout);
        const encode2 = layout.encode.bind(layout);
        const bigIntLayout = layout;
        const codec = codecsNumbers.getU64Codec();
        bigIntLayout.decode = (buffer2, offset2) => {
          const src = decode2(buffer2, offset2);
          return codec.decode(src);
        };
        bigIntLayout.encode = (bigInt, buffer2, offset2) => {
          const src = codec.encode(bigInt);
          return encode2(src, buffer2, offset2);
        };
        return bigIntLayout;
      }
      var SystemInstruction = class {
        /**
         * @internal
         */
        constructor() {
        }
        /**
         * Decode a system instruction and retrieve the instruction type.
         */
        static decodeInstructionType(instruction) {
          this.checkProgramId(instruction.programId);
          const instructionTypeLayout = BufferLayout__namespace.u32("instruction");
          const typeIndex = instructionTypeLayout.decode(instruction.data);
          let type2;
          for (const [ixType, layout] of Object.entries(SYSTEM_INSTRUCTION_LAYOUTS)) {
            if (layout.index == typeIndex) {
              type2 = ixType;
              break;
            }
          }
          if (!type2) {
            throw new Error("Instruction type incorrect; not a SystemInstruction");
          }
          return type2;
        }
        /**
         * Decode a create account system instruction and retrieve the instruction params.
         */
        static decodeCreateAccount(instruction) {
          this.checkProgramId(instruction.programId);
          this.checkKeyLength(instruction.keys, 2);
          const {
            lamports,
            space,
            programId
          } = decodeData$1(SYSTEM_INSTRUCTION_LAYOUTS.Create, instruction.data);
          return {
            fromPubkey: instruction.keys[0].pubkey,
            newAccountPubkey: instruction.keys[1].pubkey,
            lamports,
            space,
            programId: new PublicKey2(programId)
          };
        }
        /**
         * Decode a transfer system instruction and retrieve the instruction params.
         */
        static decodeTransfer(instruction) {
          this.checkProgramId(instruction.programId);
          this.checkKeyLength(instruction.keys, 2);
          const {
            lamports
          } = decodeData$1(SYSTEM_INSTRUCTION_LAYOUTS.Transfer, instruction.data);
          return {
            fromPubkey: instruction.keys[0].pubkey,
            toPubkey: instruction.keys[1].pubkey,
            lamports
          };
        }
        /**
         * Decode a transfer with seed system instruction and retrieve the instruction params.
         */
        static decodeTransferWithSeed(instruction) {
          this.checkProgramId(instruction.programId);
          this.checkKeyLength(instruction.keys, 3);
          const {
            lamports,
            seed: seed2,
            programId
          } = decodeData$1(SYSTEM_INSTRUCTION_LAYOUTS.TransferWithSeed, instruction.data);
          return {
            fromPubkey: instruction.keys[0].pubkey,
            basePubkey: instruction.keys[1].pubkey,
            toPubkey: instruction.keys[2].pubkey,
            lamports,
            seed: seed2,
            programId: new PublicKey2(programId)
          };
        }
        /**
         * Decode an allocate system instruction and retrieve the instruction params.
         */
        static decodeAllocate(instruction) {
          this.checkProgramId(instruction.programId);
          this.checkKeyLength(instruction.keys, 1);
          const {
            space
          } = decodeData$1(SYSTEM_INSTRUCTION_LAYOUTS.Allocate, instruction.data);
          return {
            accountPubkey: instruction.keys[0].pubkey,
            space
          };
        }
        /**
         * Decode an allocate with seed system instruction and retrieve the instruction params.
         */
        static decodeAllocateWithSeed(instruction) {
          this.checkProgramId(instruction.programId);
          this.checkKeyLength(instruction.keys, 1);
          const {
            base,
            seed: seed2,
            space,
            programId
          } = decodeData$1(SYSTEM_INSTRUCTION_LAYOUTS.AllocateWithSeed, instruction.data);
          return {
            accountPubkey: instruction.keys[0].pubkey,
            basePubkey: new PublicKey2(base),
            seed: seed2,
            space,
            programId: new PublicKey2(programId)
          };
        }
        /**
         * Decode an assign system instruction and retrieve the instruction params.
         */
        static decodeAssign(instruction) {
          this.checkProgramId(instruction.programId);
          this.checkKeyLength(instruction.keys, 1);
          const {
            programId
          } = decodeData$1(SYSTEM_INSTRUCTION_LAYOUTS.Assign, instruction.data);
          return {
            accountPubkey: instruction.keys[0].pubkey,
            programId: new PublicKey2(programId)
          };
        }
        /**
         * Decode an assign with seed system instruction and retrieve the instruction params.
         */
        static decodeAssignWithSeed(instruction) {
          this.checkProgramId(instruction.programId);
          this.checkKeyLength(instruction.keys, 1);
          const {
            base,
            seed: seed2,
            programId
          } = decodeData$1(SYSTEM_INSTRUCTION_LAYOUTS.AssignWithSeed, instruction.data);
          return {
            accountPubkey: instruction.keys[0].pubkey,
            basePubkey: new PublicKey2(base),
            seed: seed2,
            programId: new PublicKey2(programId)
          };
        }
        /**
         * Decode a create account with seed system instruction and retrieve the instruction params.
         */
        static decodeCreateWithSeed(instruction) {
          this.checkProgramId(instruction.programId);
          this.checkKeyLength(instruction.keys, 2);
          const {
            base,
            seed: seed2,
            lamports,
            space,
            programId
          } = decodeData$1(SYSTEM_INSTRUCTION_LAYOUTS.CreateWithSeed, instruction.data);
          return {
            fromPubkey: instruction.keys[0].pubkey,
            newAccountPubkey: instruction.keys[1].pubkey,
            basePubkey: new PublicKey2(base),
            seed: seed2,
            lamports,
            space,
            programId: new PublicKey2(programId)
          };
        }
        /**
         * Decode a nonce initialize system instruction and retrieve the instruction params.
         */
        static decodeNonceInitialize(instruction) {
          this.checkProgramId(instruction.programId);
          this.checkKeyLength(instruction.keys, 3);
          const {
            authorized: authorized2
          } = decodeData$1(SYSTEM_INSTRUCTION_LAYOUTS.InitializeNonceAccount, instruction.data);
          return {
            noncePubkey: instruction.keys[0].pubkey,
            authorizedPubkey: new PublicKey2(authorized2)
          };
        }
        /**
         * Decode a nonce advance system instruction and retrieve the instruction params.
         */
        static decodeNonceAdvance(instruction) {
          this.checkProgramId(instruction.programId);
          this.checkKeyLength(instruction.keys, 3);
          decodeData$1(SYSTEM_INSTRUCTION_LAYOUTS.AdvanceNonceAccount, instruction.data);
          return {
            noncePubkey: instruction.keys[0].pubkey,
            authorizedPubkey: instruction.keys[2].pubkey
          };
        }
        /**
         * Decode a nonce withdraw system instruction and retrieve the instruction params.
         */
        static decodeNonceWithdraw(instruction) {
          this.checkProgramId(instruction.programId);
          this.checkKeyLength(instruction.keys, 5);
          const {
            lamports
          } = decodeData$1(SYSTEM_INSTRUCTION_LAYOUTS.WithdrawNonceAccount, instruction.data);
          return {
            noncePubkey: instruction.keys[0].pubkey,
            toPubkey: instruction.keys[1].pubkey,
            authorizedPubkey: instruction.keys[4].pubkey,
            lamports
          };
        }
        /**
         * Decode a nonce authorize system instruction and retrieve the instruction params.
         */
        static decodeNonceAuthorize(instruction) {
          this.checkProgramId(instruction.programId);
          this.checkKeyLength(instruction.keys, 2);
          const {
            authorized: authorized2
          } = decodeData$1(SYSTEM_INSTRUCTION_LAYOUTS.AuthorizeNonceAccount, instruction.data);
          return {
            noncePubkey: instruction.keys[0].pubkey,
            authorizedPubkey: instruction.keys[1].pubkey,
            newAuthorizedPubkey: new PublicKey2(authorized2)
          };
        }
        /**
         * @internal
         */
        static checkProgramId(programId) {
          if (!programId.equals(SystemProgram2.programId)) {
            throw new Error("invalid instruction; programId is not SystemProgram");
          }
        }
        /**
         * @internal
         */
        static checkKeyLength(keys, expectedLength) {
          if (keys.length < expectedLength) {
            throw new Error(`invalid instruction; found ${keys.length} keys, expected at least ${expectedLength}`);
          }
        }
      };
      var SYSTEM_INSTRUCTION_LAYOUTS = Object.freeze({
        Create: {
          index: 0,
          layout: BufferLayout__namespace.struct([BufferLayout__namespace.u32("instruction"), BufferLayout__namespace.ns64("lamports"), BufferLayout__namespace.ns64("space"), publicKey3("programId")])
        },
        Assign: {
          index: 1,
          layout: BufferLayout__namespace.struct([BufferLayout__namespace.u32("instruction"), publicKey3("programId")])
        },
        Transfer: {
          index: 2,
          layout: BufferLayout__namespace.struct([BufferLayout__namespace.u32("instruction"), u643("lamports")])
        },
        CreateWithSeed: {
          index: 3,
          layout: BufferLayout__namespace.struct([BufferLayout__namespace.u32("instruction"), publicKey3("base"), rustString("seed"), BufferLayout__namespace.ns64("lamports"), BufferLayout__namespace.ns64("space"), publicKey3("programId")])
        },
        AdvanceNonceAccount: {
          index: 4,
          layout: BufferLayout__namespace.struct([BufferLayout__namespace.u32("instruction")])
        },
        WithdrawNonceAccount: {
          index: 5,
          layout: BufferLayout__namespace.struct([BufferLayout__namespace.u32("instruction"), BufferLayout__namespace.ns64("lamports")])
        },
        InitializeNonceAccount: {
          index: 6,
          layout: BufferLayout__namespace.struct([BufferLayout__namespace.u32("instruction"), publicKey3("authorized")])
        },
        AuthorizeNonceAccount: {
          index: 7,
          layout: BufferLayout__namespace.struct([BufferLayout__namespace.u32("instruction"), publicKey3("authorized")])
        },
        Allocate: {
          index: 8,
          layout: BufferLayout__namespace.struct([BufferLayout__namespace.u32("instruction"), BufferLayout__namespace.ns64("space")])
        },
        AllocateWithSeed: {
          index: 9,
          layout: BufferLayout__namespace.struct([BufferLayout__namespace.u32("instruction"), publicKey3("base"), rustString("seed"), BufferLayout__namespace.ns64("space"), publicKey3("programId")])
        },
        AssignWithSeed: {
          index: 10,
          layout: BufferLayout__namespace.struct([BufferLayout__namespace.u32("instruction"), publicKey3("base"), rustString("seed"), publicKey3("programId")])
        },
        TransferWithSeed: {
          index: 11,
          layout: BufferLayout__namespace.struct([BufferLayout__namespace.u32("instruction"), u643("lamports"), rustString("seed"), publicKey3("programId")])
        },
        UpgradeNonceAccount: {
          index: 12,
          layout: BufferLayout__namespace.struct([BufferLayout__namespace.u32("instruction")])
        }
      });
      var SystemProgram2 = class _SystemProgram {
        /**
         * @internal
         */
        constructor() {
        }
        /**
         * Public key that identifies the System program
         */
        /**
         * Generate a transaction instruction that creates a new account
         */
        static createAccount(params) {
          const type2 = SYSTEM_INSTRUCTION_LAYOUTS.Create;
          const data = encodeData2(type2, {
            lamports: params.lamports,
            space: params.space,
            programId: toBuffer(params.programId.toBuffer())
          });
          return new TransactionInstruction2({
            keys: [{
              pubkey: params.fromPubkey,
              isSigner: true,
              isWritable: true
            }, {
              pubkey: params.newAccountPubkey,
              isSigner: true,
              isWritable: true
            }],
            programId: this.programId,
            data
          });
        }
        /**
         * Generate a transaction instruction that transfers lamports from one account to another
         */
        static transfer(params) {
          let data;
          let keys;
          if ("basePubkey" in params) {
            const type2 = SYSTEM_INSTRUCTION_LAYOUTS.TransferWithSeed;
            data = encodeData2(type2, {
              lamports: BigInt(params.lamports),
              seed: params.seed,
              programId: toBuffer(params.programId.toBuffer())
            });
            keys = [{
              pubkey: params.fromPubkey,
              isSigner: false,
              isWritable: true
            }, {
              pubkey: params.basePubkey,
              isSigner: true,
              isWritable: false
            }, {
              pubkey: params.toPubkey,
              isSigner: false,
              isWritable: true
            }];
          } else {
            const type2 = SYSTEM_INSTRUCTION_LAYOUTS.Transfer;
            data = encodeData2(type2, {
              lamports: BigInt(params.lamports)
            });
            keys = [{
              pubkey: params.fromPubkey,
              isSigner: true,
              isWritable: true
            }, {
              pubkey: params.toPubkey,
              isSigner: false,
              isWritable: true
            }];
          }
          return new TransactionInstruction2({
            keys,
            programId: this.programId,
            data
          });
        }
        /**
         * Generate a transaction instruction that assigns an account to a program
         */
        static assign(params) {
          let data;
          let keys;
          if ("basePubkey" in params) {
            const type2 = SYSTEM_INSTRUCTION_LAYOUTS.AssignWithSeed;
            data = encodeData2(type2, {
              base: toBuffer(params.basePubkey.toBuffer()),
              seed: params.seed,
              programId: toBuffer(params.programId.toBuffer())
            });
            keys = [{
              pubkey: params.accountPubkey,
              isSigner: false,
              isWritable: true
            }, {
              pubkey: params.basePubkey,
              isSigner: true,
              isWritable: false
            }];
          } else {
            const type2 = SYSTEM_INSTRUCTION_LAYOUTS.Assign;
            data = encodeData2(type2, {
              programId: toBuffer(params.programId.toBuffer())
            });
            keys = [{
              pubkey: params.accountPubkey,
              isSigner: true,
              isWritable: true
            }];
          }
          return new TransactionInstruction2({
            keys,
            programId: this.programId,
            data
          });
        }
        /**
         * Generate a transaction instruction that creates a new account at
         *   an address generated with `from`, a seed, and programId
         */
        static createAccountWithSeed(params) {
          const type2 = SYSTEM_INSTRUCTION_LAYOUTS.CreateWithSeed;
          const data = encodeData2(type2, {
            base: toBuffer(params.basePubkey.toBuffer()),
            seed: params.seed,
            lamports: params.lamports,
            space: params.space,
            programId: toBuffer(params.programId.toBuffer())
          });
          let keys = [{
            pubkey: params.fromPubkey,
            isSigner: true,
            isWritable: true
          }, {
            pubkey: params.newAccountPubkey,
            isSigner: false,
            isWritable: true
          }];
          if (!params.basePubkey.equals(params.fromPubkey)) {
            keys.push({
              pubkey: params.basePubkey,
              isSigner: true,
              isWritable: false
            });
          }
          return new TransactionInstruction2({
            keys,
            programId: this.programId,
            data
          });
        }
        /**
         * Generate a transaction that creates a new Nonce account
         */
        static createNonceAccount(params) {
          const transaction = new Transaction2();
          if ("basePubkey" in params && "seed" in params) {
            transaction.add(_SystemProgram.createAccountWithSeed({
              fromPubkey: params.fromPubkey,
              newAccountPubkey: params.noncePubkey,
              basePubkey: params.basePubkey,
              seed: params.seed,
              lamports: params.lamports,
              space: NONCE_ACCOUNT_LENGTH2,
              programId: this.programId
            }));
          } else {
            transaction.add(_SystemProgram.createAccount({
              fromPubkey: params.fromPubkey,
              newAccountPubkey: params.noncePubkey,
              lamports: params.lamports,
              space: NONCE_ACCOUNT_LENGTH2,
              programId: this.programId
            }));
          }
          const initParams = {
            noncePubkey: params.noncePubkey,
            authorizedPubkey: params.authorizedPubkey
          };
          transaction.add(this.nonceInitialize(initParams));
          return transaction;
        }
        /**
         * Generate an instruction to initialize a Nonce account
         */
        static nonceInitialize(params) {
          const type2 = SYSTEM_INSTRUCTION_LAYOUTS.InitializeNonceAccount;
          const data = encodeData2(type2, {
            authorized: toBuffer(params.authorizedPubkey.toBuffer())
          });
          const instructionData = {
            keys: [{
              pubkey: params.noncePubkey,
              isSigner: false,
              isWritable: true
            }, {
              pubkey: SYSVAR_RECENT_BLOCKHASHES_PUBKEY,
              isSigner: false,
              isWritable: false
            }, {
              pubkey: SYSVAR_RENT_PUBKEY2,
              isSigner: false,
              isWritable: false
            }],
            programId: this.programId,
            data
          };
          return new TransactionInstruction2(instructionData);
        }
        /**
         * Generate an instruction to advance the nonce in a Nonce account
         */
        static nonceAdvance(params) {
          const type2 = SYSTEM_INSTRUCTION_LAYOUTS.AdvanceNonceAccount;
          const data = encodeData2(type2);
          const instructionData = {
            keys: [{
              pubkey: params.noncePubkey,
              isSigner: false,
              isWritable: true
            }, {
              pubkey: SYSVAR_RECENT_BLOCKHASHES_PUBKEY,
              isSigner: false,
              isWritable: false
            }, {
              pubkey: params.authorizedPubkey,
              isSigner: true,
              isWritable: false
            }],
            programId: this.programId,
            data
          };
          return new TransactionInstruction2(instructionData);
        }
        /**
         * Generate a transaction instruction that withdraws lamports from a Nonce account
         */
        static nonceWithdraw(params) {
          const type2 = SYSTEM_INSTRUCTION_LAYOUTS.WithdrawNonceAccount;
          const data = encodeData2(type2, {
            lamports: params.lamports
          });
          return new TransactionInstruction2({
            keys: [{
              pubkey: params.noncePubkey,
              isSigner: false,
              isWritable: true
            }, {
              pubkey: params.toPubkey,
              isSigner: false,
              isWritable: true
            }, {
              pubkey: SYSVAR_RECENT_BLOCKHASHES_PUBKEY,
              isSigner: false,
              isWritable: false
            }, {
              pubkey: SYSVAR_RENT_PUBKEY2,
              isSigner: false,
              isWritable: false
            }, {
              pubkey: params.authorizedPubkey,
              isSigner: true,
              isWritable: false
            }],
            programId: this.programId,
            data
          });
        }
        /**
         * Generate a transaction instruction that authorizes a new PublicKey as the authority
         * on a Nonce account.
         */
        static nonceAuthorize(params) {
          const type2 = SYSTEM_INSTRUCTION_LAYOUTS.AuthorizeNonceAccount;
          const data = encodeData2(type2, {
            authorized: toBuffer(params.newAuthorizedPubkey.toBuffer())
          });
          return new TransactionInstruction2({
            keys: [{
              pubkey: params.noncePubkey,
              isSigner: false,
              isWritable: true
            }, {
              pubkey: params.authorizedPubkey,
              isSigner: true,
              isWritable: false
            }],
            programId: this.programId,
            data
          });
        }
        /**
         * Generate a transaction instruction that allocates space in an account without funding
         */
        static allocate(params) {
          let data;
          let keys;
          if ("basePubkey" in params) {
            const type2 = SYSTEM_INSTRUCTION_LAYOUTS.AllocateWithSeed;
            data = encodeData2(type2, {
              base: toBuffer(params.basePubkey.toBuffer()),
              seed: params.seed,
              space: params.space,
              programId: toBuffer(params.programId.toBuffer())
            });
            keys = [{
              pubkey: params.accountPubkey,
              isSigner: false,
              isWritable: true
            }, {
              pubkey: params.basePubkey,
              isSigner: true,
              isWritable: false
            }];
          } else {
            const type2 = SYSTEM_INSTRUCTION_LAYOUTS.Allocate;
            data = encodeData2(type2, {
              space: params.space
            });
            keys = [{
              pubkey: params.accountPubkey,
              isSigner: true,
              isWritable: true
            }];
          }
          return new TransactionInstruction2({
            keys,
            programId: this.programId,
            data
          });
        }
      };
      SystemProgram2.programId = new PublicKey2("11111111111111111111111111111111");
      var CHUNK_SIZE = PACKET_DATA_SIZE - 300;
      var Loader = class _Loader {
        /**
         * @internal
         */
        constructor() {
        }
        /**
         * Amount of program data placed in each load Transaction
         */
        /**
         * Minimum number of signatures required to load a program not including
         * retries
         *
         * Can be used to calculate transaction fees
         */
        static getMinNumSignatures(dataLength) {
          return 2 * // Every transaction requires two signatures (payer + program)
          (Math.ceil(dataLength / _Loader.chunkSize) + 1 + // Add one for Create transaction
          1);
        }
        /**
         * Loads a generic program
         *
         * @param connection The connection to use
         * @param payer System account that pays to load the program
         * @param program Account to load the program into
         * @param programId Public key that identifies the loader
         * @param data Program octets
         * @return true if program was loaded successfully, false if program was already loaded
         */
        static async load(connection, payer, program2, programId, data) {
          {
            const balanceNeeded = await connection.getMinimumBalanceForRentExemption(data.length);
            const programInfo = await connection.getAccountInfo(program2.publicKey, "confirmed");
            let transaction = null;
            if (programInfo !== null) {
              if (programInfo.executable) {
                console.error("Program load failed, account is already executable");
                return false;
              }
              if (programInfo.data.length !== data.length) {
                transaction = transaction || new Transaction2();
                transaction.add(SystemProgram2.allocate({
                  accountPubkey: program2.publicKey,
                  space: data.length
                }));
              }
              if (!programInfo.owner.equals(programId)) {
                transaction = transaction || new Transaction2();
                transaction.add(SystemProgram2.assign({
                  accountPubkey: program2.publicKey,
                  programId
                }));
              }
              if (programInfo.lamports < balanceNeeded) {
                transaction = transaction || new Transaction2();
                transaction.add(SystemProgram2.transfer({
                  fromPubkey: payer.publicKey,
                  toPubkey: program2.publicKey,
                  lamports: balanceNeeded - programInfo.lamports
                }));
              }
            } else {
              transaction = new Transaction2().add(SystemProgram2.createAccount({
                fromPubkey: payer.publicKey,
                newAccountPubkey: program2.publicKey,
                lamports: balanceNeeded > 0 ? balanceNeeded : 1,
                space: data.length,
                programId
              }));
            }
            if (transaction !== null) {
              await sendAndConfirmTransaction(connection, transaction, [payer, program2], {
                commitment: "confirmed"
              });
            }
          }
          const dataLayout = BufferLayout__namespace.struct([BufferLayout__namespace.u32("instruction"), BufferLayout__namespace.u32("offset"), BufferLayout__namespace.u32("bytesLength"), BufferLayout__namespace.u32("bytesLengthPadding"), BufferLayout__namespace.seq(BufferLayout__namespace.u8("byte"), BufferLayout__namespace.offset(BufferLayout__namespace.u32(), -8), "bytes")]);
          const chunkSize = _Loader.chunkSize;
          let offset2 = 0;
          let array3 = data;
          let transactions = [];
          while (array3.length > 0) {
            const bytes = array3.slice(0, chunkSize);
            const data2 = buffer.Buffer.alloc(chunkSize + 16);
            dataLayout.encode({
              instruction: 0,
              // Load instruction
              offset: offset2,
              bytes,
              bytesLength: 0,
              bytesLengthPadding: 0
            }, data2);
            const transaction = new Transaction2().add({
              keys: [{
                pubkey: program2.publicKey,
                isSigner: true,
                isWritable: true
              }],
              programId,
              data: data2
            });
            transactions.push(sendAndConfirmTransaction(connection, transaction, [payer, program2], {
              commitment: "confirmed"
            }));
            if (connection._rpcEndpoint.includes("solana.com")) {
              const REQUESTS_PER_SECOND = 4;
              await sleep(1e3 / REQUESTS_PER_SECOND);
            }
            offset2 += chunkSize;
            array3 = array3.slice(chunkSize);
          }
          await Promise.all(transactions);
          {
            const dataLayout2 = BufferLayout__namespace.struct([BufferLayout__namespace.u32("instruction")]);
            const data2 = buffer.Buffer.alloc(dataLayout2.span);
            dataLayout2.encode({
              instruction: 1
              // Finalize instruction
            }, data2);
            const transaction = new Transaction2().add({
              keys: [{
                pubkey: program2.publicKey,
                isSigner: true,
                isWritable: true
              }, {
                pubkey: SYSVAR_RENT_PUBKEY2,
                isSigner: false,
                isWritable: false
              }],
              programId,
              data: data2
            });
            const deployCommitment = "processed";
            const finalizeSignature = await connection.sendTransaction(transaction, [payer, program2], {
              preflightCommitment: deployCommitment
            });
            const {
              context,
              value
            } = await connection.confirmTransaction({
              signature: finalizeSignature,
              lastValidBlockHeight: transaction.lastValidBlockHeight,
              blockhash: transaction.recentBlockhash
            }, deployCommitment);
            if (value.err) {
              throw new Error(`Transaction ${finalizeSignature} failed (${JSON.stringify(value)})`);
            }
            while (true) {
              try {
                const currentSlot = await connection.getSlot({
                  commitment: deployCommitment
                });
                if (currentSlot > context.slot) {
                  break;
                }
              } catch {
              }
              await new Promise((resolve) => setTimeout(resolve, Math.round(MS_PER_SLOT / 2)));
            }
          }
          return true;
        }
      };
      Loader.chunkSize = CHUNK_SIZE;
      var BPF_LOADER_PROGRAM_ID = new PublicKey2("BPFLoader2111111111111111111111111111111111");
      var BpfLoader = class {
        /**
         * Minimum number of signatures required to load a program not including
         * retries
         *
         * Can be used to calculate transaction fees
         */
        static getMinNumSignatures(dataLength) {
          return Loader.getMinNumSignatures(dataLength);
        }
        /**
         * Load a SBF program
         *
         * @param connection The connection to use
         * @param payer Account that will pay program loading fees
         * @param program Account to load the program into
         * @param elf The entire ELF containing the SBF program
         * @param loaderProgramId The program id of the BPF loader to use
         * @return true if program was loaded successfully, false if program was already loaded
         */
        static load(connection, payer, program2, elf, loaderProgramId) {
          return Loader.load(connection, payer, program2, loaderProgramId, elf);
        }
      };
      function getDefaultExportFromCjs2(x) {
        return x && x.__esModule && Object.prototype.hasOwnProperty.call(x, "default") ? x["default"] : x;
      }
      var fastStableStringify$1;
      var hasRequiredFastStableStringify;
      function requireFastStableStringify() {
        if (hasRequiredFastStableStringify) return fastStableStringify$1;
        hasRequiredFastStableStringify = 1;
        var objToString = Object.prototype.toString;
        var objKeys = Object.keys || function(obj) {
          var keys = [];
          for (var name in obj) {
            keys.push(name);
          }
          return keys;
        };
        function stringify2(val, isArrayProp) {
          var i, max, str2, keys, key, propVal, toStr;
          if (val === true) {
            return "true";
          }
          if (val === false) {
            return "false";
          }
          switch (typeof val) {
            case "object":
              if (val === null) {
                return null;
              } else if (val.toJSON && typeof val.toJSON === "function") {
                return stringify2(val.toJSON(), isArrayProp);
              } else {
                toStr = objToString.call(val);
                if (toStr === "[object Array]") {
                  str2 = "[";
                  max = val.length - 1;
                  for (i = 0; i < max; i++) {
                    str2 += stringify2(val[i], true) + ",";
                  }
                  if (max > -1) {
                    str2 += stringify2(val[i], true);
                  }
                  return str2 + "]";
                } else if (toStr === "[object Object]") {
                  keys = objKeys(val).sort();
                  max = keys.length;
                  str2 = "";
                  i = 0;
                  while (i < max) {
                    key = keys[i];
                    propVal = stringify2(val[key], false);
                    if (propVal !== void 0) {
                      if (str2) {
                        str2 += ",";
                      }
                      str2 += JSON.stringify(key) + ":" + propVal;
                    }
                    i++;
                  }
                  return "{" + str2 + "}";
                } else {
                  return JSON.stringify(val);
                }
              }
            case "function":
            case "undefined":
              return isArrayProp ? null : void 0;
            case "string":
              return JSON.stringify(val);
            default:
              return isFinite(val) ? val : null;
          }
        }
        fastStableStringify$1 = function(val) {
          var returnVal = stringify2(val, false);
          if (returnVal !== void 0) {
            return "" + returnVal;
          }
        };
        return fastStableStringify$1;
      }
      var fastStableStringifyExports = /* @__PURE__ */ requireFastStableStringify();
      var fastStableStringify = /* @__PURE__ */ getDefaultExportFromCjs2(fastStableStringifyExports);
      var MINIMUM_SLOT_PER_EPOCH = 32;
      function trailingZeros(n) {
        let trailingZeros2 = 0;
        while (n > 1) {
          n /= 2;
          trailingZeros2++;
        }
        return trailingZeros2;
      }
      function nextPowerOfTwo(n) {
        if (n === 0) return 1;
        n--;
        n |= n >> 1;
        n |= n >> 2;
        n |= n >> 4;
        n |= n >> 8;
        n |= n >> 16;
        n |= n >> 32;
        return n + 1;
      }
      var EpochSchedule = class {
        constructor(slotsPerEpoch, leaderScheduleSlotOffset, warmup, firstNormalEpoch, firstNormalSlot) {
          this.slotsPerEpoch = void 0;
          this.leaderScheduleSlotOffset = void 0;
          this.warmup = void 0;
          this.firstNormalEpoch = void 0;
          this.firstNormalSlot = void 0;
          this.slotsPerEpoch = slotsPerEpoch;
          this.leaderScheduleSlotOffset = leaderScheduleSlotOffset;
          this.warmup = warmup;
          this.firstNormalEpoch = firstNormalEpoch;
          this.firstNormalSlot = firstNormalSlot;
        }
        getEpoch(slot) {
          return this.getEpochAndSlotIndex(slot)[0];
        }
        getEpochAndSlotIndex(slot) {
          if (slot < this.firstNormalSlot) {
            const epoch = trailingZeros(nextPowerOfTwo(slot + MINIMUM_SLOT_PER_EPOCH + 1)) - trailingZeros(MINIMUM_SLOT_PER_EPOCH) - 1;
            const epochLen = this.getSlotsInEpoch(epoch);
            const slotIndex = slot - (epochLen - MINIMUM_SLOT_PER_EPOCH);
            return [epoch, slotIndex];
          } else {
            const normalSlotIndex = slot - this.firstNormalSlot;
            const normalEpochIndex = Math.floor(normalSlotIndex / this.slotsPerEpoch);
            const epoch = this.firstNormalEpoch + normalEpochIndex;
            const slotIndex = normalSlotIndex % this.slotsPerEpoch;
            return [epoch, slotIndex];
          }
        }
        getFirstSlotInEpoch(epoch) {
          if (epoch <= this.firstNormalEpoch) {
            return (Math.pow(2, epoch) - 1) * MINIMUM_SLOT_PER_EPOCH;
          } else {
            return (epoch - this.firstNormalEpoch) * this.slotsPerEpoch + this.firstNormalSlot;
          }
        }
        getLastSlotInEpoch(epoch) {
          return this.getFirstSlotInEpoch(epoch) + this.getSlotsInEpoch(epoch) - 1;
        }
        getSlotsInEpoch(epoch) {
          if (epoch < this.firstNormalEpoch) {
            return Math.pow(2, epoch + trailingZeros(MINIMUM_SLOT_PER_EPOCH));
          } else {
            return this.slotsPerEpoch;
          }
        }
      };
      var fetchImpl = globalThis.fetch;
      var RpcWebSocketClient = class extends rpcWebsockets.CommonClient {
        constructor(address, options, generate_request_id) {
          const webSocketFactory = (url) => {
            const rpc2 = rpcWebsockets.WebSocket(url, {
              autoconnect: true,
              max_reconnects: 5,
              reconnect: true,
              reconnect_interval: 1e3,
              ...options
            });
            if ("socket" in rpc2) {
              this.underlyingSocket = rpc2.socket;
            } else {
              this.underlyingSocket = rpc2;
            }
            return rpc2;
          };
          super(webSocketFactory, address, options, generate_request_id);
          this.underlyingSocket = void 0;
        }
        call(...args) {
          const readyState = this.underlyingSocket?.readyState;
          if (readyState === 1) {
            return super.call(...args);
          }
          return Promise.reject(new Error("Tried to call a JSON-RPC method `" + args[0] + "` but the socket was not `CONNECTING` or `OPEN` (`readyState` was " + readyState + ")"));
        }
        notify(...args) {
          const readyState = this.underlyingSocket?.readyState;
          if (readyState === 1) {
            return super.notify(...args);
          }
          return Promise.reject(new Error("Tried to send a JSON-RPC notification `" + args[0] + "` but the socket was not `CONNECTING` or `OPEN` (`readyState` was " + readyState + ")"));
        }
      };
      function decodeData(type2, data) {
        let decoded;
        try {
          decoded = type2.layout.decode(data);
        } catch (err2) {
          throw new Error("invalid instruction; " + err2);
        }
        if (decoded.typeIndex !== type2.index) {
          throw new Error(`invalid account data; account type mismatch ${decoded.typeIndex} != ${type2.index}`);
        }
        return decoded;
      }
      var LOOKUP_TABLE_META_SIZE = 56;
      var AddressLookupTableAccount = class {
        constructor(args) {
          this.key = void 0;
          this.state = void 0;
          this.key = args.key;
          this.state = args.state;
        }
        isActive() {
          const U64_MAX = BigInt("0xffffffffffffffff");
          return this.state.deactivationSlot === U64_MAX;
        }
        static deserialize(accountData) {
          const meta = decodeData(LookupTableMetaLayout, accountData);
          const serializedAddressesLen = accountData.length - LOOKUP_TABLE_META_SIZE;
          assert2(serializedAddressesLen >= 0, "lookup table is invalid");
          assert2(serializedAddressesLen % 32 === 0, "lookup table is invalid");
          const numSerializedAddresses = serializedAddressesLen / 32;
          const {
            addresses
          } = BufferLayout__namespace.struct([BufferLayout__namespace.seq(publicKey3(), numSerializedAddresses, "addresses")]).decode(accountData.slice(LOOKUP_TABLE_META_SIZE));
          return {
            deactivationSlot: meta.deactivationSlot,
            lastExtendedSlot: meta.lastExtendedSlot,
            lastExtendedSlotStartIndex: meta.lastExtendedStartIndex,
            authority: meta.authority.length !== 0 ? new PublicKey2(meta.authority[0]) : void 0,
            addresses: addresses.map((address) => new PublicKey2(address))
          };
        }
      };
      var LookupTableMetaLayout = {
        index: 1,
        layout: BufferLayout__namespace.struct([
          BufferLayout__namespace.u32("typeIndex"),
          u643("deactivationSlot"),
          BufferLayout__namespace.nu64("lastExtendedSlot"),
          BufferLayout__namespace.u8("lastExtendedStartIndex"),
          BufferLayout__namespace.u8(),
          // option
          BufferLayout__namespace.seq(publicKey3(), BufferLayout__namespace.offset(BufferLayout__namespace.u8(), -1), "authority")
        ])
      };
      var URL_RE = /^[^:]+:\/\/([^:[]+|\[[^\]]+\])(:\d+)?(.*)/i;
      function makeWebsocketUrl(endpoint2) {
        const matches = endpoint2.match(URL_RE);
        if (matches == null) {
          throw TypeError(`Failed to validate endpoint URL \`${endpoint2}\``);
        }
        const [
          _,
          // eslint-disable-line @typescript-eslint/no-unused-vars
          hostish,
          portWithColon,
          rest
        ] = matches;
        const protocol = endpoint2.startsWith("https:") ? "wss:" : "ws:";
        const startPort = portWithColon == null ? null : parseInt(portWithColon.slice(1), 10);
        const websocketPort = (
          // Only shift the port by +1 as a convention for ws(s) only if given endpoint
          // is explicitly specifying the endpoint port (HTTP-based RPC), assuming
          // we're directly trying to connect to agave-validator's ws listening port.
          // When the endpoint omits the port, we're connecting to the protocol
          // default ports: http(80) or https(443) and it's assumed we're behind a reverse
          // proxy which manages WebSocket upgrade and backend port redirection.
          startPort == null ? "" : `:${startPort + 1}`
        );
        return `${protocol}//${hostish}${websocketPort}${rest}`;
      }
      var PublicKeyFromString = superstruct.coerce(superstruct.instance(PublicKey2), superstruct.string(), (value) => new PublicKey2(value));
      var RawAccountDataResult = superstruct.tuple([superstruct.string(), superstruct.literal("base64")]);
      var BufferFromRawAccountData = superstruct.coerce(superstruct.instance(buffer.Buffer), RawAccountDataResult, (value) => buffer.Buffer.from(value[0], "base64"));
      var BLOCKHASH_CACHE_TIMEOUT_MS = 30 * 1e3;
      function assertEndpointUrl(putativeUrl) {
        if (/^https?:/.test(putativeUrl) === false) {
          throw new TypeError("Endpoint URL must start with `http:` or `https:`.");
        }
        return putativeUrl;
      }
      function extractCommitmentFromConfig(commitmentOrConfig) {
        let commitment;
        let config;
        if (typeof commitmentOrConfig === "string") {
          commitment = commitmentOrConfig;
        } else if (commitmentOrConfig) {
          const {
            commitment: specifiedCommitment,
            ...specifiedConfig
          } = commitmentOrConfig;
          commitment = specifiedCommitment;
          config = specifiedConfig;
        }
        return {
          commitment,
          config
        };
      }
      function applyDefaultMemcmpEncodingToFilters(filters) {
        return filters.map((filter) => "memcmp" in filter ? {
          ...filter,
          memcmp: {
            ...filter.memcmp,
            encoding: filter.memcmp.encoding ?? "base58"
          }
        } : filter);
      }
      function createRpcResult2(result) {
        return superstruct.union([superstruct.type({
          jsonrpc: superstruct.literal("2.0"),
          id: superstruct.string(),
          result
        }), superstruct.type({
          jsonrpc: superstruct.literal("2.0"),
          id: superstruct.string(),
          error: superstruct.type({
            code: superstruct.unknown(),
            message: superstruct.string(),
            data: superstruct.optional(superstruct.any())
          })
        })]);
      }
      var UnknownRpcResult2 = createRpcResult2(superstruct.unknown());
      function jsonRpcResult2(schema) {
        return superstruct.coerce(createRpcResult2(schema), UnknownRpcResult2, (value) => {
          if ("error" in value) {
            return value;
          } else {
            return {
              ...value,
              result: superstruct.create(value.result, schema)
            };
          }
        });
      }
      function jsonRpcResultAndContext2(value) {
        return jsonRpcResult2(superstruct.type({
          context: superstruct.type({
            slot: superstruct.number()
          }),
          value
        }));
      }
      function notificationResultAndContext(value) {
        return superstruct.type({
          context: superstruct.type({
            slot: superstruct.number()
          }),
          value
        });
      }
      function versionedMessageFromResponse(version2, response) {
        if (version2 === 0) {
          return new MessageV0({
            header: response.header,
            staticAccountKeys: response.accountKeys.map((accountKey) => new PublicKey2(accountKey)),
            recentBlockhash: response.recentBlockhash,
            compiledInstructions: response.instructions.map((ix) => ({
              programIdIndex: ix.programIdIndex,
              accountKeyIndexes: ix.accounts,
              data: bs58__default.default.decode(ix.data)
            })),
            addressTableLookups: response.addressTableLookups
          });
        } else {
          return new Message(response);
        }
      }
      var GetInflationGovernorResult = superstruct.type({
        foundation: superstruct.number(),
        foundationTerm: superstruct.number(),
        initial: superstruct.number(),
        taper: superstruct.number(),
        terminal: superstruct.number()
      });
      var GetInflationRewardResult = jsonRpcResult2(superstruct.array(superstruct.nullable(superstruct.type({
        epoch: superstruct.number(),
        effectiveSlot: superstruct.number(),
        amount: superstruct.number(),
        postBalance: superstruct.number(),
        commission: superstruct.optional(superstruct.nullable(superstruct.number()))
      }))));
      var GetRecentPrioritizationFeesResult = superstruct.array(superstruct.type({
        slot: superstruct.number(),
        prioritizationFee: superstruct.number()
      }));
      var GetInflationRateResult = superstruct.type({
        total: superstruct.number(),
        validator: superstruct.number(),
        foundation: superstruct.number(),
        epoch: superstruct.number()
      });
      var GetEpochInfoResult = superstruct.type({
        epoch: superstruct.number(),
        slotIndex: superstruct.number(),
        slotsInEpoch: superstruct.number(),
        absoluteSlot: superstruct.number(),
        blockHeight: superstruct.optional(superstruct.number()),
        transactionCount: superstruct.optional(superstruct.number())
      });
      var GetEpochScheduleResult = superstruct.type({
        slotsPerEpoch: superstruct.number(),
        leaderScheduleSlotOffset: superstruct.number(),
        warmup: superstruct.boolean(),
        firstNormalEpoch: superstruct.number(),
        firstNormalSlot: superstruct.number()
      });
      var GetLeaderScheduleResult = superstruct.record(superstruct.string(), superstruct.array(superstruct.number()));
      var TransactionErrorResult = superstruct.nullable(superstruct.union([superstruct.type({}), superstruct.string()]));
      var SignatureStatusResult = superstruct.type({
        err: TransactionErrorResult
      });
      var SignatureReceivedResult = superstruct.literal("receivedSignature");
      var VersionResult = superstruct.type({
        "solana-core": superstruct.string(),
        "feature-set": superstruct.optional(superstruct.number())
      });
      var ParsedInstructionStruct = superstruct.type({
        program: superstruct.string(),
        programId: PublicKeyFromString,
        parsed: superstruct.unknown()
      });
      var PartiallyDecodedInstructionStruct = superstruct.type({
        programId: PublicKeyFromString,
        accounts: superstruct.array(PublicKeyFromString),
        data: superstruct.string()
      });
      var SimulatedTransactionResponseStruct2 = jsonRpcResultAndContext2(superstruct.type({
        err: superstruct.nullable(superstruct.union([superstruct.type({}), superstruct.string()])),
        logs: superstruct.nullable(superstruct.array(superstruct.string())),
        accounts: superstruct.optional(superstruct.nullable(superstruct.array(superstruct.nullable(superstruct.type({
          executable: superstruct.boolean(),
          owner: superstruct.string(),
          lamports: superstruct.number(),
          data: superstruct.array(superstruct.string()),
          rentEpoch: superstruct.optional(superstruct.number())
        }))))),
        unitsConsumed: superstruct.optional(superstruct.number()),
        returnData: superstruct.optional(superstruct.nullable(superstruct.type({
          programId: superstruct.string(),
          data: superstruct.tuple([superstruct.string(), superstruct.literal("base64")])
        }))),
        innerInstructions: superstruct.optional(superstruct.nullable(superstruct.array(superstruct.type({
          index: superstruct.number(),
          instructions: superstruct.array(superstruct.union([ParsedInstructionStruct, PartiallyDecodedInstructionStruct]))
        }))))
      }));
      var BlockProductionResponseStruct = jsonRpcResultAndContext2(superstruct.type({
        byIdentity: superstruct.record(superstruct.string(), superstruct.array(superstruct.number())),
        range: superstruct.type({
          firstSlot: superstruct.number(),
          lastSlot: superstruct.number()
        })
      }));
      function createRpcClient(url, httpHeaders, customFetch, fetchMiddleware, disableRetryOnRateLimit, httpAgent) {
        const fetch2 = customFetch ? customFetch : fetchImpl;
        let agent;
        {
          if (httpAgent != null) {
            console.warn("You have supplied an `httpAgent` when creating a `Connection` in a browser environment.It has been ignored; `httpAgent` is only used in Node environments.");
          }
        }
        let fetchWithMiddleware;
        if (fetchMiddleware) {
          fetchWithMiddleware = async (info, init) => {
            const modifiedFetchArgs = await new Promise((resolve, reject) => {
              try {
                fetchMiddleware(info, init, (modifiedInfo, modifiedInit) => resolve([modifiedInfo, modifiedInit]));
              } catch (error) {
                reject(error);
              }
            });
            return await fetch2(...modifiedFetchArgs);
          };
        }
        const clientBrowser = new RpcClient__default.default(async (request, callback) => {
          const options = {
            method: "POST",
            body: request,
            agent,
            headers: Object.assign({
              "Content-Type": "application/json"
            }, httpHeaders || {}, COMMON_HTTP_HEADERS)
          };
          try {
            let too_many_requests_retries = 5;
            let res;
            let waitTime = 500;
            for (; ; ) {
              if (fetchWithMiddleware) {
                res = await fetchWithMiddleware(url, options);
              } else {
                res = await fetch2(url, options);
              }
              if (res.status !== 429) {
                break;
              }
              if (disableRetryOnRateLimit === true) {
                break;
              }
              too_many_requests_retries -= 1;
              if (too_many_requests_retries === 0) {
                break;
              }
              console.error(`Server responded with ${res.status} ${res.statusText}.  Retrying after ${waitTime}ms delay...`);
              await sleep(waitTime);
              waitTime *= 2;
            }
            const text = await res.text();
            if (res.ok) {
              callback(null, text);
            } else {
              callback(new Error(`${res.status} ${res.statusText}: ${text}`));
            }
          } catch (err2) {
            if (err2 instanceof Error) callback(err2);
          }
        }, {});
        return clientBrowser;
      }
      function createRpcRequest(client) {
        return (method, args) => {
          return new Promise((resolve, reject) => {
            client.request(method, args, (err2, response) => {
              if (err2) {
                reject(err2);
                return;
              }
              resolve(response);
            });
          });
        };
      }
      function createRpcBatchRequest(client) {
        return (requests) => {
          return new Promise((resolve, reject) => {
            if (requests.length === 0) resolve([]);
            const batch = requests.map((params) => {
              return client.request(params.methodName, params.args);
            });
            client.request(batch, (err2, response) => {
              if (err2) {
                reject(err2);
                return;
              }
              resolve(response);
            });
          });
        };
      }
      var GetInflationGovernorRpcResult = jsonRpcResult2(GetInflationGovernorResult);
      var GetInflationRateRpcResult = jsonRpcResult2(GetInflationRateResult);
      var GetRecentPrioritizationFeesRpcResult = jsonRpcResult2(GetRecentPrioritizationFeesResult);
      var GetEpochInfoRpcResult = jsonRpcResult2(GetEpochInfoResult);
      var GetEpochScheduleRpcResult = jsonRpcResult2(GetEpochScheduleResult);
      var GetLeaderScheduleRpcResult = jsonRpcResult2(GetLeaderScheduleResult);
      var SlotRpcResult = jsonRpcResult2(superstruct.number());
      var GetSupplyRpcResult = jsonRpcResultAndContext2(superstruct.type({
        total: superstruct.number(),
        circulating: superstruct.number(),
        nonCirculating: superstruct.number(),
        nonCirculatingAccounts: superstruct.array(PublicKeyFromString)
      }));
      var TokenAmountResult = superstruct.type({
        amount: superstruct.string(),
        uiAmount: superstruct.nullable(superstruct.number()),
        decimals: superstruct.number(),
        uiAmountString: superstruct.optional(superstruct.string())
      });
      var GetTokenLargestAccountsResult = jsonRpcResultAndContext2(superstruct.array(superstruct.type({
        address: PublicKeyFromString,
        amount: superstruct.string(),
        uiAmount: superstruct.nullable(superstruct.number()),
        decimals: superstruct.number(),
        uiAmountString: superstruct.optional(superstruct.string())
      })));
      var GetTokenAccountsByOwner = jsonRpcResultAndContext2(superstruct.array(superstruct.type({
        pubkey: PublicKeyFromString,
        account: superstruct.type({
          executable: superstruct.boolean(),
          owner: PublicKeyFromString,
          lamports: superstruct.number(),
          data: BufferFromRawAccountData,
          rentEpoch: superstruct.number()
        })
      })));
      var ParsedAccountDataResult = superstruct.type({
        program: superstruct.string(),
        parsed: superstruct.unknown(),
        space: superstruct.number()
      });
      var GetParsedTokenAccountsByOwner = jsonRpcResultAndContext2(superstruct.array(superstruct.type({
        pubkey: PublicKeyFromString,
        account: superstruct.type({
          executable: superstruct.boolean(),
          owner: PublicKeyFromString,
          lamports: superstruct.number(),
          data: ParsedAccountDataResult,
          rentEpoch: superstruct.number()
        })
      })));
      var GetLargestAccountsRpcResult = jsonRpcResultAndContext2(superstruct.array(superstruct.type({
        lamports: superstruct.number(),
        address: PublicKeyFromString
      })));
      var AccountInfoResult = superstruct.type({
        executable: superstruct.boolean(),
        owner: PublicKeyFromString,
        lamports: superstruct.number(),
        data: BufferFromRawAccountData,
        rentEpoch: superstruct.number()
      });
      var KeyedAccountInfoResult = superstruct.type({
        pubkey: PublicKeyFromString,
        account: AccountInfoResult
      });
      var ParsedOrRawAccountData = superstruct.coerce(superstruct.union([superstruct.instance(buffer.Buffer), ParsedAccountDataResult]), superstruct.union([RawAccountDataResult, ParsedAccountDataResult]), (value) => {
        if (Array.isArray(value)) {
          return superstruct.create(value, BufferFromRawAccountData);
        } else {
          return value;
        }
      });
      var ParsedAccountInfoResult = superstruct.type({
        executable: superstruct.boolean(),
        owner: PublicKeyFromString,
        lamports: superstruct.number(),
        data: ParsedOrRawAccountData,
        rentEpoch: superstruct.number()
      });
      var KeyedParsedAccountInfoResult = superstruct.type({
        pubkey: PublicKeyFromString,
        account: ParsedAccountInfoResult
      });
      var StakeActivationResult = superstruct.type({
        state: superstruct.union([superstruct.literal("active"), superstruct.literal("inactive"), superstruct.literal("activating"), superstruct.literal("deactivating")]),
        active: superstruct.number(),
        inactive: superstruct.number()
      });
      var GetConfirmedSignaturesForAddress2RpcResult = jsonRpcResult2(superstruct.array(superstruct.type({
        signature: superstruct.string(),
        slot: superstruct.number(),
        err: TransactionErrorResult,
        memo: superstruct.nullable(superstruct.string()),
        blockTime: superstruct.optional(superstruct.nullable(superstruct.number()))
      })));
      var GetSignaturesForAddressRpcResult = jsonRpcResult2(superstruct.array(superstruct.type({
        signature: superstruct.string(),
        slot: superstruct.number(),
        err: TransactionErrorResult,
        memo: superstruct.nullable(superstruct.string()),
        blockTime: superstruct.optional(superstruct.nullable(superstruct.number()))
      })));
      var AccountNotificationResult = superstruct.type({
        subscription: superstruct.number(),
        result: notificationResultAndContext(AccountInfoResult)
      });
      var ProgramAccountInfoResult = superstruct.type({
        pubkey: PublicKeyFromString,
        account: AccountInfoResult
      });
      var ProgramAccountNotificationResult = superstruct.type({
        subscription: superstruct.number(),
        result: notificationResultAndContext(ProgramAccountInfoResult)
      });
      var SlotInfoResult = superstruct.type({
        parent: superstruct.number(),
        slot: superstruct.number(),
        root: superstruct.number()
      });
      var SlotNotificationResult = superstruct.type({
        subscription: superstruct.number(),
        result: SlotInfoResult
      });
      var SlotUpdateResult = superstruct.union([superstruct.type({
        type: superstruct.union([superstruct.literal("firstShredReceived"), superstruct.literal("completed"), superstruct.literal("optimisticConfirmation"), superstruct.literal("root")]),
        slot: superstruct.number(),
        timestamp: superstruct.number()
      }), superstruct.type({
        type: superstruct.literal("createdBank"),
        parent: superstruct.number(),
        slot: superstruct.number(),
        timestamp: superstruct.number()
      }), superstruct.type({
        type: superstruct.literal("frozen"),
        slot: superstruct.number(),
        timestamp: superstruct.number(),
        stats: superstruct.type({
          numTransactionEntries: superstruct.number(),
          numSuccessfulTransactions: superstruct.number(),
          numFailedTransactions: superstruct.number(),
          maxTransactionsPerEntry: superstruct.number()
        })
      }), superstruct.type({
        type: superstruct.literal("dead"),
        slot: superstruct.number(),
        timestamp: superstruct.number(),
        err: superstruct.string()
      })]);
      var SlotUpdateNotificationResult = superstruct.type({
        subscription: superstruct.number(),
        result: SlotUpdateResult
      });
      var SignatureNotificationResult = superstruct.type({
        subscription: superstruct.number(),
        result: notificationResultAndContext(superstruct.union([SignatureStatusResult, SignatureReceivedResult]))
      });
      var RootNotificationResult = superstruct.type({
        subscription: superstruct.number(),
        result: superstruct.number()
      });
      var ContactInfoResult = superstruct.type({
        pubkey: superstruct.string(),
        gossip: superstruct.nullable(superstruct.string()),
        tpu: superstruct.nullable(superstruct.string()),
        rpc: superstruct.nullable(superstruct.string()),
        version: superstruct.nullable(superstruct.string())
      });
      var VoteAccountInfoResult = superstruct.type({
        votePubkey: superstruct.string(),
        nodePubkey: superstruct.string(),
        activatedStake: superstruct.number(),
        epochVoteAccount: superstruct.boolean(),
        epochCredits: superstruct.array(superstruct.tuple([superstruct.number(), superstruct.number(), superstruct.number()])),
        commission: superstruct.number(),
        lastVote: superstruct.number(),
        rootSlot: superstruct.nullable(superstruct.number())
      });
      var GetVoteAccounts = jsonRpcResult2(superstruct.type({
        current: superstruct.array(VoteAccountInfoResult),
        delinquent: superstruct.array(VoteAccountInfoResult)
      }));
      var ConfirmationStatus = superstruct.union([superstruct.literal("processed"), superstruct.literal("confirmed"), superstruct.literal("finalized")]);
      var SignatureStatusResponse = superstruct.type({
        slot: superstruct.number(),
        confirmations: superstruct.nullable(superstruct.number()),
        err: TransactionErrorResult,
        confirmationStatus: superstruct.optional(ConfirmationStatus)
      });
      var GetSignatureStatusesRpcResult = jsonRpcResultAndContext2(superstruct.array(superstruct.nullable(SignatureStatusResponse)));
      var GetMinimumBalanceForRentExemptionRpcResult = jsonRpcResult2(superstruct.number());
      var AddressTableLookupStruct = superstruct.type({
        accountKey: PublicKeyFromString,
        writableIndexes: superstruct.array(superstruct.number()),
        readonlyIndexes: superstruct.array(superstruct.number())
      });
      var ConfirmedTransactionResult = superstruct.type({
        signatures: superstruct.array(superstruct.string()),
        message: superstruct.type({
          accountKeys: superstruct.array(superstruct.string()),
          header: superstruct.type({
            numRequiredSignatures: superstruct.number(),
            numReadonlySignedAccounts: superstruct.number(),
            numReadonlyUnsignedAccounts: superstruct.number()
          }),
          instructions: superstruct.array(superstruct.type({
            accounts: superstruct.array(superstruct.number()),
            data: superstruct.string(),
            programIdIndex: superstruct.number()
          })),
          recentBlockhash: superstruct.string(),
          addressTableLookups: superstruct.optional(superstruct.array(AddressTableLookupStruct))
        })
      });
      var AnnotatedAccountKey = superstruct.type({
        pubkey: PublicKeyFromString,
        signer: superstruct.boolean(),
        writable: superstruct.boolean(),
        source: superstruct.optional(superstruct.union([superstruct.literal("transaction"), superstruct.literal("lookupTable")]))
      });
      var ConfirmedTransactionAccountsModeResult = superstruct.type({
        accountKeys: superstruct.array(AnnotatedAccountKey),
        signatures: superstruct.array(superstruct.string())
      });
      var ParsedInstructionResult = superstruct.type({
        parsed: superstruct.unknown(),
        program: superstruct.string(),
        programId: PublicKeyFromString
      });
      var RawInstructionResult = superstruct.type({
        accounts: superstruct.array(PublicKeyFromString),
        data: superstruct.string(),
        programId: PublicKeyFromString
      });
      var InstructionResult = superstruct.union([RawInstructionResult, ParsedInstructionResult]);
      var UnknownInstructionResult = superstruct.union([superstruct.type({
        parsed: superstruct.unknown(),
        program: superstruct.string(),
        programId: superstruct.string()
      }), superstruct.type({
        accounts: superstruct.array(superstruct.string()),
        data: superstruct.string(),
        programId: superstruct.string()
      })]);
      var ParsedOrRawInstruction = superstruct.coerce(InstructionResult, UnknownInstructionResult, (value) => {
        if ("accounts" in value) {
          return superstruct.create(value, RawInstructionResult);
        } else {
          return superstruct.create(value, ParsedInstructionResult);
        }
      });
      var ParsedConfirmedTransactionResult = superstruct.type({
        signatures: superstruct.array(superstruct.string()),
        message: superstruct.type({
          accountKeys: superstruct.array(AnnotatedAccountKey),
          instructions: superstruct.array(ParsedOrRawInstruction),
          recentBlockhash: superstruct.string(),
          addressTableLookups: superstruct.optional(superstruct.nullable(superstruct.array(AddressTableLookupStruct)))
        })
      });
      var TokenBalanceResult = superstruct.type({
        accountIndex: superstruct.number(),
        mint: superstruct.string(),
        owner: superstruct.optional(superstruct.string()),
        programId: superstruct.optional(superstruct.string()),
        uiTokenAmount: TokenAmountResult
      });
      var LoadedAddressesResult = superstruct.type({
        writable: superstruct.array(PublicKeyFromString),
        readonly: superstruct.array(PublicKeyFromString)
      });
      var ConfirmedTransactionMetaResult = superstruct.type({
        err: TransactionErrorResult,
        fee: superstruct.number(),
        innerInstructions: superstruct.optional(superstruct.nullable(superstruct.array(superstruct.type({
          index: superstruct.number(),
          instructions: superstruct.array(superstruct.type({
            accounts: superstruct.array(superstruct.number()),
            data: superstruct.string(),
            programIdIndex: superstruct.number()
          }))
        })))),
        preBalances: superstruct.array(superstruct.number()),
        postBalances: superstruct.array(superstruct.number()),
        logMessages: superstruct.optional(superstruct.nullable(superstruct.array(superstruct.string()))),
        preTokenBalances: superstruct.optional(superstruct.nullable(superstruct.array(TokenBalanceResult))),
        postTokenBalances: superstruct.optional(superstruct.nullable(superstruct.array(TokenBalanceResult))),
        loadedAddresses: superstruct.optional(LoadedAddressesResult),
        computeUnitsConsumed: superstruct.optional(superstruct.number()),
        costUnits: superstruct.optional(superstruct.number())
      });
      var ParsedConfirmedTransactionMetaResult = superstruct.type({
        err: TransactionErrorResult,
        fee: superstruct.number(),
        innerInstructions: superstruct.optional(superstruct.nullable(superstruct.array(superstruct.type({
          index: superstruct.number(),
          instructions: superstruct.array(ParsedOrRawInstruction)
        })))),
        preBalances: superstruct.array(superstruct.number()),
        postBalances: superstruct.array(superstruct.number()),
        logMessages: superstruct.optional(superstruct.nullable(superstruct.array(superstruct.string()))),
        preTokenBalances: superstruct.optional(superstruct.nullable(superstruct.array(TokenBalanceResult))),
        postTokenBalances: superstruct.optional(superstruct.nullable(superstruct.array(TokenBalanceResult))),
        loadedAddresses: superstruct.optional(LoadedAddressesResult),
        computeUnitsConsumed: superstruct.optional(superstruct.number()),
        costUnits: superstruct.optional(superstruct.number())
      });
      var TransactionVersionStruct = superstruct.union([superstruct.literal(0), superstruct.literal("legacy")]);
      var RewardsResult = superstruct.type({
        pubkey: superstruct.string(),
        lamports: superstruct.number(),
        postBalance: superstruct.nullable(superstruct.number()),
        rewardType: superstruct.nullable(superstruct.string()),
        commission: superstruct.optional(superstruct.nullable(superstruct.number()))
      });
      var GetBlockRpcResult = jsonRpcResult2(superstruct.nullable(superstruct.type({
        blockhash: superstruct.string(),
        previousBlockhash: superstruct.string(),
        parentSlot: superstruct.number(),
        transactions: superstruct.array(superstruct.type({
          transaction: ConfirmedTransactionResult,
          meta: superstruct.nullable(ConfirmedTransactionMetaResult),
          version: superstruct.optional(TransactionVersionStruct)
        })),
        rewards: superstruct.optional(superstruct.array(RewardsResult)),
        blockTime: superstruct.nullable(superstruct.number()),
        blockHeight: superstruct.nullable(superstruct.number())
      })));
      var GetNoneModeBlockRpcResult = jsonRpcResult2(superstruct.nullable(superstruct.type({
        blockhash: superstruct.string(),
        previousBlockhash: superstruct.string(),
        parentSlot: superstruct.number(),
        rewards: superstruct.optional(superstruct.array(RewardsResult)),
        blockTime: superstruct.nullable(superstruct.number()),
        blockHeight: superstruct.nullable(superstruct.number())
      })));
      var GetAccountsModeBlockRpcResult = jsonRpcResult2(superstruct.nullable(superstruct.type({
        blockhash: superstruct.string(),
        previousBlockhash: superstruct.string(),
        parentSlot: superstruct.number(),
        transactions: superstruct.array(superstruct.type({
          transaction: ConfirmedTransactionAccountsModeResult,
          meta: superstruct.nullable(ConfirmedTransactionMetaResult),
          version: superstruct.optional(TransactionVersionStruct)
        })),
        rewards: superstruct.optional(superstruct.array(RewardsResult)),
        blockTime: superstruct.nullable(superstruct.number()),
        blockHeight: superstruct.nullable(superstruct.number())
      })));
      var GetParsedBlockRpcResult = jsonRpcResult2(superstruct.nullable(superstruct.type({
        blockhash: superstruct.string(),
        previousBlockhash: superstruct.string(),
        parentSlot: superstruct.number(),
        transactions: superstruct.array(superstruct.type({
          transaction: ParsedConfirmedTransactionResult,
          meta: superstruct.nullable(ParsedConfirmedTransactionMetaResult),
          version: superstruct.optional(TransactionVersionStruct)
        })),
        rewards: superstruct.optional(superstruct.array(RewardsResult)),
        blockTime: superstruct.nullable(superstruct.number()),
        blockHeight: superstruct.nullable(superstruct.number())
      })));
      var GetParsedAccountsModeBlockRpcResult = jsonRpcResult2(superstruct.nullable(superstruct.type({
        blockhash: superstruct.string(),
        previousBlockhash: superstruct.string(),
        parentSlot: superstruct.number(),
        transactions: superstruct.array(superstruct.type({
          transaction: ConfirmedTransactionAccountsModeResult,
          meta: superstruct.nullable(ParsedConfirmedTransactionMetaResult),
          version: superstruct.optional(TransactionVersionStruct)
        })),
        rewards: superstruct.optional(superstruct.array(RewardsResult)),
        blockTime: superstruct.nullable(superstruct.number()),
        blockHeight: superstruct.nullable(superstruct.number())
      })));
      var GetParsedNoneModeBlockRpcResult = jsonRpcResult2(superstruct.nullable(superstruct.type({
        blockhash: superstruct.string(),
        previousBlockhash: superstruct.string(),
        parentSlot: superstruct.number(),
        rewards: superstruct.optional(superstruct.array(RewardsResult)),
        blockTime: superstruct.nullable(superstruct.number()),
        blockHeight: superstruct.nullable(superstruct.number())
      })));
      var GetConfirmedBlockRpcResult = jsonRpcResult2(superstruct.nullable(superstruct.type({
        blockhash: superstruct.string(),
        previousBlockhash: superstruct.string(),
        parentSlot: superstruct.number(),
        transactions: superstruct.array(superstruct.type({
          transaction: ConfirmedTransactionResult,
          meta: superstruct.nullable(ConfirmedTransactionMetaResult)
        })),
        rewards: superstruct.optional(superstruct.array(RewardsResult)),
        blockTime: superstruct.nullable(superstruct.number())
      })));
      var GetBlockSignaturesRpcResult = jsonRpcResult2(superstruct.nullable(superstruct.type({
        blockhash: superstruct.string(),
        previousBlockhash: superstruct.string(),
        parentSlot: superstruct.number(),
        signatures: superstruct.array(superstruct.string()),
        blockTime: superstruct.nullable(superstruct.number())
      })));
      var GetTransactionRpcResult = jsonRpcResult2(superstruct.nullable(superstruct.type({
        slot: superstruct.number(),
        meta: superstruct.nullable(ConfirmedTransactionMetaResult),
        blockTime: superstruct.optional(superstruct.nullable(superstruct.number())),
        transaction: ConfirmedTransactionResult,
        version: superstruct.optional(TransactionVersionStruct)
      })));
      var GetParsedTransactionRpcResult = jsonRpcResult2(superstruct.nullable(superstruct.type({
        slot: superstruct.number(),
        transaction: ParsedConfirmedTransactionResult,
        meta: superstruct.nullable(ParsedConfirmedTransactionMetaResult),
        blockTime: superstruct.optional(superstruct.nullable(superstruct.number())),
        version: superstruct.optional(TransactionVersionStruct)
      })));
      var GetLatestBlockhashRpcResult = jsonRpcResultAndContext2(superstruct.type({
        blockhash: superstruct.string(),
        lastValidBlockHeight: superstruct.number()
      }));
      var IsBlockhashValidRpcResult = jsonRpcResultAndContext2(superstruct.boolean());
      var PerfSampleResult = superstruct.type({
        slot: superstruct.number(),
        numTransactions: superstruct.number(),
        numSlots: superstruct.number(),
        samplePeriodSecs: superstruct.number()
      });
      var GetRecentPerformanceSamplesRpcResult = jsonRpcResult2(superstruct.array(PerfSampleResult));
      var GetFeeCalculatorRpcResult = jsonRpcResultAndContext2(superstruct.nullable(superstruct.type({
        feeCalculator: superstruct.type({
          lamportsPerSignature: superstruct.number()
        })
      })));
      var RequestAirdropRpcResult = jsonRpcResult2(superstruct.string());
      var SendTransactionRpcResult = jsonRpcResult2(superstruct.string());
      var LogsResult = superstruct.type({
        err: TransactionErrorResult,
        logs: superstruct.array(superstruct.string()),
        signature: superstruct.string()
      });
      var LogsNotificationResult = superstruct.type({
        result: notificationResultAndContext(LogsResult),
        subscription: superstruct.number()
      });
      var COMMON_HTTP_HEADERS = {
        "solana-client": `js/${"1.0.0-maintenance"}`
      };
      var Connection = class {
        /**
         * Establish a JSON RPC connection
         *
         * @param endpoint URL to the fullnode JSON RPC endpoint
         * @param commitmentOrConfig optional default commitment level or optional ConnectionConfig configuration object
         */
        constructor(endpoint2, _commitmentOrConfig) {
          this._commitment = void 0;
          this._confirmTransactionInitialTimeout = void 0;
          this._rpcEndpoint = void 0;
          this._rpcWsEndpoint = void 0;
          this._rpcClient = void 0;
          this._rpcRequest = void 0;
          this._rpcBatchRequest = void 0;
          this._rpcWebSocket = void 0;
          this._rpcWebSocketConnected = false;
          this._rpcWebSocketHeartbeat = null;
          this._rpcWebSocketIdleTimeout = null;
          this._rpcWebSocketGeneration = 0;
          this._disableBlockhashCaching = false;
          this._pollingBlockhash = false;
          this._blockhashInfo = {
            latestBlockhash: null,
            lastFetch: 0,
            transactionSignatures: [],
            simulatedSignatures: []
          };
          this._nextClientSubscriptionId = 0;
          this._subscriptionDisposeFunctionsByClientSubscriptionId = {};
          this._subscriptionHashByClientSubscriptionId = {};
          this._subscriptionStateChangeCallbacksByHash = {};
          this._subscriptionCallbacksByServerSubscriptionId = {};
          this._subscriptionsByHash = {};
          this._subscriptionsAutoDisposedByRpc = /* @__PURE__ */ new Set();
          this.getBlockHeight = /* @__PURE__ */ (() => {
            const requestPromises = {};
            return async (commitmentOrConfig) => {
              const {
                commitment,
                config
              } = extractCommitmentFromConfig(commitmentOrConfig);
              const args = this._buildArgs([], commitment, void 0, config);
              const requestHash = fastStableStringify(args);
              requestPromises[requestHash] = requestPromises[requestHash] ?? (async () => {
                try {
                  const unsafeRes = await this._rpcRequest("getBlockHeight", args);
                  const res = superstruct.create(unsafeRes, jsonRpcResult2(superstruct.number()));
                  if ("error" in res) {
                    throw new SolanaJSONRPCError(res.error, "failed to get block height information");
                  }
                  return res.result;
                } finally {
                  delete requestPromises[requestHash];
                }
              })();
              return await requestPromises[requestHash];
            };
          })();
          let wsEndpoint;
          let httpHeaders;
          let fetch2;
          let fetchMiddleware;
          let disableRetryOnRateLimit;
          let httpAgent;
          if (_commitmentOrConfig && typeof _commitmentOrConfig === "string") {
            this._commitment = _commitmentOrConfig;
          } else if (_commitmentOrConfig) {
            this._commitment = _commitmentOrConfig.commitment;
            this._confirmTransactionInitialTimeout = _commitmentOrConfig.confirmTransactionInitialTimeout;
            wsEndpoint = _commitmentOrConfig.wsEndpoint;
            httpHeaders = _commitmentOrConfig.httpHeaders;
            fetch2 = _commitmentOrConfig.fetch;
            fetchMiddleware = _commitmentOrConfig.fetchMiddleware;
            disableRetryOnRateLimit = _commitmentOrConfig.disableRetryOnRateLimit;
            httpAgent = _commitmentOrConfig.httpAgent;
          }
          this._rpcEndpoint = assertEndpointUrl(endpoint2);
          this._rpcWsEndpoint = wsEndpoint || makeWebsocketUrl(endpoint2);
          this._rpcClient = createRpcClient(endpoint2, httpHeaders, fetch2, fetchMiddleware, disableRetryOnRateLimit, httpAgent);
          this._rpcRequest = createRpcRequest(this._rpcClient);
          this._rpcBatchRequest = createRpcBatchRequest(this._rpcClient);
          this._rpcWebSocket = new RpcWebSocketClient(this._rpcWsEndpoint, {
            autoconnect: false,
            max_reconnects: Infinity
          });
          this._rpcWebSocket.on("open", this._wsOnOpen.bind(this));
          this._rpcWebSocket.on("error", this._wsOnError.bind(this));
          this._rpcWebSocket.on("close", this._wsOnClose.bind(this));
          this._rpcWebSocket.on("accountNotification", this._wsOnAccountNotification.bind(this));
          this._rpcWebSocket.on("programNotification", this._wsOnProgramAccountNotification.bind(this));
          this._rpcWebSocket.on("slotNotification", this._wsOnSlotNotification.bind(this));
          this._rpcWebSocket.on("slotsUpdatesNotification", this._wsOnSlotUpdatesNotification.bind(this));
          this._rpcWebSocket.on("signatureNotification", this._wsOnSignatureNotification.bind(this));
          this._rpcWebSocket.on("rootNotification", this._wsOnRootNotification.bind(this));
          this._rpcWebSocket.on("logsNotification", this._wsOnLogsNotification.bind(this));
        }
        /**
         * The default commitment used for requests
         */
        get commitment() {
          return this._commitment;
        }
        /**
         * The RPC endpoint
         */
        get rpcEndpoint() {
          return this._rpcEndpoint;
        }
        /**
         * Fetch the balance for the specified public key, return with context
         */
        async getBalanceAndContext(publicKey4, commitmentOrConfig) {
          const {
            commitment,
            config
          } = extractCommitmentFromConfig(commitmentOrConfig);
          const args = this._buildArgs([publicKey4.toBase58()], commitment, void 0, config);
          const unsafeRes = await this._rpcRequest("getBalance", args);
          const res = superstruct.create(unsafeRes, jsonRpcResultAndContext2(superstruct.number()));
          if ("error" in res) {
            throw new SolanaJSONRPCError(res.error, `failed to get balance for ${publicKey4.toBase58()}`);
          }
          return res.result;
        }
        /**
         * Fetch the balance for the specified public key
         */
        async getBalance(publicKey4, commitmentOrConfig) {
          return await this.getBalanceAndContext(publicKey4, commitmentOrConfig).then((x) => x.value).catch((e) => {
            throw new Error("failed to get balance of account " + publicKey4.toBase58() + ": " + e);
          });
        }
        /**
         * Fetch the estimated production time of a block
         */
        async getBlockTime(slot) {
          const unsafeRes = await this._rpcRequest("getBlockTime", [slot]);
          const res = superstruct.create(unsafeRes, jsonRpcResult2(superstruct.nullable(superstruct.number())));
          if ("error" in res) {
            throw new SolanaJSONRPCError(res.error, `failed to get block time for slot ${slot}`);
          }
          return res.result;
        }
        /**
         * Fetch the lowest slot that the node has information about in its ledger.
         * This value may increase over time if the node is configured to purge older ledger data
         */
        async getMinimumLedgerSlot() {
          const unsafeRes = await this._rpcRequest("minimumLedgerSlot", []);
          const res = superstruct.create(unsafeRes, jsonRpcResult2(superstruct.number()));
          if ("error" in res) {
            throw new SolanaJSONRPCError(res.error, "failed to get minimum ledger slot");
          }
          return res.result;
        }
        /**
         * Fetch the slot of the lowest confirmed block that has not been purged from the ledger
         */
        async getFirstAvailableBlock() {
          const unsafeRes = await this._rpcRequest("getFirstAvailableBlock", []);
          const res = superstruct.create(unsafeRes, SlotRpcResult);
          if ("error" in res) {
            throw new SolanaJSONRPCError(res.error, "failed to get first available block");
          }
          return res.result;
        }
        /**
         * Fetch information about the current supply
         */
        async getSupply(config) {
          let configArg = {};
          if (typeof config === "string") {
            configArg = {
              commitment: config
            };
          } else if (config) {
            configArg = {
              ...config,
              commitment: config && config.commitment || this.commitment
            };
          } else {
            configArg = {
              commitment: this.commitment
            };
          }
          const unsafeRes = await this._rpcRequest("getSupply", [configArg]);
          const res = superstruct.create(unsafeRes, GetSupplyRpcResult);
          if ("error" in res) {
            throw new SolanaJSONRPCError(res.error, "failed to get supply");
          }
          return res.result;
        }
        /**
         * Fetch the current supply of a token mint
         */
        async getTokenSupply(tokenMintAddress, commitment) {
          const args = this._buildArgs([tokenMintAddress.toBase58()], commitment);
          const unsafeRes = await this._rpcRequest("getTokenSupply", args);
          const res = superstruct.create(unsafeRes, jsonRpcResultAndContext2(TokenAmountResult));
          if ("error" in res) {
            throw new SolanaJSONRPCError(res.error, "failed to get token supply");
          }
          return res.result;
        }
        /**
         * Fetch the current balance of a token account
         */
        async getTokenAccountBalance(tokenAddress, commitment) {
          const args = this._buildArgs([tokenAddress.toBase58()], commitment);
          const unsafeRes = await this._rpcRequest("getTokenAccountBalance", args);
          const res = superstruct.create(unsafeRes, jsonRpcResultAndContext2(TokenAmountResult));
          if ("error" in res) {
            throw new SolanaJSONRPCError(res.error, "failed to get token account balance");
          }
          return res.result;
        }
        /**
         * Fetch all the token accounts owned by the specified account
         *
         * @return {Promise<RpcResponseAndContext<GetProgramAccountsResponse>}
         */
        async getTokenAccountsByOwner(ownerAddress, filter, commitmentOrConfig) {
          const {
            commitment,
            config
          } = extractCommitmentFromConfig(commitmentOrConfig);
          let _args = [ownerAddress.toBase58()];
          if ("mint" in filter) {
            _args.push({
              mint: filter.mint.toBase58()
            });
          } else {
            _args.push({
              programId: filter.programId.toBase58()
            });
          }
          const args = this._buildArgs(_args, commitment, "base64", config);
          const unsafeRes = await this._rpcRequest("getTokenAccountsByOwner", args);
          const res = superstruct.create(unsafeRes, GetTokenAccountsByOwner);
          if ("error" in res) {
            throw new SolanaJSONRPCError(res.error, `failed to get token accounts owned by account ${ownerAddress.toBase58()}`);
          }
          return res.result;
        }
        /**
         * Fetch parsed token accounts owned by the specified account
         *
         * @return {Promise<RpcResponseAndContext<Array<{pubkey: PublicKey, account: AccountInfo<ParsedAccountData>}>>>}
         */
        async getParsedTokenAccountsByOwner(ownerAddress, filter, commitment) {
          let _args = [ownerAddress.toBase58()];
          if ("mint" in filter) {
            _args.push({
              mint: filter.mint.toBase58()
            });
          } else {
            _args.push({
              programId: filter.programId.toBase58()
            });
          }
          const args = this._buildArgs(_args, commitment, "jsonParsed");
          const unsafeRes = await this._rpcRequest("getTokenAccountsByOwner", args);
          const res = superstruct.create(unsafeRes, GetParsedTokenAccountsByOwner);
          if ("error" in res) {
            throw new SolanaJSONRPCError(res.error, `failed to get token accounts owned by account ${ownerAddress.toBase58()}`);
          }
          return res.result;
        }
        /**
         * Fetch the 20 largest accounts with their current balances
         */
        async getLargestAccounts(config) {
          const arg = {
            ...config,
            commitment: config && config.commitment || this.commitment
          };
          const args = arg.filter || arg.commitment ? [arg] : [];
          const unsafeRes = await this._rpcRequest("getLargestAccounts", args);
          const res = superstruct.create(unsafeRes, GetLargestAccountsRpcResult);
          if ("error" in res) {
            throw new SolanaJSONRPCError(res.error, "failed to get largest accounts");
          }
          return res.result;
        }
        /**
         * Fetch the 20 largest token accounts with their current balances
         * for a given mint.
         */
        async getTokenLargestAccounts(mintAddress, commitment) {
          const args = this._buildArgs([mintAddress.toBase58()], commitment);
          const unsafeRes = await this._rpcRequest("getTokenLargestAccounts", args);
          const res = superstruct.create(unsafeRes, GetTokenLargestAccountsResult);
          if ("error" in res) {
            throw new SolanaJSONRPCError(res.error, "failed to get token largest accounts");
          }
          return res.result;
        }
        /**
         * Fetch all the account info for the specified public key, return with context
         */
        async getAccountInfoAndContext(publicKey4, commitmentOrConfig) {
          const {
            commitment,
            config
          } = extractCommitmentFromConfig(commitmentOrConfig);
          const args = this._buildArgs([publicKey4.toBase58()], commitment, "base64", config);
          const unsafeRes = await this._rpcRequest("getAccountInfo", args);
          const res = superstruct.create(unsafeRes, jsonRpcResultAndContext2(superstruct.nullable(AccountInfoResult)));
          if ("error" in res) {
            throw new SolanaJSONRPCError(res.error, `failed to get info about account ${publicKey4.toBase58()}`);
          }
          return res.result;
        }
        /**
         * Fetch parsed account info for the specified public key
         */
        async getParsedAccountInfo(publicKey4, commitmentOrConfig) {
          const {
            commitment,
            config
          } = extractCommitmentFromConfig(commitmentOrConfig);
          const args = this._buildArgs([publicKey4.toBase58()], commitment, "jsonParsed", config);
          const unsafeRes = await this._rpcRequest("getAccountInfo", args);
          const res = superstruct.create(unsafeRes, jsonRpcResultAndContext2(superstruct.nullable(ParsedAccountInfoResult)));
          if ("error" in res) {
            throw new SolanaJSONRPCError(res.error, `failed to get info about account ${publicKey4.toBase58()}`);
          }
          return res.result;
        }
        /**
         * Fetch all the account info for the specified public key
         */
        async getAccountInfo(publicKey4, commitmentOrConfig) {
          try {
            const res = await this.getAccountInfoAndContext(publicKey4, commitmentOrConfig);
            return res.value;
          } catch (e) {
            throw new Error("failed to get info about account " + publicKey4.toBase58() + ": " + e);
          }
        }
        /**
         * Fetch all the account info for multiple accounts specified by an array of public keys, return with context
         */
        async getMultipleParsedAccounts(publicKeys, rawConfig) {
          const {
            commitment,
            config
          } = extractCommitmentFromConfig(rawConfig);
          const keys = publicKeys.map((key) => key.toBase58());
          const args = this._buildArgs([keys], commitment, "jsonParsed", config);
          const unsafeRes = await this._rpcRequest("getMultipleAccounts", args);
          const res = superstruct.create(unsafeRes, jsonRpcResultAndContext2(superstruct.array(superstruct.nullable(ParsedAccountInfoResult))));
          if ("error" in res) {
            throw new SolanaJSONRPCError(res.error, `failed to get info for accounts ${keys}`);
          }
          return res.result;
        }
        /**
         * Fetch all the account info for multiple accounts specified by an array of public keys, return with context
         */
        async getMultipleAccountsInfoAndContext(publicKeys, commitmentOrConfig) {
          const {
            commitment,
            config
          } = extractCommitmentFromConfig(commitmentOrConfig);
          const keys = publicKeys.map((key) => key.toBase58());
          const args = this._buildArgs([keys], commitment, "base64", config);
          const unsafeRes = await this._rpcRequest("getMultipleAccounts", args);
          const res = superstruct.create(unsafeRes, jsonRpcResultAndContext2(superstruct.array(superstruct.nullable(AccountInfoResult))));
          if ("error" in res) {
            throw new SolanaJSONRPCError(res.error, `failed to get info for accounts ${keys}`);
          }
          return res.result;
        }
        /**
         * Fetch all the account info for multiple accounts specified by an array of public keys
         */
        async getMultipleAccountsInfo(publicKeys, commitmentOrConfig) {
          const res = await this.getMultipleAccountsInfoAndContext(publicKeys, commitmentOrConfig);
          return res.value;
        }
        /**
         * Returns epoch activation information for a stake account that has been delegated
         *
         * @deprecated Deprecated since RPC v1.18; will be removed in a future version.
         */
        async getStakeActivation(publicKey4, commitmentOrConfig, epoch) {
          const {
            commitment,
            config
          } = extractCommitmentFromConfig(commitmentOrConfig);
          const args = this._buildArgs([publicKey4.toBase58()], commitment, void 0, {
            ...config,
            epoch: epoch != null ? epoch : config?.epoch
          });
          const unsafeRes = await this._rpcRequest("getStakeActivation", args);
          const res = superstruct.create(unsafeRes, jsonRpcResult2(StakeActivationResult));
          if ("error" in res) {
            throw new SolanaJSONRPCError(res.error, `failed to get Stake Activation ${publicKey4.toBase58()}`);
          }
          return res.result;
        }
        /**
         * Fetch all the accounts owned by the specified program id
         *
         * @return {Promise<Array<{pubkey: PublicKey, account: AccountInfo<Buffer>}>>}
         */
        // eslint-disable-next-line no-dupe-class-members
        // eslint-disable-next-line no-dupe-class-members
        async getProgramAccounts(programId, configOrCommitment) {
          const {
            commitment,
            config
          } = extractCommitmentFromConfig(configOrCommitment);
          const {
            encoding,
            ...configWithoutEncoding
          } = config || {};
          const args = this._buildArgs([programId.toBase58()], commitment, encoding || "base64", {
            ...configWithoutEncoding,
            ...configWithoutEncoding.filters ? {
              filters: applyDefaultMemcmpEncodingToFilters(configWithoutEncoding.filters)
            } : null
          });
          const unsafeRes = await this._rpcRequest("getProgramAccounts", args);
          const baseSchema = superstruct.array(KeyedAccountInfoResult);
          const res = configWithoutEncoding.withContext === true ? superstruct.create(unsafeRes, jsonRpcResultAndContext2(baseSchema)) : superstruct.create(unsafeRes, jsonRpcResult2(baseSchema));
          if ("error" in res) {
            throw new SolanaJSONRPCError(res.error, `failed to get accounts owned by program ${programId.toBase58()}`);
          }
          return res.result;
        }
        /**
         * Fetch and parse all the accounts owned by the specified program id
         *
         * @return {Promise<Array<{pubkey: PublicKey, account: AccountInfo<Buffer | ParsedAccountData>}>>}
         */
        async getParsedProgramAccounts(programId, configOrCommitment) {
          const {
            commitment,
            config
          } = extractCommitmentFromConfig(configOrCommitment);
          const args = this._buildArgs([programId.toBase58()], commitment, "jsonParsed", config);
          const unsafeRes = await this._rpcRequest("getProgramAccounts", args);
          const res = superstruct.create(unsafeRes, jsonRpcResult2(superstruct.array(KeyedParsedAccountInfoResult)));
          if ("error" in res) {
            throw new SolanaJSONRPCError(res.error, `failed to get accounts owned by program ${programId.toBase58()}`);
          }
          return res.result;
        }
        /** @deprecated Instead, call `confirmTransaction` and pass in {@link TransactionConfirmationStrategy} */
        // eslint-disable-next-line no-dupe-class-members
        // eslint-disable-next-line no-dupe-class-members
        async confirmTransaction(strategy, commitment) {
          let rawSignature;
          if (typeof strategy == "string") {
            rawSignature = strategy;
          } else {
            const config = strategy;
            if (config.abortSignal?.aborted) {
              return Promise.reject(config.abortSignal.reason);
            }
            rawSignature = config.signature;
          }
          let decodedSignature;
          try {
            decodedSignature = bs58__default.default.decode(rawSignature);
          } catch (err2) {
            throw new Error("signature must be base58 encoded: " + rawSignature);
          }
          assert2(decodedSignature.length === 64, "signature has invalid length");
          if (typeof strategy === "string") {
            return await this.confirmTransactionUsingLegacyTimeoutStrategy({
              commitment: commitment || this.commitment,
              signature: rawSignature
            });
          } else if ("lastValidBlockHeight" in strategy) {
            return await this.confirmTransactionUsingBlockHeightExceedanceStrategy({
              commitment: commitment || this.commitment,
              strategy
            });
          } else {
            return await this.confirmTransactionUsingDurableNonceStrategy({
              commitment: commitment || this.commitment,
              strategy
            });
          }
        }
        getCancellationPromise(signal) {
          return new Promise((_, reject) => {
            if (signal == null) {
              return;
            }
            if (signal.aborted) {
              reject(signal.reason);
            } else {
              signal.addEventListener("abort", () => {
                reject(signal.reason);
              });
            }
          });
        }
        getTransactionConfirmationPromise({
          commitment,
          signature: signature2
        }) {
          let signatureSubscriptionId;
          let disposeSignatureSubscriptionStateChangeObserver;
          let done = false;
          const confirmationPromise = new Promise((resolve, reject) => {
            try {
              signatureSubscriptionId = this.onSignature(signature2, (result, context) => {
                signatureSubscriptionId = void 0;
                const response = {
                  context,
                  value: result
                };
                resolve({
                  __type: TransactionStatus.PROCESSED,
                  response
                });
              }, commitment);
              const subscriptionSetupPromise = new Promise((resolveSubscriptionSetup) => {
                if (signatureSubscriptionId == null) {
                  resolveSubscriptionSetup();
                } else {
                  disposeSignatureSubscriptionStateChangeObserver = this._onSubscriptionStateChange(signatureSubscriptionId, (nextState) => {
                    if (nextState === "subscribed") {
                      resolveSubscriptionSetup();
                    }
                  });
                }
              });
              (async () => {
                await subscriptionSetupPromise;
                if (done) return;
                const response = await this.getSignatureStatus(signature2);
                if (done) return;
                if (response == null) {
                  return;
                }
                const {
                  context,
                  value
                } = response;
                if (value == null) {
                  return;
                }
                if (value?.err) {
                  reject(value.err);
                } else {
                  switch (commitment) {
                    case "confirmed":
                    case "single":
                    case "singleGossip": {
                      if (value.confirmationStatus === "processed") {
                        return;
                      }
                      break;
                    }
                    case "finalized":
                    case "max":
                    case "root": {
                      if (value.confirmationStatus === "processed" || value.confirmationStatus === "confirmed") {
                        return;
                      }
                      break;
                    }
                    // exhaust enums to ensure full coverage
                    case "processed":
                    case "recent":
                  }
                  done = true;
                  resolve({
                    __type: TransactionStatus.PROCESSED,
                    response: {
                      context,
                      value
                    }
                  });
                }
              })();
            } catch (err2) {
              reject(err2);
            }
          });
          const abortConfirmation = () => {
            if (disposeSignatureSubscriptionStateChangeObserver) {
              disposeSignatureSubscriptionStateChangeObserver();
              disposeSignatureSubscriptionStateChangeObserver = void 0;
            }
            if (signatureSubscriptionId != null) {
              this.removeSignatureListener(signatureSubscriptionId);
              signatureSubscriptionId = void 0;
            }
          };
          return {
            abortConfirmation,
            confirmationPromise
          };
        }
        async confirmTransactionUsingBlockHeightExceedanceStrategy({
          commitment,
          strategy: {
            abortSignal,
            lastValidBlockHeight,
            signature: signature2
          }
        }) {
          let done = false;
          const expiryPromise = new Promise((resolve) => {
            const checkBlockHeight = async () => {
              try {
                const blockHeight = await this.getBlockHeight(commitment);
                return blockHeight;
              } catch (_e) {
                return -1;
              }
            };
            (async () => {
              let currentBlockHeight = await checkBlockHeight();
              if (done) return;
              while (currentBlockHeight <= lastValidBlockHeight) {
                await sleep(1e3);
                if (done) return;
                currentBlockHeight = await checkBlockHeight();
                if (done) return;
              }
              resolve({
                __type: TransactionStatus.BLOCKHEIGHT_EXCEEDED
              });
            })();
          });
          const {
            abortConfirmation,
            confirmationPromise
          } = this.getTransactionConfirmationPromise({
            commitment,
            signature: signature2
          });
          const cancellationPromise = this.getCancellationPromise(abortSignal);
          let result;
          try {
            const outcome = await Promise.race([cancellationPromise, confirmationPromise, expiryPromise]);
            if (outcome.__type === TransactionStatus.PROCESSED) {
              result = outcome.response;
            } else {
              throw new TransactionExpiredBlockheightExceededError(signature2);
            }
          } finally {
            done = true;
            abortConfirmation();
          }
          return result;
        }
        async confirmTransactionUsingDurableNonceStrategy({
          commitment,
          strategy: {
            abortSignal,
            minContextSlot,
            nonceAccountPubkey,
            nonceValue,
            signature: signature2
          }
        }) {
          let done = false;
          const expiryPromise = new Promise((resolve) => {
            let currentNonceValue = nonceValue;
            let lastCheckedSlot = null;
            const getCurrentNonceValue = async () => {
              try {
                const {
                  context,
                  value: nonceAccount
                } = await this.getNonceAndContext(nonceAccountPubkey, {
                  commitment,
                  minContextSlot
                });
                lastCheckedSlot = context.slot;
                return nonceAccount?.nonce;
              } catch (e) {
                return currentNonceValue;
              }
            };
            (async () => {
              currentNonceValue = await getCurrentNonceValue();
              if (done) return;
              while (true) {
                if (nonceValue !== currentNonceValue) {
                  resolve({
                    __type: TransactionStatus.NONCE_INVALID,
                    slotInWhichNonceDidAdvance: lastCheckedSlot
                  });
                  return;
                }
                await sleep(2e3);
                if (done) return;
                currentNonceValue = await getCurrentNonceValue();
                if (done) return;
              }
            })();
          });
          const {
            abortConfirmation,
            confirmationPromise
          } = this.getTransactionConfirmationPromise({
            commitment,
            signature: signature2
          });
          const cancellationPromise = this.getCancellationPromise(abortSignal);
          let result;
          try {
            const outcome = await Promise.race([cancellationPromise, confirmationPromise, expiryPromise]);
            if (outcome.__type === TransactionStatus.PROCESSED) {
              result = outcome.response;
            } else {
              let signatureStatus;
              while (true) {
                const status = await this.getSignatureStatus(signature2);
                if (status == null) {
                  break;
                }
                if (status.context.slot < (outcome.slotInWhichNonceDidAdvance ?? minContextSlot)) {
                  await sleep(400);
                  continue;
                }
                signatureStatus = status;
                break;
              }
              if (signatureStatus?.value) {
                const commitmentForStatus = commitment || "finalized";
                const {
                  confirmationStatus
                } = signatureStatus.value;
                switch (commitmentForStatus) {
                  case "processed":
                  case "recent":
                    if (confirmationStatus !== "processed" && confirmationStatus !== "confirmed" && confirmationStatus !== "finalized") {
                      throw new TransactionExpiredNonceInvalidError(signature2);
                    }
                    break;
                  case "confirmed":
                  case "single":
                  case "singleGossip":
                    if (confirmationStatus !== "confirmed" && confirmationStatus !== "finalized") {
                      throw new TransactionExpiredNonceInvalidError(signature2);
                    }
                    break;
                  case "finalized":
                  case "max":
                  case "root":
                    if (confirmationStatus !== "finalized") {
                      throw new TransactionExpiredNonceInvalidError(signature2);
                    }
                    break;
                  default:
                    /* @__PURE__ */ ((_) => {
                    })(commitmentForStatus);
                }
                result = {
                  context: signatureStatus.context,
                  value: {
                    err: signatureStatus.value.err
                  }
                };
              } else {
                throw new TransactionExpiredNonceInvalidError(signature2);
              }
            }
          } finally {
            done = true;
            abortConfirmation();
          }
          return result;
        }
        async confirmTransactionUsingLegacyTimeoutStrategy({
          commitment,
          signature: signature2
        }) {
          let timeoutId;
          const expiryPromise = new Promise((resolve) => {
            let timeoutMs = this._confirmTransactionInitialTimeout || 60 * 1e3;
            switch (commitment) {
              case "processed":
              case "recent":
              case "single":
              case "confirmed":
              case "singleGossip": {
                timeoutMs = this._confirmTransactionInitialTimeout || 30 * 1e3;
                break;
              }
            }
            timeoutId = setTimeout(() => resolve({
              __type: TransactionStatus.TIMED_OUT,
              timeoutMs
            }), timeoutMs);
          });
          const {
            abortConfirmation,
            confirmationPromise
          } = this.getTransactionConfirmationPromise({
            commitment,
            signature: signature2
          });
          let result;
          try {
            const outcome = await Promise.race([confirmationPromise, expiryPromise]);
            if (outcome.__type === TransactionStatus.PROCESSED) {
              result = outcome.response;
            } else {
              throw new TransactionExpiredTimeoutError(signature2, outcome.timeoutMs / 1e3);
            }
          } finally {
            clearTimeout(timeoutId);
            abortConfirmation();
          }
          return result;
        }
        /**
         * Return the list of nodes that are currently participating in the cluster
         */
        async getClusterNodes() {
          const unsafeRes = await this._rpcRequest("getClusterNodes", []);
          const res = superstruct.create(unsafeRes, jsonRpcResult2(superstruct.array(ContactInfoResult)));
          if ("error" in res) {
            throw new SolanaJSONRPCError(res.error, "failed to get cluster nodes");
          }
          return res.result;
        }
        /**
         * Return the list of nodes that are currently participating in the cluster
         */
        async getVoteAccounts(commitment) {
          const args = this._buildArgs([], commitment);
          const unsafeRes = await this._rpcRequest("getVoteAccounts", args);
          const res = superstruct.create(unsafeRes, GetVoteAccounts);
          if ("error" in res) {
            throw new SolanaJSONRPCError(res.error, "failed to get vote accounts");
          }
          return res.result;
        }
        /**
         * Fetch the current slot that the node is processing
         */
        async getSlot(commitmentOrConfig) {
          const {
            commitment,
            config
          } = extractCommitmentFromConfig(commitmentOrConfig);
          const args = this._buildArgs([], commitment, void 0, config);
          const unsafeRes = await this._rpcRequest("getSlot", args);
          const res = superstruct.create(unsafeRes, jsonRpcResult2(superstruct.number()));
          if ("error" in res) {
            throw new SolanaJSONRPCError(res.error, "failed to get slot");
          }
          return res.result;
        }
        /**
         * Fetch the current slot leader of the cluster
         */
        async getSlotLeader(commitmentOrConfig) {
          const {
            commitment,
            config
          } = extractCommitmentFromConfig(commitmentOrConfig);
          const args = this._buildArgs([], commitment, void 0, config);
          const unsafeRes = await this._rpcRequest("getSlotLeader", args);
          const res = superstruct.create(unsafeRes, jsonRpcResult2(superstruct.string()));
          if ("error" in res) {
            throw new SolanaJSONRPCError(res.error, "failed to get slot leader");
          }
          return res.result;
        }
        /**
         * Fetch `limit` number of slot leaders starting from `startSlot`
         *
         * @param startSlot fetch slot leaders starting from this slot
         * @param limit number of slot leaders to return
         */
        async getSlotLeaders(startSlot, limit) {
          const args = [startSlot, limit];
          const unsafeRes = await this._rpcRequest("getSlotLeaders", args);
          const res = superstruct.create(unsafeRes, jsonRpcResult2(superstruct.array(PublicKeyFromString)));
          if ("error" in res) {
            throw new SolanaJSONRPCError(res.error, "failed to get slot leaders");
          }
          return res.result;
        }
        /**
         * Fetch the current status of a signature
         */
        async getSignatureStatus(signature2, config) {
          const {
            context,
            value: values
          } = await this.getSignatureStatuses([signature2], config);
          assert2(values.length === 1);
          const value = values[0];
          return {
            context,
            value
          };
        }
        /**
         * Fetch the current statuses of a batch of signatures
         */
        async getSignatureStatuses(signatures, config) {
          const params = [signatures];
          if (config) {
            params.push(config);
          }
          const unsafeRes = await this._rpcRequest("getSignatureStatuses", params);
          const res = superstruct.create(unsafeRes, GetSignatureStatusesRpcResult);
          if ("error" in res) {
            throw new SolanaJSONRPCError(res.error, "failed to get signature status");
          }
          return res.result;
        }
        /**
         * Fetch the current transaction count of the cluster
         */
        async getTransactionCount(commitmentOrConfig) {
          const {
            commitment,
            config
          } = extractCommitmentFromConfig(commitmentOrConfig);
          const args = this._buildArgs([], commitment, void 0, config);
          const unsafeRes = await this._rpcRequest("getTransactionCount", args);
          const res = superstruct.create(unsafeRes, jsonRpcResult2(superstruct.number()));
          if ("error" in res) {
            throw new SolanaJSONRPCError(res.error, "failed to get transaction count");
          }
          return res.result;
        }
        /**
         * Fetch the current total currency supply of the cluster in lamports
         *
         * @deprecated Deprecated since RPC v1.2.8. Please use {@link getSupply} instead.
         */
        async getTotalSupply(commitment) {
          const result = await this.getSupply({
            commitment,
            excludeNonCirculatingAccountsList: true
          });
          return result.value.total;
        }
        /**
         * Fetch the cluster InflationGovernor parameters
         */
        async getInflationGovernor(commitment) {
          const args = this._buildArgs([], commitment);
          const unsafeRes = await this._rpcRequest("getInflationGovernor", args);
          const res = superstruct.create(unsafeRes, GetInflationGovernorRpcResult);
          if ("error" in res) {
            throw new SolanaJSONRPCError(res.error, "failed to get inflation");
          }
          return res.result;
        }
        /**
         * Fetch the inflation reward for a list of addresses for an epoch
         */
        async getInflationReward(addresses, epoch, commitmentOrConfig) {
          const {
            commitment,
            config
          } = extractCommitmentFromConfig(commitmentOrConfig);
          const args = this._buildArgs([addresses.map((pubkey2) => pubkey2.toBase58())], commitment, void 0, {
            ...config,
            epoch: epoch != null ? epoch : config?.epoch
          });
          const unsafeRes = await this._rpcRequest("getInflationReward", args);
          const res = superstruct.create(unsafeRes, GetInflationRewardResult);
          if ("error" in res) {
            throw new SolanaJSONRPCError(res.error, "failed to get inflation reward");
          }
          return res.result;
        }
        /**
         * Fetch the specific inflation values for the current epoch
         */
        async getInflationRate() {
          const unsafeRes = await this._rpcRequest("getInflationRate", []);
          const res = superstruct.create(unsafeRes, GetInflationRateRpcResult);
          if ("error" in res) {
            throw new SolanaJSONRPCError(res.error, "failed to get inflation rate");
          }
          return res.result;
        }
        /**
         * Fetch the Epoch Info parameters
         */
        async getEpochInfo(commitmentOrConfig) {
          const {
            commitment,
            config
          } = extractCommitmentFromConfig(commitmentOrConfig);
          const args = this._buildArgs([], commitment, void 0, config);
          const unsafeRes = await this._rpcRequest("getEpochInfo", args);
          const res = superstruct.create(unsafeRes, GetEpochInfoRpcResult);
          if ("error" in res) {
            throw new SolanaJSONRPCError(res.error, "failed to get epoch info");
          }
          return res.result;
        }
        /**
         * Fetch the Epoch Schedule parameters
         */
        async getEpochSchedule() {
          const unsafeRes = await this._rpcRequest("getEpochSchedule", []);
          const res = superstruct.create(unsafeRes, GetEpochScheduleRpcResult);
          if ("error" in res) {
            throw new SolanaJSONRPCError(res.error, "failed to get epoch schedule");
          }
          const epochSchedule = res.result;
          return new EpochSchedule(epochSchedule.slotsPerEpoch, epochSchedule.leaderScheduleSlotOffset, epochSchedule.warmup, epochSchedule.firstNormalEpoch, epochSchedule.firstNormalSlot);
        }
        /**
         * Fetch the leader schedule for the current epoch
         * @return {Promise<RpcResponseAndContext<LeaderSchedule>>}
         */
        async getLeaderSchedule() {
          const unsafeRes = await this._rpcRequest("getLeaderSchedule", []);
          const res = superstruct.create(unsafeRes, GetLeaderScheduleRpcResult);
          if ("error" in res) {
            throw new SolanaJSONRPCError(res.error, "failed to get leader schedule");
          }
          return res.result;
        }
        /**
         * Fetch the minimum balance needed to exempt an account of `dataLength`
         * size from rent
         */
        async getMinimumBalanceForRentExemption(dataLength, commitment) {
          const args = this._buildArgs([dataLength], commitment);
          const unsafeRes = await this._rpcRequest("getMinimumBalanceForRentExemption", args);
          const res = superstruct.create(unsafeRes, GetMinimumBalanceForRentExemptionRpcResult);
          if ("error" in res) {
            console.warn("Unable to fetch minimum balance for rent exemption");
            return 0;
          }
          return res.result;
        }
        /**
         * Fetch a recent blockhash from the cluster, return with context
         * @return {Promise<RpcResponseAndContext<{blockhash: Blockhash, feeCalculator: FeeCalculator}>>}
         *
         * @deprecated Deprecated since RPC v1.9.0. Please use {@link getLatestBlockhash} instead.
         */
        async getRecentBlockhashAndContext(commitment) {
          const {
            context,
            value: {
              blockhash
            }
          } = await this.getLatestBlockhashAndContext(commitment);
          const feeCalculator = {
            get lamportsPerSignature() {
              throw new Error("The capability to fetch `lamportsPerSignature` using the `getRecentBlockhash` API is no longer offered by the network. Use the `getFeeForMessage` API to obtain the fee for a given message.");
            },
            toJSON() {
              return {};
            }
          };
          return {
            context,
            value: {
              blockhash,
              feeCalculator
            }
          };
        }
        /**
         * Fetch recent performance samples
         * @return {Promise<Array<PerfSample>>}
         */
        async getRecentPerformanceSamples(limit) {
          const unsafeRes = await this._rpcRequest("getRecentPerformanceSamples", limit ? [limit] : []);
          const res = superstruct.create(unsafeRes, GetRecentPerformanceSamplesRpcResult);
          if ("error" in res) {
            throw new SolanaJSONRPCError(res.error, "failed to get recent performance samples");
          }
          return res.result;
        }
        /**
         * Fetch the fee calculator for a recent blockhash from the cluster, return with context
         *
         * @deprecated Deprecated since RPC v1.9.0. Please use {@link getFeeForMessage} instead.
         */
        async getFeeCalculatorForBlockhash(blockhash, commitment) {
          const args = this._buildArgs([blockhash], commitment);
          const unsafeRes = await this._rpcRequest("getFeeCalculatorForBlockhash", args);
          const res = superstruct.create(unsafeRes, GetFeeCalculatorRpcResult);
          if ("error" in res) {
            throw new SolanaJSONRPCError(res.error, "failed to get fee calculator");
          }
          const {
            context,
            value
          } = res.result;
          return {
            context,
            value: value !== null ? value.feeCalculator : null
          };
        }
        /**
         * Fetch the fee for a message from the cluster, return with context
         */
        async getFeeForMessage(message, commitment) {
          const wireMessage = toBuffer(message.serialize()).toString("base64");
          const args = this._buildArgs([wireMessage], commitment);
          const unsafeRes = await this._rpcRequest("getFeeForMessage", args);
          const res = superstruct.create(unsafeRes, jsonRpcResultAndContext2(superstruct.nullable(superstruct.number())));
          if ("error" in res) {
            throw new SolanaJSONRPCError(res.error, "failed to get fee for message");
          }
          if (res.result === null) {
            throw new Error("invalid blockhash");
          }
          return res.result;
        }
        /**
         * Fetch a list of prioritization fees from recent blocks.
         */
        async getRecentPrioritizationFees(config) {
          const accounts = config?.lockedWritableAccounts?.map((key) => key.toBase58());
          const args = accounts?.length ? [accounts] : [];
          const unsafeRes = await this._rpcRequest("getRecentPrioritizationFees", args);
          const res = superstruct.create(unsafeRes, GetRecentPrioritizationFeesRpcResult);
          if ("error" in res) {
            throw new SolanaJSONRPCError(res.error, "failed to get recent prioritization fees");
          }
          return res.result;
        }
        /**
         * Fetch a recent blockhash from the cluster
         * @return {Promise<{blockhash: Blockhash, feeCalculator: FeeCalculator}>}
         *
         * @deprecated Deprecated since RPC v1.8.0. Please use {@link getLatestBlockhash} instead.
         */
        async getRecentBlockhash(commitment) {
          try {
            const res = await this.getRecentBlockhashAndContext(commitment);
            return res.value;
          } catch (e) {
            throw new Error("failed to get recent blockhash: " + e);
          }
        }
        /**
         * Fetch the latest blockhash from the cluster
         * @return {Promise<BlockhashWithExpiryBlockHeight>}
         */
        async getLatestBlockhash(commitmentOrConfig) {
          try {
            const res = await this.getLatestBlockhashAndContext(commitmentOrConfig);
            return res.value;
          } catch (e) {
            throw new Error("failed to get recent blockhash: " + e);
          }
        }
        /**
         * Fetch the latest blockhash from the cluster
         * @return {Promise<BlockhashWithExpiryBlockHeight>}
         */
        async getLatestBlockhashAndContext(commitmentOrConfig) {
          const {
            commitment,
            config
          } = extractCommitmentFromConfig(commitmentOrConfig);
          const args = this._buildArgs([], commitment, void 0, config);
          const unsafeRes = await this._rpcRequest("getLatestBlockhash", args);
          const res = superstruct.create(unsafeRes, GetLatestBlockhashRpcResult);
          if ("error" in res) {
            throw new SolanaJSONRPCError(res.error, "failed to get latest blockhash");
          }
          return res.result;
        }
        /**
         * Returns whether a blockhash is still valid or not
         */
        async isBlockhashValid(blockhash, rawConfig) {
          const {
            commitment,
            config
          } = extractCommitmentFromConfig(rawConfig);
          const args = this._buildArgs([blockhash], commitment, void 0, config);
          const unsafeRes = await this._rpcRequest("isBlockhashValid", args);
          const res = superstruct.create(unsafeRes, IsBlockhashValidRpcResult);
          if ("error" in res) {
            throw new SolanaJSONRPCError(res.error, "failed to determine if the blockhash `" + blockhash + "`is valid");
          }
          return res.result;
        }
        /**
         * Fetch the node version
         */
        async getVersion() {
          const unsafeRes = await this._rpcRequest("getVersion", []);
          const res = superstruct.create(unsafeRes, jsonRpcResult2(VersionResult));
          if ("error" in res) {
            throw new SolanaJSONRPCError(res.error, "failed to get version");
          }
          return res.result;
        }
        /**
         * Fetch the genesis hash
         */
        async getGenesisHash() {
          const unsafeRes = await this._rpcRequest("getGenesisHash", []);
          const res = superstruct.create(unsafeRes, jsonRpcResult2(superstruct.string()));
          if ("error" in res) {
            throw new SolanaJSONRPCError(res.error, "failed to get genesis hash");
          }
          return res.result;
        }
        /**
         * Fetch a processed block from the cluster.
         *
         * @deprecated Instead, call `getBlock` using a `GetVersionedBlockConfig` by
         * setting the `maxSupportedTransactionVersion` property.
         */
        /**
         * @deprecated Instead, call `getBlock` using a `GetVersionedBlockConfig` by
         * setting the `maxSupportedTransactionVersion` property.
         */
        // eslint-disable-next-line no-dupe-class-members
        /**
         * @deprecated Instead, call `getBlock` using a `GetVersionedBlockConfig` by
         * setting the `maxSupportedTransactionVersion` property.
         */
        // eslint-disable-next-line no-dupe-class-members
        /**
         * Fetch a processed block from the cluster.
         */
        // eslint-disable-next-line no-dupe-class-members
        // eslint-disable-next-line no-dupe-class-members
        // eslint-disable-next-line no-dupe-class-members
        /**
         * Fetch a processed block from the cluster.
         */
        // eslint-disable-next-line no-dupe-class-members
        async getBlock(slot, rawConfig) {
          const {
            commitment,
            config
          } = extractCommitmentFromConfig(rawConfig);
          const args = this._buildArgsAtLeastConfirmed([slot], commitment, void 0, config);
          const unsafeRes = await this._rpcRequest("getBlock", args);
          try {
            switch (config?.transactionDetails) {
              case "accounts": {
                const res = superstruct.create(unsafeRes, GetAccountsModeBlockRpcResult);
                if ("error" in res) {
                  throw res.error;
                }
                return res.result;
              }
              case "none": {
                const res = superstruct.create(unsafeRes, GetNoneModeBlockRpcResult);
                if ("error" in res) {
                  throw res.error;
                }
                return res.result;
              }
              default: {
                const res = superstruct.create(unsafeRes, GetBlockRpcResult);
                if ("error" in res) {
                  throw res.error;
                }
                const {
                  result
                } = res;
                return result ? {
                  ...result,
                  transactions: result.transactions.map(({
                    transaction,
                    meta,
                    version: version2
                  }) => ({
                    meta,
                    transaction: {
                      ...transaction,
                      message: versionedMessageFromResponse(version2, transaction.message)
                    },
                    version: version2
                  }))
                } : null;
              }
            }
          } catch (e) {
            throw new SolanaJSONRPCError(e, "failed to get confirmed block");
          }
        }
        /**
         * Fetch parsed transaction details for a confirmed or finalized block
         */
        // eslint-disable-next-line no-dupe-class-members
        // eslint-disable-next-line no-dupe-class-members
        // eslint-disable-next-line no-dupe-class-members
        async getParsedBlock(slot, rawConfig) {
          const {
            commitment,
            config
          } = extractCommitmentFromConfig(rawConfig);
          const args = this._buildArgsAtLeastConfirmed([slot], commitment, "jsonParsed", config);
          const unsafeRes = await this._rpcRequest("getBlock", args);
          try {
            switch (config?.transactionDetails) {
              case "accounts": {
                const res = superstruct.create(unsafeRes, GetParsedAccountsModeBlockRpcResult);
                if ("error" in res) {
                  throw res.error;
                }
                return res.result;
              }
              case "none": {
                const res = superstruct.create(unsafeRes, GetParsedNoneModeBlockRpcResult);
                if ("error" in res) {
                  throw res.error;
                }
                return res.result;
              }
              default: {
                const res = superstruct.create(unsafeRes, GetParsedBlockRpcResult);
                if ("error" in res) {
                  throw res.error;
                }
                return res.result;
              }
            }
          } catch (e) {
            throw new SolanaJSONRPCError(e, "failed to get block");
          }
        }
        /*
         * Returns recent block production information from the current or previous epoch
         */
        async getBlockProduction(configOrCommitment) {
          let extra;
          let commitment;
          if (typeof configOrCommitment === "string") {
            commitment = configOrCommitment;
          } else if (configOrCommitment) {
            const {
              commitment: c,
              ...rest
            } = configOrCommitment;
            commitment = c;
            extra = rest;
          }
          const args = this._buildArgs([], commitment, "base64", extra);
          const unsafeRes = await this._rpcRequest("getBlockProduction", args);
          const res = superstruct.create(unsafeRes, BlockProductionResponseStruct);
          if ("error" in res) {
            throw new SolanaJSONRPCError(res.error, "failed to get block production information");
          }
          return res.result;
        }
        /**
         * Fetch a confirmed or finalized transaction from the cluster.
         *
         * @deprecated Instead, call `getTransaction` using a
         * `GetVersionedTransactionConfig` by setting the
         * `maxSupportedTransactionVersion` property.
         */
        /**
         * Fetch a confirmed or finalized transaction from the cluster.
         */
        // eslint-disable-next-line no-dupe-class-members
        /**
         * Fetch a confirmed or finalized transaction from the cluster.
         */
        // eslint-disable-next-line no-dupe-class-members
        async getTransaction(signature2, rawConfig) {
          const {
            commitment,
            config
          } = extractCommitmentFromConfig(rawConfig);
          const args = this._buildArgsAtLeastConfirmed([signature2], commitment, void 0, config);
          const unsafeRes = await this._rpcRequest("getTransaction", args);
          const res = superstruct.create(unsafeRes, GetTransactionRpcResult);
          if ("error" in res) {
            throw new SolanaJSONRPCError(res.error, "failed to get transaction");
          }
          const result = res.result;
          if (!result) return result;
          return {
            ...result,
            transaction: {
              ...result.transaction,
              message: versionedMessageFromResponse(result.version, result.transaction.message)
            }
          };
        }
        /**
         * Fetch parsed transaction details for a confirmed or finalized transaction
         */
        async getParsedTransaction(signature2, commitmentOrConfig) {
          const {
            commitment,
            config
          } = extractCommitmentFromConfig(commitmentOrConfig);
          const args = this._buildArgsAtLeastConfirmed([signature2], commitment, "jsonParsed", config);
          const unsafeRes = await this._rpcRequest("getTransaction", args);
          const res = superstruct.create(unsafeRes, GetParsedTransactionRpcResult);
          if ("error" in res) {
            throw new SolanaJSONRPCError(res.error, "failed to get transaction");
          }
          return res.result;
        }
        /**
         * Fetch parsed transaction details for a batch of confirmed transactions
         */
        async getParsedTransactions(signatures, commitmentOrConfig) {
          const {
            commitment,
            config
          } = extractCommitmentFromConfig(commitmentOrConfig);
          const batch = signatures.map((signature2) => {
            const args = this._buildArgsAtLeastConfirmed([signature2], commitment, "jsonParsed", config);
            return {
              methodName: "getTransaction",
              args
            };
          });
          const unsafeRes = await this._rpcBatchRequest(batch);
          const res = unsafeRes.map((unsafeRes2) => {
            const res2 = superstruct.create(unsafeRes2, GetParsedTransactionRpcResult);
            if ("error" in res2) {
              throw new SolanaJSONRPCError(res2.error, "failed to get transactions");
            }
            return res2.result;
          });
          return res;
        }
        /**
         * Fetch transaction details for a batch of confirmed transactions.
         * Similar to {@link getParsedTransactions} but returns a {@link TransactionResponse}.
         *
         * @deprecated Instead, call `getTransactions` using a
         * `GetVersionedTransactionConfig` by setting the
         * `maxSupportedTransactionVersion` property.
         */
        /**
         * Fetch transaction details for a batch of confirmed transactions.
         * Similar to {@link getParsedTransactions} but returns a {@link
         * VersionedTransactionResponse}.
         */
        // eslint-disable-next-line no-dupe-class-members
        /**
         * Fetch transaction details for a batch of confirmed transactions.
         * Similar to {@link getParsedTransactions} but returns a {@link
         * VersionedTransactionResponse}.
         */
        // eslint-disable-next-line no-dupe-class-members
        async getTransactions(signatures, commitmentOrConfig) {
          const {
            commitment,
            config
          } = extractCommitmentFromConfig(commitmentOrConfig);
          const batch = signatures.map((signature2) => {
            const args = this._buildArgsAtLeastConfirmed([signature2], commitment, void 0, config);
            return {
              methodName: "getTransaction",
              args
            };
          });
          const unsafeRes = await this._rpcBatchRequest(batch);
          const res = unsafeRes.map((unsafeRes2) => {
            const res2 = superstruct.create(unsafeRes2, GetTransactionRpcResult);
            if ("error" in res2) {
              throw new SolanaJSONRPCError(res2.error, "failed to get transactions");
            }
            const result = res2.result;
            if (!result) return result;
            return {
              ...result,
              transaction: {
                ...result.transaction,
                message: versionedMessageFromResponse(result.version, result.transaction.message)
              }
            };
          });
          return res;
        }
        /**
         * Fetch a list of Transactions and transaction statuses from the cluster
         * for a confirmed block.
         *
         * @deprecated Deprecated since RPC v1.7.0. Please use {@link getBlock} instead.
         */
        async getConfirmedBlock(slot, commitment) {
          const args = this._buildArgsAtLeastConfirmed([slot], commitment);
          const unsafeRes = await this._rpcRequest("getBlock", args);
          const res = superstruct.create(unsafeRes, GetConfirmedBlockRpcResult);
          if ("error" in res) {
            throw new SolanaJSONRPCError(res.error, "failed to get confirmed block");
          }
          const result = res.result;
          if (!result) {
            throw new Error("Confirmed block " + slot + " not found");
          }
          const block = {
            ...result,
            transactions: result.transactions.map(({
              transaction,
              meta
            }) => {
              const message = new Message(transaction.message);
              return {
                meta,
                transaction: {
                  ...transaction,
                  message
                }
              };
            })
          };
          return {
            ...block,
            transactions: block.transactions.map(({
              transaction,
              meta
            }) => {
              return {
                meta,
                transaction: Transaction2.populate(transaction.message, transaction.signatures)
              };
            })
          };
        }
        /**
         * Fetch confirmed blocks between two slots
         */
        async getBlocks(startSlot, endSlot, commitment) {
          const args = this._buildArgsAtLeastConfirmed(endSlot !== void 0 ? [startSlot, endSlot] : [startSlot], commitment);
          const unsafeRes = await this._rpcRequest("getBlocks", args);
          const res = superstruct.create(unsafeRes, jsonRpcResult2(superstruct.array(superstruct.number())));
          if ("error" in res) {
            throw new SolanaJSONRPCError(res.error, "failed to get blocks");
          }
          return res.result;
        }
        /**
         * Fetch a list of Signatures from the cluster for a block, excluding rewards
         */
        async getBlockSignatures(slot, commitment) {
          const args = this._buildArgsAtLeastConfirmed([slot], commitment, void 0, {
            transactionDetails: "signatures",
            rewards: false
          });
          const unsafeRes = await this._rpcRequest("getBlock", args);
          const res = superstruct.create(unsafeRes, GetBlockSignaturesRpcResult);
          if ("error" in res) {
            throw new SolanaJSONRPCError(res.error, "failed to get block");
          }
          const result = res.result;
          if (!result) {
            throw new Error("Block " + slot + " not found");
          }
          return result;
        }
        /**
         * Fetch a list of Signatures from the cluster for a confirmed block, excluding rewards
         *
         * @deprecated Deprecated since RPC v1.7.0. Please use {@link getBlockSignatures} instead.
         */
        async getConfirmedBlockSignatures(slot, commitment) {
          const args = this._buildArgsAtLeastConfirmed([slot], commitment, void 0, {
            transactionDetails: "signatures",
            rewards: false
          });
          const unsafeRes = await this._rpcRequest("getBlock", args);
          const res = superstruct.create(unsafeRes, GetBlockSignaturesRpcResult);
          if ("error" in res) {
            throw new SolanaJSONRPCError(res.error, "failed to get confirmed block");
          }
          const result = res.result;
          if (!result) {
            throw new Error("Confirmed block " + slot + " not found");
          }
          return result;
        }
        /**
         * Fetch a transaction details for a confirmed transaction
         *
         * @deprecated Deprecated since RPC v1.7.0. Please use {@link getTransaction} instead.
         */
        async getConfirmedTransaction(signature2, commitment) {
          const args = this._buildArgsAtLeastConfirmed([signature2], commitment);
          const unsafeRes = await this._rpcRequest("getTransaction", args);
          const res = superstruct.create(unsafeRes, GetTransactionRpcResult);
          if ("error" in res) {
            throw new SolanaJSONRPCError(res.error, "failed to get transaction");
          }
          const result = res.result;
          if (!result) return result;
          const message = new Message(result.transaction.message);
          const signatures = result.transaction.signatures;
          return {
            ...result,
            transaction: Transaction2.populate(message, signatures)
          };
        }
        /**
         * Fetch parsed transaction details for a confirmed transaction
         *
         * @deprecated Deprecated since RPC v1.7.0. Please use {@link getParsedTransaction} instead.
         */
        async getParsedConfirmedTransaction(signature2, commitment) {
          const args = this._buildArgsAtLeastConfirmed([signature2], commitment, "jsonParsed");
          const unsafeRes = await this._rpcRequest("getTransaction", args);
          const res = superstruct.create(unsafeRes, GetParsedTransactionRpcResult);
          if ("error" in res) {
            throw new SolanaJSONRPCError(res.error, "failed to get confirmed transaction");
          }
          return res.result;
        }
        /**
         * Fetch parsed transaction details for a batch of confirmed transactions
         *
         * @deprecated Deprecated since RPC v1.7.0. Please use {@link getParsedTransactions} instead.
         */
        async getParsedConfirmedTransactions(signatures, commitment) {
          const batch = signatures.map((signature2) => {
            const args = this._buildArgsAtLeastConfirmed([signature2], commitment, "jsonParsed");
            return {
              methodName: "getTransaction",
              args
            };
          });
          const unsafeRes = await this._rpcBatchRequest(batch);
          const res = unsafeRes.map((unsafeRes2) => {
            const res2 = superstruct.create(unsafeRes2, GetParsedTransactionRpcResult);
            if ("error" in res2) {
              throw new SolanaJSONRPCError(res2.error, "failed to get confirmed transactions");
            }
            return res2.result;
          });
          return res;
        }
        /**
         * Fetch a list of all the confirmed signatures for transactions involving an address
         * within a specified slot range. Max range allowed is 10,000 slots.
         *
         * @deprecated Deprecated since RPC v1.3. Please use {@link getConfirmedSignaturesForAddress2} instead.
         *
         * @param address queried address
         * @param startSlot start slot, inclusive
         * @param endSlot end slot, inclusive
         */
        async getConfirmedSignaturesForAddress(address, startSlot, endSlot) {
          let options = {};
          let firstAvailableBlock = await this.getFirstAvailableBlock();
          while (!("until" in options)) {
            startSlot--;
            if (startSlot <= 0 || startSlot < firstAvailableBlock) {
              break;
            }
            try {
              const block = await this.getConfirmedBlockSignatures(startSlot, "finalized");
              if (block.signatures.length > 0) {
                options.until = block.signatures[block.signatures.length - 1].toString();
              }
            } catch (err2) {
              if (err2 instanceof Error && err2.message.includes("skipped")) {
                continue;
              } else {
                throw err2;
              }
            }
          }
          let highestConfirmedRoot = await this.getSlot("finalized");
          while (!("before" in options)) {
            endSlot++;
            if (endSlot > highestConfirmedRoot) {
              break;
            }
            try {
              const block = await this.getConfirmedBlockSignatures(endSlot);
              if (block.signatures.length > 0) {
                options.before = block.signatures[block.signatures.length - 1].toString();
              }
            } catch (err2) {
              if (err2 instanceof Error && err2.message.includes("skipped")) {
                continue;
              } else {
                throw err2;
              }
            }
          }
          const confirmedSignatureInfo = await this.getConfirmedSignaturesForAddress2(address, options);
          return confirmedSignatureInfo.map((info) => info.signature);
        }
        /**
         * Returns confirmed signatures for transactions involving an
         * address backwards in time from the provided signature or most recent confirmed block
         *
         * @deprecated Deprecated since RPC v1.7.0. Please use {@link getSignaturesForAddress} instead.
         */
        async getConfirmedSignaturesForAddress2(address, options, commitment) {
          const args = this._buildArgsAtLeastConfirmed([address.toBase58()], commitment, void 0, options);
          const unsafeRes = await this._rpcRequest("getConfirmedSignaturesForAddress2", args);
          const res = superstruct.create(unsafeRes, GetConfirmedSignaturesForAddress2RpcResult);
          if ("error" in res) {
            throw new SolanaJSONRPCError(res.error, "failed to get confirmed signatures for address");
          }
          return res.result;
        }
        /**
         * Returns confirmed signatures for transactions involving an
         * address backwards in time from the provided signature or most recent confirmed block
         *
         *
         * @param address queried address
         * @param options
         */
        async getSignaturesForAddress(address, options, commitment) {
          const args = this._buildArgsAtLeastConfirmed([address.toBase58()], commitment, void 0, options);
          const unsafeRes = await this._rpcRequest("getSignaturesForAddress", args);
          const res = superstruct.create(unsafeRes, GetSignaturesForAddressRpcResult);
          if ("error" in res) {
            throw new SolanaJSONRPCError(res.error, "failed to get signatures for address");
          }
          return res.result;
        }
        async getAddressLookupTable(accountKey, config) {
          const {
            context,
            value: accountInfo
          } = await this.getAccountInfoAndContext(accountKey, config);
          let value = null;
          if (accountInfo !== null) {
            value = new AddressLookupTableAccount({
              key: accountKey,
              state: AddressLookupTableAccount.deserialize(accountInfo.data)
            });
          }
          return {
            context,
            value
          };
        }
        /**
         * Fetch the contents of a Nonce account from the cluster, return with context
         */
        async getNonceAndContext(nonceAccount, commitmentOrConfig) {
          const {
            context,
            value: accountInfo
          } = await this.getAccountInfoAndContext(nonceAccount, commitmentOrConfig);
          let value = null;
          if (accountInfo !== null) {
            value = NonceAccount.fromAccountData(accountInfo.data);
          }
          return {
            context,
            value
          };
        }
        /**
         * Fetch the contents of a Nonce account from the cluster
         */
        async getNonce(nonceAccount, commitmentOrConfig) {
          return await this.getNonceAndContext(nonceAccount, commitmentOrConfig).then((x) => x.value).catch((e) => {
            throw new Error("failed to get nonce for account " + nonceAccount.toBase58() + ": " + e);
          });
        }
        /**
         * Request an allocation of lamports to the specified address
         *
         * ```typescript
         * import { Connection, PublicKey, LAMPORTS_PER_SOL } from "@solana/web3.js";
         *
         * (async () => {
         *   const connection = new Connection("https://api.testnet.solana.com", "confirmed");
         *   const myAddress = new PublicKey("2nr1bHFT86W9tGnyvmYW4vcHKsQB3sVQfnddasz4kExM");
         *   const signature = await connection.requestAirdrop(myAddress, LAMPORTS_PER_SOL);
         *   await connection.confirmTransaction(signature);
         * })();
         * ```
         */
        async requestAirdrop(to, lamports) {
          const unsafeRes = await this._rpcRequest("requestAirdrop", [to.toBase58(), lamports]);
          const res = superstruct.create(unsafeRes, RequestAirdropRpcResult);
          if ("error" in res) {
            throw new SolanaJSONRPCError(res.error, `airdrop to ${to.toBase58()} failed`);
          }
          return res.result;
        }
        /**
         * @internal
         */
        async _blockhashWithExpiryBlockHeight(disableCache) {
          if (!disableCache) {
            while (this._pollingBlockhash) {
              await sleep(100);
            }
            const timeSinceFetch = Date.now() - this._blockhashInfo.lastFetch;
            const expired = timeSinceFetch >= BLOCKHASH_CACHE_TIMEOUT_MS;
            if (this._blockhashInfo.latestBlockhash !== null && !expired) {
              return this._blockhashInfo.latestBlockhash;
            }
          }
          return await this._pollNewBlockhash();
        }
        /**
         * @internal
         */
        async _pollNewBlockhash() {
          this._pollingBlockhash = true;
          try {
            const startTime = Date.now();
            const cachedLatestBlockhash = this._blockhashInfo.latestBlockhash;
            const cachedBlockhash = cachedLatestBlockhash ? cachedLatestBlockhash.blockhash : null;
            for (let i = 0; i < 50; i++) {
              const latestBlockhash = await this.getLatestBlockhash("finalized");
              if (cachedBlockhash !== latestBlockhash.blockhash) {
                this._blockhashInfo = {
                  latestBlockhash,
                  lastFetch: Date.now(),
                  transactionSignatures: [],
                  simulatedSignatures: []
                };
                return latestBlockhash;
              }
              await sleep(MS_PER_SLOT / 2);
            }
            throw new Error(`Unable to obtain a new blockhash after ${Date.now() - startTime}ms`);
          } finally {
            this._pollingBlockhash = false;
          }
        }
        /**
         * get the stake minimum delegation
         */
        async getStakeMinimumDelegation(config) {
          const {
            commitment,
            config: configArg
          } = extractCommitmentFromConfig(config);
          const args = this._buildArgs([], commitment, "base64", configArg);
          const unsafeRes = await this._rpcRequest("getStakeMinimumDelegation", args);
          const res = superstruct.create(unsafeRes, jsonRpcResultAndContext2(superstruct.number()));
          if ("error" in res) {
            throw new SolanaJSONRPCError(res.error, `failed to get stake minimum delegation`);
          }
          return res.result;
        }
        /**
         * Simulate a transaction
         *
         * @deprecated Instead, call {@link simulateTransaction} with {@link
         * VersionedTransaction} and {@link SimulateTransactionConfig} parameters
         */
        /**
         * Simulate a transaction
         */
        // eslint-disable-next-line no-dupe-class-members
        /**
         * Simulate a transaction
         */
        // eslint-disable-next-line no-dupe-class-members
        async simulateTransaction(transactionOrMessage, configOrSigners, includeAccounts) {
          if ("message" in transactionOrMessage) {
            const versionedTx = transactionOrMessage;
            const wireTransaction2 = versionedTx.serialize();
            const encodedTransaction2 = buffer.Buffer.from(wireTransaction2).toString("base64");
            if (Array.isArray(configOrSigners) || includeAccounts !== void 0) {
              throw new Error("Invalid arguments");
            }
            const config2 = configOrSigners || {};
            config2.encoding = "base64";
            if (!("commitment" in config2)) {
              config2.commitment = this.commitment;
            }
            if (configOrSigners && typeof configOrSigners === "object" && "innerInstructions" in configOrSigners) {
              config2.innerInstructions = configOrSigners.innerInstructions;
            }
            const args2 = [encodedTransaction2, config2];
            const unsafeRes2 = await this._rpcRequest("simulateTransaction", args2);
            const res2 = superstruct.create(unsafeRes2, SimulatedTransactionResponseStruct2);
            if ("error" in res2) {
              throw new Error("failed to simulate transaction: " + res2.error.message);
            }
            return res2.result;
          }
          let transaction;
          if (transactionOrMessage instanceof Transaction2) {
            let originalTx = transactionOrMessage;
            transaction = new Transaction2();
            transaction.feePayer = originalTx.feePayer;
            transaction.instructions = transactionOrMessage.instructions;
            transaction.nonceInfo = originalTx.nonceInfo;
            transaction.signatures = originalTx.signatures;
          } else {
            transaction = Transaction2.populate(transactionOrMessage);
            transaction._message = transaction._json = void 0;
          }
          if (configOrSigners !== void 0 && !Array.isArray(configOrSigners)) {
            throw new Error("Invalid arguments");
          }
          const signers = configOrSigners;
          if (transaction.nonceInfo && signers) {
            transaction.sign(...signers);
          } else {
            let disableCache = this._disableBlockhashCaching;
            for (; ; ) {
              const latestBlockhash = await this._blockhashWithExpiryBlockHeight(disableCache);
              transaction.lastValidBlockHeight = latestBlockhash.lastValidBlockHeight;
              transaction.recentBlockhash = latestBlockhash.blockhash;
              if (!signers) break;
              transaction.sign(...signers);
              if (!transaction.signature) {
                throw new Error("!signature");
              }
              const signature2 = transaction.signature.toString("base64");
              if (!this._blockhashInfo.simulatedSignatures.includes(signature2) && !this._blockhashInfo.transactionSignatures.includes(signature2)) {
                this._blockhashInfo.simulatedSignatures.push(signature2);
                break;
              } else {
                disableCache = true;
              }
            }
          }
          const message = transaction._compile();
          const signData = message.serialize();
          const wireTransaction = transaction._serialize(signData);
          const encodedTransaction = wireTransaction.toString("base64");
          const config = {
            encoding: "base64",
            commitment: this.commitment
          };
          if (includeAccounts) {
            const addresses = (Array.isArray(includeAccounts) ? includeAccounts : message.nonProgramIds()).map((key) => key.toBase58());
            config["accounts"] = {
              encoding: "base64",
              addresses
            };
          }
          if (signers) {
            config.sigVerify = true;
          }
          if (configOrSigners && typeof configOrSigners === "object" && "innerInstructions" in configOrSigners) {
            config.innerInstructions = configOrSigners.innerInstructions;
          }
          const args = [encodedTransaction, config];
          const unsafeRes = await this._rpcRequest("simulateTransaction", args);
          const res = superstruct.create(unsafeRes, SimulatedTransactionResponseStruct2);
          if ("error" in res) {
            let logs;
            if ("data" in res.error) {
              logs = res.error.data.logs;
              if (logs && Array.isArray(logs)) {
                const traceIndent = "\n    ";
                const logTrace = traceIndent + logs.join(traceIndent);
                console.error(res.error.message, logTrace);
              }
            }
            throw new SendTransactionError2({
              action: "simulate",
              signature: "",
              transactionMessage: res.error.message,
              logs
            });
          }
          return res.result;
        }
        /**
         * Sign and send a transaction
         *
         * @deprecated Instead, call {@link sendTransaction} with a {@link
         * VersionedTransaction}
         */
        /**
         * Send a signed transaction
         */
        // eslint-disable-next-line no-dupe-class-members
        /**
         * Sign and send a transaction
         */
        // eslint-disable-next-line no-dupe-class-members
        async sendTransaction(transaction, signersOrOptions, options) {
          if ("version" in transaction) {
            if (signersOrOptions && Array.isArray(signersOrOptions)) {
              throw new Error("Invalid arguments");
            }
            const wireTransaction2 = transaction.serialize();
            return await this.sendRawTransaction(wireTransaction2, signersOrOptions);
          }
          if (signersOrOptions === void 0 || !Array.isArray(signersOrOptions)) {
            throw new Error("Invalid arguments");
          }
          const signers = signersOrOptions;
          if (transaction.nonceInfo) {
            transaction.sign(...signers);
          } else {
            let disableCache = this._disableBlockhashCaching;
            for (; ; ) {
              const latestBlockhash = await this._blockhashWithExpiryBlockHeight(disableCache);
              transaction.lastValidBlockHeight = latestBlockhash.lastValidBlockHeight;
              transaction.recentBlockhash = latestBlockhash.blockhash;
              transaction.sign(...signers);
              if (!transaction.signature) {
                throw new Error("!signature");
              }
              const signature2 = transaction.signature.toString("base64");
              if (!this._blockhashInfo.transactionSignatures.includes(signature2)) {
                this._blockhashInfo.transactionSignatures.push(signature2);
                break;
              } else {
                disableCache = true;
              }
            }
          }
          const wireTransaction = transaction.serialize();
          return await this.sendRawTransaction(wireTransaction, options);
        }
        /**
         * Send a transaction that has already been signed and serialized into the
         * wire format
         */
        async sendRawTransaction(rawTransaction, options) {
          const encodedTransaction = toBuffer(rawTransaction).toString("base64");
          const result = await this.sendEncodedTransaction(encodedTransaction, options);
          return result;
        }
        /**
         * Send a transaction that has already been signed, serialized into the
         * wire format, and encoded as a base64 string
         */
        async sendEncodedTransaction(encodedTransaction, options) {
          const config = {
            encoding: "base64"
          };
          const skipPreflight = options && options.skipPreflight;
          const preflightCommitment = skipPreflight === true ? "processed" : options && options.preflightCommitment || this.commitment;
          if (options && options.maxRetries != null) {
            config.maxRetries = options.maxRetries;
          }
          if (options && options.minContextSlot != null) {
            config.minContextSlot = options.minContextSlot;
          }
          if (skipPreflight) {
            config.skipPreflight = skipPreflight;
          }
          if (preflightCommitment) {
            config.preflightCommitment = preflightCommitment;
          }
          const args = [encodedTransaction, config];
          const unsafeRes = await this._rpcRequest("sendTransaction", args);
          const res = superstruct.create(unsafeRes, SendTransactionRpcResult);
          if ("error" in res) {
            let logs = void 0;
            if ("data" in res.error) {
              logs = res.error.data.logs;
            }
            throw new SendTransactionError2({
              action: skipPreflight ? "send" : "simulate",
              signature: "",
              transactionMessage: res.error.message,
              logs
            });
          }
          return res.result;
        }
        /**
         * @internal
         */
        _wsOnOpen() {
          this._rpcWebSocketConnected = true;
          this._rpcWebSocketHeartbeat = setInterval(() => {
            (async () => {
              try {
                await this._rpcWebSocket.notify("ping");
              } catch {
              }
            })();
          }, 5e3);
          this._updateSubscriptions();
        }
        /**
         * @internal
         */
        _wsOnError(err2) {
          this._rpcWebSocketConnected = false;
          console.error("ws error:", err2.message);
        }
        /**
         * @internal
         */
        _wsOnClose(code) {
          this._rpcWebSocketConnected = false;
          this._rpcWebSocketGeneration = (this._rpcWebSocketGeneration + 1) % Number.MAX_SAFE_INTEGER;
          if (this._rpcWebSocketIdleTimeout) {
            clearTimeout(this._rpcWebSocketIdleTimeout);
            this._rpcWebSocketIdleTimeout = null;
          }
          if (this._rpcWebSocketHeartbeat) {
            clearInterval(this._rpcWebSocketHeartbeat);
            this._rpcWebSocketHeartbeat = null;
          }
          if (code === 1e3) {
            this._updateSubscriptions();
            return;
          }
          this._subscriptionCallbacksByServerSubscriptionId = {};
          Object.entries(this._subscriptionsByHash).forEach(([hash2, subscription]) => {
            this._setSubscription(hash2, {
              ...subscription,
              state: "pending"
            });
          });
        }
        /**
         * @internal
         */
        _setSubscription(hash2, nextSubscription) {
          const prevState = this._subscriptionsByHash[hash2]?.state;
          this._subscriptionsByHash[hash2] = nextSubscription;
          if (prevState !== nextSubscription.state) {
            const stateChangeCallbacks = this._subscriptionStateChangeCallbacksByHash[hash2];
            if (stateChangeCallbacks) {
              stateChangeCallbacks.forEach((cb) => {
                try {
                  cb(nextSubscription.state);
                } catch {
                }
              });
            }
          }
        }
        /**
         * @internal
         */
        _onSubscriptionStateChange(clientSubscriptionId, callback) {
          var _a;
          const hash2 = this._subscriptionHashByClientSubscriptionId[clientSubscriptionId];
          if (hash2 == null) {
            return () => {
            };
          }
          const stateChangeCallbacks = (_a = this._subscriptionStateChangeCallbacksByHash)[hash2] || (_a[hash2] = /* @__PURE__ */ new Set());
          stateChangeCallbacks.add(callback);
          return () => {
            stateChangeCallbacks.delete(callback);
            if (stateChangeCallbacks.size === 0) {
              delete this._subscriptionStateChangeCallbacksByHash[hash2];
            }
          };
        }
        /**
         * @internal
         */
        async _updateSubscriptions() {
          if (Object.keys(this._subscriptionsByHash).length === 0) {
            if (this._rpcWebSocketConnected) {
              this._rpcWebSocketConnected = false;
              this._rpcWebSocketIdleTimeout = setTimeout(() => {
                this._rpcWebSocketIdleTimeout = null;
                try {
                  this._rpcWebSocket.close();
                } catch (err2) {
                  if (err2 instanceof Error) {
                    console.log(`Error when closing socket connection: ${err2.message}`);
                  }
                }
              }, 500);
            }
            return;
          }
          if (this._rpcWebSocketIdleTimeout !== null) {
            clearTimeout(this._rpcWebSocketIdleTimeout);
            this._rpcWebSocketIdleTimeout = null;
            this._rpcWebSocketConnected = true;
          }
          if (!this._rpcWebSocketConnected) {
            this._rpcWebSocket.connect();
            return;
          }
          const activeWebSocketGeneration = this._rpcWebSocketGeneration;
          const isCurrentConnectionStillActive = () => {
            return activeWebSocketGeneration === this._rpcWebSocketGeneration;
          };
          await Promise.all(
            // Don't be tempted to change this to `Object.entries`. We call
            // `_updateSubscriptions` recursively when processing the state,
            // so it's important that we look up the *current* version of
            // each subscription, every time we process a hash.
            Object.keys(this._subscriptionsByHash).map(async (hash2) => {
              const subscription = this._subscriptionsByHash[hash2];
              if (subscription === void 0) {
                return;
              }
              switch (subscription.state) {
                case "pending":
                case "unsubscribed":
                  if (subscription.callbacks.size === 0) {
                    delete this._subscriptionsByHash[hash2];
                    if (subscription.state === "unsubscribed") {
                      delete this._subscriptionCallbacksByServerSubscriptionId[subscription.serverSubscriptionId];
                    }
                    await this._updateSubscriptions();
                    return;
                  }
                  await (async () => {
                    const {
                      args,
                      method
                    } = subscription;
                    try {
                      this._setSubscription(hash2, {
                        ...subscription,
                        state: "subscribing"
                      });
                      const serverSubscriptionId = await this._rpcWebSocket.call(method, args);
                      this._setSubscription(hash2, {
                        ...subscription,
                        serverSubscriptionId,
                        state: "subscribed"
                      });
                      this._subscriptionCallbacksByServerSubscriptionId[serverSubscriptionId] = subscription.callbacks;
                      await this._updateSubscriptions();
                    } catch (e) {
                      console.error(`Received ${e instanceof Error ? "" : "JSON-RPC "}error calling \`${method}\``, {
                        args,
                        error: e
                      });
                      if (!isCurrentConnectionStillActive()) {
                        return;
                      }
                      this._setSubscription(hash2, {
                        ...subscription,
                        state: "pending"
                      });
                      await this._updateSubscriptions();
                    }
                  })();
                  break;
                case "subscribed":
                  if (subscription.callbacks.size === 0) {
                    await (async () => {
                      const {
                        serverSubscriptionId,
                        unsubscribeMethod
                      } = subscription;
                      if (this._subscriptionsAutoDisposedByRpc.has(serverSubscriptionId)) {
                        this._subscriptionsAutoDisposedByRpc.delete(serverSubscriptionId);
                      } else {
                        this._setSubscription(hash2, {
                          ...subscription,
                          state: "unsubscribing"
                        });
                        this._setSubscription(hash2, {
                          ...subscription,
                          state: "unsubscribing"
                        });
                        try {
                          await this._rpcWebSocket.call(unsubscribeMethod, [serverSubscriptionId]);
                        } catch (e) {
                          if (e instanceof Error) {
                            console.error(`${unsubscribeMethod} error:`, e.message);
                          }
                          if (!isCurrentConnectionStillActive()) {
                            return;
                          }
                          this._setSubscription(hash2, {
                            ...subscription,
                            state: "subscribed"
                          });
                          await this._updateSubscriptions();
                          return;
                        }
                      }
                      this._setSubscription(hash2, {
                        ...subscription,
                        state: "unsubscribed"
                      });
                      await this._updateSubscriptions();
                    })();
                  }
                  break;
              }
            })
          );
        }
        /**
         * @internal
         */
        _handleServerNotification(serverSubscriptionId, callbackArgs) {
          const callbacks = this._subscriptionCallbacksByServerSubscriptionId[serverSubscriptionId];
          if (callbacks === void 0) {
            return;
          }
          callbacks.forEach((cb) => {
            try {
              cb(
                ...callbackArgs
              );
            } catch (e) {
              console.error(e);
            }
          });
        }
        /**
         * @internal
         */
        _wsOnAccountNotification(notification) {
          const {
            result,
            subscription
          } = superstruct.create(notification, AccountNotificationResult);
          this._handleServerNotification(subscription, [result.value, result.context]);
        }
        /**
         * @internal
         */
        _makeSubscription(subscriptionConfig, args) {
          const clientSubscriptionId = this._nextClientSubscriptionId++;
          const hash2 = fastStableStringify([subscriptionConfig.method, args]);
          const existingSubscription = this._subscriptionsByHash[hash2];
          if (existingSubscription === void 0) {
            this._subscriptionsByHash[hash2] = {
              ...subscriptionConfig,
              args,
              callbacks: /* @__PURE__ */ new Set([subscriptionConfig.callback]),
              state: "pending"
            };
          } else {
            existingSubscription.callbacks.add(subscriptionConfig.callback);
          }
          this._subscriptionHashByClientSubscriptionId[clientSubscriptionId] = hash2;
          this._subscriptionDisposeFunctionsByClientSubscriptionId[clientSubscriptionId] = async () => {
            delete this._subscriptionDisposeFunctionsByClientSubscriptionId[clientSubscriptionId];
            delete this._subscriptionHashByClientSubscriptionId[clientSubscriptionId];
            const subscription = this._subscriptionsByHash[hash2];
            assert2(subscription !== void 0, `Could not find a \`Subscription\` when tearing down client subscription #${clientSubscriptionId}`);
            subscription.callbacks.delete(subscriptionConfig.callback);
            await this._updateSubscriptions();
          };
          this._updateSubscriptions();
          return clientSubscriptionId;
        }
        /**
         * Register a callback to be invoked whenever the specified account changes
         *
         * @param publicKey Public key of the account to monitor
         * @param callback Function to invoke whenever the account is changed
         * @param config
         * @return subscription id
         */
        /** @deprecated Instead, pass in an {@link AccountSubscriptionConfig} */
        // eslint-disable-next-line no-dupe-class-members
        // eslint-disable-next-line no-dupe-class-members
        onAccountChange(publicKey4, callback, commitmentOrConfig) {
          const {
            commitment,
            config
          } = extractCommitmentFromConfig(commitmentOrConfig);
          const args = this._buildArgs(
            [publicKey4.toBase58()],
            commitment || this._commitment || "finalized",
            // Apply connection/server default.
            "base64",
            config
          );
          return this._makeSubscription({
            callback,
            method: "accountSubscribe",
            unsubscribeMethod: "accountUnsubscribe"
          }, args);
        }
        /**
         * Deregister an account notification callback
         *
         * @param clientSubscriptionId client subscription id to deregister
         */
        async removeAccountChangeListener(clientSubscriptionId) {
          await this._unsubscribeClientSubscription(clientSubscriptionId, "account change");
        }
        /**
         * @internal
         */
        _wsOnProgramAccountNotification(notification) {
          const {
            result,
            subscription
          } = superstruct.create(notification, ProgramAccountNotificationResult);
          this._handleServerNotification(subscription, [{
            accountId: result.value.pubkey,
            accountInfo: result.value.account
          }, result.context]);
        }
        /**
         * Register a callback to be invoked whenever accounts owned by the
         * specified program change
         *
         * @param programId Public key of the program to monitor
         * @param callback Function to invoke whenever the account is changed
         * @param config
         * @return subscription id
         */
        /** @deprecated Instead, pass in a {@link ProgramAccountSubscriptionConfig} */
        // eslint-disable-next-line no-dupe-class-members
        // eslint-disable-next-line no-dupe-class-members
        onProgramAccountChange(programId, callback, commitmentOrConfig, maybeFilters) {
          const {
            commitment,
            config
          } = extractCommitmentFromConfig(commitmentOrConfig);
          const args = this._buildArgs(
            [programId.toBase58()],
            commitment || this._commitment || "finalized",
            // Apply connection/server default.
            "base64",
            config ? config : maybeFilters ? {
              filters: applyDefaultMemcmpEncodingToFilters(maybeFilters)
            } : void 0
            /* extra */
          );
          return this._makeSubscription({
            callback,
            method: "programSubscribe",
            unsubscribeMethod: "programUnsubscribe"
          }, args);
        }
        /**
         * Deregister an account notification callback
         *
         * @param clientSubscriptionId client subscription id to deregister
         */
        async removeProgramAccountChangeListener(clientSubscriptionId) {
          await this._unsubscribeClientSubscription(clientSubscriptionId, "program account change");
        }
        /**
         * Registers a callback to be invoked whenever logs are emitted.
         */
        onLogs(filter, callback, commitment) {
          const args = this._buildArgs(
            [typeof filter === "object" ? {
              mentions: [filter.toString()]
            } : filter],
            commitment || this._commitment || "finalized"
            // Apply connection/server default.
          );
          return this._makeSubscription({
            callback,
            method: "logsSubscribe",
            unsubscribeMethod: "logsUnsubscribe"
          }, args);
        }
        /**
         * Deregister a logs callback.
         *
         * @param clientSubscriptionId client subscription id to deregister.
         */
        async removeOnLogsListener(clientSubscriptionId) {
          await this._unsubscribeClientSubscription(clientSubscriptionId, "logs");
        }
        /**
         * @internal
         */
        _wsOnLogsNotification(notification) {
          const {
            result,
            subscription
          } = superstruct.create(notification, LogsNotificationResult);
          this._handleServerNotification(subscription, [result.value, result.context]);
        }
        /**
         * @internal
         */
        _wsOnSlotNotification(notification) {
          const {
            result,
            subscription
          } = superstruct.create(notification, SlotNotificationResult);
          this._handleServerNotification(subscription, [result]);
        }
        /**
         * Register a callback to be invoked upon slot changes
         *
         * @param callback Function to invoke whenever the slot changes
         * @return subscription id
         */
        onSlotChange(callback) {
          return this._makeSubscription(
            {
              callback,
              method: "slotSubscribe",
              unsubscribeMethod: "slotUnsubscribe"
            },
            []
            /* args */
          );
        }
        /**
         * Deregister a slot notification callback
         *
         * @param clientSubscriptionId client subscription id to deregister
         */
        async removeSlotChangeListener(clientSubscriptionId) {
          await this._unsubscribeClientSubscription(clientSubscriptionId, "slot change");
        }
        /**
         * @internal
         */
        _wsOnSlotUpdatesNotification(notification) {
          const {
            result,
            subscription
          } = superstruct.create(notification, SlotUpdateNotificationResult);
          this._handleServerNotification(subscription, [result]);
        }
        /**
         * Register a callback to be invoked upon slot updates. {@link SlotUpdate}'s
         * may be useful to track live progress of a cluster.
         *
         * @param callback Function to invoke whenever the slot updates
         * @return subscription id
         */
        onSlotUpdate(callback) {
          return this._makeSubscription(
            {
              callback,
              method: "slotsUpdatesSubscribe",
              unsubscribeMethod: "slotsUpdatesUnsubscribe"
            },
            []
            /* args */
          );
        }
        /**
         * Deregister a slot update notification callback
         *
         * @param clientSubscriptionId client subscription id to deregister
         */
        async removeSlotUpdateListener(clientSubscriptionId) {
          await this._unsubscribeClientSubscription(clientSubscriptionId, "slot update");
        }
        /**
         * @internal
         */
        async _unsubscribeClientSubscription(clientSubscriptionId, subscriptionName) {
          const dispose = this._subscriptionDisposeFunctionsByClientSubscriptionId[clientSubscriptionId];
          if (dispose) {
            await dispose();
          } else {
            console.warn(`Ignored unsubscribe request because an active subscription with id \`${clientSubscriptionId}\` for '${subscriptionName}' events could not be found.`);
          }
        }
        _buildArgs(args, override, encoding, extra) {
          const commitment = override || this._commitment;
          if (commitment || encoding || extra) {
            let options = {};
            if (encoding) {
              options.encoding = encoding;
            }
            if (commitment) {
              options.commitment = commitment;
            }
            if (extra) {
              options = Object.assign(options, extra);
            }
            args.push(options);
          }
          return args;
        }
        /**
         * @internal
         */
        _buildArgsAtLeastConfirmed(args, override, encoding, extra) {
          const commitment = override || this._commitment;
          if (commitment && !["confirmed", "finalized"].includes(commitment)) {
            throw new Error("Using Connection with default commitment: `" + this._commitment + "`, but method requires at least `confirmed`");
          }
          return this._buildArgs(args, override, encoding, extra);
        }
        /**
         * @internal
         */
        _wsOnSignatureNotification(notification) {
          const {
            result,
            subscription
          } = superstruct.create(notification, SignatureNotificationResult);
          if (result.value !== "receivedSignature") {
            this._subscriptionsAutoDisposedByRpc.add(subscription);
          }
          this._handleServerNotification(subscription, result.value === "receivedSignature" ? [{
            type: "received"
          }, result.context] : [{
            type: "status",
            result: result.value
          }, result.context]);
        }
        /**
         * Register a callback to be invoked upon signature updates
         *
         * @param signature Transaction signature string in base 58
         * @param callback Function to invoke on signature notifications
         * @param commitment Specify the commitment level signature must reach before notification
         * @return subscription id
         */
        onSignature(signature2, callback, commitment) {
          const args = this._buildArgs(
            [signature2],
            commitment || this._commitment || "finalized"
            // Apply connection/server default.
          );
          const clientSubscriptionId = this._makeSubscription({
            callback: (notification, context) => {
              if (notification.type === "status") {
                callback(notification.result, context);
                try {
                  this.removeSignatureListener(clientSubscriptionId);
                } catch (_err) {
                }
              }
            },
            method: "signatureSubscribe",
            unsubscribeMethod: "signatureUnsubscribe"
          }, args);
          return clientSubscriptionId;
        }
        /**
         * Register a callback to be invoked when a transaction is
         * received and/or processed.
         *
         * @param signature Transaction signature string in base 58
         * @param callback Function to invoke on signature notifications
         * @param options Enable received notifications and set the commitment
         *   level that signature must reach before notification
         * @return subscription id
         */
        onSignatureWithOptions(signature2, callback, options) {
          const {
            commitment,
            ...extra
          } = {
            ...options,
            commitment: options && options.commitment || this._commitment || "finalized"
            // Apply connection/server default.
          };
          const args = this._buildArgs([signature2], commitment, void 0, extra);
          const clientSubscriptionId = this._makeSubscription({
            callback: (notification, context) => {
              callback(notification, context);
              try {
                this.removeSignatureListener(clientSubscriptionId);
              } catch (_err) {
              }
            },
            method: "signatureSubscribe",
            unsubscribeMethod: "signatureUnsubscribe"
          }, args);
          return clientSubscriptionId;
        }
        /**
         * Deregister a signature notification callback
         *
         * @param clientSubscriptionId client subscription id to deregister
         */
        async removeSignatureListener(clientSubscriptionId) {
          await this._unsubscribeClientSubscription(clientSubscriptionId, "signature result");
        }
        /**
         * @internal
         */
        _wsOnRootNotification(notification) {
          const {
            result,
            subscription
          } = superstruct.create(notification, RootNotificationResult);
          this._handleServerNotification(subscription, [result]);
        }
        /**
         * Register a callback to be invoked upon root changes
         *
         * @param callback Function to invoke whenever the root changes
         * @return subscription id
         */
        onRootChange(callback) {
          return this._makeSubscription(
            {
              callback,
              method: "rootSubscribe",
              unsubscribeMethod: "rootUnsubscribe"
            },
            []
            /* args */
          );
        }
        /**
         * Deregister a root notification callback
         *
         * @param clientSubscriptionId client subscription id to deregister
         */
        async removeRootChangeListener(clientSubscriptionId) {
          await this._unsubscribeClientSubscription(clientSubscriptionId, "root change");
        }
      };
      var Keypair = class _Keypair {
        /**
         * Create a new keypair instance.
         * Generate random keypair if no {@link Ed25519Keypair} is provided.
         *
         * @param {Ed25519Keypair} keypair ed25519 keypair
         */
        constructor(keypair) {
          this._keypair = void 0;
          this._keypair = keypair ?? generateKeypair();
        }
        /**
         * Generate a new random keypair
         *
         * @returns {Keypair} Keypair
         */
        static generate() {
          return new _Keypair(generateKeypair());
        }
        /**
         * Create a keypair from a raw secret key byte array.
         *
         * This method should only be used to recreate a keypair from a previously
         * generated secret key. Generating keypairs from a random seed should be done
         * with the {@link Keypair.fromSeed} method.
         *
         * @throws error if the provided secret key is invalid and validation is not skipped.
         *
         * @param secretKey secret key byte array
         * @param options skip secret key validation
         *
         * @returns {Keypair} Keypair
         */
        static fromSecretKey(secretKey, options) {
          if (secretKey.byteLength !== 64) {
            throw new Error("bad secret key size");
          }
          const publicKey4 = secretKey.slice(32, 64);
          if (!options || !options.skipValidation) {
            const privateScalar = secretKey.slice(0, 32);
            const computedPublicKey = getPublicKey(privateScalar);
            for (let ii = 0; ii < 32; ii++) {
              if (publicKey4[ii] !== computedPublicKey[ii]) {
                throw new Error("provided secretKey is invalid");
              }
            }
          }
          return new _Keypair({
            publicKey: publicKey4,
            secretKey
          });
        }
        /**
         * Generate a keypair from a 32 byte seed.
         *
         * @param seed seed byte array
         *
         * @returns {Keypair} Keypair
         */
        static fromSeed(seed2) {
          const publicKey4 = getPublicKey(seed2);
          const secretKey = new Uint8Array(64);
          secretKey.set(seed2);
          secretKey.set(publicKey4, 32);
          return new _Keypair({
            publicKey: publicKey4,
            secretKey
          });
        }
        /**
         * The public key for this keypair
         *
         * @returns {PublicKey} PublicKey
         */
        get publicKey() {
          return new PublicKey2(this._keypair.publicKey);
        }
        /**
         * The raw secret key for this keypair
         * @returns {Uint8Array} Secret key in an array of Uint8 bytes
         */
        get secretKey() {
          return new Uint8Array(this._keypair.secretKey);
        }
      };
      var LOOKUP_TABLE_INSTRUCTION_LAYOUTS = Object.freeze({
        CreateLookupTable: {
          index: 0,
          layout: BufferLayout__namespace.struct([BufferLayout__namespace.u32("instruction"), u643("recentSlot"), BufferLayout__namespace.u8("bumpSeed")])
        },
        FreezeLookupTable: {
          index: 1,
          layout: BufferLayout__namespace.struct([BufferLayout__namespace.u32("instruction")])
        },
        ExtendLookupTable: {
          index: 2,
          layout: BufferLayout__namespace.struct([BufferLayout__namespace.u32("instruction"), u643(), BufferLayout__namespace.seq(publicKey3(), BufferLayout__namespace.offset(BufferLayout__namespace.u32(), -8), "addresses")])
        },
        DeactivateLookupTable: {
          index: 3,
          layout: BufferLayout__namespace.struct([BufferLayout__namespace.u32("instruction")])
        },
        CloseLookupTable: {
          index: 4,
          layout: BufferLayout__namespace.struct([BufferLayout__namespace.u32("instruction")])
        }
      });
      var AddressLookupTableInstruction = class {
        /**
         * @internal
         */
        constructor() {
        }
        static decodeInstructionType(instruction) {
          this.checkProgramId(instruction.programId);
          const instructionTypeLayout = BufferLayout__namespace.u32("instruction");
          const index2 = instructionTypeLayout.decode(instruction.data);
          let type2;
          for (const [layoutType, layout] of Object.entries(LOOKUP_TABLE_INSTRUCTION_LAYOUTS)) {
            if (layout.index == index2) {
              type2 = layoutType;
              break;
            }
          }
          if (!type2) {
            throw new Error("Invalid Instruction. Should be a LookupTable Instruction");
          }
          return type2;
        }
        static decodeCreateLookupTable(instruction) {
          this.checkProgramId(instruction.programId);
          this.checkKeysLength(instruction.keys, 4);
          const {
            recentSlot
          } = decodeData$1(LOOKUP_TABLE_INSTRUCTION_LAYOUTS.CreateLookupTable, instruction.data);
          return {
            authority: instruction.keys[1].pubkey,
            payer: instruction.keys[2].pubkey,
            recentSlot: Number(recentSlot)
          };
        }
        static decodeExtendLookupTable(instruction) {
          this.checkProgramId(instruction.programId);
          if (instruction.keys.length < 2) {
            throw new Error(`invalid instruction; found ${instruction.keys.length} keys, expected at least 2`);
          }
          const {
            addresses
          } = decodeData$1(LOOKUP_TABLE_INSTRUCTION_LAYOUTS.ExtendLookupTable, instruction.data);
          return {
            lookupTable: instruction.keys[0].pubkey,
            authority: instruction.keys[1].pubkey,
            payer: instruction.keys.length > 2 ? instruction.keys[2].pubkey : void 0,
            addresses: addresses.map((buffer2) => new PublicKey2(buffer2))
          };
        }
        static decodeCloseLookupTable(instruction) {
          this.checkProgramId(instruction.programId);
          this.checkKeysLength(instruction.keys, 3);
          return {
            lookupTable: instruction.keys[0].pubkey,
            authority: instruction.keys[1].pubkey,
            recipient: instruction.keys[2].pubkey
          };
        }
        static decodeFreezeLookupTable(instruction) {
          this.checkProgramId(instruction.programId);
          this.checkKeysLength(instruction.keys, 2);
          return {
            lookupTable: instruction.keys[0].pubkey,
            authority: instruction.keys[1].pubkey
          };
        }
        static decodeDeactivateLookupTable(instruction) {
          this.checkProgramId(instruction.programId);
          this.checkKeysLength(instruction.keys, 2);
          return {
            lookupTable: instruction.keys[0].pubkey,
            authority: instruction.keys[1].pubkey
          };
        }
        /**
         * @internal
         */
        static checkProgramId(programId) {
          if (!programId.equals(AddressLookupTableProgram.programId)) {
            throw new Error("invalid instruction; programId is not AddressLookupTable Program");
          }
        }
        /**
         * @internal
         */
        static checkKeysLength(keys, expectedLength) {
          if (keys.length < expectedLength) {
            throw new Error(`invalid instruction; found ${keys.length} keys, expected at least ${expectedLength}`);
          }
        }
      };
      var AddressLookupTableProgram = class {
        /**
         * @internal
         */
        constructor() {
        }
        static createLookupTable(params) {
          const [lookupTableAddress, bumpSeed] = PublicKey2.findProgramAddressSync([params.authority.toBuffer(), codecsNumbers.getU64Encoder().encode(params.recentSlot)], this.programId);
          const type2 = LOOKUP_TABLE_INSTRUCTION_LAYOUTS.CreateLookupTable;
          const data = encodeData2(type2, {
            recentSlot: BigInt(params.recentSlot),
            bumpSeed
          });
          const keys = [{
            pubkey: lookupTableAddress,
            isSigner: false,
            isWritable: true
          }, {
            pubkey: params.authority,
            isSigner: true,
            isWritable: false
          }, {
            pubkey: params.payer,
            isSigner: true,
            isWritable: true
          }, {
            pubkey: SystemProgram2.programId,
            isSigner: false,
            isWritable: false
          }];
          return [new TransactionInstruction2({
            programId: this.programId,
            keys,
            data
          }), lookupTableAddress];
        }
        static freezeLookupTable(params) {
          const type2 = LOOKUP_TABLE_INSTRUCTION_LAYOUTS.FreezeLookupTable;
          const data = encodeData2(type2);
          const keys = [{
            pubkey: params.lookupTable,
            isSigner: false,
            isWritable: true
          }, {
            pubkey: params.authority,
            isSigner: true,
            isWritable: false
          }];
          return new TransactionInstruction2({
            programId: this.programId,
            keys,
            data
          });
        }
        static extendLookupTable(params) {
          const type2 = LOOKUP_TABLE_INSTRUCTION_LAYOUTS.ExtendLookupTable;
          const data = encodeData2(type2, {
            addresses: params.addresses.map((addr) => addr.toBytes())
          });
          const keys = [{
            pubkey: params.lookupTable,
            isSigner: false,
            isWritable: true
          }, {
            pubkey: params.authority,
            isSigner: true,
            isWritable: false
          }];
          if (params.payer) {
            keys.push({
              pubkey: params.payer,
              isSigner: true,
              isWritable: true
            }, {
              pubkey: SystemProgram2.programId,
              isSigner: false,
              isWritable: false
            });
          }
          return new TransactionInstruction2({
            programId: this.programId,
            keys,
            data
          });
        }
        static deactivateLookupTable(params) {
          const type2 = LOOKUP_TABLE_INSTRUCTION_LAYOUTS.DeactivateLookupTable;
          const data = encodeData2(type2);
          const keys = [{
            pubkey: params.lookupTable,
            isSigner: false,
            isWritable: true
          }, {
            pubkey: params.authority,
            isSigner: true,
            isWritable: false
          }];
          return new TransactionInstruction2({
            programId: this.programId,
            keys,
            data
          });
        }
        static closeLookupTable(params) {
          const type2 = LOOKUP_TABLE_INSTRUCTION_LAYOUTS.CloseLookupTable;
          const data = encodeData2(type2);
          const keys = [{
            pubkey: params.lookupTable,
            isSigner: false,
            isWritable: true
          }, {
            pubkey: params.authority,
            isSigner: true,
            isWritable: false
          }, {
            pubkey: params.recipient,
            isSigner: false,
            isWritable: true
          }];
          return new TransactionInstruction2({
            programId: this.programId,
            keys,
            data
          });
        }
      };
      AddressLookupTableProgram.programId = new PublicKey2("AddressLookupTab1e1111111111111111111111111");
      var ComputeBudgetInstruction = class {
        /**
         * @internal
         */
        constructor() {
        }
        /**
         * Decode a compute budget instruction and retrieve the instruction type.
         */
        static decodeInstructionType(instruction) {
          this.checkProgramId(instruction.programId);
          const instructionTypeLayout = BufferLayout__namespace.u8("instruction");
          const typeIndex = instructionTypeLayout.decode(instruction.data);
          let type2;
          for (const [ixType, layout] of Object.entries(COMPUTE_BUDGET_INSTRUCTION_LAYOUTS)) {
            if (layout.index == typeIndex) {
              type2 = ixType;
              break;
            }
          }
          if (!type2) {
            throw new Error("Instruction type incorrect; not a ComputeBudgetInstruction");
          }
          return type2;
        }
        /**
         * Decode request units compute budget instruction and retrieve the instruction params.
         */
        static decodeRequestUnits(instruction) {
          this.checkProgramId(instruction.programId);
          const {
            units,
            additionalFee
          } = decodeData$1(COMPUTE_BUDGET_INSTRUCTION_LAYOUTS.RequestUnits, instruction.data);
          return {
            units,
            additionalFee
          };
        }
        /**
         * Decode request heap frame compute budget instruction and retrieve the instruction params.
         */
        static decodeRequestHeapFrame(instruction) {
          this.checkProgramId(instruction.programId);
          const {
            bytes
          } = decodeData$1(COMPUTE_BUDGET_INSTRUCTION_LAYOUTS.RequestHeapFrame, instruction.data);
          return {
            bytes
          };
        }
        /**
         * Decode set compute unit limit compute budget instruction and retrieve the instruction params.
         */
        static decodeSetComputeUnitLimit(instruction) {
          this.checkProgramId(instruction.programId);
          const {
            units
          } = decodeData$1(COMPUTE_BUDGET_INSTRUCTION_LAYOUTS.SetComputeUnitLimit, instruction.data);
          return {
            units
          };
        }
        /**
         * Decode set compute unit price compute budget instruction and retrieve the instruction params.
         */
        static decodeSetComputeUnitPrice(instruction) {
          this.checkProgramId(instruction.programId);
          const {
            microLamports
          } = decodeData$1(COMPUTE_BUDGET_INSTRUCTION_LAYOUTS.SetComputeUnitPrice, instruction.data);
          return {
            microLamports
          };
        }
        /**
         * @internal
         */
        static checkProgramId(programId) {
          if (!programId.equals(ComputeBudgetProgram.programId)) {
            throw new Error("invalid instruction; programId is not ComputeBudgetProgram");
          }
        }
      };
      var COMPUTE_BUDGET_INSTRUCTION_LAYOUTS = Object.freeze({
        RequestUnits: {
          index: 0,
          layout: BufferLayout__namespace.struct([BufferLayout__namespace.u8("instruction"), BufferLayout__namespace.u32("units"), BufferLayout__namespace.u32("additionalFee")])
        },
        RequestHeapFrame: {
          index: 1,
          layout: BufferLayout__namespace.struct([BufferLayout__namespace.u8("instruction"), BufferLayout__namespace.u32("bytes")])
        },
        SetComputeUnitLimit: {
          index: 2,
          layout: BufferLayout__namespace.struct([BufferLayout__namespace.u8("instruction"), BufferLayout__namespace.u32("units")])
        },
        SetComputeUnitPrice: {
          index: 3,
          layout: BufferLayout__namespace.struct([BufferLayout__namespace.u8("instruction"), u643("microLamports")])
        }
      });
      var ComputeBudgetProgram = class {
        /**
         * @internal
         */
        constructor() {
        }
        /**
         * Public key that identifies the Compute Budget program
         */
        /**
         * @deprecated Instead, call {@link setComputeUnitLimit} and/or {@link setComputeUnitPrice}
         */
        static requestUnits(params) {
          const type2 = COMPUTE_BUDGET_INSTRUCTION_LAYOUTS.RequestUnits;
          const data = encodeData2(type2, params);
          return new TransactionInstruction2({
            keys: [],
            programId: this.programId,
            data
          });
        }
        static requestHeapFrame(params) {
          const type2 = COMPUTE_BUDGET_INSTRUCTION_LAYOUTS.RequestHeapFrame;
          const data = encodeData2(type2, params);
          return new TransactionInstruction2({
            keys: [],
            programId: this.programId,
            data
          });
        }
        static setComputeUnitLimit(params) {
          const type2 = COMPUTE_BUDGET_INSTRUCTION_LAYOUTS.SetComputeUnitLimit;
          const data = encodeData2(type2, params);
          return new TransactionInstruction2({
            keys: [],
            programId: this.programId,
            data
          });
        }
        static setComputeUnitPrice(params) {
          const type2 = COMPUTE_BUDGET_INSTRUCTION_LAYOUTS.SetComputeUnitPrice;
          const data = encodeData2(type2, {
            microLamports: BigInt(params.microLamports)
          });
          return new TransactionInstruction2({
            keys: [],
            programId: this.programId,
            data
          });
        }
      };
      ComputeBudgetProgram.programId = new PublicKey2("ComputeBudget111111111111111111111111111111");
      var PRIVATE_KEY_BYTES$1 = 64;
      var PUBLIC_KEY_BYTES$1 = 32;
      var SIGNATURE_BYTES = 64;
      var ED25519_INSTRUCTION_LAYOUT = BufferLayout__namespace.struct([BufferLayout__namespace.u8("numSignatures"), BufferLayout__namespace.u8("padding"), BufferLayout__namespace.u16("signatureOffset"), BufferLayout__namespace.u16("signatureInstructionIndex"), BufferLayout__namespace.u16("publicKeyOffset"), BufferLayout__namespace.u16("publicKeyInstructionIndex"), BufferLayout__namespace.u16("messageDataOffset"), BufferLayout__namespace.u16("messageDataSize"), BufferLayout__namespace.u16("messageInstructionIndex")]);
      var Ed25519Program = class _Ed25519Program {
        /**
         * @internal
         */
        constructor() {
        }
        /**
         * Public key that identifies the ed25519 program
         */
        /**
         * Create an ed25519 instruction with a public key and signature. The
         * public key must be a buffer that is 32 bytes long, and the signature
         * must be a buffer of 64 bytes.
         */
        static createInstructionWithPublicKey(params) {
          const {
            publicKey: publicKey4,
            message,
            signature: signature2,
            instructionIndex
          } = params;
          assert2(publicKey4.length === PUBLIC_KEY_BYTES$1, `Public Key must be ${PUBLIC_KEY_BYTES$1} bytes but received ${publicKey4.length} bytes`);
          assert2(signature2.length === SIGNATURE_BYTES, `Signature must be ${SIGNATURE_BYTES} bytes but received ${signature2.length} bytes`);
          const publicKeyOffset = ED25519_INSTRUCTION_LAYOUT.span;
          const signatureOffset = publicKeyOffset + publicKey4.length;
          const messageDataOffset = signatureOffset + signature2.length;
          const numSignatures = 1;
          const instructionData = buffer.Buffer.alloc(messageDataOffset + message.length);
          const index2 = instructionIndex == null ? 65535 : instructionIndex;
          ED25519_INSTRUCTION_LAYOUT.encode({
            numSignatures,
            padding: 0,
            signatureOffset,
            signatureInstructionIndex: index2,
            publicKeyOffset,
            publicKeyInstructionIndex: index2,
            messageDataOffset,
            messageDataSize: message.length,
            messageInstructionIndex: index2
          }, instructionData);
          instructionData.fill(publicKey4, publicKeyOffset);
          instructionData.fill(signature2, signatureOffset);
          instructionData.fill(message, messageDataOffset);
          return new TransactionInstruction2({
            keys: [],
            programId: _Ed25519Program.programId,
            data: instructionData
          });
        }
        /**
         * Create an ed25519 instruction with a private key. The private key
         * must be a buffer that is 64 bytes long.
         */
        static createInstructionWithPrivateKey(params) {
          const {
            privateKey,
            message,
            instructionIndex
          } = params;
          assert2(privateKey.length === PRIVATE_KEY_BYTES$1, `Private key must be ${PRIVATE_KEY_BYTES$1} bytes but received ${privateKey.length} bytes`);
          try {
            const keypair = Keypair.fromSecretKey(privateKey);
            const publicKey4 = keypair.publicKey.toBytes();
            const signature2 = sign(message, keypair.secretKey);
            return this.createInstructionWithPublicKey({
              publicKey: publicKey4,
              message,
              signature: signature2,
              instructionIndex
            });
          } catch (error) {
            throw new Error(`Error creating instruction; ${error}`);
          }
        }
      };
      Ed25519Program.programId = new PublicKey2("Ed25519SigVerify111111111111111111111111111");
      var ecdsaSign = (msgHash, privKey) => {
        const signature2 = secp256k1.secp256k1.sign(msgHash, privKey);
        return [signature2.toCompactRawBytes(), signature2.recovery];
      };
      secp256k1.secp256k1.utils.isValidPrivateKey;
      var publicKeyCreate = secp256k1.secp256k1.getPublicKey;
      var PRIVATE_KEY_BYTES = 32;
      var ETHEREUM_ADDRESS_BYTES = 20;
      var PUBLIC_KEY_BYTES = 64;
      var SIGNATURE_OFFSETS_SERIALIZED_SIZE = 11;
      var SECP256K1_INSTRUCTION_LAYOUT = BufferLayout__namespace.struct([BufferLayout__namespace.u8("numSignatures"), BufferLayout__namespace.u16("signatureOffset"), BufferLayout__namespace.u8("signatureInstructionIndex"), BufferLayout__namespace.u16("ethAddressOffset"), BufferLayout__namespace.u8("ethAddressInstructionIndex"), BufferLayout__namespace.u16("messageDataOffset"), BufferLayout__namespace.u16("messageDataSize"), BufferLayout__namespace.u8("messageInstructionIndex"), BufferLayout__namespace.blob(20, "ethAddress"), BufferLayout__namespace.blob(64, "signature"), BufferLayout__namespace.u8("recoveryId")]);
      var Secp256k1Program = class _Secp256k1Program {
        /**
         * @internal
         */
        constructor() {
        }
        /**
         * Public key that identifies the secp256k1 program
         */
        /**
         * Construct an Ethereum address from a secp256k1 public key buffer.
         * @param {Buffer} publicKey a 64 byte secp256k1 public key buffer
         */
        static publicKeyToEthAddress(publicKey4) {
          assert2(publicKey4.length === PUBLIC_KEY_BYTES, `Public key must be ${PUBLIC_KEY_BYTES} bytes but received ${publicKey4.length} bytes`);
          try {
            return buffer.Buffer.from(sha3.keccak_256(toBuffer(publicKey4))).slice(-ETHEREUM_ADDRESS_BYTES);
          } catch (error) {
            throw new Error(`Error constructing Ethereum address: ${error}`);
          }
        }
        /**
         * Create an secp256k1 instruction with a public key. The public key
         * must be a buffer that is 64 bytes long.
         */
        static createInstructionWithPublicKey(params) {
          const {
            publicKey: publicKey4,
            message,
            signature: signature2,
            recoveryId,
            instructionIndex
          } = params;
          return _Secp256k1Program.createInstructionWithEthAddress({
            ethAddress: _Secp256k1Program.publicKeyToEthAddress(publicKey4),
            message,
            signature: signature2,
            recoveryId,
            instructionIndex
          });
        }
        /**
         * Create an secp256k1 instruction with an Ethereum address. The address
         * must be a hex string or a buffer that is 20 bytes long.
         */
        static createInstructionWithEthAddress(params) {
          const {
            ethAddress: rawAddress,
            message,
            signature: signature2,
            recoveryId,
            instructionIndex = 0
          } = params;
          let ethAddress;
          if (typeof rawAddress === "string") {
            if (rawAddress.startsWith("0x")) {
              ethAddress = buffer.Buffer.from(rawAddress.substr(2), "hex");
            } else {
              ethAddress = buffer.Buffer.from(rawAddress, "hex");
            }
          } else {
            ethAddress = rawAddress;
          }
          assert2(ethAddress.length === ETHEREUM_ADDRESS_BYTES, `Address must be ${ETHEREUM_ADDRESS_BYTES} bytes but received ${ethAddress.length} bytes`);
          const dataStart = 1 + SIGNATURE_OFFSETS_SERIALIZED_SIZE;
          const ethAddressOffset = dataStart;
          const signatureOffset = dataStart + ethAddress.length;
          const messageDataOffset = signatureOffset + signature2.length + 1;
          const numSignatures = 1;
          const instructionData = buffer.Buffer.alloc(SECP256K1_INSTRUCTION_LAYOUT.span + message.length);
          SECP256K1_INSTRUCTION_LAYOUT.encode({
            numSignatures,
            signatureOffset,
            signatureInstructionIndex: instructionIndex,
            ethAddressOffset,
            ethAddressInstructionIndex: instructionIndex,
            messageDataOffset,
            messageDataSize: message.length,
            messageInstructionIndex: instructionIndex,
            signature: toBuffer(signature2),
            ethAddress: toBuffer(ethAddress),
            recoveryId
          }, instructionData);
          instructionData.fill(toBuffer(message), SECP256K1_INSTRUCTION_LAYOUT.span);
          return new TransactionInstruction2({
            keys: [],
            programId: _Secp256k1Program.programId,
            data: instructionData
          });
        }
        /**
         * Create an secp256k1 instruction with a private key. The private key
         * must be a buffer that is 32 bytes long.
         */
        static createInstructionWithPrivateKey(params) {
          const {
            privateKey: pkey,
            message,
            instructionIndex
          } = params;
          assert2(pkey.length === PRIVATE_KEY_BYTES, `Private key must be ${PRIVATE_KEY_BYTES} bytes but received ${pkey.length} bytes`);
          try {
            const privateKey = toBuffer(pkey);
            const publicKey4 = publicKeyCreate(
              privateKey,
              false
              /* isCompressed */
            ).slice(1);
            const messageHash = buffer.Buffer.from(sha3.keccak_256(toBuffer(message)));
            const [signature2, recoveryId] = ecdsaSign(messageHash, privateKey);
            return this.createInstructionWithPublicKey({
              publicKey: publicKey4,
              message,
              signature: signature2,
              recoveryId,
              instructionIndex
            });
          } catch (error) {
            throw new Error(`Error creating instruction; ${error}`);
          }
        }
      };
      Secp256k1Program.programId = new PublicKey2("KeccakSecp256k11111111111111111111111111111");
      var _Lockup;
      var STAKE_CONFIG_ID = new PublicKey2("StakeConfig11111111111111111111111111111111");
      var Authorized = class {
        /**
         * Create a new Authorized object
         * @param staker the stake authority
         * @param withdrawer the withdraw authority
         */
        constructor(staker, withdrawer) {
          this.staker = void 0;
          this.withdrawer = void 0;
          this.staker = staker;
          this.withdrawer = withdrawer;
        }
      };
      var Lockup = class {
        /**
         * Create a new Lockup object
         */
        constructor(unixTimestamp, epoch, custodian) {
          this.unixTimestamp = void 0;
          this.epoch = void 0;
          this.custodian = void 0;
          this.unixTimestamp = unixTimestamp;
          this.epoch = epoch;
          this.custodian = custodian;
        }
        /**
         * Default, inactive Lockup value
         */
      };
      _Lockup = Lockup;
      Lockup.default = new _Lockup(0, 0, PublicKey2.default);
      var StakeInstruction = class {
        /**
         * @internal
         */
        constructor() {
        }
        /**
         * Decode a stake instruction and retrieve the instruction type.
         */
        static decodeInstructionType(instruction) {
          this.checkProgramId(instruction.programId);
          const instructionTypeLayout = BufferLayout__namespace.u32("instruction");
          const typeIndex = instructionTypeLayout.decode(instruction.data);
          let type2;
          for (const [ixType, layout] of Object.entries(STAKE_INSTRUCTION_LAYOUTS)) {
            if (layout.index == typeIndex) {
              type2 = ixType;
              break;
            }
          }
          if (!type2) {
            throw new Error("Instruction type incorrect; not a StakeInstruction");
          }
          return type2;
        }
        /**
         * Decode a initialize stake instruction and retrieve the instruction params.
         */
        static decodeInitialize(instruction) {
          this.checkProgramId(instruction.programId);
          this.checkKeyLength(instruction.keys, 2);
          const {
            authorized: authorized2,
            lockup: lockup2
          } = decodeData$1(STAKE_INSTRUCTION_LAYOUTS.Initialize, instruction.data);
          return {
            stakePubkey: instruction.keys[0].pubkey,
            authorized: new Authorized(new PublicKey2(authorized2.staker), new PublicKey2(authorized2.withdrawer)),
            lockup: new Lockup(lockup2.unixTimestamp, lockup2.epoch, new PublicKey2(lockup2.custodian))
          };
        }
        /**
         * Decode a delegate stake instruction and retrieve the instruction params.
         */
        static decodeDelegate(instruction) {
          this.checkProgramId(instruction.programId);
          this.checkKeyLength(instruction.keys, 6);
          decodeData$1(STAKE_INSTRUCTION_LAYOUTS.Delegate, instruction.data);
          return {
            stakePubkey: instruction.keys[0].pubkey,
            votePubkey: instruction.keys[1].pubkey,
            authorizedPubkey: instruction.keys[5].pubkey
          };
        }
        /**
         * Decode an authorize stake instruction and retrieve the instruction params.
         */
        static decodeAuthorize(instruction) {
          this.checkProgramId(instruction.programId);
          this.checkKeyLength(instruction.keys, 3);
          const {
            newAuthorized,
            stakeAuthorizationType
          } = decodeData$1(STAKE_INSTRUCTION_LAYOUTS.Authorize, instruction.data);
          const o = {
            stakePubkey: instruction.keys[0].pubkey,
            authorizedPubkey: instruction.keys[2].pubkey,
            newAuthorizedPubkey: new PublicKey2(newAuthorized),
            stakeAuthorizationType: {
              index: stakeAuthorizationType
            }
          };
          if (instruction.keys.length > 3) {
            o.custodianPubkey = instruction.keys[3].pubkey;
          }
          return o;
        }
        /**
         * Decode an authorize-with-seed stake instruction and retrieve the instruction params.
         */
        static decodeAuthorizeWithSeed(instruction) {
          this.checkProgramId(instruction.programId);
          this.checkKeyLength(instruction.keys, 2);
          const {
            newAuthorized,
            stakeAuthorizationType,
            authoritySeed,
            authorityOwner
          } = decodeData$1(STAKE_INSTRUCTION_LAYOUTS.AuthorizeWithSeed, instruction.data);
          const o = {
            stakePubkey: instruction.keys[0].pubkey,
            authorityBase: instruction.keys[1].pubkey,
            authoritySeed,
            authorityOwner: new PublicKey2(authorityOwner),
            newAuthorizedPubkey: new PublicKey2(newAuthorized),
            stakeAuthorizationType: {
              index: stakeAuthorizationType
            }
          };
          if (instruction.keys.length > 3) {
            o.custodianPubkey = instruction.keys[3].pubkey;
          }
          return o;
        }
        /**
         * Decode a split stake instruction and retrieve the instruction params.
         */
        static decodeSplit(instruction) {
          this.checkProgramId(instruction.programId);
          this.checkKeyLength(instruction.keys, 3);
          const {
            lamports
          } = decodeData$1(STAKE_INSTRUCTION_LAYOUTS.Split, instruction.data);
          return {
            stakePubkey: instruction.keys[0].pubkey,
            splitStakePubkey: instruction.keys[1].pubkey,
            authorizedPubkey: instruction.keys[2].pubkey,
            lamports
          };
        }
        /**
         * Decode a merge stake instruction and retrieve the instruction params.
         */
        static decodeMerge(instruction) {
          this.checkProgramId(instruction.programId);
          this.checkKeyLength(instruction.keys, 3);
          decodeData$1(STAKE_INSTRUCTION_LAYOUTS.Merge, instruction.data);
          return {
            stakePubkey: instruction.keys[0].pubkey,
            sourceStakePubKey: instruction.keys[1].pubkey,
            authorizedPubkey: instruction.keys[4].pubkey
          };
        }
        /**
         * Decode a withdraw stake instruction and retrieve the instruction params.
         */
        static decodeWithdraw(instruction) {
          this.checkProgramId(instruction.programId);
          this.checkKeyLength(instruction.keys, 5);
          const {
            lamports
          } = decodeData$1(STAKE_INSTRUCTION_LAYOUTS.Withdraw, instruction.data);
          const o = {
            stakePubkey: instruction.keys[0].pubkey,
            toPubkey: instruction.keys[1].pubkey,
            authorizedPubkey: instruction.keys[4].pubkey,
            lamports
          };
          if (instruction.keys.length > 5) {
            o.custodianPubkey = instruction.keys[5].pubkey;
          }
          return o;
        }
        /**
         * Decode a deactivate stake instruction and retrieve the instruction params.
         */
        static decodeDeactivate(instruction) {
          this.checkProgramId(instruction.programId);
          this.checkKeyLength(instruction.keys, 3);
          decodeData$1(STAKE_INSTRUCTION_LAYOUTS.Deactivate, instruction.data);
          return {
            stakePubkey: instruction.keys[0].pubkey,
            authorizedPubkey: instruction.keys[2].pubkey
          };
        }
        /**
         * @internal
         */
        static checkProgramId(programId) {
          if (!programId.equals(StakeProgram.programId)) {
            throw new Error("invalid instruction; programId is not StakeProgram");
          }
        }
        /**
         * @internal
         */
        static checkKeyLength(keys, expectedLength) {
          if (keys.length < expectedLength) {
            throw new Error(`invalid instruction; found ${keys.length} keys, expected at least ${expectedLength}`);
          }
        }
      };
      var STAKE_INSTRUCTION_LAYOUTS = Object.freeze({
        Initialize: {
          index: 0,
          layout: BufferLayout__namespace.struct([BufferLayout__namespace.u32("instruction"), authorized(), lockup()])
        },
        Authorize: {
          index: 1,
          layout: BufferLayout__namespace.struct([BufferLayout__namespace.u32("instruction"), publicKey3("newAuthorized"), BufferLayout__namespace.u32("stakeAuthorizationType")])
        },
        Delegate: {
          index: 2,
          layout: BufferLayout__namespace.struct([BufferLayout__namespace.u32("instruction")])
        },
        Split: {
          index: 3,
          layout: BufferLayout__namespace.struct([BufferLayout__namespace.u32("instruction"), BufferLayout__namespace.ns64("lamports")])
        },
        Withdraw: {
          index: 4,
          layout: BufferLayout__namespace.struct([BufferLayout__namespace.u32("instruction"), BufferLayout__namespace.ns64("lamports")])
        },
        Deactivate: {
          index: 5,
          layout: BufferLayout__namespace.struct([BufferLayout__namespace.u32("instruction")])
        },
        Merge: {
          index: 7,
          layout: BufferLayout__namespace.struct([BufferLayout__namespace.u32("instruction")])
        },
        AuthorizeWithSeed: {
          index: 8,
          layout: BufferLayout__namespace.struct([BufferLayout__namespace.u32("instruction"), publicKey3("newAuthorized"), BufferLayout__namespace.u32("stakeAuthorizationType"), rustString("authoritySeed"), publicKey3("authorityOwner")])
        }
      });
      var StakeAuthorizationLayout = Object.freeze({
        Staker: {
          index: 0
        },
        Withdrawer: {
          index: 1
        }
      });
      var StakeProgram = class {
        /**
         * @internal
         */
        constructor() {
        }
        /**
         * Public key that identifies the Stake program
         */
        /**
         * Generate an Initialize instruction to add to a Stake Create transaction
         */
        static initialize(params) {
          const {
            stakePubkey,
            authorized: authorized2,
            lockup: maybeLockup
          } = params;
          const lockup2 = maybeLockup || Lockup.default;
          const type2 = STAKE_INSTRUCTION_LAYOUTS.Initialize;
          const data = encodeData2(type2, {
            authorized: {
              staker: toBuffer(authorized2.staker.toBuffer()),
              withdrawer: toBuffer(authorized2.withdrawer.toBuffer())
            },
            lockup: {
              unixTimestamp: lockup2.unixTimestamp,
              epoch: lockup2.epoch,
              custodian: toBuffer(lockup2.custodian.toBuffer())
            }
          });
          const instructionData = {
            keys: [{
              pubkey: stakePubkey,
              isSigner: false,
              isWritable: true
            }, {
              pubkey: SYSVAR_RENT_PUBKEY2,
              isSigner: false,
              isWritable: false
            }],
            programId: this.programId,
            data
          };
          return new TransactionInstruction2(instructionData);
        }
        /**
         * Generate a Transaction that creates a new Stake account at
         *   an address generated with `from`, a seed, and the Stake programId
         */
        static createAccountWithSeed(params) {
          const transaction = new Transaction2();
          transaction.add(SystemProgram2.createAccountWithSeed({
            fromPubkey: params.fromPubkey,
            newAccountPubkey: params.stakePubkey,
            basePubkey: params.basePubkey,
            seed: params.seed,
            lamports: params.lamports,
            space: this.space,
            programId: this.programId
          }));
          const {
            stakePubkey,
            authorized: authorized2,
            lockup: lockup2
          } = params;
          return transaction.add(this.initialize({
            stakePubkey,
            authorized: authorized2,
            lockup: lockup2
          }));
        }
        /**
         * Generate a Transaction that creates a new Stake account
         */
        static createAccount(params) {
          const transaction = new Transaction2();
          transaction.add(SystemProgram2.createAccount({
            fromPubkey: params.fromPubkey,
            newAccountPubkey: params.stakePubkey,
            lamports: params.lamports,
            space: this.space,
            programId: this.programId
          }));
          const {
            stakePubkey,
            authorized: authorized2,
            lockup: lockup2
          } = params;
          return transaction.add(this.initialize({
            stakePubkey,
            authorized: authorized2,
            lockup: lockup2
          }));
        }
        /**
         * Generate a Transaction that delegates Stake tokens to a validator
         * Vote PublicKey. This transaction can also be used to redelegate Stake
         * to a new validator Vote PublicKey.
         */
        static delegate(params) {
          const {
            stakePubkey,
            authorizedPubkey,
            votePubkey
          } = params;
          const type2 = STAKE_INSTRUCTION_LAYOUTS.Delegate;
          const data = encodeData2(type2);
          return new Transaction2().add({
            keys: [{
              pubkey: stakePubkey,
              isSigner: false,
              isWritable: true
            }, {
              pubkey: votePubkey,
              isSigner: false,
              isWritable: false
            }, {
              pubkey: SYSVAR_CLOCK_PUBKEY2,
              isSigner: false,
              isWritable: false
            }, {
              pubkey: SYSVAR_STAKE_HISTORY_PUBKEY,
              isSigner: false,
              isWritable: false
            }, {
              pubkey: STAKE_CONFIG_ID,
              isSigner: false,
              isWritable: false
            }, {
              pubkey: authorizedPubkey,
              isSigner: true,
              isWritable: false
            }],
            programId: this.programId,
            data
          });
        }
        /**
         * Generate a Transaction that authorizes a new PublicKey as Staker
         * or Withdrawer on the Stake account.
         */
        static authorize(params) {
          const {
            stakePubkey,
            authorizedPubkey,
            newAuthorizedPubkey,
            stakeAuthorizationType,
            custodianPubkey
          } = params;
          const type2 = STAKE_INSTRUCTION_LAYOUTS.Authorize;
          const data = encodeData2(type2, {
            newAuthorized: toBuffer(newAuthorizedPubkey.toBuffer()),
            stakeAuthorizationType: stakeAuthorizationType.index
          });
          const keys = [{
            pubkey: stakePubkey,
            isSigner: false,
            isWritable: true
          }, {
            pubkey: SYSVAR_CLOCK_PUBKEY2,
            isSigner: false,
            isWritable: true
          }, {
            pubkey: authorizedPubkey,
            isSigner: true,
            isWritable: false
          }];
          if (custodianPubkey) {
            keys.push({
              pubkey: custodianPubkey,
              isSigner: true,
              isWritable: false
            });
          }
          return new Transaction2().add({
            keys,
            programId: this.programId,
            data
          });
        }
        /**
         * Generate a Transaction that authorizes a new PublicKey as Staker
         * or Withdrawer on the Stake account.
         */
        static authorizeWithSeed(params) {
          const {
            stakePubkey,
            authorityBase,
            authoritySeed,
            authorityOwner,
            newAuthorizedPubkey,
            stakeAuthorizationType,
            custodianPubkey
          } = params;
          const type2 = STAKE_INSTRUCTION_LAYOUTS.AuthorizeWithSeed;
          const data = encodeData2(type2, {
            newAuthorized: toBuffer(newAuthorizedPubkey.toBuffer()),
            stakeAuthorizationType: stakeAuthorizationType.index,
            authoritySeed,
            authorityOwner: toBuffer(authorityOwner.toBuffer())
          });
          const keys = [{
            pubkey: stakePubkey,
            isSigner: false,
            isWritable: true
          }, {
            pubkey: authorityBase,
            isSigner: true,
            isWritable: false
          }, {
            pubkey: SYSVAR_CLOCK_PUBKEY2,
            isSigner: false,
            isWritable: false
          }];
          if (custodianPubkey) {
            keys.push({
              pubkey: custodianPubkey,
              isSigner: true,
              isWritable: false
            });
          }
          return new Transaction2().add({
            keys,
            programId: this.programId,
            data
          });
        }
        /**
         * @internal
         */
        static splitInstruction(params) {
          const {
            stakePubkey,
            authorizedPubkey,
            splitStakePubkey,
            lamports
          } = params;
          const type2 = STAKE_INSTRUCTION_LAYOUTS.Split;
          const data = encodeData2(type2, {
            lamports
          });
          return new TransactionInstruction2({
            keys: [{
              pubkey: stakePubkey,
              isSigner: false,
              isWritable: true
            }, {
              pubkey: splitStakePubkey,
              isSigner: false,
              isWritable: true
            }, {
              pubkey: authorizedPubkey,
              isSigner: true,
              isWritable: false
            }],
            programId: this.programId,
            data
          });
        }
        /**
         * Generate a Transaction that splits Stake tokens into another stake account
         */
        static split(params, rentExemptReserve) {
          const transaction = new Transaction2();
          transaction.add(SystemProgram2.createAccount({
            fromPubkey: params.authorizedPubkey,
            newAccountPubkey: params.splitStakePubkey,
            lamports: rentExemptReserve,
            space: this.space,
            programId: this.programId
          }));
          return transaction.add(this.splitInstruction(params));
        }
        /**
         * Generate a Transaction that splits Stake tokens into another account
         * derived from a base public key and seed
         */
        static splitWithSeed(params, rentExemptReserve) {
          const {
            stakePubkey,
            authorizedPubkey,
            splitStakePubkey,
            basePubkey,
            seed: seed2,
            lamports
          } = params;
          const transaction = new Transaction2();
          transaction.add(SystemProgram2.allocate({
            accountPubkey: splitStakePubkey,
            basePubkey,
            seed: seed2,
            space: this.space,
            programId: this.programId
          }));
          if (rentExemptReserve && rentExemptReserve > 0) {
            transaction.add(SystemProgram2.transfer({
              fromPubkey: params.authorizedPubkey,
              toPubkey: splitStakePubkey,
              lamports: rentExemptReserve
            }));
          }
          return transaction.add(this.splitInstruction({
            stakePubkey,
            authorizedPubkey,
            splitStakePubkey,
            lamports
          }));
        }
        /**
         * Generate a Transaction that merges Stake accounts.
         */
        static merge(params) {
          const {
            stakePubkey,
            sourceStakePubKey,
            authorizedPubkey
          } = params;
          const type2 = STAKE_INSTRUCTION_LAYOUTS.Merge;
          const data = encodeData2(type2);
          return new Transaction2().add({
            keys: [{
              pubkey: stakePubkey,
              isSigner: false,
              isWritable: true
            }, {
              pubkey: sourceStakePubKey,
              isSigner: false,
              isWritable: true
            }, {
              pubkey: SYSVAR_CLOCK_PUBKEY2,
              isSigner: false,
              isWritable: false
            }, {
              pubkey: SYSVAR_STAKE_HISTORY_PUBKEY,
              isSigner: false,
              isWritable: false
            }, {
              pubkey: authorizedPubkey,
              isSigner: true,
              isWritable: false
            }],
            programId: this.programId,
            data
          });
        }
        /**
         * Generate a Transaction that withdraws deactivated Stake tokens.
         */
        static withdraw(params) {
          const {
            stakePubkey,
            authorizedPubkey,
            toPubkey,
            lamports,
            custodianPubkey
          } = params;
          const type2 = STAKE_INSTRUCTION_LAYOUTS.Withdraw;
          const data = encodeData2(type2, {
            lamports
          });
          const keys = [{
            pubkey: stakePubkey,
            isSigner: false,
            isWritable: true
          }, {
            pubkey: toPubkey,
            isSigner: false,
            isWritable: true
          }, {
            pubkey: SYSVAR_CLOCK_PUBKEY2,
            isSigner: false,
            isWritable: false
          }, {
            pubkey: SYSVAR_STAKE_HISTORY_PUBKEY,
            isSigner: false,
            isWritable: false
          }, {
            pubkey: authorizedPubkey,
            isSigner: true,
            isWritable: false
          }];
          if (custodianPubkey) {
            keys.push({
              pubkey: custodianPubkey,
              isSigner: true,
              isWritable: false
            });
          }
          return new Transaction2().add({
            keys,
            programId: this.programId,
            data
          });
        }
        /**
         * Generate a Transaction that deactivates Stake tokens.
         */
        static deactivate(params) {
          const {
            stakePubkey,
            authorizedPubkey
          } = params;
          const type2 = STAKE_INSTRUCTION_LAYOUTS.Deactivate;
          const data = encodeData2(type2);
          return new Transaction2().add({
            keys: [{
              pubkey: stakePubkey,
              isSigner: false,
              isWritable: true
            }, {
              pubkey: SYSVAR_CLOCK_PUBKEY2,
              isSigner: false,
              isWritable: false
            }, {
              pubkey: authorizedPubkey,
              isSigner: true,
              isWritable: false
            }],
            programId: this.programId,
            data
          });
        }
      };
      StakeProgram.programId = new PublicKey2("Stake11111111111111111111111111111111111111");
      StakeProgram.space = 200;
      var VoteInit = class {
        /** [0, 100] */
        constructor(nodePubkey, authorizedVoter, authorizedWithdrawer, commission) {
          this.nodePubkey = void 0;
          this.authorizedVoter = void 0;
          this.authorizedWithdrawer = void 0;
          this.commission = void 0;
          this.nodePubkey = nodePubkey;
          this.authorizedVoter = authorizedVoter;
          this.authorizedWithdrawer = authorizedWithdrawer;
          this.commission = commission;
        }
      };
      var VoteInstruction = class {
        /**
         * @internal
         */
        constructor() {
        }
        /**
         * Decode a vote instruction and retrieve the instruction type.
         */
        static decodeInstructionType(instruction) {
          this.checkProgramId(instruction.programId);
          const instructionTypeLayout = BufferLayout__namespace.u32("instruction");
          const typeIndex = instructionTypeLayout.decode(instruction.data);
          let type2;
          for (const [ixType, layout] of Object.entries(VOTE_INSTRUCTION_LAYOUTS)) {
            if (layout.index == typeIndex) {
              type2 = ixType;
              break;
            }
          }
          if (!type2) {
            throw new Error("Instruction type incorrect; not a VoteInstruction");
          }
          return type2;
        }
        /**
         * Decode an initialize vote instruction and retrieve the instruction params.
         */
        static decodeInitializeAccount(instruction) {
          this.checkProgramId(instruction.programId);
          this.checkKeyLength(instruction.keys, 4);
          const {
            voteInit: voteInit2
          } = decodeData$1(VOTE_INSTRUCTION_LAYOUTS.InitializeAccount, instruction.data);
          return {
            votePubkey: instruction.keys[0].pubkey,
            nodePubkey: instruction.keys[3].pubkey,
            voteInit: new VoteInit(new PublicKey2(voteInit2.nodePubkey), new PublicKey2(voteInit2.authorizedVoter), new PublicKey2(voteInit2.authorizedWithdrawer), voteInit2.commission)
          };
        }
        /**
         * Decode an authorize instruction and retrieve the instruction params.
         */
        static decodeAuthorize(instruction) {
          this.checkProgramId(instruction.programId);
          this.checkKeyLength(instruction.keys, 3);
          const {
            newAuthorized,
            voteAuthorizationType
          } = decodeData$1(VOTE_INSTRUCTION_LAYOUTS.Authorize, instruction.data);
          return {
            votePubkey: instruction.keys[0].pubkey,
            authorizedPubkey: instruction.keys[2].pubkey,
            newAuthorizedPubkey: new PublicKey2(newAuthorized),
            voteAuthorizationType: {
              index: voteAuthorizationType
            }
          };
        }
        /**
         * Decode an authorize instruction and retrieve the instruction params.
         */
        static decodeAuthorizeWithSeed(instruction) {
          this.checkProgramId(instruction.programId);
          this.checkKeyLength(instruction.keys, 3);
          const {
            voteAuthorizeWithSeedArgs: {
              currentAuthorityDerivedKeyOwnerPubkey,
              currentAuthorityDerivedKeySeed,
              newAuthorized,
              voteAuthorizationType
            }
          } = decodeData$1(VOTE_INSTRUCTION_LAYOUTS.AuthorizeWithSeed, instruction.data);
          return {
            currentAuthorityDerivedKeyBasePubkey: instruction.keys[2].pubkey,
            currentAuthorityDerivedKeyOwnerPubkey: new PublicKey2(currentAuthorityDerivedKeyOwnerPubkey),
            currentAuthorityDerivedKeySeed,
            newAuthorizedPubkey: new PublicKey2(newAuthorized),
            voteAuthorizationType: {
              index: voteAuthorizationType
            },
            votePubkey: instruction.keys[0].pubkey
          };
        }
        /**
         * Decode a withdraw instruction and retrieve the instruction params.
         */
        static decodeWithdraw(instruction) {
          this.checkProgramId(instruction.programId);
          this.checkKeyLength(instruction.keys, 3);
          const {
            lamports
          } = decodeData$1(VOTE_INSTRUCTION_LAYOUTS.Withdraw, instruction.data);
          return {
            votePubkey: instruction.keys[0].pubkey,
            authorizedWithdrawerPubkey: instruction.keys[2].pubkey,
            lamports,
            toPubkey: instruction.keys[1].pubkey
          };
        }
        /**
         * @internal
         */
        static checkProgramId(programId) {
          if (!programId.equals(VoteProgram.programId)) {
            throw new Error("invalid instruction; programId is not VoteProgram");
          }
        }
        /**
         * @internal
         */
        static checkKeyLength(keys, expectedLength) {
          if (keys.length < expectedLength) {
            throw new Error(`invalid instruction; found ${keys.length} keys, expected at least ${expectedLength}`);
          }
        }
      };
      var VOTE_INSTRUCTION_LAYOUTS = Object.freeze({
        InitializeAccount: {
          index: 0,
          layout: BufferLayout__namespace.struct([BufferLayout__namespace.u32("instruction"), voteInit()])
        },
        Authorize: {
          index: 1,
          layout: BufferLayout__namespace.struct([BufferLayout__namespace.u32("instruction"), publicKey3("newAuthorized"), BufferLayout__namespace.u32("voteAuthorizationType")])
        },
        Withdraw: {
          index: 3,
          layout: BufferLayout__namespace.struct([BufferLayout__namespace.u32("instruction"), BufferLayout__namespace.ns64("lamports")])
        },
        UpdateValidatorIdentity: {
          index: 4,
          layout: BufferLayout__namespace.struct([BufferLayout__namespace.u32("instruction")])
        },
        AuthorizeWithSeed: {
          index: 10,
          layout: BufferLayout__namespace.struct([BufferLayout__namespace.u32("instruction"), voteAuthorizeWithSeedArgs()])
        }
      });
      var VoteAuthorizationLayout = Object.freeze({
        Voter: {
          index: 0
        },
        Withdrawer: {
          index: 1
        }
      });
      var VoteProgram = class _VoteProgram {
        /**
         * @internal
         */
        constructor() {
        }
        /**
         * Public key that identifies the Vote program
         */
        /**
         * Generate an Initialize instruction.
         */
        static initializeAccount(params) {
          const {
            votePubkey,
            nodePubkey,
            voteInit: voteInit2
          } = params;
          const type2 = VOTE_INSTRUCTION_LAYOUTS.InitializeAccount;
          const data = encodeData2(type2, {
            voteInit: {
              nodePubkey: toBuffer(voteInit2.nodePubkey.toBuffer()),
              authorizedVoter: toBuffer(voteInit2.authorizedVoter.toBuffer()),
              authorizedWithdrawer: toBuffer(voteInit2.authorizedWithdrawer.toBuffer()),
              commission: voteInit2.commission
            }
          });
          const instructionData = {
            keys: [{
              pubkey: votePubkey,
              isSigner: false,
              isWritable: true
            }, {
              pubkey: SYSVAR_RENT_PUBKEY2,
              isSigner: false,
              isWritable: false
            }, {
              pubkey: SYSVAR_CLOCK_PUBKEY2,
              isSigner: false,
              isWritable: false
            }, {
              pubkey: nodePubkey,
              isSigner: true,
              isWritable: false
            }],
            programId: this.programId,
            data
          };
          return new TransactionInstruction2(instructionData);
        }
        /**
         * Generate a transaction that creates a new Vote account.
         */
        static createAccount(params) {
          const transaction = new Transaction2();
          transaction.add(SystemProgram2.createAccount({
            fromPubkey: params.fromPubkey,
            newAccountPubkey: params.votePubkey,
            lamports: params.lamports,
            space: this.space,
            programId: this.programId
          }));
          return transaction.add(this.initializeAccount({
            votePubkey: params.votePubkey,
            nodePubkey: params.voteInit.nodePubkey,
            voteInit: params.voteInit
          }));
        }
        /**
         * Generate a transaction that authorizes a new Voter or Withdrawer on the Vote account.
         */
        static authorize(params) {
          const {
            votePubkey,
            authorizedPubkey,
            newAuthorizedPubkey,
            voteAuthorizationType
          } = params;
          const type2 = VOTE_INSTRUCTION_LAYOUTS.Authorize;
          const data = encodeData2(type2, {
            newAuthorized: toBuffer(newAuthorizedPubkey.toBuffer()),
            voteAuthorizationType: voteAuthorizationType.index
          });
          const keys = [{
            pubkey: votePubkey,
            isSigner: false,
            isWritable: true
          }, {
            pubkey: SYSVAR_CLOCK_PUBKEY2,
            isSigner: false,
            isWritable: false
          }, {
            pubkey: authorizedPubkey,
            isSigner: true,
            isWritable: false
          }];
          return new Transaction2().add({
            keys,
            programId: this.programId,
            data
          });
        }
        /**
         * Generate a transaction that authorizes a new Voter or Withdrawer on the Vote account
         * where the current Voter or Withdrawer authority is a derived key.
         */
        static authorizeWithSeed(params) {
          const {
            currentAuthorityDerivedKeyBasePubkey,
            currentAuthorityDerivedKeyOwnerPubkey,
            currentAuthorityDerivedKeySeed,
            newAuthorizedPubkey,
            voteAuthorizationType,
            votePubkey
          } = params;
          const type2 = VOTE_INSTRUCTION_LAYOUTS.AuthorizeWithSeed;
          const data = encodeData2(type2, {
            voteAuthorizeWithSeedArgs: {
              currentAuthorityDerivedKeyOwnerPubkey: toBuffer(currentAuthorityDerivedKeyOwnerPubkey.toBuffer()),
              currentAuthorityDerivedKeySeed,
              newAuthorized: toBuffer(newAuthorizedPubkey.toBuffer()),
              voteAuthorizationType: voteAuthorizationType.index
            }
          });
          const keys = [{
            pubkey: votePubkey,
            isSigner: false,
            isWritable: true
          }, {
            pubkey: SYSVAR_CLOCK_PUBKEY2,
            isSigner: false,
            isWritable: false
          }, {
            pubkey: currentAuthorityDerivedKeyBasePubkey,
            isSigner: true,
            isWritable: false
          }];
          return new Transaction2().add({
            keys,
            programId: this.programId,
            data
          });
        }
        /**
         * Generate a transaction to withdraw from a Vote account.
         */
        static withdraw(params) {
          const {
            votePubkey,
            authorizedWithdrawerPubkey,
            lamports,
            toPubkey
          } = params;
          const type2 = VOTE_INSTRUCTION_LAYOUTS.Withdraw;
          const data = encodeData2(type2, {
            lamports
          });
          const keys = [{
            pubkey: votePubkey,
            isSigner: false,
            isWritable: true
          }, {
            pubkey: toPubkey,
            isSigner: false,
            isWritable: true
          }, {
            pubkey: authorizedWithdrawerPubkey,
            isSigner: true,
            isWritable: false
          }];
          return new Transaction2().add({
            keys,
            programId: this.programId,
            data
          });
        }
        /**
         * Generate a transaction to withdraw safely from a Vote account.
         *
         * This function was created as a safeguard for vote accounts running validators, `safeWithdraw`
         * checks that the withdraw amount will not exceed the specified balance while leaving enough left
         * to cover rent. If you wish to close the vote account by withdrawing the full amount, call the
         * `withdraw` method directly.
         */
        static safeWithdraw(params, currentVoteAccountBalance, rentExemptMinimum) {
          if (params.lamports > currentVoteAccountBalance - rentExemptMinimum) {
            throw new Error("Withdraw will leave vote account with insufficient funds.");
          }
          return _VoteProgram.withdraw(params);
        }
        /**
         * Generate a transaction to update the validator identity (node pubkey) of a Vote account.
         */
        static updateValidatorIdentity(params) {
          const {
            votePubkey,
            authorizedWithdrawerPubkey,
            nodePubkey
          } = params;
          const type2 = VOTE_INSTRUCTION_LAYOUTS.UpdateValidatorIdentity;
          const data = encodeData2(type2);
          const keys = [{
            pubkey: votePubkey,
            isSigner: false,
            isWritable: true
          }, {
            pubkey: nodePubkey,
            isSigner: true,
            isWritable: false
          }, {
            pubkey: authorizedWithdrawerPubkey,
            isSigner: true,
            isWritable: false
          }];
          return new Transaction2().add({
            keys,
            programId: this.programId,
            data
          });
        }
      };
      VoteProgram.programId = new PublicKey2("Vote111111111111111111111111111111111111111");
      VoteProgram.space = 3762;
      var VALIDATOR_INFO_KEY = new PublicKey2("Va1idator1nfo111111111111111111111111111111");
      var InfoString = superstruct.type({
        name: superstruct.string(),
        website: superstruct.optional(superstruct.string()),
        details: superstruct.optional(superstruct.string()),
        iconUrl: superstruct.optional(superstruct.string()),
        keybaseUsername: superstruct.optional(superstruct.string())
      });
      var ValidatorInfo = class _ValidatorInfo {
        /**
         * Construct a valid ValidatorInfo
         *
         * @param key validator public key
         * @param info validator information
         */
        constructor(key, info) {
          this.key = void 0;
          this.info = void 0;
          this.key = key;
          this.info = info;
        }
        /**
         * Deserialize ValidatorInfo from the config account data. Exactly two config
         * keys are required in the data.
         *
         * @param buffer config account data
         * @return null if info was not found
         */
        static fromConfigData(buffer$1) {
          let byteArray = [...buffer$1];
          const configKeyCount = decodeLength(byteArray);
          if (configKeyCount !== 2) return null;
          const configKeys = [];
          for (let i = 0; i < 2; i++) {
            const publicKey4 = new PublicKey2(guardedSplice(byteArray, 0, PUBLIC_KEY_LENGTH));
            const isSigner = guardedShift(byteArray) === 1;
            configKeys.push({
              publicKey: publicKey4,
              isSigner
            });
          }
          if (configKeys[0].publicKey.equals(VALIDATOR_INFO_KEY)) {
            if (configKeys[1].isSigner) {
              const rawInfo = rustString().decode(buffer.Buffer.from(byteArray));
              const info = JSON.parse(rawInfo);
              superstruct.assert(info, InfoString);
              return new _ValidatorInfo(configKeys[1].publicKey, info);
            }
          }
          return null;
        }
      };
      var VOTE_PROGRAM_ID = new PublicKey2("Vote111111111111111111111111111111111111111");
      var VoteAccountLayout = BufferLayout__namespace.struct([
        publicKey3("nodePubkey"),
        publicKey3("authorizedWithdrawer"),
        BufferLayout__namespace.u8("commission"),
        BufferLayout__namespace.nu64(),
        // votes.length
        BufferLayout__namespace.seq(BufferLayout__namespace.struct([BufferLayout__namespace.nu64("slot"), BufferLayout__namespace.u32("confirmationCount")]), BufferLayout__namespace.offset(BufferLayout__namespace.u32(), -8), "votes"),
        BufferLayout__namespace.u8("rootSlotValid"),
        BufferLayout__namespace.nu64("rootSlot"),
        BufferLayout__namespace.nu64(),
        // authorizedVoters.length
        BufferLayout__namespace.seq(BufferLayout__namespace.struct([BufferLayout__namespace.nu64("epoch"), publicKey3("authorizedVoter")]), BufferLayout__namespace.offset(BufferLayout__namespace.u32(), -8), "authorizedVoters"),
        BufferLayout__namespace.struct([BufferLayout__namespace.seq(BufferLayout__namespace.struct([publicKey3("authorizedPubkey"), BufferLayout__namespace.nu64("epochOfLastAuthorizedSwitch"), BufferLayout__namespace.nu64("targetEpoch")]), 32, "buf"), BufferLayout__namespace.nu64("idx"), BufferLayout__namespace.u8("isEmpty")], "priorVoters"),
        BufferLayout__namespace.nu64(),
        // epochCredits.length
        BufferLayout__namespace.seq(BufferLayout__namespace.struct([BufferLayout__namespace.nu64("epoch"), BufferLayout__namespace.nu64("credits"), BufferLayout__namespace.nu64("prevCredits")]), BufferLayout__namespace.offset(BufferLayout__namespace.u32(), -8), "epochCredits"),
        BufferLayout__namespace.struct([BufferLayout__namespace.nu64("slot"), BufferLayout__namespace.nu64("timestamp")], "lastTimestamp")
      ]);
      var VoteAccount = class _VoteAccount {
        /**
         * @internal
         */
        constructor(args) {
          this.nodePubkey = void 0;
          this.authorizedWithdrawer = void 0;
          this.commission = void 0;
          this.rootSlot = void 0;
          this.votes = void 0;
          this.authorizedVoters = void 0;
          this.priorVoters = void 0;
          this.epochCredits = void 0;
          this.lastTimestamp = void 0;
          this.nodePubkey = args.nodePubkey;
          this.authorizedWithdrawer = args.authorizedWithdrawer;
          this.commission = args.commission;
          this.rootSlot = args.rootSlot;
          this.votes = args.votes;
          this.authorizedVoters = args.authorizedVoters;
          this.priorVoters = args.priorVoters;
          this.epochCredits = args.epochCredits;
          this.lastTimestamp = args.lastTimestamp;
        }
        /**
         * Deserialize VoteAccount from the account data.
         *
         * @param buffer account data
         * @return VoteAccount
         */
        static fromAccountData(buffer2) {
          const versionOffset = 4;
          const va = VoteAccountLayout.decode(toBuffer(buffer2), versionOffset);
          let rootSlot = va.rootSlot;
          if (!va.rootSlotValid) {
            rootSlot = null;
          }
          return new _VoteAccount({
            nodePubkey: new PublicKey2(va.nodePubkey),
            authorizedWithdrawer: new PublicKey2(va.authorizedWithdrawer),
            commission: va.commission,
            votes: va.votes,
            rootSlot,
            authorizedVoters: va.authorizedVoters.map(parseAuthorizedVoter),
            priorVoters: getPriorVoters(va.priorVoters),
            epochCredits: va.epochCredits,
            lastTimestamp: va.lastTimestamp
          });
        }
      };
      function parseAuthorizedVoter({
        authorizedVoter,
        epoch
      }) {
        return {
          epoch,
          authorizedVoter: new PublicKey2(authorizedVoter)
        };
      }
      function parsePriorVoters({
        authorizedPubkey,
        epochOfLastAuthorizedSwitch,
        targetEpoch
      }) {
        return {
          authorizedPubkey: new PublicKey2(authorizedPubkey),
          epochOfLastAuthorizedSwitch,
          targetEpoch
        };
      }
      function getPriorVoters({
        buf,
        idx,
        isEmpty
      }) {
        if (isEmpty) {
          return [];
        }
        return [...buf.slice(idx + 1).map(parsePriorVoters), ...buf.slice(0, idx).map(parsePriorVoters)];
      }
      var endpoint = {
        http: {
          devnet: "http://api.devnet.solana.com",
          testnet: "http://api.testnet.solana.com",
          "mainnet-beta": "http://api.mainnet-beta.solana.com/"
        },
        https: {
          devnet: "https://api.devnet.solana.com",
          testnet: "https://api.testnet.solana.com",
          "mainnet-beta": "https://api.mainnet-beta.solana.com/"
        }
      };
      function clusterApiUrl(cluster, tls) {
        const key = tls === false ? "http" : "https";
        if (!cluster) {
          return endpoint[key]["devnet"];
        }
        const url = endpoint[key][cluster];
        if (!url) {
          throw new Error(`Unknown ${key} cluster: ${cluster}`);
        }
        return url;
      }
      async function sendAndConfirmRawTransaction2(connection, rawTransaction, confirmationStrategyOrConfirmOptions, maybeConfirmOptions) {
        let confirmationStrategy;
        let options;
        if (confirmationStrategyOrConfirmOptions && Object.prototype.hasOwnProperty.call(confirmationStrategyOrConfirmOptions, "lastValidBlockHeight")) {
          confirmationStrategy = confirmationStrategyOrConfirmOptions;
          options = maybeConfirmOptions;
        } else if (confirmationStrategyOrConfirmOptions && Object.prototype.hasOwnProperty.call(confirmationStrategyOrConfirmOptions, "nonceValue")) {
          confirmationStrategy = confirmationStrategyOrConfirmOptions;
          options = maybeConfirmOptions;
        } else {
          options = confirmationStrategyOrConfirmOptions;
        }
        const sendOptions = options && {
          skipPreflight: options.skipPreflight,
          preflightCommitment: options.preflightCommitment || options.commitment,
          minContextSlot: options.minContextSlot
        };
        const signature2 = await connection.sendRawTransaction(rawTransaction, sendOptions);
        const commitment = options && options.commitment;
        const confirmationPromise = confirmationStrategy ? connection.confirmTransaction(confirmationStrategy, commitment) : connection.confirmTransaction(signature2, commitment);
        const status = (await confirmationPromise).value;
        if (status.err) {
          if (signature2 != null) {
            throw new SendTransactionError2({
              action: sendOptions?.skipPreflight ? "send" : "simulate",
              signature: signature2,
              transactionMessage: `Status: (${JSON.stringify(status)})`
            });
          }
          throw new Error(`Raw transaction ${signature2} failed (${JSON.stringify(status)})`);
        }
        return signature2;
      }
      var LAMPORTS_PER_SOL = 1e9;
      exports.Account = Account;
      exports.AddressLookupTableAccount = AddressLookupTableAccount;
      exports.AddressLookupTableInstruction = AddressLookupTableInstruction;
      exports.AddressLookupTableProgram = AddressLookupTableProgram;
      exports.Authorized = Authorized;
      exports.BLOCKHASH_CACHE_TIMEOUT_MS = BLOCKHASH_CACHE_TIMEOUT_MS;
      exports.BPF_LOADER_DEPRECATED_PROGRAM_ID = BPF_LOADER_DEPRECATED_PROGRAM_ID;
      exports.BPF_LOADER_PROGRAM_ID = BPF_LOADER_PROGRAM_ID;
      exports.BpfLoader = BpfLoader;
      exports.COMPUTE_BUDGET_INSTRUCTION_LAYOUTS = COMPUTE_BUDGET_INSTRUCTION_LAYOUTS;
      exports.ComputeBudgetInstruction = ComputeBudgetInstruction;
      exports.ComputeBudgetProgram = ComputeBudgetProgram;
      exports.Connection = Connection;
      exports.Ed25519Program = Ed25519Program;
      exports.Enum = Enum;
      exports.EpochSchedule = EpochSchedule;
      exports.FeeCalculatorLayout = FeeCalculatorLayout;
      exports.Keypair = Keypair;
      exports.LAMPORTS_PER_SOL = LAMPORTS_PER_SOL;
      exports.LOOKUP_TABLE_INSTRUCTION_LAYOUTS = LOOKUP_TABLE_INSTRUCTION_LAYOUTS;
      exports.Loader = Loader;
      exports.Lockup = Lockup;
      exports.MAX_SEED_LENGTH = MAX_SEED_LENGTH;
      exports.Message = Message;
      exports.MessageAccountKeys = MessageAccountKeys;
      exports.MessageV0 = MessageV0;
      exports.NONCE_ACCOUNT_LENGTH = NONCE_ACCOUNT_LENGTH2;
      exports.NonceAccount = NonceAccount;
      exports.PACKET_DATA_SIZE = PACKET_DATA_SIZE;
      exports.PUBLIC_KEY_LENGTH = PUBLIC_KEY_LENGTH;
      exports.PublicKey = PublicKey2;
      exports.SIGNATURE_LENGTH_IN_BYTES = SIGNATURE_LENGTH_IN_BYTES;
      exports.SOLANA_SCHEMA = SOLANA_SCHEMA;
      exports.STAKE_CONFIG_ID = STAKE_CONFIG_ID;
      exports.STAKE_INSTRUCTION_LAYOUTS = STAKE_INSTRUCTION_LAYOUTS;
      exports.SYSTEM_INSTRUCTION_LAYOUTS = SYSTEM_INSTRUCTION_LAYOUTS;
      exports.SYSVAR_CLOCK_PUBKEY = SYSVAR_CLOCK_PUBKEY2;
      exports.SYSVAR_EPOCH_SCHEDULE_PUBKEY = SYSVAR_EPOCH_SCHEDULE_PUBKEY;
      exports.SYSVAR_INSTRUCTIONS_PUBKEY = SYSVAR_INSTRUCTIONS_PUBKEY;
      exports.SYSVAR_RECENT_BLOCKHASHES_PUBKEY = SYSVAR_RECENT_BLOCKHASHES_PUBKEY;
      exports.SYSVAR_RENT_PUBKEY = SYSVAR_RENT_PUBKEY2;
      exports.SYSVAR_REWARDS_PUBKEY = SYSVAR_REWARDS_PUBKEY;
      exports.SYSVAR_SLOT_HASHES_PUBKEY = SYSVAR_SLOT_HASHES_PUBKEY;
      exports.SYSVAR_SLOT_HISTORY_PUBKEY = SYSVAR_SLOT_HISTORY_PUBKEY;
      exports.SYSVAR_STAKE_HISTORY_PUBKEY = SYSVAR_STAKE_HISTORY_PUBKEY;
      exports.Secp256k1Program = Secp256k1Program;
      exports.SendTransactionError = SendTransactionError2;
      exports.SolanaJSONRPCError = SolanaJSONRPCError;
      exports.SolanaJSONRPCErrorCode = SolanaJSONRPCErrorCode;
      exports.StakeAuthorizationLayout = StakeAuthorizationLayout;
      exports.StakeInstruction = StakeInstruction;
      exports.StakeProgram = StakeProgram;
      exports.Struct = Struct2;
      exports.SystemInstruction = SystemInstruction;
      exports.SystemProgram = SystemProgram2;
      exports.Transaction = Transaction2;
      exports.TransactionExpiredBlockheightExceededError = TransactionExpiredBlockheightExceededError;
      exports.TransactionExpiredNonceInvalidError = TransactionExpiredNonceInvalidError;
      exports.TransactionExpiredTimeoutError = TransactionExpiredTimeoutError;
      exports.TransactionInstruction = TransactionInstruction2;
      exports.TransactionMessage = TransactionMessage;
      exports.TransactionStatus = TransactionStatus;
      exports.VALIDATOR_INFO_KEY = VALIDATOR_INFO_KEY;
      exports.VERSION_PREFIX_MASK = VERSION_PREFIX_MASK;
      exports.VOTE_PROGRAM_ID = VOTE_PROGRAM_ID;
      exports.ValidatorInfo = ValidatorInfo;
      exports.VersionedMessage = VersionedMessage;
      exports.VersionedTransaction = VersionedTransaction;
      exports.VoteAccount = VoteAccount;
      exports.VoteAuthorizationLayout = VoteAuthorizationLayout;
      exports.VoteInit = VoteInit;
      exports.VoteInstruction = VoteInstruction;
      exports.VoteProgram = VoteProgram;
      exports.clusterApiUrl = clusterApiUrl;
      exports.sendAndConfirmRawTransaction = sendAndConfirmRawTransaction2;
      exports.sendAndConfirmTransaction = sendAndConfirmTransaction;
    }
  });

  // node_modules/camelcase/index.js
  var require_camelcase = __commonJS({
    "node_modules/camelcase/index.js"(exports, module) {
      "use strict";
      var UPPERCASE = /[\p{Lu}]/u;
      var LOWERCASE = /[\p{Ll}]/u;
      var LEADING_CAPITAL = /^[\p{Lu}](?![\p{Lu}])/gu;
      var IDENTIFIER = /([\p{Alpha}\p{N}_]|$)/u;
      var SEPARATORS = /[_.\- ]+/;
      var LEADING_SEPARATORS = new RegExp("^" + SEPARATORS.source);
      var SEPARATORS_AND_IDENTIFIER = new RegExp(SEPARATORS.source + IDENTIFIER.source, "gu");
      var NUMBERS_AND_IDENTIFIER = new RegExp("\\d+" + IDENTIFIER.source, "gu");
      var preserveCamelCase = (string2, toLowerCase, toUpperCase) => {
        let isLastCharLower = false;
        let isLastCharUpper = false;
        let isLastLastCharUpper = false;
        for (let i = 0; i < string2.length; i++) {
          const character = string2[i];
          if (isLastCharLower && UPPERCASE.test(character)) {
            string2 = string2.slice(0, i) + "-" + string2.slice(i);
            isLastCharLower = false;
            isLastLastCharUpper = isLastCharUpper;
            isLastCharUpper = true;
            i++;
          } else if (isLastCharUpper && isLastLastCharUpper && LOWERCASE.test(character)) {
            string2 = string2.slice(0, i - 1) + "-" + string2.slice(i - 1);
            isLastLastCharUpper = isLastCharUpper;
            isLastCharUpper = false;
            isLastCharLower = true;
          } else {
            isLastCharLower = toLowerCase(character) === character && toUpperCase(character) !== character;
            isLastLastCharUpper = isLastCharUpper;
            isLastCharUpper = toUpperCase(character) === character && toLowerCase(character) !== character;
          }
        }
        return string2;
      };
      var preserveConsecutiveUppercase = (input, toLowerCase) => {
        LEADING_CAPITAL.lastIndex = 0;
        return input.replace(LEADING_CAPITAL, (m1) => toLowerCase(m1));
      };
      var postProcess = (input, toUpperCase) => {
        SEPARATORS_AND_IDENTIFIER.lastIndex = 0;
        NUMBERS_AND_IDENTIFIER.lastIndex = 0;
        return input.replace(SEPARATORS_AND_IDENTIFIER, (_, identifier) => toUpperCase(identifier)).replace(NUMBERS_AND_IDENTIFIER, (m) => toUpperCase(m));
      };
      var camelCase2 = (input, options) => {
        if (!(typeof input === "string" || Array.isArray(input))) {
          throw new TypeError("Expected the input to be `string | string[]`");
        }
        options = {
          pascalCase: false,
          preserveConsecutiveUppercase: false,
          ...options
        };
        if (Array.isArray(input)) {
          input = input.map((x) => x.trim()).filter((x) => x.length).join("-");
        } else {
          input = input.trim();
        }
        if (input.length === 0) {
          return "";
        }
        const toLowerCase = options.locale === false ? (string2) => string2.toLowerCase() : (string2) => string2.toLocaleLowerCase(options.locale);
        const toUpperCase = options.locale === false ? (string2) => string2.toUpperCase() : (string2) => string2.toLocaleUpperCase(options.locale);
        if (input.length === 1) {
          return options.pascalCase ? toUpperCase(input) : toLowerCase(input);
        }
        const hasUpperCase = input !== toLowerCase(input);
        if (hasUpperCase) {
          input = preserveCamelCase(input, toLowerCase, toUpperCase);
        }
        input = input.replace(LEADING_SEPARATORS, "");
        if (options.preserveConsecutiveUppercase) {
          input = preserveConsecutiveUppercase(input, toLowerCase);
        } else {
          input = toLowerCase(input);
        }
        if (options.pascalCase) {
          input = toUpperCase(input.charAt(0)) + input.slice(1);
        }
        return postProcess(input, toUpperCase);
      };
      module.exports = camelCase2;
      module.exports.default = camelCase2;
    }
  });

  // node_modules/buffer-layout/lib/Layout.js
  var require_Layout2 = __commonJS({
    "node_modules/buffer-layout/lib/Layout.js"(exports) {
      "use strict";
      var Layout2 = class {
        constructor(span, property) {
          if (!Number.isInteger(span)) {
            throw new TypeError("span must be an integer");
          }
          this.span = span;
          this.property = property;
        }
        /** Function to create an Object into which decoded properties will
         * be written.
         *
         * Used only for layouts that {@link Layout#decode|decode} to Object
         * instances, which means:
         * * {@link Structure}
         * * {@link Union}
         * * {@link VariantLayout}
         * * {@link BitStructure}
         *
         * If left undefined the JavaScript representation of these layouts
         * will be Object instances.
         *
         * See {@link bindConstructorLayout}.
         */
        makeDestinationObject() {
          return {};
        }
        /**
         * Decode from a Buffer into an JavaScript value.
         *
         * @param {Buffer} b - the buffer from which encoded data is read.
         *
         * @param {Number} [offset] - the offset at which the encoded data
         * starts.  If absent a zero offset is inferred.
         *
         * @returns {(Number|Array|Object)} - the value of the decoded data.
         *
         * @abstract
         */
        decode(b, offset2) {
          throw new Error("Layout is abstract");
        }
        /**
         * Encode a JavaScript value into a Buffer.
         *
         * @param {(Number|Array|Object)} src - the value to be encoded into
         * the buffer.  The type accepted depends on the (sub-)type of {@link
         * Layout}.
         *
         * @param {Buffer} b - the buffer into which encoded data will be
         * written.
         *
         * @param {Number} [offset] - the offset at which the encoded data
         * starts.  If absent a zero offset is inferred.
         *
         * @returns {Number} - the number of bytes encoded, including the
         * space skipped for internal padding, but excluding data such as
         * {@link Sequence#count|lengths} when stored {@link
         * ExternalLayout|externally}.  This is the adjustment to `offset`
         * producing the offset where data for the next layout would be
         * written.
         *
         * @abstract
         */
        encode(src, b, offset2) {
          throw new Error("Layout is abstract");
        }
        /**
         * Calculate the span of a specific instance of a layout.
         *
         * @param {Buffer} b - the buffer that contains an encoded instance.
         *
         * @param {Number} [offset] - the offset at which the encoded instance
         * starts.  If absent a zero offset is inferred.
         *
         * @return {Number} - the number of bytes covered by the layout
         * instance.  If this method is not overridden in a subclass the
         * definition-time constant {@link Layout#span|span} will be
         * returned.
         *
         * @throws {RangeError} - if the length of the value cannot be
         * determined.
         */
        getSpan(b, offset2) {
          if (0 > this.span) {
            throw new RangeError("indeterminate span");
          }
          return this.span;
        }
        /**
         * Replicate the layout using a new property.
         *
         * This function must be used to get a structurally-equivalent layout
         * with a different name since all {@link Layout} instances are
         * immutable.
         *
         * **NOTE** This is a shallow copy.  All fields except {@link
         * Layout#property|property} are strictly equal to the origin layout.
         *
         * @param {String} property - the value for {@link
         * Layout#property|property} in the replica.
         *
         * @returns {Layout} - the copy with {@link Layout#property|property}
         * set to `property`.
         */
        replicate(property) {
          const rv = Object.create(this.constructor.prototype);
          Object.assign(rv, this);
          rv.property = property;
          return rv;
        }
        /**
         * Create an object from layout properties and an array of values.
         *
         * **NOTE** This function returns `undefined` if invoked on a layout
         * that does not return its value as an Object.  Objects are
         * returned for things that are a {@link Structure}, which includes
         * {@link VariantLayout|variant layouts} if they are structures, and
         * excludes {@link Union}s.  If you want this feature for a union
         * you must use {@link Union.getVariant|getVariant} to select the
         * desired layout.
         *
         * @param {Array} values - an array of values that correspond to the
         * default order for properties.  As with {@link Layout#decode|decode}
         * layout elements that have no property name are skipped when
         * iterating over the array values.  Only the top-level properties are
         * assigned; arguments are not assigned to properties of contained
         * layouts.  Any unused values are ignored.
         *
         * @return {(Object|undefined)}
         */
        fromArray(values) {
          return void 0;
        }
      };
      exports.Layout = Layout2;
      function nameWithProperty2(name, lo) {
        if (lo.property) {
          return name + "[" + lo.property + "]";
        }
        return name;
      }
      exports.nameWithProperty = nameWithProperty2;
      function bindConstructorLayout(Class, layout) {
        if ("function" !== typeof Class) {
          throw new TypeError("Class must be constructor");
        }
        if (Class.hasOwnProperty("layout_")) {
          throw new Error("Class is already bound to a layout");
        }
        if (!(layout && layout instanceof Layout2)) {
          throw new TypeError("layout must be a Layout");
        }
        if (layout.hasOwnProperty("boundConstructor_")) {
          throw new Error("layout is already bound to a constructor");
        }
        Class.layout_ = layout;
        layout.boundConstructor_ = Class;
        layout.makeDestinationObject = (() => new Class());
        Object.defineProperty(Class.prototype, "encode", {
          value: function(b, offset2) {
            return layout.encode(this, b, offset2);
          },
          writable: true
        });
        Object.defineProperty(Class, "decode", {
          value: function(b, offset2) {
            return layout.decode(b, offset2);
          },
          writable: true
        });
      }
      exports.bindConstructorLayout = bindConstructorLayout;
      var ExternalLayout2 = class extends Layout2 {
        /**
         * Return `true` iff the external layout decodes to an unsigned
         * integer layout.
         *
         * In that case it can be used as the source of {@link
         * Sequence#count|Sequence counts}, {@link Blob#length|Blob lengths},
         * or as {@link UnionLayoutDiscriminator#layout|external union
         * discriminators}.
         *
         * @abstract
         */
        isCount() {
          throw new Error("ExternalLayout is abstract");
        }
      };
      var GreedyCount = class extends ExternalLayout2 {
        constructor(elementSpan, property) {
          if (void 0 === elementSpan) {
            elementSpan = 1;
          }
          if (!Number.isInteger(elementSpan) || 0 >= elementSpan) {
            throw new TypeError("elementSpan must be a (positive) integer");
          }
          super(-1, property);
          this.elementSpan = elementSpan;
        }
        /** @override */
        isCount() {
          return true;
        }
        /** @override */
        decode(b, offset2) {
          if (void 0 === offset2) {
            offset2 = 0;
          }
          const rem = b.length - offset2;
          return Math.floor(rem / this.elementSpan);
        }
        /** @override */
        encode(src, b, offset2) {
          return 0;
        }
      };
      var OffsetLayout2 = class extends ExternalLayout2 {
        constructor(layout, offset2, property) {
          if (!(layout instanceof Layout2)) {
            throw new TypeError("layout must be a Layout");
          }
          if (void 0 === offset2) {
            offset2 = 0;
          } else if (!Number.isInteger(offset2)) {
            throw new TypeError("offset must be integer or undefined");
          }
          super(layout.span, property || layout.property);
          this.layout = layout;
          this.offset = offset2;
        }
        /** @override */
        isCount() {
          return this.layout instanceof UInt2 || this.layout instanceof UIntBE2;
        }
        /** @override */
        decode(b, offset2) {
          if (void 0 === offset2) {
            offset2 = 0;
          }
          return this.layout.decode(b, offset2 + this.offset);
        }
        /** @override */
        encode(src, b, offset2) {
          if (void 0 === offset2) {
            offset2 = 0;
          }
          return this.layout.encode(src, b, offset2 + this.offset);
        }
      };
      var UInt2 = class extends Layout2 {
        constructor(span, property) {
          super(span, property);
          if (6 < this.span) {
            throw new RangeError("span must not exceed 6 bytes");
          }
        }
        /** @override */
        decode(b, offset2) {
          if (void 0 === offset2) {
            offset2 = 0;
          }
          return b.readUIntLE(offset2, this.span);
        }
        /** @override */
        encode(src, b, offset2) {
          if (void 0 === offset2) {
            offset2 = 0;
          }
          b.writeUIntLE(src, offset2, this.span);
          return this.span;
        }
      };
      var UIntBE2 = class extends Layout2 {
        constructor(span, property) {
          super(span, property);
          if (6 < this.span) {
            throw new RangeError("span must not exceed 6 bytes");
          }
        }
        /** @override */
        decode(b, offset2) {
          if (void 0 === offset2) {
            offset2 = 0;
          }
          return b.readUIntBE(offset2, this.span);
        }
        /** @override */
        encode(src, b, offset2) {
          if (void 0 === offset2) {
            offset2 = 0;
          }
          b.writeUIntBE(src, offset2, this.span);
          return this.span;
        }
      };
      var Int = class extends Layout2 {
        constructor(span, property) {
          super(span, property);
          if (6 < this.span) {
            throw new RangeError("span must not exceed 6 bytes");
          }
        }
        /** @override */
        decode(b, offset2) {
          if (void 0 === offset2) {
            offset2 = 0;
          }
          return b.readIntLE(offset2, this.span);
        }
        /** @override */
        encode(src, b, offset2) {
          if (void 0 === offset2) {
            offset2 = 0;
          }
          b.writeIntLE(src, offset2, this.span);
          return this.span;
        }
      };
      var IntBE = class extends Layout2 {
        constructor(span, property) {
          super(span, property);
          if (6 < this.span) {
            throw new RangeError("span must not exceed 6 bytes");
          }
        }
        /** @override */
        decode(b, offset2) {
          if (void 0 === offset2) {
            offset2 = 0;
          }
          return b.readIntBE(offset2, this.span);
        }
        /** @override */
        encode(src, b, offset2) {
          if (void 0 === offset2) {
            offset2 = 0;
          }
          b.writeIntBE(src, offset2, this.span);
          return this.span;
        }
      };
      var V2E322 = Math.pow(2, 32);
      function divmodInt642(src) {
        const hi32 = Math.floor(src / V2E322);
        const lo32 = src - hi32 * V2E322;
        return { hi32, lo32 };
      }
      function roundedInt642(hi32, lo32) {
        return hi32 * V2E322 + lo32;
      }
      var NearUInt642 = class extends Layout2 {
        constructor(property) {
          super(8, property);
        }
        /** @override */
        decode(b, offset2) {
          if (void 0 === offset2) {
            offset2 = 0;
          }
          const lo32 = b.readUInt32LE(offset2);
          const hi32 = b.readUInt32LE(offset2 + 4);
          return roundedInt642(hi32, lo32);
        }
        /** @override */
        encode(src, b, offset2) {
          if (void 0 === offset2) {
            offset2 = 0;
          }
          const split = divmodInt642(src);
          b.writeUInt32LE(split.lo32, offset2);
          b.writeUInt32LE(split.hi32, offset2 + 4);
          return 8;
        }
      };
      var NearUInt64BE = class extends Layout2 {
        constructor(property) {
          super(8, property);
        }
        /** @override */
        decode(b, offset2) {
          if (void 0 === offset2) {
            offset2 = 0;
          }
          const hi32 = b.readUInt32BE(offset2);
          const lo32 = b.readUInt32BE(offset2 + 4);
          return roundedInt642(hi32, lo32);
        }
        /** @override */
        encode(src, b, offset2) {
          if (void 0 === offset2) {
            offset2 = 0;
          }
          const split = divmodInt642(src);
          b.writeUInt32BE(split.hi32, offset2);
          b.writeUInt32BE(split.lo32, offset2 + 4);
          return 8;
        }
      };
      var NearInt642 = class extends Layout2 {
        constructor(property) {
          super(8, property);
        }
        /** @override */
        decode(b, offset2) {
          if (void 0 === offset2) {
            offset2 = 0;
          }
          const lo32 = b.readUInt32LE(offset2);
          const hi32 = b.readInt32LE(offset2 + 4);
          return roundedInt642(hi32, lo32);
        }
        /** @override */
        encode(src, b, offset2) {
          if (void 0 === offset2) {
            offset2 = 0;
          }
          const split = divmodInt642(src);
          b.writeUInt32LE(split.lo32, offset2);
          b.writeInt32LE(split.hi32, offset2 + 4);
          return 8;
        }
      };
      var NearInt64BE = class extends Layout2 {
        constructor(property) {
          super(8, property);
        }
        /** @override */
        decode(b, offset2) {
          if (void 0 === offset2) {
            offset2 = 0;
          }
          const hi32 = b.readInt32BE(offset2);
          const lo32 = b.readUInt32BE(offset2 + 4);
          return roundedInt642(hi32, lo32);
        }
        /** @override */
        encode(src, b, offset2) {
          if (void 0 === offset2) {
            offset2 = 0;
          }
          const split = divmodInt642(src);
          b.writeInt32BE(split.hi32, offset2);
          b.writeUInt32BE(split.lo32, offset2 + 4);
          return 8;
        }
      };
      var Float = class extends Layout2 {
        constructor(property) {
          super(4, property);
        }
        /** @override */
        decode(b, offset2) {
          if (void 0 === offset2) {
            offset2 = 0;
          }
          return b.readFloatLE(offset2);
        }
        /** @override */
        encode(src, b, offset2) {
          if (void 0 === offset2) {
            offset2 = 0;
          }
          b.writeFloatLE(src, offset2);
          return 4;
        }
      };
      var FloatBE = class extends Layout2 {
        constructor(property) {
          super(4, property);
        }
        /** @override */
        decode(b, offset2) {
          if (void 0 === offset2) {
            offset2 = 0;
          }
          return b.readFloatBE(offset2);
        }
        /** @override */
        encode(src, b, offset2) {
          if (void 0 === offset2) {
            offset2 = 0;
          }
          b.writeFloatBE(src, offset2);
          return 4;
        }
      };
      var Double = class extends Layout2 {
        constructor(property) {
          super(8, property);
        }
        /** @override */
        decode(b, offset2) {
          if (void 0 === offset2) {
            offset2 = 0;
          }
          return b.readDoubleLE(offset2);
        }
        /** @override */
        encode(src, b, offset2) {
          if (void 0 === offset2) {
            offset2 = 0;
          }
          b.writeDoubleLE(src, offset2);
          return 8;
        }
      };
      var DoubleBE = class extends Layout2 {
        constructor(property) {
          super(8, property);
        }
        /** @override */
        decode(b, offset2) {
          if (void 0 === offset2) {
            offset2 = 0;
          }
          return b.readDoubleBE(offset2);
        }
        /** @override */
        encode(src, b, offset2) {
          if (void 0 === offset2) {
            offset2 = 0;
          }
          b.writeDoubleBE(src, offset2);
          return 8;
        }
      };
      var Sequence = class extends Layout2 {
        constructor(elementLayout, count, property) {
          if (!(elementLayout instanceof Layout2)) {
            throw new TypeError("elementLayout must be a Layout");
          }
          if (!(count instanceof ExternalLayout2 && count.isCount() || Number.isInteger(count) && 0 <= count)) {
            throw new TypeError("count must be non-negative integer or an unsigned integer ExternalLayout");
          }
          let span = -1;
          if (!(count instanceof ExternalLayout2) && 0 < elementLayout.span) {
            span = count * elementLayout.span;
          }
          super(span, property);
          this.elementLayout = elementLayout;
          this.count = count;
        }
        /** @override */
        getSpan(b, offset2) {
          if (0 <= this.span) {
            return this.span;
          }
          if (void 0 === offset2) {
            offset2 = 0;
          }
          let span = 0;
          let count = this.count;
          if (count instanceof ExternalLayout2) {
            count = count.decode(b, offset2);
          }
          if (0 < this.elementLayout.span) {
            span = count * this.elementLayout.span;
          } else {
            let idx = 0;
            while (idx < count) {
              span += this.elementLayout.getSpan(b, offset2 + span);
              ++idx;
            }
          }
          return span;
        }
        /** @override */
        decode(b, offset2) {
          if (void 0 === offset2) {
            offset2 = 0;
          }
          const rv = [];
          let i = 0;
          let count = this.count;
          if (count instanceof ExternalLayout2) {
            count = count.decode(b, offset2);
          }
          while (i < count) {
            rv.push(this.elementLayout.decode(b, offset2));
            offset2 += this.elementLayout.getSpan(b, offset2);
            i += 1;
          }
          return rv;
        }
        /** Implement {@link Layout#encode|encode} for {@link Sequence}.
         *
         * **NOTE** If `src` is shorter than {@link Sequence#count|count} then
         * the unused space in the buffer is left unchanged.  If `src` is
         * longer than {@link Sequence#count|count} the unneeded elements are
         * ignored.
         *
         * **NOTE** If {@link Layout#count|count} is an instance of {@link
         * ExternalLayout} then the length of `src` will be encoded as the
         * count after `src` is encoded. */
        encode(src, b, offset2) {
          if (void 0 === offset2) {
            offset2 = 0;
          }
          const elo = this.elementLayout;
          const span = src.reduce((span2, v) => {
            return span2 + elo.encode(v, b, offset2 + span2);
          }, 0);
          if (this.count instanceof ExternalLayout2) {
            this.count.encode(src.length, b, offset2);
          }
          return span;
        }
      };
      var Structure2 = class extends Layout2 {
        constructor(fields, property, decodePrefixes) {
          if (!(Array.isArray(fields) && fields.reduce((acc, v) => acc && v instanceof Layout2, true))) {
            throw new TypeError("fields must be array of Layout instances");
          }
          if ("boolean" === typeof property && void 0 === decodePrefixes) {
            decodePrefixes = property;
            property = void 0;
          }
          for (const fd of fields) {
            if (0 > fd.span && void 0 === fd.property) {
              throw new Error("fields cannot contain unnamed variable-length layout");
            }
          }
          let span = -1;
          try {
            span = fields.reduce((span2, fd) => span2 + fd.getSpan(), 0);
          } catch (e) {
          }
          super(span, property);
          this.fields = fields;
          this.decodePrefixes = !!decodePrefixes;
        }
        /** @override */
        getSpan(b, offset2) {
          if (0 <= this.span) {
            return this.span;
          }
          if (void 0 === offset2) {
            offset2 = 0;
          }
          let span = 0;
          try {
            span = this.fields.reduce((span2, fd) => {
              const fsp = fd.getSpan(b, offset2);
              offset2 += fsp;
              return span2 + fsp;
            }, 0);
          } catch (e) {
            throw new RangeError("indeterminate span");
          }
          return span;
        }
        /** @override */
        decode(b, offset2) {
          if (void 0 === offset2) {
            offset2 = 0;
          }
          const dest = this.makeDestinationObject();
          for (const fd of this.fields) {
            if (void 0 !== fd.property) {
              dest[fd.property] = fd.decode(b, offset2);
            }
            offset2 += fd.getSpan(b, offset2);
            if (this.decodePrefixes && b.length === offset2) {
              break;
            }
          }
          return dest;
        }
        /** Implement {@link Layout#encode|encode} for {@link Structure}.
         *
         * If `src` is missing a property for a member with a defined {@link
         * Layout#property|property} the corresponding region of the buffer is
         * left unmodified. */
        encode(src, b, offset2) {
          if (void 0 === offset2) {
            offset2 = 0;
          }
          const firstOffset = offset2;
          let lastOffset = 0;
          let lastWrote = 0;
          for (const fd of this.fields) {
            let span = fd.span;
            lastWrote = 0 < span ? span : 0;
            if (void 0 !== fd.property) {
              const fv = src[fd.property];
              if (void 0 !== fv) {
                lastWrote = fd.encode(fv, b, offset2);
                if (0 > span) {
                  span = fd.getSpan(b, offset2);
                }
              }
            }
            lastOffset = offset2;
            offset2 += span;
          }
          return lastOffset + lastWrote - firstOffset;
        }
        /** @override */
        fromArray(values) {
          const dest = this.makeDestinationObject();
          for (const fd of this.fields) {
            if (void 0 !== fd.property && 0 < values.length) {
              dest[fd.property] = values.shift();
            }
          }
          return dest;
        }
        /**
         * Get access to the layout of a given property.
         *
         * @param {String} property - the structure member of interest.
         *
         * @return {Layout} - the layout associated with `property`, or
         * undefined if there is no such property.
         */
        layoutFor(property) {
          if ("string" !== typeof property) {
            throw new TypeError("property must be string");
          }
          for (const fd of this.fields) {
            if (fd.property === property) {
              return fd;
            }
          }
        }
        /**
         * Get the offset of a structure member.
         *
         * @param {String} property - the structure member of interest.
         *
         * @return {Number} - the offset in bytes to the start of `property`
         * within the structure, or undefined if `property` is not a field
         * within the structure.  If the property is a member but follows a
         * variable-length structure member a negative number will be
         * returned.
         */
        offsetOf(property) {
          if ("string" !== typeof property) {
            throw new TypeError("property must be string");
          }
          let offset2 = 0;
          for (const fd of this.fields) {
            if (fd.property === property) {
              return offset2;
            }
            if (0 > fd.span) {
              offset2 = -1;
            } else if (0 <= offset2) {
              offset2 += fd.span;
            }
          }
        }
      };
      var UnionDiscriminator2 = class {
        constructor(property) {
          this.property = property;
        }
        /** Analog to {@link Layout#decode|Layout decode} for union discriminators.
         *
         * The implementation of this method need not reference the buffer if
         * variant information is available through other means. */
        decode() {
          throw new Error("UnionDiscriminator is abstract");
        }
        /** Analog to {@link Layout#decode|Layout encode} for union discriminators.
         *
         * The implementation of this method need not store the value if
         * variant information is maintained through other means. */
        encode() {
          throw new Error("UnionDiscriminator is abstract");
        }
      };
      var UnionLayoutDiscriminator2 = class extends UnionDiscriminator2 {
        constructor(layout, property) {
          if (!(layout instanceof ExternalLayout2 && layout.isCount())) {
            throw new TypeError("layout must be an unsigned integer ExternalLayout");
          }
          super(property || layout.property || "variant");
          this.layout = layout;
        }
        /** Delegate decoding to {@link UnionLayoutDiscriminator#layout|layout}. */
        decode(b, offset2) {
          return this.layout.decode(b, offset2);
        }
        /** Delegate encoding to {@link UnionLayoutDiscriminator#layout|layout}. */
        encode(src, b, offset2) {
          return this.layout.encode(src, b, offset2);
        }
      };
      var Union2 = class extends Layout2 {
        constructor(discr, defaultLayout, property) {
          const upv = discr instanceof UInt2 || discr instanceof UIntBE2;
          if (upv) {
            discr = new UnionLayoutDiscriminator2(new OffsetLayout2(discr));
          } else if (discr instanceof ExternalLayout2 && discr.isCount()) {
            discr = new UnionLayoutDiscriminator2(discr);
          } else if (!(discr instanceof UnionDiscriminator2)) {
            throw new TypeError("discr must be a UnionDiscriminator or an unsigned integer layout");
          }
          if (void 0 === defaultLayout) {
            defaultLayout = null;
          }
          if (!(null === defaultLayout || defaultLayout instanceof Layout2)) {
            throw new TypeError("defaultLayout must be null or a Layout");
          }
          if (null !== defaultLayout) {
            if (0 > defaultLayout.span) {
              throw new Error("defaultLayout must have constant span");
            }
            if (void 0 === defaultLayout.property) {
              defaultLayout = defaultLayout.replicate("content");
            }
          }
          let span = -1;
          if (defaultLayout) {
            span = defaultLayout.span;
            if (0 <= span && upv) {
              span += discr.layout.span;
            }
          }
          super(span, property);
          this.discriminator = discr;
          this.usesPrefixDiscriminator = upv;
          this.defaultLayout = defaultLayout;
          this.registry = {};
          let boundGetSourceVariant = this.defaultGetSourceVariant.bind(this);
          this.getSourceVariant = function(src) {
            return boundGetSourceVariant(src);
          };
          this.configGetSourceVariant = function(gsv) {
            boundGetSourceVariant = gsv.bind(this);
          };
        }
        /** @override */
        getSpan(b, offset2) {
          if (0 <= this.span) {
            return this.span;
          }
          if (void 0 === offset2) {
            offset2 = 0;
          }
          const vlo = this.getVariant(b, offset2);
          if (!vlo) {
            throw new Error("unable to determine span for unrecognized variant");
          }
          return vlo.getSpan(b, offset2);
        }
        /**
         * Method to infer a registered Union variant compatible with `src`.
         *
         * The first satisified rule in the following sequence defines the
         * return value:
         * * If `src` has properties matching the Union discriminator and
         *   the default layout, `undefined` is returned regardless of the
         *   value of the discriminator property (this ensures the default
         *   layout will be used);
         * * If `src` has a property matching the Union discriminator, the
         *   value of the discriminator identifies a registered variant, and
         *   either (a) the variant has no layout, or (b) `src` has the
         *   variant's property, then the variant is returned (because the
         *   source satisfies the constraints of the variant it identifies);
         * * If `src` does not have a property matching the Union
         *   discriminator, but does have a property matching a registered
         *   variant, then the variant is returned (because the source
         *   matches a variant without an explicit conflict);
         * * An error is thrown (because we either can't identify a variant,
         *   or we were explicitly told the variant but can't satisfy it).
         *
         * @param {Object} src - an object presumed to be compatible with
         * the content of the Union.
         *
         * @return {(undefined|VariantLayout)} - as described above.
         *
         * @throws {Error} - if `src` cannot be associated with a default or
         * registered variant.
         */
        defaultGetSourceVariant(src) {
          if (src.hasOwnProperty(this.discriminator.property)) {
            if (this.defaultLayout && src.hasOwnProperty(this.defaultLayout.property)) {
              return void 0;
            }
            const vlo = this.registry[src[this.discriminator.property]];
            if (vlo && (!vlo.layout || src.hasOwnProperty(vlo.property))) {
              return vlo;
            }
          } else {
            for (const tag in this.registry) {
              const vlo = this.registry[tag];
              if (src.hasOwnProperty(vlo.property)) {
                return vlo;
              }
            }
          }
          throw new Error("unable to infer src variant");
        }
        /** Implement {@link Layout#decode|decode} for {@link Union}.
         *
         * If the variant is {@link Union#addVariant|registered} the return
         * value is an instance of that variant, with no explicit
         * discriminator.  Otherwise the {@link Union#defaultLayout|default
         * layout} is used to decode the content. */
        decode(b, offset2) {
          if (void 0 === offset2) {
            offset2 = 0;
          }
          let dest;
          const dlo = this.discriminator;
          const discr = dlo.decode(b, offset2);
          let clo = this.registry[discr];
          if (void 0 === clo) {
            let contentOffset = 0;
            clo = this.defaultLayout;
            if (this.usesPrefixDiscriminator) {
              contentOffset = dlo.layout.span;
            }
            dest = this.makeDestinationObject();
            dest[dlo.property] = discr;
            dest[clo.property] = this.defaultLayout.decode(b, offset2 + contentOffset);
          } else {
            dest = clo.decode(b, offset2);
          }
          return dest;
        }
        /** Implement {@link Layout#encode|encode} for {@link Union}.
         *
         * This API assumes the `src` object is consistent with the union's
         * {@link Union#defaultLayout|default layout}.  To encode variants
         * use the appropriate variant-specific {@link VariantLayout#encode}
         * method. */
        encode(src, b, offset2) {
          if (void 0 === offset2) {
            offset2 = 0;
          }
          const vlo = this.getSourceVariant(src);
          if (void 0 === vlo) {
            const dlo = this.discriminator;
            const clo = this.defaultLayout;
            let contentOffset = 0;
            if (this.usesPrefixDiscriminator) {
              contentOffset = dlo.layout.span;
            }
            dlo.encode(src[dlo.property], b, offset2);
            return contentOffset + clo.encode(
              src[clo.property],
              b,
              offset2 + contentOffset
            );
          }
          return vlo.encode(src, b, offset2);
        }
        /** Register a new variant structure within a union.  The newly
         * created variant is returned.
         *
         * @param {Number} variant - initializer for {@link
         * VariantLayout#variant|variant}.
         *
         * @param {Layout} layout - initializer for {@link
         * VariantLayout#layout|layout}.
         *
         * @param {String} property - initializer for {@link
         * Layout#property|property}.
         *
         * @return {VariantLayout} */
        addVariant(variant, layout, property) {
          const rv = new VariantLayout2(this, variant, layout, property);
          this.registry[variant] = rv;
          return rv;
        }
        /**
         * Get the layout associated with a registered variant.
         *
         * If `vb` does not produce a registered variant the function returns
         * `undefined`.
         *
         * @param {(Number|Buffer)} vb - either the variant number, or a
         * buffer from which the discriminator is to be read.
         *
         * @param {Number} offset - offset into `vb` for the start of the
         * union.  Used only when `vb` is an instance of {Buffer}.
         *
         * @return {({VariantLayout}|undefined)}
         */
        getVariant(vb, offset2) {
          let variant = vb;
          if (Buffer.isBuffer(vb)) {
            if (void 0 === offset2) {
              offset2 = 0;
            }
            variant = this.discriminator.decode(vb, offset2);
          }
          return this.registry[variant];
        }
      };
      var VariantLayout2 = class extends Layout2 {
        constructor(union2, variant, layout, property) {
          if (!(union2 instanceof Union2)) {
            throw new TypeError("union must be a Union");
          }
          if (!Number.isInteger(variant) || 0 > variant) {
            throw new TypeError("variant must be a (non-negative) integer");
          }
          if ("string" === typeof layout && void 0 === property) {
            property = layout;
            layout = null;
          }
          if (layout) {
            if (!(layout instanceof Layout2)) {
              throw new TypeError("layout must be a Layout");
            }
            if (null !== union2.defaultLayout && 0 <= layout.span && layout.span > union2.defaultLayout.span) {
              throw new Error("variant span exceeds span of containing union");
            }
            if ("string" !== typeof property) {
              throw new TypeError("variant must have a String property");
            }
          }
          let span = union2.span;
          if (0 > union2.span) {
            span = layout ? layout.span : 0;
            if (0 <= span && union2.usesPrefixDiscriminator) {
              span += union2.discriminator.layout.span;
            }
          }
          super(span, property);
          this.union = union2;
          this.variant = variant;
          this.layout = layout || null;
        }
        /** @override */
        getSpan(b, offset2) {
          if (0 <= this.span) {
            return this.span;
          }
          if (void 0 === offset2) {
            offset2 = 0;
          }
          let contentOffset = 0;
          if (this.union.usesPrefixDiscriminator) {
            contentOffset = this.union.discriminator.layout.span;
          }
          return contentOffset + this.layout.getSpan(b, offset2 + contentOffset);
        }
        /** @override */
        decode(b, offset2) {
          const dest = this.makeDestinationObject();
          if (void 0 === offset2) {
            offset2 = 0;
          }
          if (this !== this.union.getVariant(b, offset2)) {
            throw new Error("variant mismatch");
          }
          let contentOffset = 0;
          if (this.union.usesPrefixDiscriminator) {
            contentOffset = this.union.discriminator.layout.span;
          }
          if (this.layout) {
            dest[this.property] = this.layout.decode(b, offset2 + contentOffset);
          } else if (this.property) {
            dest[this.property] = true;
          } else if (this.union.usesPrefixDiscriminator) {
            dest[this.union.discriminator.property] = this.variant;
          }
          return dest;
        }
        /** @override */
        encode(src, b, offset2) {
          if (void 0 === offset2) {
            offset2 = 0;
          }
          let contentOffset = 0;
          if (this.union.usesPrefixDiscriminator) {
            contentOffset = this.union.discriminator.layout.span;
          }
          if (this.layout && !src.hasOwnProperty(this.property)) {
            throw new TypeError("variant lacks property " + this.property);
          }
          this.union.discriminator.encode(this.variant, b, offset2);
          let span = contentOffset;
          if (this.layout) {
            this.layout.encode(src[this.property], b, offset2 + contentOffset);
            span += this.layout.getSpan(b, offset2 + contentOffset);
            if (0 <= this.union.span && span > this.union.span) {
              throw new Error("encoded variant overruns containing union");
            }
          }
          return span;
        }
        /** Delegate {@link Layout#fromArray|fromArray} to {@link
         * VariantLayout#layout|layout}. */
        fromArray(values) {
          if (this.layout) {
            return this.layout.fromArray(values);
          }
        }
      };
      function fixBitwiseResult(v) {
        if (0 > v) {
          v += 4294967296;
        }
        return v;
      }
      var BitStructure = class extends Layout2 {
        constructor(word, msb, property) {
          if (!(word instanceof UInt2 || word instanceof UIntBE2)) {
            throw new TypeError("word must be a UInt or UIntBE layout");
          }
          if ("string" === typeof msb && void 0 === property) {
            property = msb;
            msb = void 0;
          }
          if (4 < word.span) {
            throw new RangeError("word cannot exceed 32 bits");
          }
          super(word.span, property);
          this.word = word;
          this.msb = !!msb;
          this.fields = [];
          let value = 0;
          this._packedSetValue = function(v) {
            value = fixBitwiseResult(v);
            return this;
          };
          this._packedGetValue = function() {
            return value;
          };
        }
        /** @override */
        decode(b, offset2) {
          const dest = this.makeDestinationObject();
          if (void 0 === offset2) {
            offset2 = 0;
          }
          const value = this.word.decode(b, offset2);
          this._packedSetValue(value);
          for (const fd of this.fields) {
            if (void 0 !== fd.property) {
              dest[fd.property] = fd.decode(value);
            }
          }
          return dest;
        }
        /** Implement {@link Layout#encode|encode} for {@link BitStructure}.
         *
         * If `src` is missing a property for a member with a defined {@link
         * Layout#property|property} the corresponding region of the packed
         * value is left unmodified.  Unused bits are also left unmodified. */
        encode(src, b, offset2) {
          if (void 0 === offset2) {
            offset2 = 0;
          }
          const value = this.word.decode(b, offset2);
          this._packedSetValue(value);
          for (const fd of this.fields) {
            if (void 0 !== fd.property) {
              const fv = src[fd.property];
              if (void 0 !== fv) {
                fd.encode(fv);
              }
            }
          }
          return this.word.encode(this._packedGetValue(), b, offset2);
        }
        /** Register a new bitfield with a containing bit structure.  The
         * resulting bitfield is returned.
         *
         * @param {Number} bits - initializer for {@link BitField#bits|bits}.
         *
         * @param {string} property - initializer for {@link
         * Layout#property|property}.
         *
         * @return {BitField} */
        addField(bits, property) {
          const bf = new BitField(this, bits, property);
          this.fields.push(bf);
          return bf;
        }
        /** As with {@link BitStructure#addField|addField} for single-bit
         * fields with `boolean` value representation.
         *
         * @param {string} property - initializer for {@link
         * Layout#property|property}.
         *
         * @return {Boolean} */
        addBoolean(property) {
          const bf = new Boolean2(this, property);
          this.fields.push(bf);
          return bf;
        }
        /**
         * Get access to the bit field for a given property.
         *
         * @param {String} property - the bit field of interest.
         *
         * @return {BitField} - the field associated with `property`, or
         * undefined if there is no such property.
         */
        fieldFor(property) {
          if ("string" !== typeof property) {
            throw new TypeError("property must be string");
          }
          for (const fd of this.fields) {
            if (fd.property === property) {
              return fd;
            }
          }
        }
      };
      var BitField = class {
        constructor(container, bits, property) {
          if (!(container instanceof BitStructure)) {
            throw new TypeError("container must be a BitStructure");
          }
          if (!Number.isInteger(bits) || 0 >= bits) {
            throw new TypeError("bits must be positive integer");
          }
          const totalBits = 8 * container.span;
          const usedBits = container.fields.reduce((sum, fd) => sum + fd.bits, 0);
          if (bits + usedBits > totalBits) {
            throw new Error("bits too long for span remainder (" + (totalBits - usedBits) + " of " + totalBits + " remain)");
          }
          this.container = container;
          this.bits = bits;
          this.valueMask = (1 << bits) - 1;
          if (32 === bits) {
            this.valueMask = 4294967295;
          }
          this.start = usedBits;
          if (this.container.msb) {
            this.start = totalBits - usedBits - bits;
          }
          this.wordMask = fixBitwiseResult(this.valueMask << this.start);
          this.property = property;
        }
        /** Store a value into the corresponding subsequence of the containing
         * bit field. */
        decode() {
          const word = this.container._packedGetValue();
          const wordValue = fixBitwiseResult(word & this.wordMask);
          const value = wordValue >>> this.start;
          return value;
        }
        /** Store a value into the corresponding subsequence of the containing
         * bit field.
         *
         * **NOTE** This is not a specialization of {@link
         * Layout#encode|Layout.encode} and there is no return value. */
        encode(value) {
          if (!Number.isInteger(value) || value !== fixBitwiseResult(value & this.valueMask)) {
            throw new TypeError(nameWithProperty2("BitField.encode", this) + " value must be integer not exceeding " + this.valueMask);
          }
          const word = this.container._packedGetValue();
          const wordValue = fixBitwiseResult(value << this.start);
          this.container._packedSetValue(fixBitwiseResult(word & ~this.wordMask) | wordValue);
        }
      };
      var Boolean2 = class extends BitField {
        constructor(container, property) {
          super(container, 1, property);
        }
        /** Override {@link BitField#decode|decode} for {@link Boolean|Boolean}.
         *
         * @returns {boolean} */
        decode(b, offset2) {
          return !!BitField.prototype.decode.call(this, b, offset2);
        }
        /** @override */
        encode(value) {
          if ("boolean" === typeof value) {
            value = +value;
          }
          return BitField.prototype.encode.call(this, value);
        }
      };
      var Blob2 = class extends Layout2 {
        constructor(length, property) {
          if (!(length instanceof ExternalLayout2 && length.isCount() || Number.isInteger(length) && 0 <= length)) {
            throw new TypeError("length must be positive integer or an unsigned integer ExternalLayout");
          }
          let span = -1;
          if (!(length instanceof ExternalLayout2)) {
            span = length;
          }
          super(span, property);
          this.length = length;
        }
        /** @override */
        getSpan(b, offset2) {
          let span = this.span;
          if (0 > span) {
            span = this.length.decode(b, offset2);
          }
          return span;
        }
        /** @override */
        decode(b, offset2) {
          if (void 0 === offset2) {
            offset2 = 0;
          }
          let span = this.span;
          if (0 > span) {
            span = this.length.decode(b, offset2);
          }
          return b.slice(offset2, offset2 + span);
        }
        /** Implement {@link Layout#encode|encode} for {@link Blob}.
         *
         * **NOTE** If {@link Layout#count|count} is an instance of {@link
         * ExternalLayout} then the length of `src` will be encoded as the
         * count after `src` is encoded. */
        encode(src, b, offset2) {
          let span = this.length;
          if (this.length instanceof ExternalLayout2) {
            span = src.length;
          }
          if (!(Buffer.isBuffer(src) && span === src.length)) {
            throw new TypeError(nameWithProperty2("Blob.encode", this) + " requires (length " + span + ") Buffer as src");
          }
          if (offset2 + span > b.length) {
            throw new RangeError("encoding overruns Buffer");
          }
          b.write(src.toString("hex"), offset2, span, "hex");
          if (this.length instanceof ExternalLayout2) {
            this.length.encode(span, b, offset2);
          }
          return span;
        }
      };
      var CString = class extends Layout2 {
        constructor(property) {
          super(-1, property);
        }
        /** @override */
        getSpan(b, offset2) {
          if (!Buffer.isBuffer(b)) {
            throw new TypeError("b must be a Buffer");
          }
          if (void 0 === offset2) {
            offset2 = 0;
          }
          let idx = offset2;
          while (idx < b.length && 0 !== b[idx]) {
            idx += 1;
          }
          return 1 + idx - offset2;
        }
        /** @override */
        decode(b, offset2, dest) {
          if (void 0 === offset2) {
            offset2 = 0;
          }
          let span = this.getSpan(b, offset2);
          return b.slice(offset2, offset2 + span - 1).toString("utf-8");
        }
        /** @override */
        encode(src, b, offset2) {
          if (void 0 === offset2) {
            offset2 = 0;
          }
          if ("string" !== typeof src) {
            src = src.toString();
          }
          const srcb = new Buffer(src, "utf8");
          const span = srcb.length;
          if (offset2 + span > b.length) {
            throw new RangeError("encoding overruns Buffer");
          }
          srcb.copy(b, offset2);
          b[offset2 + span] = 0;
          return span + 1;
        }
      };
      var UTF8 = class extends Layout2 {
        constructor(maxSpan, property) {
          if ("string" === typeof maxSpan && void 0 === property) {
            property = maxSpan;
            maxSpan = void 0;
          }
          if (void 0 === maxSpan) {
            maxSpan = -1;
          } else if (!Number.isInteger(maxSpan)) {
            throw new TypeError("maxSpan must be an integer");
          }
          super(-1, property);
          this.maxSpan = maxSpan;
        }
        /** @override */
        getSpan(b, offset2) {
          if (!Buffer.isBuffer(b)) {
            throw new TypeError("b must be a Buffer");
          }
          if (void 0 === offset2) {
            offset2 = 0;
          }
          return b.length - offset2;
        }
        /** @override */
        decode(b, offset2, dest) {
          if (void 0 === offset2) {
            offset2 = 0;
          }
          let span = this.getSpan(b, offset2);
          if (0 <= this.maxSpan && this.maxSpan < span) {
            throw new RangeError("text length exceeds maxSpan");
          }
          return b.slice(offset2, offset2 + span).toString("utf-8");
        }
        /** @override */
        encode(src, b, offset2) {
          if (void 0 === offset2) {
            offset2 = 0;
          }
          if ("string" !== typeof src) {
            src = src.toString();
          }
          const srcb = new Buffer(src, "utf8");
          const span = srcb.length;
          if (0 <= this.maxSpan && this.maxSpan < span) {
            throw new RangeError("text length exceeds maxSpan");
          }
          if (offset2 + span > b.length) {
            throw new RangeError("encoding overruns Buffer");
          }
          srcb.copy(b, offset2);
          return span;
        }
      };
      var Constant = class extends Layout2 {
        constructor(value, property) {
          super(0, property);
          this.value = value;
        }
        /** @override */
        decode(b, offset2, dest) {
          return this.value;
        }
        /** @override */
        encode(src, b, offset2) {
          return 0;
        }
      };
      exports.ExternalLayout = ExternalLayout2;
      exports.GreedyCount = GreedyCount;
      exports.OffsetLayout = OffsetLayout2;
      exports.UInt = UInt2;
      exports.UIntBE = UIntBE2;
      exports.Int = Int;
      exports.IntBE = IntBE;
      exports.Float = Float;
      exports.FloatBE = FloatBE;
      exports.Double = Double;
      exports.DoubleBE = DoubleBE;
      exports.Sequence = Sequence;
      exports.Structure = Structure2;
      exports.UnionDiscriminator = UnionDiscriminator2;
      exports.UnionLayoutDiscriminator = UnionLayoutDiscriminator2;
      exports.Union = Union2;
      exports.VariantLayout = VariantLayout2;
      exports.BitStructure = BitStructure;
      exports.BitField = BitField;
      exports.Boolean = Boolean2;
      exports.Blob = Blob2;
      exports.CString = CString;
      exports.UTF8 = UTF8;
      exports.Constant = Constant;
      exports.greedy = ((elementSpan, property) => new GreedyCount(elementSpan, property));
      exports.offset = ((layout, offset2, property) => new OffsetLayout2(layout, offset2, property));
      exports.u8 = ((property) => new UInt2(1, property));
      exports.u16 = ((property) => new UInt2(2, property));
      exports.u24 = ((property) => new UInt2(3, property));
      exports.u32 = ((property) => new UInt2(4, property));
      exports.u40 = ((property) => new UInt2(5, property));
      exports.u48 = ((property) => new UInt2(6, property));
      exports.nu64 = ((property) => new NearUInt642(property));
      exports.u16be = ((property) => new UIntBE2(2, property));
      exports.u24be = ((property) => new UIntBE2(3, property));
      exports.u32be = ((property) => new UIntBE2(4, property));
      exports.u40be = ((property) => new UIntBE2(5, property));
      exports.u48be = ((property) => new UIntBE2(6, property));
      exports.nu64be = ((property) => new NearUInt64BE(property));
      exports.s8 = ((property) => new Int(1, property));
      exports.s16 = ((property) => new Int(2, property));
      exports.s24 = ((property) => new Int(3, property));
      exports.s32 = ((property) => new Int(4, property));
      exports.s40 = ((property) => new Int(5, property));
      exports.s48 = ((property) => new Int(6, property));
      exports.ns64 = ((property) => new NearInt642(property));
      exports.s16be = ((property) => new IntBE(2, property));
      exports.s24be = ((property) => new IntBE(3, property));
      exports.s32be = ((property) => new IntBE(4, property));
      exports.s40be = ((property) => new IntBE(5, property));
      exports.s48be = ((property) => new IntBE(6, property));
      exports.ns64be = ((property) => new NearInt64BE(property));
      exports.f32 = ((property) => new Float(property));
      exports.f32be = ((property) => new FloatBE(property));
      exports.f64 = ((property) => new Double(property));
      exports.f64be = ((property) => new DoubleBE(property));
      exports.struct = ((fields, property, decodePrefixes) => new Structure2(fields, property, decodePrefixes));
      exports.bits = ((word, msb, property) => new BitStructure(word, msb, property));
      exports.seq = ((elementLayout, count, property) => new Sequence(elementLayout, count, property));
      exports.union = ((discr, defaultLayout, property) => new Union2(discr, defaultLayout, property));
      exports.unionLayoutDiscriminator = ((layout, property) => new UnionLayoutDiscriminator2(layout, property));
      exports.blob = ((length, property) => new Blob2(length, property));
      exports.cstr = ((property) => new CString(property));
      exports.utf8 = ((maxSpan, property) => new UTF8(maxSpan, property));
      exports.const = ((value, property) => new Constant(value, property));
    }
  });

  // node_modules/@coral-xyz/anchor/node_modules/@coral-xyz/borsh/dist/index.js
  var require_dist2 = __commonJS({
    "node_modules/@coral-xyz/anchor/node_modules/@coral-xyz/borsh/dist/index.js"(exports) {
      "use strict";
      var __importDefault = exports && exports.__importDefault || function(mod) {
        return mod && mod.__esModule ? mod : { "default": mod };
      };
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.map = exports.array = exports.rustEnum = exports.str = exports.vecU8 = exports.tagged = exports.vec = exports.bool = exports.option = exports.publicKey = exports.i256 = exports.u256 = exports.i128 = exports.u128 = exports.i64 = exports.u64 = exports.struct = exports.f64 = exports.f32 = exports.i32 = exports.u32 = exports.i16 = exports.u16 = exports.i8 = exports.u8 = void 0;
      var buffer_layout_1 = require_Layout2();
      var web3_js_1 = require_index_browser_cjs();
      var bn_js_1 = __importDefault(require_bn());
      var buffer_layout_2 = require_Layout2();
      Object.defineProperty(exports, "u8", { enumerable: true, get: function() {
        return buffer_layout_2.u8;
      } });
      Object.defineProperty(exports, "i8", { enumerable: true, get: function() {
        return buffer_layout_2.s8;
      } });
      Object.defineProperty(exports, "u16", { enumerable: true, get: function() {
        return buffer_layout_2.u16;
      } });
      Object.defineProperty(exports, "i16", { enumerable: true, get: function() {
        return buffer_layout_2.s16;
      } });
      Object.defineProperty(exports, "u32", { enumerable: true, get: function() {
        return buffer_layout_2.u32;
      } });
      Object.defineProperty(exports, "i32", { enumerable: true, get: function() {
        return buffer_layout_2.s32;
      } });
      Object.defineProperty(exports, "f32", { enumerable: true, get: function() {
        return buffer_layout_2.f32;
      } });
      Object.defineProperty(exports, "f64", { enumerable: true, get: function() {
        return buffer_layout_2.f64;
      } });
      Object.defineProperty(exports, "struct", { enumerable: true, get: function() {
        return buffer_layout_2.struct;
      } });
      var BNLayout = class extends buffer_layout_1.Layout {
        constructor(span, signed, property) {
          super(span, property);
          this.blob = (0, buffer_layout_1.blob)(span);
          this.signed = signed;
        }
        decode(b, offset2 = 0) {
          const num = new bn_js_1.default(this.blob.decode(b, offset2), 10, "le");
          if (this.signed) {
            return num.fromTwos(this.span * 8).clone();
          }
          return num;
        }
        encode(src, b, offset2 = 0) {
          if (this.signed) {
            src = src.toTwos(this.span * 8);
          }
          return this.blob.encode(src.toArrayLike(Buffer, "le", this.span), b, offset2);
        }
      };
      function u643(property) {
        return new BNLayout(8, false, property);
      }
      exports.u64 = u643;
      function i642(property) {
        return new BNLayout(8, true, property);
      }
      exports.i64 = i642;
      function u1282(property) {
        return new BNLayout(16, false, property);
      }
      exports.u128 = u1282;
      function i1282(property) {
        return new BNLayout(16, true, property);
      }
      exports.i128 = i1282;
      function u2562(property) {
        return new BNLayout(32, false, property);
      }
      exports.u256 = u2562;
      function i2562(property) {
        return new BNLayout(32, true, property);
      }
      exports.i256 = i2562;
      var WrappedLayout2 = class extends buffer_layout_1.Layout {
        constructor(layout, decoder, encoder, property) {
          super(layout.span, property);
          this.layout = layout;
          this.decoder = decoder;
          this.encoder = encoder;
        }
        decode(b, offset2) {
          return this.decoder(this.layout.decode(b, offset2));
        }
        encode(src, b, offset2) {
          return this.layout.encode(this.encoder(src), b, offset2);
        }
        getSpan(b, offset2) {
          return this.layout.getSpan(b, offset2);
        }
      };
      function publicKey3(property) {
        return new WrappedLayout2((0, buffer_layout_1.blob)(32), (b) => new web3_js_1.PublicKey(b), (key) => key.toBuffer(), property);
      }
      exports.publicKey = publicKey3;
      var OptionLayout = class extends buffer_layout_1.Layout {
        constructor(layout, property) {
          super(-1, property);
          this.layout = layout;
          this.discriminator = (0, buffer_layout_1.u8)();
        }
        encode(src, b, offset2 = 0) {
          if (src === null || src === void 0) {
            return this.discriminator.encode(0, b, offset2);
          }
          this.discriminator.encode(1, b, offset2);
          return this.layout.encode(src, b, offset2 + 1) + 1;
        }
        decode(b, offset2 = 0) {
          const discriminator2 = this.discriminator.decode(b, offset2);
          if (discriminator2 === 0) {
            return null;
          } else if (discriminator2 === 1) {
            return this.layout.decode(b, offset2 + 1);
          }
          throw new Error("Invalid option " + this.property);
        }
        getSpan(b, offset2 = 0) {
          const discriminator2 = this.discriminator.decode(b, offset2);
          if (discriminator2 === 0) {
            return 1;
          } else if (discriminator2 === 1) {
            return this.layout.getSpan(b, offset2 + 1) + 1;
          }
          throw new Error("Invalid option " + this.property);
        }
      };
      function option2(layout, property) {
        return new OptionLayout(layout, property);
      }
      exports.option = option2;
      function bool2(property) {
        return new WrappedLayout2((0, buffer_layout_1.u8)(), decodeBool, encodeBool, property);
      }
      exports.bool = bool2;
      function decodeBool(value) {
        if (value === 0) {
          return false;
        } else if (value === 1) {
          return true;
        }
        throw new Error("Invalid bool: " + value);
      }
      function encodeBool(value) {
        return value ? 1 : 0;
      }
      function vec2(elementLayout, property) {
        const length = (0, buffer_layout_1.u32)("length");
        const layout = (0, buffer_layout_1.struct)([
          length,
          (0, buffer_layout_1.seq)(elementLayout, (0, buffer_layout_1.offset)(length, -length.span), "values")
        ]);
        return new WrappedLayout2(layout, ({ values }) => values, (values) => ({ values }), property);
      }
      exports.vec = vec2;
      function tagged(tag, layout, property) {
        const wrappedLayout = (0, buffer_layout_1.struct)([
          u643("tag"),
          layout.replicate("data")
        ]);
        function decodeTag({ tag: receivedTag, data }) {
          if (!receivedTag.eq(tag)) {
            throw new Error("Invalid tag, expected: " + tag.toString("hex") + ", got: " + receivedTag.toString("hex"));
          }
          return data;
        }
        return new WrappedLayout2(wrappedLayout, decodeTag, (data) => ({ tag, data }), property);
      }
      exports.tagged = tagged;
      function vecU82(property) {
        const length = (0, buffer_layout_1.u32)("length");
        const layout = (0, buffer_layout_1.struct)([
          length,
          (0, buffer_layout_1.blob)((0, buffer_layout_1.offset)(length, -length.span), "data")
        ]);
        return new WrappedLayout2(layout, ({ data }) => data, (data) => ({ data }), property);
      }
      exports.vecU8 = vecU82;
      function str2(property) {
        return new WrappedLayout2(vecU82(), (data) => data.toString("utf-8"), (s) => Buffer.from(s, "utf-8"), property);
      }
      exports.str = str2;
      function rustEnum2(variants, property, discriminant) {
        const unionLayout = (0, buffer_layout_1.union)(discriminant !== null && discriminant !== void 0 ? discriminant : (0, buffer_layout_1.u8)(), property);
        variants.forEach((variant, index2) => unionLayout.addVariant(index2, variant, variant.property));
        return unionLayout;
      }
      exports.rustEnum = rustEnum2;
      function array3(elementLayout, length, property) {
        const layout = (0, buffer_layout_1.struct)([
          (0, buffer_layout_1.seq)(elementLayout, length, "values")
        ]);
        return new WrappedLayout2(layout, ({ values }) => values, (values) => ({ values }), property);
      }
      exports.array = array3;
      var MapEntryLayout = class extends buffer_layout_1.Layout {
        constructor(keyLayout, valueLayout, property) {
          super(keyLayout.span + valueLayout.span, property);
          this.keyLayout = keyLayout;
          this.valueLayout = valueLayout;
        }
        decode(b, offset2) {
          offset2 = offset2 || 0;
          const key = this.keyLayout.decode(b, offset2);
          const value = this.valueLayout.decode(b, offset2 + this.keyLayout.getSpan(b, offset2));
          return [key, value];
        }
        encode(src, b, offset2) {
          offset2 = offset2 || 0;
          const keyBytes = this.keyLayout.encode(src[0], b, offset2);
          const valueBytes = this.valueLayout.encode(src[1], b, offset2 + keyBytes);
          return keyBytes + valueBytes;
        }
        getSpan(b, offset2) {
          return this.keyLayout.getSpan(b, offset2) + this.valueLayout.getSpan(b, offset2);
        }
      };
      function map(keyLayout, valueLayout, property) {
        const length = (0, buffer_layout_1.u32)("length");
        const layout = (0, buffer_layout_1.struct)([
          length,
          (0, buffer_layout_1.seq)(new MapEntryLayout(keyLayout, valueLayout), (0, buffer_layout_1.offset)(length, -length.span), "values")
        ]);
        return new WrappedLayout2(layout, ({ values }) => new Map(values), (values) => ({ values: Array.from(values.entries()) }), property);
      }
      exports.map = map;
    }
  });

  // node_modules/@coral-xyz/anchor/node_modules/eventemitter3/index.js
  var require_eventemitter32 = __commonJS({
    "node_modules/@coral-xyz/anchor/node_modules/eventemitter3/index.js"(exports, module) {
      "use strict";
      var has = Object.prototype.hasOwnProperty;
      var prefix = "~";
      function Events() {
      }
      if (Object.create) {
        Events.prototype = /* @__PURE__ */ Object.create(null);
        if (!new Events().__proto__) prefix = false;
      }
      function EE(fn, context, once) {
        this.fn = fn;
        this.context = context;
        this.once = once || false;
      }
      function addListener(emitter, event, fn, context, once) {
        if (typeof fn !== "function") {
          throw new TypeError("The listener must be a function");
        }
        var listener = new EE(fn, context || emitter, once), evt = prefix ? prefix + event : event;
        if (!emitter._events[evt]) emitter._events[evt] = listener, emitter._eventsCount++;
        else if (!emitter._events[evt].fn) emitter._events[evt].push(listener);
        else emitter._events[evt] = [emitter._events[evt], listener];
        return emitter;
      }
      function clearEvent(emitter, evt) {
        if (--emitter._eventsCount === 0) emitter._events = new Events();
        else delete emitter._events[evt];
      }
      function EventEmitter2() {
        this._events = new Events();
        this._eventsCount = 0;
      }
      EventEmitter2.prototype.eventNames = function eventNames() {
        var names = [], events, name;
        if (this._eventsCount === 0) return names;
        for (name in events = this._events) {
          if (has.call(events, name)) names.push(prefix ? name.slice(1) : name);
        }
        if (Object.getOwnPropertySymbols) {
          return names.concat(Object.getOwnPropertySymbols(events));
        }
        return names;
      };
      EventEmitter2.prototype.listeners = function listeners(event) {
        var evt = prefix ? prefix + event : event, handlers = this._events[evt];
        if (!handlers) return [];
        if (handlers.fn) return [handlers.fn];
        for (var i = 0, l = handlers.length, ee = new Array(l); i < l; i++) {
          ee[i] = handlers[i].fn;
        }
        return ee;
      };
      EventEmitter2.prototype.listenerCount = function listenerCount(event) {
        var evt = prefix ? prefix + event : event, listeners = this._events[evt];
        if (!listeners) return 0;
        if (listeners.fn) return 1;
        return listeners.length;
      };
      EventEmitter2.prototype.emit = function emit(event, a1, a2, a3, a4, a5) {
        var evt = prefix ? prefix + event : event;
        if (!this._events[evt]) return false;
        var listeners = this._events[evt], len = arguments.length, args, i;
        if (listeners.fn) {
          if (listeners.once) this.removeListener(event, listeners.fn, void 0, true);
          switch (len) {
            case 1:
              return listeners.fn.call(listeners.context), true;
            case 2:
              return listeners.fn.call(listeners.context, a1), true;
            case 3:
              return listeners.fn.call(listeners.context, a1, a2), true;
            case 4:
              return listeners.fn.call(listeners.context, a1, a2, a3), true;
            case 5:
              return listeners.fn.call(listeners.context, a1, a2, a3, a4), true;
            case 6:
              return listeners.fn.call(listeners.context, a1, a2, a3, a4, a5), true;
          }
          for (i = 1, args = new Array(len - 1); i < len; i++) {
            args[i - 1] = arguments[i];
          }
          listeners.fn.apply(listeners.context, args);
        } else {
          var length = listeners.length, j;
          for (i = 0; i < length; i++) {
            if (listeners[i].once) this.removeListener(event, listeners[i].fn, void 0, true);
            switch (len) {
              case 1:
                listeners[i].fn.call(listeners[i].context);
                break;
              case 2:
                listeners[i].fn.call(listeners[i].context, a1);
                break;
              case 3:
                listeners[i].fn.call(listeners[i].context, a1, a2);
                break;
              case 4:
                listeners[i].fn.call(listeners[i].context, a1, a2, a3);
                break;
              default:
                if (!args) for (j = 1, args = new Array(len - 1); j < len; j++) {
                  args[j - 1] = arguments[j];
                }
                listeners[i].fn.apply(listeners[i].context, args);
            }
          }
        }
        return true;
      };
      EventEmitter2.prototype.on = function on(event, fn, context) {
        return addListener(this, event, fn, context, false);
      };
      EventEmitter2.prototype.once = function once(event, fn, context) {
        return addListener(this, event, fn, context, true);
      };
      EventEmitter2.prototype.removeListener = function removeListener(event, fn, context, once) {
        var evt = prefix ? prefix + event : event;
        if (!this._events[evt]) return this;
        if (!fn) {
          clearEvent(this, evt);
          return this;
        }
        var listeners = this._events[evt];
        if (listeners.fn) {
          if (listeners.fn === fn && (!once || listeners.once) && (!context || listeners.context === context)) {
            clearEvent(this, evt);
          }
        } else {
          for (var i = 0, events = [], length = listeners.length; i < length; i++) {
            if (listeners[i].fn !== fn || once && !listeners[i].once || context && listeners[i].context !== context) {
              events.push(listeners[i]);
            }
          }
          if (events.length) this._events[evt] = events.length === 1 ? events[0] : events;
          else clearEvent(this, evt);
        }
        return this;
      };
      EventEmitter2.prototype.removeAllListeners = function removeAllListeners(event) {
        var evt;
        if (event) {
          evt = prefix ? prefix + event : event;
          if (this._events[evt]) clearEvent(this, evt);
        } else {
          this._events = new Events();
          this._eventsCount = 0;
        }
        return this;
      };
      EventEmitter2.prototype.off = EventEmitter2.prototype.removeListener;
      EventEmitter2.prototype.addListener = EventEmitter2.prototype.on;
      EventEmitter2.prefixed = prefix;
      EventEmitter2.EventEmitter = EventEmitter2;
      if ("undefined" !== typeof module) {
        module.exports = EventEmitter2;
      }
    }
  });

  // temp-entry.js
  var import_buffer2 = __toESM(require_buffer());
  var solanaWeb3 = __toESM(require_index_browser_cjs());

  // node_modules/@coral-xyz/anchor/dist/browser/index.js
  var browser_exports = {};
  __export(browser_exports, {
    AccountClient: () => AccountClient,
    AnchorError: () => AnchorError,
    AnchorProvider: () => AnchorProvider,
    BN: () => import_bn2.default,
    BorshAccountsCoder: () => BorshAccountsCoder,
    BorshCoder: () => BorshCoder,
    BorshEventCoder: () => BorshEventCoder,
    BorshInstructionCoder: () => BorshInstructionCoder,
    DISCRIMINATOR_SIZE: () => DISCRIMINATOR_SIZE,
    EventManager: () => EventManager,
    EventParser: () => EventParser,
    IdlError: () => IdlError,
    LangErrorCode: () => LangErrorCode,
    LangErrorMessage: () => LangErrorMessage,
    MethodsBuilderFactory: () => MethodsBuilderFactory,
    Native: () => Native,
    Program: () => Program,
    ProgramError: () => ProgramError,
    ProgramErrorStack: () => ProgramErrorStack,
    SystemCoder: () => SystemCoder,
    eventDiscriminator: () => eventDiscriminator,
    getProvider: () => getProvider,
    parseIdlErrors: () => parseIdlErrors,
    setProvider: () => setProvider,
    splitArgsAndCtx: () => splitArgsAndCtx,
    toInstruction: () => toInstruction,
    translateAddress: () => translateAddress,
    translateError: () => translateError,
    utils: () => index,
    validateAccounts: () => validateAccounts,
    web3: () => web3_js
  });
  var import_buffer = __toESM(require_buffer());
  var import_web3 = __toESM(require_index_browser_cjs());
  var web3_js = __toESM(require_index_browser_cjs());
  var import_bn = __toESM(require_bn());
  var import_bn2 = __toESM(require_bn());
  var import_bs58 = __toESM(require_bs58());
  var import_camelcase = __toESM(require_camelcase());
  var borsh = __toESM(require_dist2());

  // node_modules/@noble/hashes/esm/utils.js
  function isBytes(a) {
    return a instanceof Uint8Array || ArrayBuffer.isView(a) && a.constructor.name === "Uint8Array";
  }
  function abytes(b, ...lengths) {
    if (!isBytes(b))
      throw new Error("Uint8Array expected");
    if (lengths.length > 0 && !lengths.includes(b.length))
      throw new Error("Uint8Array expected of length " + lengths + ", got length=" + b.length);
  }
  function aexists(instance, checkFinished = true) {
    if (instance.destroyed)
      throw new Error("Hash instance has been destroyed");
    if (checkFinished && instance.finished)
      throw new Error("Hash#digest() has already been called");
  }
  function aoutput(out, instance) {
    abytes(out);
    const min = instance.outputLen;
    if (out.length < min) {
      throw new Error("digestInto() expects output buffer of length at least " + min);
    }
  }
  function clean(...arrays) {
    for (let i = 0; i < arrays.length; i++) {
      arrays[i].fill(0);
    }
  }
  function createView(arr) {
    return new DataView(arr.buffer, arr.byteOffset, arr.byteLength);
  }
  function rotr(word, shift) {
    return word << 32 - shift | word >>> shift;
  }
  function utf8ToBytes(str2) {
    if (typeof str2 !== "string")
      throw new Error("string expected");
    return new Uint8Array(new TextEncoder().encode(str2));
  }
  function toBytes(data) {
    if (typeof data === "string")
      data = utf8ToBytes(data);
    abytes(data);
    return data;
  }
  var Hash = class {
  };
  function createHasher(hashCons) {
    const hashC = (msg) => hashCons().update(toBytes(msg)).digest();
    const tmp = hashCons();
    hashC.outputLen = tmp.outputLen;
    hashC.blockLen = tmp.blockLen;
    hashC.create = () => hashCons();
    return hashC;
  }

  // node_modules/@noble/hashes/esm/_md.js
  function setBigUint64(view, byteOffset, value, isLE) {
    if (typeof view.setBigUint64 === "function")
      return view.setBigUint64(byteOffset, value, isLE);
    const _32n = BigInt(32);
    const _u32_max = BigInt(4294967295);
    const wh = Number(value >> _32n & _u32_max);
    const wl = Number(value & _u32_max);
    const h = isLE ? 4 : 0;
    const l = isLE ? 0 : 4;
    view.setUint32(byteOffset + h, wh, isLE);
    view.setUint32(byteOffset + l, wl, isLE);
  }
  function Chi(a, b, c) {
    return a & b ^ ~a & c;
  }
  function Maj(a, b, c) {
    return a & b ^ a & c ^ b & c;
  }
  var HashMD = class extends Hash {
    constructor(blockLen, outputLen, padOffset, isLE) {
      super();
      this.finished = false;
      this.length = 0;
      this.pos = 0;
      this.destroyed = false;
      this.blockLen = blockLen;
      this.outputLen = outputLen;
      this.padOffset = padOffset;
      this.isLE = isLE;
      this.buffer = new Uint8Array(blockLen);
      this.view = createView(this.buffer);
    }
    update(data) {
      aexists(this);
      data = toBytes(data);
      abytes(data);
      const { view, buffer, blockLen } = this;
      const len = data.length;
      for (let pos = 0; pos < len; ) {
        const take = Math.min(blockLen - this.pos, len - pos);
        if (take === blockLen) {
          const dataView = createView(data);
          for (; blockLen <= len - pos; pos += blockLen)
            this.process(dataView, pos);
          continue;
        }
        buffer.set(data.subarray(pos, pos + take), this.pos);
        this.pos += take;
        pos += take;
        if (this.pos === blockLen) {
          this.process(view, 0);
          this.pos = 0;
        }
      }
      this.length += data.length;
      this.roundClean();
      return this;
    }
    digestInto(out) {
      aexists(this);
      aoutput(out, this);
      this.finished = true;
      const { buffer, view, blockLen, isLE } = this;
      let { pos } = this;
      buffer[pos++] = 128;
      clean(this.buffer.subarray(pos));
      if (this.padOffset > blockLen - pos) {
        this.process(view, 0);
        pos = 0;
      }
      for (let i = pos; i < blockLen; i++)
        buffer[i] = 0;
      setBigUint64(view, blockLen - 8, BigInt(this.length * 8), isLE);
      this.process(view, 0);
      const oview = createView(out);
      const len = this.outputLen;
      if (len % 4)
        throw new Error("_sha2: outputLen should be aligned to 32bit");
      const outLen = len / 4;
      const state = this.get();
      if (outLen > state.length)
        throw new Error("_sha2: outputLen bigger than state");
      for (let i = 0; i < outLen; i++)
        oview.setUint32(4 * i, state[i], isLE);
    }
    digest() {
      const { buffer, outputLen } = this;
      this.digestInto(buffer);
      const res = buffer.slice(0, outputLen);
      this.destroy();
      return res;
    }
    _cloneInto(to) {
      to || (to = new this.constructor());
      to.set(...this.get());
      const { blockLen, buffer, length, finished, destroyed, pos } = this;
      to.destroyed = destroyed;
      to.finished = finished;
      to.length = length;
      to.pos = pos;
      if (length % blockLen)
        to.buffer.set(buffer);
      return to;
    }
    clone() {
      return this._cloneInto();
    }
  };
  var SHA256_IV = /* @__PURE__ */ Uint32Array.from([
    1779033703,
    3144134277,
    1013904242,
    2773480762,
    1359893119,
    2600822924,
    528734635,
    1541459225
  ]);

  // node_modules/@noble/hashes/esm/sha2.js
  var SHA256_K = /* @__PURE__ */ Uint32Array.from([
    1116352408,
    1899447441,
    3049323471,
    3921009573,
    961987163,
    1508970993,
    2453635748,
    2870763221,
    3624381080,
    310598401,
    607225278,
    1426881987,
    1925078388,
    2162078206,
    2614888103,
    3248222580,
    3835390401,
    4022224774,
    264347078,
    604807628,
    770255983,
    1249150122,
    1555081692,
    1996064986,
    2554220882,
    2821834349,
    2952996808,
    3210313671,
    3336571891,
    3584528711,
    113926993,
    338241895,
    666307205,
    773529912,
    1294757372,
    1396182291,
    1695183700,
    1986661051,
    2177026350,
    2456956037,
    2730485921,
    2820302411,
    3259730800,
    3345764771,
    3516065817,
    3600352804,
    4094571909,
    275423344,
    430227734,
    506948616,
    659060556,
    883997877,
    958139571,
    1322822218,
    1537002063,
    1747873779,
    1955562222,
    2024104815,
    2227730452,
    2361852424,
    2428436474,
    2756734187,
    3204031479,
    3329325298
  ]);
  var SHA256_W = /* @__PURE__ */ new Uint32Array(64);
  var SHA256 = class extends HashMD {
    constructor(outputLen = 32) {
      super(64, outputLen, 8, false);
      this.A = SHA256_IV[0] | 0;
      this.B = SHA256_IV[1] | 0;
      this.C = SHA256_IV[2] | 0;
      this.D = SHA256_IV[3] | 0;
      this.E = SHA256_IV[4] | 0;
      this.F = SHA256_IV[5] | 0;
      this.G = SHA256_IV[6] | 0;
      this.H = SHA256_IV[7] | 0;
    }
    get() {
      const { A, B, C, D, E, F, G, H } = this;
      return [A, B, C, D, E, F, G, H];
    }
    // prettier-ignore
    set(A, B, C, D, E, F, G, H) {
      this.A = A | 0;
      this.B = B | 0;
      this.C = C | 0;
      this.D = D | 0;
      this.E = E | 0;
      this.F = F | 0;
      this.G = G | 0;
      this.H = H | 0;
    }
    process(view, offset2) {
      for (let i = 0; i < 16; i++, offset2 += 4)
        SHA256_W[i] = view.getUint32(offset2, false);
      for (let i = 16; i < 64; i++) {
        const W15 = SHA256_W[i - 15];
        const W2 = SHA256_W[i - 2];
        const s0 = rotr(W15, 7) ^ rotr(W15, 18) ^ W15 >>> 3;
        const s1 = rotr(W2, 17) ^ rotr(W2, 19) ^ W2 >>> 10;
        SHA256_W[i] = s1 + SHA256_W[i - 7] + s0 + SHA256_W[i - 16] | 0;
      }
      let { A, B, C, D, E, F, G, H } = this;
      for (let i = 0; i < 64; i++) {
        const sigma1 = rotr(E, 6) ^ rotr(E, 11) ^ rotr(E, 25);
        const T1 = H + sigma1 + Chi(E, F, G) + SHA256_K[i] + SHA256_W[i] | 0;
        const sigma0 = rotr(A, 2) ^ rotr(A, 13) ^ rotr(A, 22);
        const T2 = sigma0 + Maj(A, B, C) | 0;
        H = G;
        G = F;
        F = E;
        E = D + T1 | 0;
        D = C;
        C = B;
        B = A;
        A = T1 + T2 | 0;
      }
      A = A + this.A | 0;
      B = B + this.B | 0;
      C = C + this.C | 0;
      D = D + this.D | 0;
      E = E + this.E | 0;
      F = F + this.F | 0;
      G = G + this.G | 0;
      H = H + this.H | 0;
      this.set(A, B, C, D, E, F, G, H);
    }
    roundClean() {
      clean(SHA256_W);
    }
    destroy() {
      this.set(0, 0, 0, 0, 0, 0, 0, 0);
      clean(this.buffer);
    }
  };
  var sha256 = /* @__PURE__ */ createHasher(() => new SHA256());

  // node_modules/@noble/hashes/esm/sha256.js
  var sha2562 = sha256;

  // node_modules/pako/dist/pako.esm.mjs
  var Z_FIXED$1 = 4;
  var Z_BINARY = 0;
  var Z_TEXT = 1;
  var Z_UNKNOWN$1 = 2;
  function zero$1(buf) {
    let len = buf.length;
    while (--len >= 0) {
      buf[len] = 0;
    }
  }
  var STORED_BLOCK = 0;
  var STATIC_TREES = 1;
  var DYN_TREES = 2;
  var MIN_MATCH$1 = 3;
  var MAX_MATCH$1 = 258;
  var LENGTH_CODES$1 = 29;
  var LITERALS$1 = 256;
  var L_CODES$1 = LITERALS$1 + 1 + LENGTH_CODES$1;
  var D_CODES$1 = 30;
  var BL_CODES$1 = 19;
  var HEAP_SIZE$1 = 2 * L_CODES$1 + 1;
  var MAX_BITS$1 = 15;
  var Buf_size = 16;
  var MAX_BL_BITS = 7;
  var END_BLOCK = 256;
  var REP_3_6 = 16;
  var REPZ_3_10 = 17;
  var REPZ_11_138 = 18;
  var extra_lbits = (
    /* extra bits for each length code */
    new Uint8Array([0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 2, 2, 2, 2, 3, 3, 3, 3, 4, 4, 4, 4, 5, 5, 5, 5, 0])
  );
  var extra_dbits = (
    /* extra bits for each distance code */
    new Uint8Array([0, 0, 0, 0, 1, 1, 2, 2, 3, 3, 4, 4, 5, 5, 6, 6, 7, 7, 8, 8, 9, 9, 10, 10, 11, 11, 12, 12, 13, 13])
  );
  var extra_blbits = (
    /* extra bits for each bit length code */
    new Uint8Array([0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 3, 7])
  );
  var bl_order = new Uint8Array([16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15]);
  var DIST_CODE_LEN = 512;
  var static_ltree = new Array((L_CODES$1 + 2) * 2);
  zero$1(static_ltree);
  var static_dtree = new Array(D_CODES$1 * 2);
  zero$1(static_dtree);
  var _dist_code = new Array(DIST_CODE_LEN);
  zero$1(_dist_code);
  var _length_code = new Array(MAX_MATCH$1 - MIN_MATCH$1 + 1);
  zero$1(_length_code);
  var base_length = new Array(LENGTH_CODES$1);
  zero$1(base_length);
  var base_dist = new Array(D_CODES$1);
  zero$1(base_dist);
  function StaticTreeDesc(static_tree, extra_bits, extra_base, elems, max_length) {
    this.static_tree = static_tree;
    this.extra_bits = extra_bits;
    this.extra_base = extra_base;
    this.elems = elems;
    this.max_length = max_length;
    this.has_stree = static_tree && static_tree.length;
  }
  var static_l_desc;
  var static_d_desc;
  var static_bl_desc;
  function TreeDesc(dyn_tree, stat_desc) {
    this.dyn_tree = dyn_tree;
    this.max_code = 0;
    this.stat_desc = stat_desc;
  }
  var d_code = (dist) => {
    return dist < 256 ? _dist_code[dist] : _dist_code[256 + (dist >>> 7)];
  };
  var put_short = (s, w) => {
    s.pending_buf[s.pending++] = w & 255;
    s.pending_buf[s.pending++] = w >>> 8 & 255;
  };
  var send_bits = (s, value, length) => {
    if (s.bi_valid > Buf_size - length) {
      s.bi_buf |= value << s.bi_valid & 65535;
      put_short(s, s.bi_buf);
      s.bi_buf = value >> Buf_size - s.bi_valid;
      s.bi_valid += length - Buf_size;
    } else {
      s.bi_buf |= value << s.bi_valid & 65535;
      s.bi_valid += length;
    }
  };
  var send_code = (s, c, tree) => {
    send_bits(
      s,
      tree[c * 2],
      tree[c * 2 + 1]
      /*.Len*/
    );
  };
  var bi_reverse = (code, len) => {
    let res = 0;
    do {
      res |= code & 1;
      code >>>= 1;
      res <<= 1;
    } while (--len > 0);
    return res >>> 1;
  };
  var bi_flush = (s) => {
    if (s.bi_valid === 16) {
      put_short(s, s.bi_buf);
      s.bi_buf = 0;
      s.bi_valid = 0;
    } else if (s.bi_valid >= 8) {
      s.pending_buf[s.pending++] = s.bi_buf & 255;
      s.bi_buf >>= 8;
      s.bi_valid -= 8;
    }
  };
  var gen_bitlen = (s, desc) => {
    const tree = desc.dyn_tree;
    const max_code = desc.max_code;
    const stree = desc.stat_desc.static_tree;
    const has_stree = desc.stat_desc.has_stree;
    const extra = desc.stat_desc.extra_bits;
    const base = desc.stat_desc.extra_base;
    const max_length = desc.stat_desc.max_length;
    let h;
    let n, m;
    let bits;
    let xbits;
    let f2;
    let overflow = 0;
    for (bits = 0; bits <= MAX_BITS$1; bits++) {
      s.bl_count[bits] = 0;
    }
    tree[s.heap[s.heap_max] * 2 + 1] = 0;
    for (h = s.heap_max + 1; h < HEAP_SIZE$1; h++) {
      n = s.heap[h];
      bits = tree[tree[n * 2 + 1] * 2 + 1] + 1;
      if (bits > max_length) {
        bits = max_length;
        overflow++;
      }
      tree[n * 2 + 1] = bits;
      if (n > max_code) {
        continue;
      }
      s.bl_count[bits]++;
      xbits = 0;
      if (n >= base) {
        xbits = extra[n - base];
      }
      f2 = tree[n * 2];
      s.opt_len += f2 * (bits + xbits);
      if (has_stree) {
        s.static_len += f2 * (stree[n * 2 + 1] + xbits);
      }
    }
    if (overflow === 0) {
      return;
    }
    do {
      bits = max_length - 1;
      while (s.bl_count[bits] === 0) {
        bits--;
      }
      s.bl_count[bits]--;
      s.bl_count[bits + 1] += 2;
      s.bl_count[max_length]--;
      overflow -= 2;
    } while (overflow > 0);
    for (bits = max_length; bits !== 0; bits--) {
      n = s.bl_count[bits];
      while (n !== 0) {
        m = s.heap[--h];
        if (m > max_code) {
          continue;
        }
        if (tree[m * 2 + 1] !== bits) {
          s.opt_len += (bits - tree[m * 2 + 1]) * tree[m * 2];
          tree[m * 2 + 1] = bits;
        }
        n--;
      }
    }
  };
  var gen_codes = (tree, max_code, bl_count) => {
    const next_code = new Array(MAX_BITS$1 + 1);
    let code = 0;
    let bits;
    let n;
    for (bits = 1; bits <= MAX_BITS$1; bits++) {
      code = code + bl_count[bits - 1] << 1;
      next_code[bits] = code;
    }
    for (n = 0; n <= max_code; n++) {
      let len = tree[n * 2 + 1];
      if (len === 0) {
        continue;
      }
      tree[n * 2] = bi_reverse(next_code[len]++, len);
    }
  };
  var tr_static_init = () => {
    let n;
    let bits;
    let length;
    let code;
    let dist;
    const bl_count = new Array(MAX_BITS$1 + 1);
    length = 0;
    for (code = 0; code < LENGTH_CODES$1 - 1; code++) {
      base_length[code] = length;
      for (n = 0; n < 1 << extra_lbits[code]; n++) {
        _length_code[length++] = code;
      }
    }
    _length_code[length - 1] = code;
    dist = 0;
    for (code = 0; code < 16; code++) {
      base_dist[code] = dist;
      for (n = 0; n < 1 << extra_dbits[code]; n++) {
        _dist_code[dist++] = code;
      }
    }
    dist >>= 7;
    for (; code < D_CODES$1; code++) {
      base_dist[code] = dist << 7;
      for (n = 0; n < 1 << extra_dbits[code] - 7; n++) {
        _dist_code[256 + dist++] = code;
      }
    }
    for (bits = 0; bits <= MAX_BITS$1; bits++) {
      bl_count[bits] = 0;
    }
    n = 0;
    while (n <= 143) {
      static_ltree[n * 2 + 1] = 8;
      n++;
      bl_count[8]++;
    }
    while (n <= 255) {
      static_ltree[n * 2 + 1] = 9;
      n++;
      bl_count[9]++;
    }
    while (n <= 279) {
      static_ltree[n * 2 + 1] = 7;
      n++;
      bl_count[7]++;
    }
    while (n <= 287) {
      static_ltree[n * 2 + 1] = 8;
      n++;
      bl_count[8]++;
    }
    gen_codes(static_ltree, L_CODES$1 + 1, bl_count);
    for (n = 0; n < D_CODES$1; n++) {
      static_dtree[n * 2 + 1] = 5;
      static_dtree[n * 2] = bi_reverse(n, 5);
    }
    static_l_desc = new StaticTreeDesc(static_ltree, extra_lbits, LITERALS$1 + 1, L_CODES$1, MAX_BITS$1);
    static_d_desc = new StaticTreeDesc(static_dtree, extra_dbits, 0, D_CODES$1, MAX_BITS$1);
    static_bl_desc = new StaticTreeDesc(new Array(0), extra_blbits, 0, BL_CODES$1, MAX_BL_BITS);
  };
  var init_block = (s) => {
    let n;
    for (n = 0; n < L_CODES$1; n++) {
      s.dyn_ltree[n * 2] = 0;
    }
    for (n = 0; n < D_CODES$1; n++) {
      s.dyn_dtree[n * 2] = 0;
    }
    for (n = 0; n < BL_CODES$1; n++) {
      s.bl_tree[n * 2] = 0;
    }
    s.dyn_ltree[END_BLOCK * 2] = 1;
    s.opt_len = s.static_len = 0;
    s.sym_next = s.matches = 0;
  };
  var bi_windup = (s) => {
    if (s.bi_valid > 8) {
      put_short(s, s.bi_buf);
    } else if (s.bi_valid > 0) {
      s.pending_buf[s.pending++] = s.bi_buf;
    }
    s.bi_buf = 0;
    s.bi_valid = 0;
  };
  var smaller = (tree, n, m, depth) => {
    const _n2 = n * 2;
    const _m2 = m * 2;
    return tree[_n2] < tree[_m2] || tree[_n2] === tree[_m2] && depth[n] <= depth[m];
  };
  var pqdownheap = (s, tree, k) => {
    const v = s.heap[k];
    let j = k << 1;
    while (j <= s.heap_len) {
      if (j < s.heap_len && smaller(tree, s.heap[j + 1], s.heap[j], s.depth)) {
        j++;
      }
      if (smaller(tree, v, s.heap[j], s.depth)) {
        break;
      }
      s.heap[k] = s.heap[j];
      k = j;
      j <<= 1;
    }
    s.heap[k] = v;
  };
  var compress_block = (s, ltree, dtree) => {
    let dist;
    let lc;
    let sx = 0;
    let code;
    let extra;
    if (s.sym_next !== 0) {
      do {
        dist = s.pending_buf[s.sym_buf + sx++] & 255;
        dist += (s.pending_buf[s.sym_buf + sx++] & 255) << 8;
        lc = s.pending_buf[s.sym_buf + sx++];
        if (dist === 0) {
          send_code(s, lc, ltree);
        } else {
          code = _length_code[lc];
          send_code(s, code + LITERALS$1 + 1, ltree);
          extra = extra_lbits[code];
          if (extra !== 0) {
            lc -= base_length[code];
            send_bits(s, lc, extra);
          }
          dist--;
          code = d_code(dist);
          send_code(s, code, dtree);
          extra = extra_dbits[code];
          if (extra !== 0) {
            dist -= base_dist[code];
            send_bits(s, dist, extra);
          }
        }
      } while (sx < s.sym_next);
    }
    send_code(s, END_BLOCK, ltree);
  };
  var build_tree = (s, desc) => {
    const tree = desc.dyn_tree;
    const stree = desc.stat_desc.static_tree;
    const has_stree = desc.stat_desc.has_stree;
    const elems = desc.stat_desc.elems;
    let n, m;
    let max_code = -1;
    let node;
    s.heap_len = 0;
    s.heap_max = HEAP_SIZE$1;
    for (n = 0; n < elems; n++) {
      if (tree[n * 2] !== 0) {
        s.heap[++s.heap_len] = max_code = n;
        s.depth[n] = 0;
      } else {
        tree[n * 2 + 1] = 0;
      }
    }
    while (s.heap_len < 2) {
      node = s.heap[++s.heap_len] = max_code < 2 ? ++max_code : 0;
      tree[node * 2] = 1;
      s.depth[node] = 0;
      s.opt_len--;
      if (has_stree) {
        s.static_len -= stree[node * 2 + 1];
      }
    }
    desc.max_code = max_code;
    for (n = s.heap_len >> 1; n >= 1; n--) {
      pqdownheap(s, tree, n);
    }
    node = elems;
    do {
      n = s.heap[
        1
        /*SMALLEST*/
      ];
      s.heap[
        1
        /*SMALLEST*/
      ] = s.heap[s.heap_len--];
      pqdownheap(
        s,
        tree,
        1
        /*SMALLEST*/
      );
      m = s.heap[
        1
        /*SMALLEST*/
      ];
      s.heap[--s.heap_max] = n;
      s.heap[--s.heap_max] = m;
      tree[node * 2] = tree[n * 2] + tree[m * 2];
      s.depth[node] = (s.depth[n] >= s.depth[m] ? s.depth[n] : s.depth[m]) + 1;
      tree[n * 2 + 1] = tree[m * 2 + 1] = node;
      s.heap[
        1
        /*SMALLEST*/
      ] = node++;
      pqdownheap(
        s,
        tree,
        1
        /*SMALLEST*/
      );
    } while (s.heap_len >= 2);
    s.heap[--s.heap_max] = s.heap[
      1
      /*SMALLEST*/
    ];
    gen_bitlen(s, desc);
    gen_codes(tree, max_code, s.bl_count);
  };
  var scan_tree = (s, tree, max_code) => {
    let n;
    let prevlen = -1;
    let curlen;
    let nextlen = tree[0 * 2 + 1];
    let count = 0;
    let max_count = 7;
    let min_count = 4;
    if (nextlen === 0) {
      max_count = 138;
      min_count = 3;
    }
    tree[(max_code + 1) * 2 + 1] = 65535;
    for (n = 0; n <= max_code; n++) {
      curlen = nextlen;
      nextlen = tree[(n + 1) * 2 + 1];
      if (++count < max_count && curlen === nextlen) {
        continue;
      } else if (count < min_count) {
        s.bl_tree[curlen * 2] += count;
      } else if (curlen !== 0) {
        if (curlen !== prevlen) {
          s.bl_tree[curlen * 2]++;
        }
        s.bl_tree[REP_3_6 * 2]++;
      } else if (count <= 10) {
        s.bl_tree[REPZ_3_10 * 2]++;
      } else {
        s.bl_tree[REPZ_11_138 * 2]++;
      }
      count = 0;
      prevlen = curlen;
      if (nextlen === 0) {
        max_count = 138;
        min_count = 3;
      } else if (curlen === nextlen) {
        max_count = 6;
        min_count = 3;
      } else {
        max_count = 7;
        min_count = 4;
      }
    }
  };
  var send_tree = (s, tree, max_code) => {
    let n;
    let prevlen = -1;
    let curlen;
    let nextlen = tree[0 * 2 + 1];
    let count = 0;
    let max_count = 7;
    let min_count = 4;
    if (nextlen === 0) {
      max_count = 138;
      min_count = 3;
    }
    for (n = 0; n <= max_code; n++) {
      curlen = nextlen;
      nextlen = tree[(n + 1) * 2 + 1];
      if (++count < max_count && curlen === nextlen) {
        continue;
      } else if (count < min_count) {
        do {
          send_code(s, curlen, s.bl_tree);
        } while (--count !== 0);
      } else if (curlen !== 0) {
        if (curlen !== prevlen) {
          send_code(s, curlen, s.bl_tree);
          count--;
        }
        send_code(s, REP_3_6, s.bl_tree);
        send_bits(s, count - 3, 2);
      } else if (count <= 10) {
        send_code(s, REPZ_3_10, s.bl_tree);
        send_bits(s, count - 3, 3);
      } else {
        send_code(s, REPZ_11_138, s.bl_tree);
        send_bits(s, count - 11, 7);
      }
      count = 0;
      prevlen = curlen;
      if (nextlen === 0) {
        max_count = 138;
        min_count = 3;
      } else if (curlen === nextlen) {
        max_count = 6;
        min_count = 3;
      } else {
        max_count = 7;
        min_count = 4;
      }
    }
  };
  var build_bl_tree = (s) => {
    let max_blindex;
    scan_tree(s, s.dyn_ltree, s.l_desc.max_code);
    scan_tree(s, s.dyn_dtree, s.d_desc.max_code);
    build_tree(s, s.bl_desc);
    for (max_blindex = BL_CODES$1 - 1; max_blindex >= 3; max_blindex--) {
      if (s.bl_tree[bl_order[max_blindex] * 2 + 1] !== 0) {
        break;
      }
    }
    s.opt_len += 3 * (max_blindex + 1) + 5 + 5 + 4;
    return max_blindex;
  };
  var send_all_trees = (s, lcodes, dcodes, blcodes) => {
    let rank2;
    send_bits(s, lcodes - 257, 5);
    send_bits(s, dcodes - 1, 5);
    send_bits(s, blcodes - 4, 4);
    for (rank2 = 0; rank2 < blcodes; rank2++) {
      send_bits(s, s.bl_tree[bl_order[rank2] * 2 + 1], 3);
    }
    send_tree(s, s.dyn_ltree, lcodes - 1);
    send_tree(s, s.dyn_dtree, dcodes - 1);
  };
  var detect_data_type = (s) => {
    let block_mask = 4093624447;
    let n;
    for (n = 0; n <= 31; n++, block_mask >>>= 1) {
      if (block_mask & 1 && s.dyn_ltree[n * 2] !== 0) {
        return Z_BINARY;
      }
    }
    if (s.dyn_ltree[9 * 2] !== 0 || s.dyn_ltree[10 * 2] !== 0 || s.dyn_ltree[13 * 2] !== 0) {
      return Z_TEXT;
    }
    for (n = 32; n < LITERALS$1; n++) {
      if (s.dyn_ltree[n * 2] !== 0) {
        return Z_TEXT;
      }
    }
    return Z_BINARY;
  };
  var static_init_done = false;
  var _tr_init$1 = (s) => {
    if (!static_init_done) {
      tr_static_init();
      static_init_done = true;
    }
    s.l_desc = new TreeDesc(s.dyn_ltree, static_l_desc);
    s.d_desc = new TreeDesc(s.dyn_dtree, static_d_desc);
    s.bl_desc = new TreeDesc(s.bl_tree, static_bl_desc);
    s.bi_buf = 0;
    s.bi_valid = 0;
    init_block(s);
  };
  var _tr_stored_block$1 = (s, buf, stored_len, last) => {
    send_bits(s, (STORED_BLOCK << 1) + (last ? 1 : 0), 3);
    bi_windup(s);
    put_short(s, stored_len);
    put_short(s, ~stored_len);
    if (stored_len) {
      s.pending_buf.set(s.window.subarray(buf, buf + stored_len), s.pending);
    }
    s.pending += stored_len;
  };
  var _tr_align$1 = (s) => {
    send_bits(s, STATIC_TREES << 1, 3);
    send_code(s, END_BLOCK, static_ltree);
    bi_flush(s);
  };
  var _tr_flush_block$1 = (s, buf, stored_len, last) => {
    let opt_lenb, static_lenb;
    let max_blindex = 0;
    if (s.level > 0) {
      if (s.strm.data_type === Z_UNKNOWN$1) {
        s.strm.data_type = detect_data_type(s);
      }
      build_tree(s, s.l_desc);
      build_tree(s, s.d_desc);
      max_blindex = build_bl_tree(s);
      opt_lenb = s.opt_len + 3 + 7 >>> 3;
      static_lenb = s.static_len + 3 + 7 >>> 3;
      if (static_lenb <= opt_lenb) {
        opt_lenb = static_lenb;
      }
    } else {
      opt_lenb = static_lenb = stored_len + 5;
    }
    if (stored_len + 4 <= opt_lenb && buf !== -1) {
      _tr_stored_block$1(s, buf, stored_len, last);
    } else if (s.strategy === Z_FIXED$1 || static_lenb === opt_lenb) {
      send_bits(s, (STATIC_TREES << 1) + (last ? 1 : 0), 3);
      compress_block(s, static_ltree, static_dtree);
    } else {
      send_bits(s, (DYN_TREES << 1) + (last ? 1 : 0), 3);
      send_all_trees(s, s.l_desc.max_code + 1, s.d_desc.max_code + 1, max_blindex + 1);
      compress_block(s, s.dyn_ltree, s.dyn_dtree);
    }
    init_block(s);
    if (last) {
      bi_windup(s);
    }
  };
  var _tr_tally$1 = (s, dist, lc) => {
    s.pending_buf[s.sym_buf + s.sym_next++] = dist;
    s.pending_buf[s.sym_buf + s.sym_next++] = dist >> 8;
    s.pending_buf[s.sym_buf + s.sym_next++] = lc;
    if (dist === 0) {
      s.dyn_ltree[lc * 2]++;
    } else {
      s.matches++;
      dist--;
      s.dyn_ltree[(_length_code[lc] + LITERALS$1 + 1) * 2]++;
      s.dyn_dtree[d_code(dist) * 2]++;
    }
    return s.sym_next === s.sym_end;
  };
  var _tr_init_1 = _tr_init$1;
  var _tr_stored_block_1 = _tr_stored_block$1;
  var _tr_flush_block_1 = _tr_flush_block$1;
  var _tr_tally_1 = _tr_tally$1;
  var _tr_align_1 = _tr_align$1;
  var trees = {
    _tr_init: _tr_init_1,
    _tr_stored_block: _tr_stored_block_1,
    _tr_flush_block: _tr_flush_block_1,
    _tr_tally: _tr_tally_1,
    _tr_align: _tr_align_1
  };
  var adler32 = (adler, buf, len, pos) => {
    let s1 = adler & 65535 | 0, s2 = adler >>> 16 & 65535 | 0, n = 0;
    while (len !== 0) {
      n = len > 2e3 ? 2e3 : len;
      len -= n;
      do {
        s1 = s1 + buf[pos++] | 0;
        s2 = s2 + s1 | 0;
      } while (--n);
      s1 %= 65521;
      s2 %= 65521;
    }
    return s1 | s2 << 16 | 0;
  };
  var adler32_1 = adler32;
  var makeTable = () => {
    let c, table = [];
    for (var n = 0; n < 256; n++) {
      c = n;
      for (var k = 0; k < 8; k++) {
        c = c & 1 ? 3988292384 ^ c >>> 1 : c >>> 1;
      }
      table[n] = c;
    }
    return table;
  };
  var crcTable = new Uint32Array(makeTable());
  var crc32 = (crc, buf, len, pos) => {
    const t = crcTable;
    const end = pos + len;
    crc ^= -1;
    for (let i = pos; i < end; i++) {
      crc = crc >>> 8 ^ t[(crc ^ buf[i]) & 255];
    }
    return crc ^ -1;
  };
  var crc32_1 = crc32;
  var messages = {
    2: "need dictionary",
    /* Z_NEED_DICT       2  */
    1: "stream end",
    /* Z_STREAM_END      1  */
    0: "",
    /* Z_OK              0  */
    "-1": "file error",
    /* Z_ERRNO         (-1) */
    "-2": "stream error",
    /* Z_STREAM_ERROR  (-2) */
    "-3": "data error",
    /* Z_DATA_ERROR    (-3) */
    "-4": "insufficient memory",
    /* Z_MEM_ERROR     (-4) */
    "-5": "buffer error",
    /* Z_BUF_ERROR     (-5) */
    "-6": "incompatible version"
    /* Z_VERSION_ERROR (-6) */
  };
  var constants$2 = {
    /* Allowed flush values; see deflate() and inflate() below for details */
    Z_NO_FLUSH: 0,
    Z_PARTIAL_FLUSH: 1,
    Z_SYNC_FLUSH: 2,
    Z_FULL_FLUSH: 3,
    Z_FINISH: 4,
    Z_BLOCK: 5,
    Z_TREES: 6,
    /* Return codes for the compression/decompression functions. Negative values
    * are errors, positive values are used for special but normal events.
    */
    Z_OK: 0,
    Z_STREAM_END: 1,
    Z_NEED_DICT: 2,
    Z_ERRNO: -1,
    Z_STREAM_ERROR: -2,
    Z_DATA_ERROR: -3,
    Z_MEM_ERROR: -4,
    Z_BUF_ERROR: -5,
    //Z_VERSION_ERROR: -6,
    /* compression levels */
    Z_NO_COMPRESSION: 0,
    Z_BEST_SPEED: 1,
    Z_BEST_COMPRESSION: 9,
    Z_DEFAULT_COMPRESSION: -1,
    Z_FILTERED: 1,
    Z_HUFFMAN_ONLY: 2,
    Z_RLE: 3,
    Z_FIXED: 4,
    Z_DEFAULT_STRATEGY: 0,
    /* Possible values of the data_type field (though see inflate()) */
    Z_BINARY: 0,
    Z_TEXT: 1,
    //Z_ASCII:                1, // = Z_TEXT (deprecated)
    Z_UNKNOWN: 2,
    /* The deflate compression method */
    Z_DEFLATED: 8
    //Z_NULL:                 null // Use -1 or null inline, depending on var type
  };
  var { _tr_init, _tr_stored_block, _tr_flush_block, _tr_tally, _tr_align } = trees;
  var {
    Z_NO_FLUSH: Z_NO_FLUSH$2,
    Z_PARTIAL_FLUSH,
    Z_FULL_FLUSH: Z_FULL_FLUSH$1,
    Z_FINISH: Z_FINISH$3,
    Z_BLOCK: Z_BLOCK$1,
    Z_OK: Z_OK$3,
    Z_STREAM_END: Z_STREAM_END$3,
    Z_STREAM_ERROR: Z_STREAM_ERROR$2,
    Z_DATA_ERROR: Z_DATA_ERROR$2,
    Z_BUF_ERROR: Z_BUF_ERROR$1,
    Z_DEFAULT_COMPRESSION: Z_DEFAULT_COMPRESSION$1,
    Z_FILTERED,
    Z_HUFFMAN_ONLY,
    Z_RLE,
    Z_FIXED,
    Z_DEFAULT_STRATEGY: Z_DEFAULT_STRATEGY$1,
    Z_UNKNOWN,
    Z_DEFLATED: Z_DEFLATED$2
  } = constants$2;
  var MAX_MEM_LEVEL = 9;
  var MAX_WBITS$1 = 15;
  var DEF_MEM_LEVEL = 8;
  var LENGTH_CODES = 29;
  var LITERALS = 256;
  var L_CODES = LITERALS + 1 + LENGTH_CODES;
  var D_CODES = 30;
  var BL_CODES = 19;
  var HEAP_SIZE = 2 * L_CODES + 1;
  var MAX_BITS = 15;
  var MIN_MATCH = 3;
  var MAX_MATCH = 258;
  var MIN_LOOKAHEAD = MAX_MATCH + MIN_MATCH + 1;
  var PRESET_DICT = 32;
  var INIT_STATE = 42;
  var GZIP_STATE = 57;
  var EXTRA_STATE = 69;
  var NAME_STATE = 73;
  var COMMENT_STATE = 91;
  var HCRC_STATE = 103;
  var BUSY_STATE = 113;
  var FINISH_STATE = 666;
  var BS_NEED_MORE = 1;
  var BS_BLOCK_DONE = 2;
  var BS_FINISH_STARTED = 3;
  var BS_FINISH_DONE = 4;
  var OS_CODE = 3;
  var err = (strm, errorCode) => {
    strm.msg = messages[errorCode];
    return errorCode;
  };
  var rank = (f2) => {
    return f2 * 2 - (f2 > 4 ? 9 : 0);
  };
  var zero = (buf) => {
    let len = buf.length;
    while (--len >= 0) {
      buf[len] = 0;
    }
  };
  var slide_hash = (s) => {
    let n, m;
    let p;
    let wsize = s.w_size;
    n = s.hash_size;
    p = n;
    do {
      m = s.head[--p];
      s.head[p] = m >= wsize ? m - wsize : 0;
    } while (--n);
    n = wsize;
    p = n;
    do {
      m = s.prev[--p];
      s.prev[p] = m >= wsize ? m - wsize : 0;
    } while (--n);
  };
  var HASH_ZLIB = (s, prev, data) => (prev << s.hash_shift ^ data) & s.hash_mask;
  var HASH = HASH_ZLIB;
  var flush_pending = (strm) => {
    const s = strm.state;
    let len = s.pending;
    if (len > strm.avail_out) {
      len = strm.avail_out;
    }
    if (len === 0) {
      return;
    }
    strm.output.set(s.pending_buf.subarray(s.pending_out, s.pending_out + len), strm.next_out);
    strm.next_out += len;
    s.pending_out += len;
    strm.total_out += len;
    strm.avail_out -= len;
    s.pending -= len;
    if (s.pending === 0) {
      s.pending_out = 0;
    }
  };
  var flush_block_only = (s, last) => {
    _tr_flush_block(s, s.block_start >= 0 ? s.block_start : -1, s.strstart - s.block_start, last);
    s.block_start = s.strstart;
    flush_pending(s.strm);
  };
  var put_byte = (s, b) => {
    s.pending_buf[s.pending++] = b;
  };
  var putShortMSB = (s, b) => {
    s.pending_buf[s.pending++] = b >>> 8 & 255;
    s.pending_buf[s.pending++] = b & 255;
  };
  var read_buf = (strm, buf, start, size) => {
    let len = strm.avail_in;
    if (len > size) {
      len = size;
    }
    if (len === 0) {
      return 0;
    }
    strm.avail_in -= len;
    buf.set(strm.input.subarray(strm.next_in, strm.next_in + len), start);
    if (strm.state.wrap === 1) {
      strm.adler = adler32_1(strm.adler, buf, len, start);
    } else if (strm.state.wrap === 2) {
      strm.adler = crc32_1(strm.adler, buf, len, start);
    }
    strm.next_in += len;
    strm.total_in += len;
    return len;
  };
  var longest_match = (s, cur_match) => {
    let chain_length = s.max_chain_length;
    let scan = s.strstart;
    let match;
    let len;
    let best_len = s.prev_length;
    let nice_match = s.nice_match;
    const limit = s.strstart > s.w_size - MIN_LOOKAHEAD ? s.strstart - (s.w_size - MIN_LOOKAHEAD) : 0;
    const _win = s.window;
    const wmask = s.w_mask;
    const prev = s.prev;
    const strend = s.strstart + MAX_MATCH;
    let scan_end1 = _win[scan + best_len - 1];
    let scan_end = _win[scan + best_len];
    if (s.prev_length >= s.good_match) {
      chain_length >>= 2;
    }
    if (nice_match > s.lookahead) {
      nice_match = s.lookahead;
    }
    do {
      match = cur_match;
      if (_win[match + best_len] !== scan_end || _win[match + best_len - 1] !== scan_end1 || _win[match] !== _win[scan] || _win[++match] !== _win[scan + 1]) {
        continue;
      }
      scan += 2;
      match++;
      do {
      } while (_win[++scan] === _win[++match] && _win[++scan] === _win[++match] && _win[++scan] === _win[++match] && _win[++scan] === _win[++match] && _win[++scan] === _win[++match] && _win[++scan] === _win[++match] && _win[++scan] === _win[++match] && _win[++scan] === _win[++match] && scan < strend);
      len = MAX_MATCH - (strend - scan);
      scan = strend - MAX_MATCH;
      if (len > best_len) {
        s.match_start = cur_match;
        best_len = len;
        if (len >= nice_match) {
          break;
        }
        scan_end1 = _win[scan + best_len - 1];
        scan_end = _win[scan + best_len];
      }
    } while ((cur_match = prev[cur_match & wmask]) > limit && --chain_length !== 0);
    if (best_len <= s.lookahead) {
      return best_len;
    }
    return s.lookahead;
  };
  var fill_window = (s) => {
    const _w_size = s.w_size;
    let n, more, str2;
    do {
      more = s.window_size - s.lookahead - s.strstart;
      if (s.strstart >= _w_size + (_w_size - MIN_LOOKAHEAD)) {
        s.window.set(s.window.subarray(_w_size, _w_size + _w_size - more), 0);
        s.match_start -= _w_size;
        s.strstart -= _w_size;
        s.block_start -= _w_size;
        if (s.insert > s.strstart) {
          s.insert = s.strstart;
        }
        slide_hash(s);
        more += _w_size;
      }
      if (s.strm.avail_in === 0) {
        break;
      }
      n = read_buf(s.strm, s.window, s.strstart + s.lookahead, more);
      s.lookahead += n;
      if (s.lookahead + s.insert >= MIN_MATCH) {
        str2 = s.strstart - s.insert;
        s.ins_h = s.window[str2];
        s.ins_h = HASH(s, s.ins_h, s.window[str2 + 1]);
        while (s.insert) {
          s.ins_h = HASH(s, s.ins_h, s.window[str2 + MIN_MATCH - 1]);
          s.prev[str2 & s.w_mask] = s.head[s.ins_h];
          s.head[s.ins_h] = str2;
          str2++;
          s.insert--;
          if (s.lookahead + s.insert < MIN_MATCH) {
            break;
          }
        }
      }
    } while (s.lookahead < MIN_LOOKAHEAD && s.strm.avail_in !== 0);
  };
  var deflate_stored = (s, flush) => {
    let min_block = s.pending_buf_size - 5 > s.w_size ? s.w_size : s.pending_buf_size - 5;
    let len, left, have, last = 0;
    let used = s.strm.avail_in;
    do {
      len = 65535;
      have = s.bi_valid + 42 >> 3;
      if (s.strm.avail_out < have) {
        break;
      }
      have = s.strm.avail_out - have;
      left = s.strstart - s.block_start;
      if (len > left + s.strm.avail_in) {
        len = left + s.strm.avail_in;
      }
      if (len > have) {
        len = have;
      }
      if (len < min_block && (len === 0 && flush !== Z_FINISH$3 || flush === Z_NO_FLUSH$2 || len !== left + s.strm.avail_in)) {
        break;
      }
      last = flush === Z_FINISH$3 && len === left + s.strm.avail_in ? 1 : 0;
      _tr_stored_block(s, 0, 0, last);
      s.pending_buf[s.pending - 4] = len;
      s.pending_buf[s.pending - 3] = len >> 8;
      s.pending_buf[s.pending - 2] = ~len;
      s.pending_buf[s.pending - 1] = ~len >> 8;
      flush_pending(s.strm);
      if (left) {
        if (left > len) {
          left = len;
        }
        s.strm.output.set(s.window.subarray(s.block_start, s.block_start + left), s.strm.next_out);
        s.strm.next_out += left;
        s.strm.avail_out -= left;
        s.strm.total_out += left;
        s.block_start += left;
        len -= left;
      }
      if (len) {
        read_buf(s.strm, s.strm.output, s.strm.next_out, len);
        s.strm.next_out += len;
        s.strm.avail_out -= len;
        s.strm.total_out += len;
      }
    } while (last === 0);
    used -= s.strm.avail_in;
    if (used) {
      if (used >= s.w_size) {
        s.matches = 2;
        s.window.set(s.strm.input.subarray(s.strm.next_in - s.w_size, s.strm.next_in), 0);
        s.strstart = s.w_size;
        s.insert = s.strstart;
      } else {
        if (s.window_size - s.strstart <= used) {
          s.strstart -= s.w_size;
          s.window.set(s.window.subarray(s.w_size, s.w_size + s.strstart), 0);
          if (s.matches < 2) {
            s.matches++;
          }
          if (s.insert > s.strstart) {
            s.insert = s.strstart;
          }
        }
        s.window.set(s.strm.input.subarray(s.strm.next_in - used, s.strm.next_in), s.strstart);
        s.strstart += used;
        s.insert += used > s.w_size - s.insert ? s.w_size - s.insert : used;
      }
      s.block_start = s.strstart;
    }
    if (s.high_water < s.strstart) {
      s.high_water = s.strstart;
    }
    if (last) {
      return BS_FINISH_DONE;
    }
    if (flush !== Z_NO_FLUSH$2 && flush !== Z_FINISH$3 && s.strm.avail_in === 0 && s.strstart === s.block_start) {
      return BS_BLOCK_DONE;
    }
    have = s.window_size - s.strstart;
    if (s.strm.avail_in > have && s.block_start >= s.w_size) {
      s.block_start -= s.w_size;
      s.strstart -= s.w_size;
      s.window.set(s.window.subarray(s.w_size, s.w_size + s.strstart), 0);
      if (s.matches < 2) {
        s.matches++;
      }
      have += s.w_size;
      if (s.insert > s.strstart) {
        s.insert = s.strstart;
      }
    }
    if (have > s.strm.avail_in) {
      have = s.strm.avail_in;
    }
    if (have) {
      read_buf(s.strm, s.window, s.strstart, have);
      s.strstart += have;
      s.insert += have > s.w_size - s.insert ? s.w_size - s.insert : have;
    }
    if (s.high_water < s.strstart) {
      s.high_water = s.strstart;
    }
    have = s.bi_valid + 42 >> 3;
    have = s.pending_buf_size - have > 65535 ? 65535 : s.pending_buf_size - have;
    min_block = have > s.w_size ? s.w_size : have;
    left = s.strstart - s.block_start;
    if (left >= min_block || (left || flush === Z_FINISH$3) && flush !== Z_NO_FLUSH$2 && s.strm.avail_in === 0 && left <= have) {
      len = left > have ? have : left;
      last = flush === Z_FINISH$3 && s.strm.avail_in === 0 && len === left ? 1 : 0;
      _tr_stored_block(s, s.block_start, len, last);
      s.block_start += len;
      flush_pending(s.strm);
    }
    return last ? BS_FINISH_STARTED : BS_NEED_MORE;
  };
  var deflate_fast = (s, flush) => {
    let hash_head;
    let bflush;
    for (; ; ) {
      if (s.lookahead < MIN_LOOKAHEAD) {
        fill_window(s);
        if (s.lookahead < MIN_LOOKAHEAD && flush === Z_NO_FLUSH$2) {
          return BS_NEED_MORE;
        }
        if (s.lookahead === 0) {
          break;
        }
      }
      hash_head = 0;
      if (s.lookahead >= MIN_MATCH) {
        s.ins_h = HASH(s, s.ins_h, s.window[s.strstart + MIN_MATCH - 1]);
        hash_head = s.prev[s.strstart & s.w_mask] = s.head[s.ins_h];
        s.head[s.ins_h] = s.strstart;
      }
      if (hash_head !== 0 && s.strstart - hash_head <= s.w_size - MIN_LOOKAHEAD) {
        s.match_length = longest_match(s, hash_head);
      }
      if (s.match_length >= MIN_MATCH) {
        bflush = _tr_tally(s, s.strstart - s.match_start, s.match_length - MIN_MATCH);
        s.lookahead -= s.match_length;
        if (s.match_length <= s.max_lazy_match && s.lookahead >= MIN_MATCH) {
          s.match_length--;
          do {
            s.strstart++;
            s.ins_h = HASH(s, s.ins_h, s.window[s.strstart + MIN_MATCH - 1]);
            hash_head = s.prev[s.strstart & s.w_mask] = s.head[s.ins_h];
            s.head[s.ins_h] = s.strstart;
          } while (--s.match_length !== 0);
          s.strstart++;
        } else {
          s.strstart += s.match_length;
          s.match_length = 0;
          s.ins_h = s.window[s.strstart];
          s.ins_h = HASH(s, s.ins_h, s.window[s.strstart + 1]);
        }
      } else {
        bflush = _tr_tally(s, 0, s.window[s.strstart]);
        s.lookahead--;
        s.strstart++;
      }
      if (bflush) {
        flush_block_only(s, false);
        if (s.strm.avail_out === 0) {
          return BS_NEED_MORE;
        }
      }
    }
    s.insert = s.strstart < MIN_MATCH - 1 ? s.strstart : MIN_MATCH - 1;
    if (flush === Z_FINISH$3) {
      flush_block_only(s, true);
      if (s.strm.avail_out === 0) {
        return BS_FINISH_STARTED;
      }
      return BS_FINISH_DONE;
    }
    if (s.sym_next) {
      flush_block_only(s, false);
      if (s.strm.avail_out === 0) {
        return BS_NEED_MORE;
      }
    }
    return BS_BLOCK_DONE;
  };
  var deflate_slow = (s, flush) => {
    let hash_head;
    let bflush;
    let max_insert;
    for (; ; ) {
      if (s.lookahead < MIN_LOOKAHEAD) {
        fill_window(s);
        if (s.lookahead < MIN_LOOKAHEAD && flush === Z_NO_FLUSH$2) {
          return BS_NEED_MORE;
        }
        if (s.lookahead === 0) {
          break;
        }
      }
      hash_head = 0;
      if (s.lookahead >= MIN_MATCH) {
        s.ins_h = HASH(s, s.ins_h, s.window[s.strstart + MIN_MATCH - 1]);
        hash_head = s.prev[s.strstart & s.w_mask] = s.head[s.ins_h];
        s.head[s.ins_h] = s.strstart;
      }
      s.prev_length = s.match_length;
      s.prev_match = s.match_start;
      s.match_length = MIN_MATCH - 1;
      if (hash_head !== 0 && s.prev_length < s.max_lazy_match && s.strstart - hash_head <= s.w_size - MIN_LOOKAHEAD) {
        s.match_length = longest_match(s, hash_head);
        if (s.match_length <= 5 && (s.strategy === Z_FILTERED || s.match_length === MIN_MATCH && s.strstart - s.match_start > 4096)) {
          s.match_length = MIN_MATCH - 1;
        }
      }
      if (s.prev_length >= MIN_MATCH && s.match_length <= s.prev_length) {
        max_insert = s.strstart + s.lookahead - MIN_MATCH;
        bflush = _tr_tally(s, s.strstart - 1 - s.prev_match, s.prev_length - MIN_MATCH);
        s.lookahead -= s.prev_length - 1;
        s.prev_length -= 2;
        do {
          if (++s.strstart <= max_insert) {
            s.ins_h = HASH(s, s.ins_h, s.window[s.strstart + MIN_MATCH - 1]);
            hash_head = s.prev[s.strstart & s.w_mask] = s.head[s.ins_h];
            s.head[s.ins_h] = s.strstart;
          }
        } while (--s.prev_length !== 0);
        s.match_available = 0;
        s.match_length = MIN_MATCH - 1;
        s.strstart++;
        if (bflush) {
          flush_block_only(s, false);
          if (s.strm.avail_out === 0) {
            return BS_NEED_MORE;
          }
        }
      } else if (s.match_available) {
        bflush = _tr_tally(s, 0, s.window[s.strstart - 1]);
        if (bflush) {
          flush_block_only(s, false);
        }
        s.strstart++;
        s.lookahead--;
        if (s.strm.avail_out === 0) {
          return BS_NEED_MORE;
        }
      } else {
        s.match_available = 1;
        s.strstart++;
        s.lookahead--;
      }
    }
    if (s.match_available) {
      bflush = _tr_tally(s, 0, s.window[s.strstart - 1]);
      s.match_available = 0;
    }
    s.insert = s.strstart < MIN_MATCH - 1 ? s.strstart : MIN_MATCH - 1;
    if (flush === Z_FINISH$3) {
      flush_block_only(s, true);
      if (s.strm.avail_out === 0) {
        return BS_FINISH_STARTED;
      }
      return BS_FINISH_DONE;
    }
    if (s.sym_next) {
      flush_block_only(s, false);
      if (s.strm.avail_out === 0) {
        return BS_NEED_MORE;
      }
    }
    return BS_BLOCK_DONE;
  };
  var deflate_rle = (s, flush) => {
    let bflush;
    let prev;
    let scan, strend;
    const _win = s.window;
    for (; ; ) {
      if (s.lookahead <= MAX_MATCH) {
        fill_window(s);
        if (s.lookahead <= MAX_MATCH && flush === Z_NO_FLUSH$2) {
          return BS_NEED_MORE;
        }
        if (s.lookahead === 0) {
          break;
        }
      }
      s.match_length = 0;
      if (s.lookahead >= MIN_MATCH && s.strstart > 0) {
        scan = s.strstart - 1;
        prev = _win[scan];
        if (prev === _win[++scan] && prev === _win[++scan] && prev === _win[++scan]) {
          strend = s.strstart + MAX_MATCH;
          do {
          } while (prev === _win[++scan] && prev === _win[++scan] && prev === _win[++scan] && prev === _win[++scan] && prev === _win[++scan] && prev === _win[++scan] && prev === _win[++scan] && prev === _win[++scan] && scan < strend);
          s.match_length = MAX_MATCH - (strend - scan);
          if (s.match_length > s.lookahead) {
            s.match_length = s.lookahead;
          }
        }
      }
      if (s.match_length >= MIN_MATCH) {
        bflush = _tr_tally(s, 1, s.match_length - MIN_MATCH);
        s.lookahead -= s.match_length;
        s.strstart += s.match_length;
        s.match_length = 0;
      } else {
        bflush = _tr_tally(s, 0, s.window[s.strstart]);
        s.lookahead--;
        s.strstart++;
      }
      if (bflush) {
        flush_block_only(s, false);
        if (s.strm.avail_out === 0) {
          return BS_NEED_MORE;
        }
      }
    }
    s.insert = 0;
    if (flush === Z_FINISH$3) {
      flush_block_only(s, true);
      if (s.strm.avail_out === 0) {
        return BS_FINISH_STARTED;
      }
      return BS_FINISH_DONE;
    }
    if (s.sym_next) {
      flush_block_only(s, false);
      if (s.strm.avail_out === 0) {
        return BS_NEED_MORE;
      }
    }
    return BS_BLOCK_DONE;
  };
  var deflate_huff = (s, flush) => {
    let bflush;
    for (; ; ) {
      if (s.lookahead === 0) {
        fill_window(s);
        if (s.lookahead === 0) {
          if (flush === Z_NO_FLUSH$2) {
            return BS_NEED_MORE;
          }
          break;
        }
      }
      s.match_length = 0;
      bflush = _tr_tally(s, 0, s.window[s.strstart]);
      s.lookahead--;
      s.strstart++;
      if (bflush) {
        flush_block_only(s, false);
        if (s.strm.avail_out === 0) {
          return BS_NEED_MORE;
        }
      }
    }
    s.insert = 0;
    if (flush === Z_FINISH$3) {
      flush_block_only(s, true);
      if (s.strm.avail_out === 0) {
        return BS_FINISH_STARTED;
      }
      return BS_FINISH_DONE;
    }
    if (s.sym_next) {
      flush_block_only(s, false);
      if (s.strm.avail_out === 0) {
        return BS_NEED_MORE;
      }
    }
    return BS_BLOCK_DONE;
  };
  function Config(good_length, max_lazy, nice_length, max_chain, func) {
    this.good_length = good_length;
    this.max_lazy = max_lazy;
    this.nice_length = nice_length;
    this.max_chain = max_chain;
    this.func = func;
  }
  var configuration_table = [
    /*      good lazy nice chain */
    new Config(0, 0, 0, 0, deflate_stored),
    /* 0 store only */
    new Config(4, 4, 8, 4, deflate_fast),
    /* 1 max speed, no lazy matches */
    new Config(4, 5, 16, 8, deflate_fast),
    /* 2 */
    new Config(4, 6, 32, 32, deflate_fast),
    /* 3 */
    new Config(4, 4, 16, 16, deflate_slow),
    /* 4 lazy matches */
    new Config(8, 16, 32, 32, deflate_slow),
    /* 5 */
    new Config(8, 16, 128, 128, deflate_slow),
    /* 6 */
    new Config(8, 32, 128, 256, deflate_slow),
    /* 7 */
    new Config(32, 128, 258, 1024, deflate_slow),
    /* 8 */
    new Config(32, 258, 258, 4096, deflate_slow)
    /* 9 max compression */
  ];
  var lm_init = (s) => {
    s.window_size = 2 * s.w_size;
    zero(s.head);
    s.max_lazy_match = configuration_table[s.level].max_lazy;
    s.good_match = configuration_table[s.level].good_length;
    s.nice_match = configuration_table[s.level].nice_length;
    s.max_chain_length = configuration_table[s.level].max_chain;
    s.strstart = 0;
    s.block_start = 0;
    s.lookahead = 0;
    s.insert = 0;
    s.match_length = s.prev_length = MIN_MATCH - 1;
    s.match_available = 0;
    s.ins_h = 0;
  };
  function DeflateState() {
    this.strm = null;
    this.status = 0;
    this.pending_buf = null;
    this.pending_buf_size = 0;
    this.pending_out = 0;
    this.pending = 0;
    this.wrap = 0;
    this.gzhead = null;
    this.gzindex = 0;
    this.method = Z_DEFLATED$2;
    this.last_flush = -1;
    this.w_size = 0;
    this.w_bits = 0;
    this.w_mask = 0;
    this.window = null;
    this.window_size = 0;
    this.prev = null;
    this.head = null;
    this.ins_h = 0;
    this.hash_size = 0;
    this.hash_bits = 0;
    this.hash_mask = 0;
    this.hash_shift = 0;
    this.block_start = 0;
    this.match_length = 0;
    this.prev_match = 0;
    this.match_available = 0;
    this.strstart = 0;
    this.match_start = 0;
    this.lookahead = 0;
    this.prev_length = 0;
    this.max_chain_length = 0;
    this.max_lazy_match = 0;
    this.level = 0;
    this.strategy = 0;
    this.good_match = 0;
    this.nice_match = 0;
    this.dyn_ltree = new Uint16Array(HEAP_SIZE * 2);
    this.dyn_dtree = new Uint16Array((2 * D_CODES + 1) * 2);
    this.bl_tree = new Uint16Array((2 * BL_CODES + 1) * 2);
    zero(this.dyn_ltree);
    zero(this.dyn_dtree);
    zero(this.bl_tree);
    this.l_desc = null;
    this.d_desc = null;
    this.bl_desc = null;
    this.bl_count = new Uint16Array(MAX_BITS + 1);
    this.heap = new Uint16Array(2 * L_CODES + 1);
    zero(this.heap);
    this.heap_len = 0;
    this.heap_max = 0;
    this.depth = new Uint16Array(2 * L_CODES + 1);
    zero(this.depth);
    this.sym_buf = 0;
    this.lit_bufsize = 0;
    this.sym_next = 0;
    this.sym_end = 0;
    this.opt_len = 0;
    this.static_len = 0;
    this.matches = 0;
    this.insert = 0;
    this.bi_buf = 0;
    this.bi_valid = 0;
  }
  var deflateStateCheck = (strm) => {
    if (!strm) {
      return 1;
    }
    const s = strm.state;
    if (!s || s.strm !== strm || s.status !== INIT_STATE && //#ifdef GZIP
    s.status !== GZIP_STATE && //#endif
    s.status !== EXTRA_STATE && s.status !== NAME_STATE && s.status !== COMMENT_STATE && s.status !== HCRC_STATE && s.status !== BUSY_STATE && s.status !== FINISH_STATE) {
      return 1;
    }
    return 0;
  };
  var deflateResetKeep = (strm) => {
    if (deflateStateCheck(strm)) {
      return err(strm, Z_STREAM_ERROR$2);
    }
    strm.total_in = strm.total_out = 0;
    strm.data_type = Z_UNKNOWN;
    const s = strm.state;
    s.pending = 0;
    s.pending_out = 0;
    if (s.wrap < 0) {
      s.wrap = -s.wrap;
    }
    s.status = //#ifdef GZIP
    s.wrap === 2 ? GZIP_STATE : (
      //#endif
      s.wrap ? INIT_STATE : BUSY_STATE
    );
    strm.adler = s.wrap === 2 ? 0 : 1;
    s.last_flush = -2;
    _tr_init(s);
    return Z_OK$3;
  };
  var deflateReset = (strm) => {
    const ret = deflateResetKeep(strm);
    if (ret === Z_OK$3) {
      lm_init(strm.state);
    }
    return ret;
  };
  var deflateSetHeader = (strm, head) => {
    if (deflateStateCheck(strm) || strm.state.wrap !== 2) {
      return Z_STREAM_ERROR$2;
    }
    strm.state.gzhead = head;
    return Z_OK$3;
  };
  var deflateInit2 = (strm, level, method, windowBits, memLevel, strategy) => {
    if (!strm) {
      return Z_STREAM_ERROR$2;
    }
    let wrap = 1;
    if (level === Z_DEFAULT_COMPRESSION$1) {
      level = 6;
    }
    if (windowBits < 0) {
      wrap = 0;
      windowBits = -windowBits;
    } else if (windowBits > 15) {
      wrap = 2;
      windowBits -= 16;
    }
    if (memLevel < 1 || memLevel > MAX_MEM_LEVEL || method !== Z_DEFLATED$2 || windowBits < 8 || windowBits > 15 || level < 0 || level > 9 || strategy < 0 || strategy > Z_FIXED || windowBits === 8 && wrap !== 1) {
      return err(strm, Z_STREAM_ERROR$2);
    }
    if (windowBits === 8) {
      windowBits = 9;
    }
    const s = new DeflateState();
    strm.state = s;
    s.strm = strm;
    s.status = INIT_STATE;
    s.wrap = wrap;
    s.gzhead = null;
    s.w_bits = windowBits;
    s.w_size = 1 << s.w_bits;
    s.w_mask = s.w_size - 1;
    s.hash_bits = memLevel + 7;
    s.hash_size = 1 << s.hash_bits;
    s.hash_mask = s.hash_size - 1;
    s.hash_shift = ~~((s.hash_bits + MIN_MATCH - 1) / MIN_MATCH);
    s.window = new Uint8Array(s.w_size * 2);
    s.head = new Uint16Array(s.hash_size);
    s.prev = new Uint16Array(s.w_size);
    s.lit_bufsize = 1 << memLevel + 6;
    s.pending_buf_size = s.lit_bufsize * 4;
    s.pending_buf = new Uint8Array(s.pending_buf_size);
    s.sym_buf = s.lit_bufsize;
    s.sym_end = (s.lit_bufsize - 1) * 3;
    s.level = level;
    s.strategy = strategy;
    s.method = method;
    return deflateReset(strm);
  };
  var deflateInit = (strm, level) => {
    return deflateInit2(strm, level, Z_DEFLATED$2, MAX_WBITS$1, DEF_MEM_LEVEL, Z_DEFAULT_STRATEGY$1);
  };
  var deflate$2 = (strm, flush) => {
    if (deflateStateCheck(strm) || flush > Z_BLOCK$1 || flush < 0) {
      return strm ? err(strm, Z_STREAM_ERROR$2) : Z_STREAM_ERROR$2;
    }
    const s = strm.state;
    if (!strm.output || strm.avail_in !== 0 && !strm.input || s.status === FINISH_STATE && flush !== Z_FINISH$3) {
      return err(strm, strm.avail_out === 0 ? Z_BUF_ERROR$1 : Z_STREAM_ERROR$2);
    }
    const old_flush = s.last_flush;
    s.last_flush = flush;
    if (s.pending !== 0) {
      flush_pending(strm);
      if (strm.avail_out === 0) {
        s.last_flush = -1;
        return Z_OK$3;
      }
    } else if (strm.avail_in === 0 && rank(flush) <= rank(old_flush) && flush !== Z_FINISH$3) {
      return err(strm, Z_BUF_ERROR$1);
    }
    if (s.status === FINISH_STATE && strm.avail_in !== 0) {
      return err(strm, Z_BUF_ERROR$1);
    }
    if (s.status === INIT_STATE && s.wrap === 0) {
      s.status = BUSY_STATE;
    }
    if (s.status === INIT_STATE) {
      let header = Z_DEFLATED$2 + (s.w_bits - 8 << 4) << 8;
      let level_flags = -1;
      if (s.strategy >= Z_HUFFMAN_ONLY || s.level < 2) {
        level_flags = 0;
      } else if (s.level < 6) {
        level_flags = 1;
      } else if (s.level === 6) {
        level_flags = 2;
      } else {
        level_flags = 3;
      }
      header |= level_flags << 6;
      if (s.strstart !== 0) {
        header |= PRESET_DICT;
      }
      header += 31 - header % 31;
      putShortMSB(s, header);
      if (s.strstart !== 0) {
        putShortMSB(s, strm.adler >>> 16);
        putShortMSB(s, strm.adler & 65535);
      }
      strm.adler = 1;
      s.status = BUSY_STATE;
      flush_pending(strm);
      if (s.pending !== 0) {
        s.last_flush = -1;
        return Z_OK$3;
      }
    }
    if (s.status === GZIP_STATE) {
      strm.adler = 0;
      put_byte(s, 31);
      put_byte(s, 139);
      put_byte(s, 8);
      if (!s.gzhead) {
        put_byte(s, 0);
        put_byte(s, 0);
        put_byte(s, 0);
        put_byte(s, 0);
        put_byte(s, 0);
        put_byte(s, s.level === 9 ? 2 : s.strategy >= Z_HUFFMAN_ONLY || s.level < 2 ? 4 : 0);
        put_byte(s, OS_CODE);
        s.status = BUSY_STATE;
        flush_pending(strm);
        if (s.pending !== 0) {
          s.last_flush = -1;
          return Z_OK$3;
        }
      } else {
        put_byte(
          s,
          (s.gzhead.text ? 1 : 0) + (s.gzhead.hcrc ? 2 : 0) + (!s.gzhead.extra ? 0 : 4) + (!s.gzhead.name ? 0 : 8) + (!s.gzhead.comment ? 0 : 16)
        );
        put_byte(s, s.gzhead.time & 255);
        put_byte(s, s.gzhead.time >> 8 & 255);
        put_byte(s, s.gzhead.time >> 16 & 255);
        put_byte(s, s.gzhead.time >> 24 & 255);
        put_byte(s, s.level === 9 ? 2 : s.strategy >= Z_HUFFMAN_ONLY || s.level < 2 ? 4 : 0);
        put_byte(s, s.gzhead.os & 255);
        if (s.gzhead.extra && s.gzhead.extra.length) {
          put_byte(s, s.gzhead.extra.length & 255);
          put_byte(s, s.gzhead.extra.length >> 8 & 255);
        }
        if (s.gzhead.hcrc) {
          strm.adler = crc32_1(strm.adler, s.pending_buf, s.pending, 0);
        }
        s.gzindex = 0;
        s.status = EXTRA_STATE;
      }
    }
    if (s.status === EXTRA_STATE) {
      if (s.gzhead.extra) {
        let beg = s.pending;
        let left = (s.gzhead.extra.length & 65535) - s.gzindex;
        while (s.pending + left > s.pending_buf_size) {
          let copy = s.pending_buf_size - s.pending;
          s.pending_buf.set(s.gzhead.extra.subarray(s.gzindex, s.gzindex + copy), s.pending);
          s.pending = s.pending_buf_size;
          if (s.gzhead.hcrc && s.pending > beg) {
            strm.adler = crc32_1(strm.adler, s.pending_buf, s.pending - beg, beg);
          }
          s.gzindex += copy;
          flush_pending(strm);
          if (s.pending !== 0) {
            s.last_flush = -1;
            return Z_OK$3;
          }
          beg = 0;
          left -= copy;
        }
        let gzhead_extra = new Uint8Array(s.gzhead.extra);
        s.pending_buf.set(gzhead_extra.subarray(s.gzindex, s.gzindex + left), s.pending);
        s.pending += left;
        if (s.gzhead.hcrc && s.pending > beg) {
          strm.adler = crc32_1(strm.adler, s.pending_buf, s.pending - beg, beg);
        }
        s.gzindex = 0;
      }
      s.status = NAME_STATE;
    }
    if (s.status === NAME_STATE) {
      if (s.gzhead.name) {
        let beg = s.pending;
        let val;
        do {
          if (s.pending === s.pending_buf_size) {
            if (s.gzhead.hcrc && s.pending > beg) {
              strm.adler = crc32_1(strm.adler, s.pending_buf, s.pending - beg, beg);
            }
            flush_pending(strm);
            if (s.pending !== 0) {
              s.last_flush = -1;
              return Z_OK$3;
            }
            beg = 0;
          }
          if (s.gzindex < s.gzhead.name.length) {
            val = s.gzhead.name.charCodeAt(s.gzindex++) & 255;
          } else {
            val = 0;
          }
          put_byte(s, val);
        } while (val !== 0);
        if (s.gzhead.hcrc && s.pending > beg) {
          strm.adler = crc32_1(strm.adler, s.pending_buf, s.pending - beg, beg);
        }
        s.gzindex = 0;
      }
      s.status = COMMENT_STATE;
    }
    if (s.status === COMMENT_STATE) {
      if (s.gzhead.comment) {
        let beg = s.pending;
        let val;
        do {
          if (s.pending === s.pending_buf_size) {
            if (s.gzhead.hcrc && s.pending > beg) {
              strm.adler = crc32_1(strm.adler, s.pending_buf, s.pending - beg, beg);
            }
            flush_pending(strm);
            if (s.pending !== 0) {
              s.last_flush = -1;
              return Z_OK$3;
            }
            beg = 0;
          }
          if (s.gzindex < s.gzhead.comment.length) {
            val = s.gzhead.comment.charCodeAt(s.gzindex++) & 255;
          } else {
            val = 0;
          }
          put_byte(s, val);
        } while (val !== 0);
        if (s.gzhead.hcrc && s.pending > beg) {
          strm.adler = crc32_1(strm.adler, s.pending_buf, s.pending - beg, beg);
        }
      }
      s.status = HCRC_STATE;
    }
    if (s.status === HCRC_STATE) {
      if (s.gzhead.hcrc) {
        if (s.pending + 2 > s.pending_buf_size) {
          flush_pending(strm);
          if (s.pending !== 0) {
            s.last_flush = -1;
            return Z_OK$3;
          }
        }
        put_byte(s, strm.adler & 255);
        put_byte(s, strm.adler >> 8 & 255);
        strm.adler = 0;
      }
      s.status = BUSY_STATE;
      flush_pending(strm);
      if (s.pending !== 0) {
        s.last_flush = -1;
        return Z_OK$3;
      }
    }
    if (strm.avail_in !== 0 || s.lookahead !== 0 || flush !== Z_NO_FLUSH$2 && s.status !== FINISH_STATE) {
      let bstate = s.level === 0 ? deflate_stored(s, flush) : s.strategy === Z_HUFFMAN_ONLY ? deflate_huff(s, flush) : s.strategy === Z_RLE ? deflate_rle(s, flush) : configuration_table[s.level].func(s, flush);
      if (bstate === BS_FINISH_STARTED || bstate === BS_FINISH_DONE) {
        s.status = FINISH_STATE;
      }
      if (bstate === BS_NEED_MORE || bstate === BS_FINISH_STARTED) {
        if (strm.avail_out === 0) {
          s.last_flush = -1;
        }
        return Z_OK$3;
      }
      if (bstate === BS_BLOCK_DONE) {
        if (flush === Z_PARTIAL_FLUSH) {
          _tr_align(s);
        } else if (flush !== Z_BLOCK$1) {
          _tr_stored_block(s, 0, 0, false);
          if (flush === Z_FULL_FLUSH$1) {
            zero(s.head);
            if (s.lookahead === 0) {
              s.strstart = 0;
              s.block_start = 0;
              s.insert = 0;
            }
          }
        }
        flush_pending(strm);
        if (strm.avail_out === 0) {
          s.last_flush = -1;
          return Z_OK$3;
        }
      }
    }
    if (flush !== Z_FINISH$3) {
      return Z_OK$3;
    }
    if (s.wrap <= 0) {
      return Z_STREAM_END$3;
    }
    if (s.wrap === 2) {
      put_byte(s, strm.adler & 255);
      put_byte(s, strm.adler >> 8 & 255);
      put_byte(s, strm.adler >> 16 & 255);
      put_byte(s, strm.adler >> 24 & 255);
      put_byte(s, strm.total_in & 255);
      put_byte(s, strm.total_in >> 8 & 255);
      put_byte(s, strm.total_in >> 16 & 255);
      put_byte(s, strm.total_in >> 24 & 255);
    } else {
      putShortMSB(s, strm.adler >>> 16);
      putShortMSB(s, strm.adler & 65535);
    }
    flush_pending(strm);
    if (s.wrap > 0) {
      s.wrap = -s.wrap;
    }
    return s.pending !== 0 ? Z_OK$3 : Z_STREAM_END$3;
  };
  var deflateEnd = (strm) => {
    if (deflateStateCheck(strm)) {
      return Z_STREAM_ERROR$2;
    }
    const status = strm.state.status;
    strm.state = null;
    return status === BUSY_STATE ? err(strm, Z_DATA_ERROR$2) : Z_OK$3;
  };
  var deflateSetDictionary = (strm, dictionary) => {
    let dictLength = dictionary.length;
    if (deflateStateCheck(strm)) {
      return Z_STREAM_ERROR$2;
    }
    const s = strm.state;
    const wrap = s.wrap;
    if (wrap === 2 || wrap === 1 && s.status !== INIT_STATE || s.lookahead) {
      return Z_STREAM_ERROR$2;
    }
    if (wrap === 1) {
      strm.adler = adler32_1(strm.adler, dictionary, dictLength, 0);
    }
    s.wrap = 0;
    if (dictLength >= s.w_size) {
      if (wrap === 0) {
        zero(s.head);
        s.strstart = 0;
        s.block_start = 0;
        s.insert = 0;
      }
      let tmpDict = new Uint8Array(s.w_size);
      tmpDict.set(dictionary.subarray(dictLength - s.w_size, dictLength), 0);
      dictionary = tmpDict;
      dictLength = s.w_size;
    }
    const avail = strm.avail_in;
    const next = strm.next_in;
    const input = strm.input;
    strm.avail_in = dictLength;
    strm.next_in = 0;
    strm.input = dictionary;
    fill_window(s);
    while (s.lookahead >= MIN_MATCH) {
      let str2 = s.strstart;
      let n = s.lookahead - (MIN_MATCH - 1);
      do {
        s.ins_h = HASH(s, s.ins_h, s.window[str2 + MIN_MATCH - 1]);
        s.prev[str2 & s.w_mask] = s.head[s.ins_h];
        s.head[s.ins_h] = str2;
        str2++;
      } while (--n);
      s.strstart = str2;
      s.lookahead = MIN_MATCH - 1;
      fill_window(s);
    }
    s.strstart += s.lookahead;
    s.block_start = s.strstart;
    s.insert = s.lookahead;
    s.lookahead = 0;
    s.match_length = s.prev_length = MIN_MATCH - 1;
    s.match_available = 0;
    strm.next_in = next;
    strm.input = input;
    strm.avail_in = avail;
    s.wrap = wrap;
    return Z_OK$3;
  };
  var deflateInit_1 = deflateInit;
  var deflateInit2_1 = deflateInit2;
  var deflateReset_1 = deflateReset;
  var deflateResetKeep_1 = deflateResetKeep;
  var deflateSetHeader_1 = deflateSetHeader;
  var deflate_2$1 = deflate$2;
  var deflateEnd_1 = deflateEnd;
  var deflateSetDictionary_1 = deflateSetDictionary;
  var deflateInfo = "pako deflate (from Nodeca project)";
  var deflate_1$2 = {
    deflateInit: deflateInit_1,
    deflateInit2: deflateInit2_1,
    deflateReset: deflateReset_1,
    deflateResetKeep: deflateResetKeep_1,
    deflateSetHeader: deflateSetHeader_1,
    deflate: deflate_2$1,
    deflateEnd: deflateEnd_1,
    deflateSetDictionary: deflateSetDictionary_1,
    deflateInfo
  };
  var _has = (obj, key) => {
    return Object.prototype.hasOwnProperty.call(obj, key);
  };
  var assign = function(obj) {
    const sources = Array.prototype.slice.call(arguments, 1);
    while (sources.length) {
      const source = sources.shift();
      if (!source) {
        continue;
      }
      if (typeof source !== "object") {
        throw new TypeError(source + "must be non-object");
      }
      for (const p in source) {
        if (_has(source, p)) {
          obj[p] = source[p];
        }
      }
    }
    return obj;
  };
  var flattenChunks = (chunks2) => {
    let len = 0;
    for (let i = 0, l = chunks2.length; i < l; i++) {
      len += chunks2[i].length;
    }
    const result = new Uint8Array(len);
    for (let i = 0, pos = 0, l = chunks2.length; i < l; i++) {
      let chunk = chunks2[i];
      result.set(chunk, pos);
      pos += chunk.length;
    }
    return result;
  };
  var common = {
    assign,
    flattenChunks
  };
  var STR_APPLY_UIA_OK = true;
  try {
    String.fromCharCode.apply(null, new Uint8Array(1));
  } catch (__) {
    STR_APPLY_UIA_OK = false;
  }
  var _utf8len = new Uint8Array(256);
  for (let q = 0; q < 256; q++) {
    _utf8len[q] = q >= 252 ? 6 : q >= 248 ? 5 : q >= 240 ? 4 : q >= 224 ? 3 : q >= 192 ? 2 : 1;
  }
  _utf8len[254] = _utf8len[254] = 1;
  var string2buf = (str2) => {
    if (typeof TextEncoder === "function" && TextEncoder.prototype.encode) {
      return new TextEncoder().encode(str2);
    }
    let buf, c, c2, m_pos, i, str_len = str2.length, buf_len = 0;
    for (m_pos = 0; m_pos < str_len; m_pos++) {
      c = str2.charCodeAt(m_pos);
      if ((c & 64512) === 55296 && m_pos + 1 < str_len) {
        c2 = str2.charCodeAt(m_pos + 1);
        if ((c2 & 64512) === 56320) {
          c = 65536 + (c - 55296 << 10) + (c2 - 56320);
          m_pos++;
        }
      }
      buf_len += c < 128 ? 1 : c < 2048 ? 2 : c < 65536 ? 3 : 4;
    }
    buf = new Uint8Array(buf_len);
    for (i = 0, m_pos = 0; i < buf_len; m_pos++) {
      c = str2.charCodeAt(m_pos);
      if ((c & 64512) === 55296 && m_pos + 1 < str_len) {
        c2 = str2.charCodeAt(m_pos + 1);
        if ((c2 & 64512) === 56320) {
          c = 65536 + (c - 55296 << 10) + (c2 - 56320);
          m_pos++;
        }
      }
      if (c < 128) {
        buf[i++] = c;
      } else if (c < 2048) {
        buf[i++] = 192 | c >>> 6;
        buf[i++] = 128 | c & 63;
      } else if (c < 65536) {
        buf[i++] = 224 | c >>> 12;
        buf[i++] = 128 | c >>> 6 & 63;
        buf[i++] = 128 | c & 63;
      } else {
        buf[i++] = 240 | c >>> 18;
        buf[i++] = 128 | c >>> 12 & 63;
        buf[i++] = 128 | c >>> 6 & 63;
        buf[i++] = 128 | c & 63;
      }
    }
    return buf;
  };
  var buf2binstring = (buf, len) => {
    if (len < 65534) {
      if (buf.subarray && STR_APPLY_UIA_OK) {
        return String.fromCharCode.apply(null, buf.length === len ? buf : buf.subarray(0, len));
      }
    }
    let result = "";
    for (let i = 0; i < len; i++) {
      result += String.fromCharCode(buf[i]);
    }
    return result;
  };
  var buf2string = (buf, max) => {
    const len = max || buf.length;
    if (typeof TextDecoder === "function" && TextDecoder.prototype.decode) {
      return new TextDecoder().decode(buf.subarray(0, max));
    }
    let i, out;
    const utf16buf = new Array(len * 2);
    for (out = 0, i = 0; i < len; ) {
      let c = buf[i++];
      if (c < 128) {
        utf16buf[out++] = c;
        continue;
      }
      let c_len = _utf8len[c];
      if (c_len > 4) {
        utf16buf[out++] = 65533;
        i += c_len - 1;
        continue;
      }
      c &= c_len === 2 ? 31 : c_len === 3 ? 15 : 7;
      while (c_len > 1 && i < len) {
        c = c << 6 | buf[i++] & 63;
        c_len--;
      }
      if (c_len > 1) {
        utf16buf[out++] = 65533;
        continue;
      }
      if (c < 65536) {
        utf16buf[out++] = c;
      } else {
        c -= 65536;
        utf16buf[out++] = 55296 | c >> 10 & 1023;
        utf16buf[out++] = 56320 | c & 1023;
      }
    }
    return buf2binstring(utf16buf, out);
  };
  var utf8border = (buf, max) => {
    max = max || buf.length;
    if (max > buf.length) {
      max = buf.length;
    }
    let pos = max - 1;
    while (pos >= 0 && (buf[pos] & 192) === 128) {
      pos--;
    }
    if (pos < 0) {
      return max;
    }
    if (pos === 0) {
      return max;
    }
    return pos + _utf8len[buf[pos]] > max ? pos : max;
  };
  var strings = {
    string2buf,
    buf2string,
    utf8border
  };
  function ZStream() {
    this.input = null;
    this.next_in = 0;
    this.avail_in = 0;
    this.total_in = 0;
    this.output = null;
    this.next_out = 0;
    this.avail_out = 0;
    this.total_out = 0;
    this.msg = "";
    this.state = null;
    this.data_type = 2;
    this.adler = 0;
  }
  var zstream = ZStream;
  var toString$1 = Object.prototype.toString;
  var {
    Z_NO_FLUSH: Z_NO_FLUSH$1,
    Z_SYNC_FLUSH,
    Z_FULL_FLUSH,
    Z_FINISH: Z_FINISH$2,
    Z_OK: Z_OK$2,
    Z_STREAM_END: Z_STREAM_END$2,
    Z_DEFAULT_COMPRESSION,
    Z_DEFAULT_STRATEGY,
    Z_DEFLATED: Z_DEFLATED$1
  } = constants$2;
  function Deflate$1(options) {
    this.options = common.assign({
      level: Z_DEFAULT_COMPRESSION,
      method: Z_DEFLATED$1,
      chunkSize: 16384,
      windowBits: 15,
      memLevel: 8,
      strategy: Z_DEFAULT_STRATEGY
    }, options || {});
    let opt = this.options;
    if (opt.raw && opt.windowBits > 0) {
      opt.windowBits = -opt.windowBits;
    } else if (opt.gzip && opt.windowBits > 0 && opt.windowBits < 16) {
      opt.windowBits += 16;
    }
    this.err = 0;
    this.msg = "";
    this.ended = false;
    this.chunks = [];
    this.strm = new zstream();
    this.strm.avail_out = 0;
    let status = deflate_1$2.deflateInit2(
      this.strm,
      opt.level,
      opt.method,
      opt.windowBits,
      opt.memLevel,
      opt.strategy
    );
    if (status !== Z_OK$2) {
      throw new Error(messages[status]);
    }
    if (opt.header) {
      deflate_1$2.deflateSetHeader(this.strm, opt.header);
    }
    if (opt.dictionary) {
      let dict;
      if (typeof opt.dictionary === "string") {
        dict = strings.string2buf(opt.dictionary);
      } else if (toString$1.call(opt.dictionary) === "[object ArrayBuffer]") {
        dict = new Uint8Array(opt.dictionary);
      } else {
        dict = opt.dictionary;
      }
      status = deflate_1$2.deflateSetDictionary(this.strm, dict);
      if (status !== Z_OK$2) {
        throw new Error(messages[status]);
      }
      this._dict_set = true;
    }
  }
  Deflate$1.prototype.push = function(data, flush_mode) {
    const strm = this.strm;
    const chunkSize = this.options.chunkSize;
    let status, _flush_mode;
    if (this.ended) {
      return false;
    }
    if (flush_mode === ~~flush_mode) _flush_mode = flush_mode;
    else _flush_mode = flush_mode === true ? Z_FINISH$2 : Z_NO_FLUSH$1;
    if (typeof data === "string") {
      strm.input = strings.string2buf(data);
    } else if (toString$1.call(data) === "[object ArrayBuffer]") {
      strm.input = new Uint8Array(data);
    } else {
      strm.input = data;
    }
    strm.next_in = 0;
    strm.avail_in = strm.input.length;
    for (; ; ) {
      if (strm.avail_out === 0) {
        strm.output = new Uint8Array(chunkSize);
        strm.next_out = 0;
        strm.avail_out = chunkSize;
      }
      if ((_flush_mode === Z_SYNC_FLUSH || _flush_mode === Z_FULL_FLUSH) && strm.avail_out <= 6) {
        this.onData(strm.output.subarray(0, strm.next_out));
        strm.avail_out = 0;
        continue;
      }
      status = deflate_1$2.deflate(strm, _flush_mode);
      if (status === Z_STREAM_END$2) {
        if (strm.next_out > 0) {
          this.onData(strm.output.subarray(0, strm.next_out));
        }
        status = deflate_1$2.deflateEnd(this.strm);
        this.onEnd(status);
        this.ended = true;
        return status === Z_OK$2;
      }
      if (strm.avail_out === 0) {
        this.onData(strm.output);
        continue;
      }
      if (_flush_mode > 0 && strm.next_out > 0) {
        this.onData(strm.output.subarray(0, strm.next_out));
        strm.avail_out = 0;
        continue;
      }
      if (strm.avail_in === 0) break;
    }
    return true;
  };
  Deflate$1.prototype.onData = function(chunk) {
    this.chunks.push(chunk);
  };
  Deflate$1.prototype.onEnd = function(status) {
    if (status === Z_OK$2) {
      this.result = common.flattenChunks(this.chunks);
    }
    this.chunks = [];
    this.err = status;
    this.msg = this.strm.msg;
  };
  function deflate$1(input, options) {
    const deflator = new Deflate$1(options);
    deflator.push(input, true);
    if (deflator.err) {
      throw deflator.msg || messages[deflator.err];
    }
    return deflator.result;
  }
  function deflateRaw$1(input, options) {
    options = options || {};
    options.raw = true;
    return deflate$1(input, options);
  }
  function gzip$1(input, options) {
    options = options || {};
    options.gzip = true;
    return deflate$1(input, options);
  }
  var Deflate_1$1 = Deflate$1;
  var deflate_2 = deflate$1;
  var deflateRaw_1$1 = deflateRaw$1;
  var gzip_1$1 = gzip$1;
  var constants$1 = constants$2;
  var deflate_1$1 = {
    Deflate: Deflate_1$1,
    deflate: deflate_2,
    deflateRaw: deflateRaw_1$1,
    gzip: gzip_1$1,
    constants: constants$1
  };
  var BAD$1 = 16209;
  var TYPE$1 = 16191;
  var inffast = function inflate_fast(strm, start) {
    let _in;
    let last;
    let _out;
    let beg;
    let end;
    let dmax;
    let wsize;
    let whave;
    let wnext;
    let s_window;
    let hold;
    let bits;
    let lcode;
    let dcode;
    let lmask;
    let dmask;
    let here;
    let op;
    let len;
    let dist;
    let from;
    let from_source;
    let input, output;
    const state = strm.state;
    _in = strm.next_in;
    input = strm.input;
    last = _in + (strm.avail_in - 5);
    _out = strm.next_out;
    output = strm.output;
    beg = _out - (start - strm.avail_out);
    end = _out + (strm.avail_out - 257);
    dmax = state.dmax;
    wsize = state.wsize;
    whave = state.whave;
    wnext = state.wnext;
    s_window = state.window;
    hold = state.hold;
    bits = state.bits;
    lcode = state.lencode;
    dcode = state.distcode;
    lmask = (1 << state.lenbits) - 1;
    dmask = (1 << state.distbits) - 1;
    top:
      do {
        if (bits < 15) {
          hold += input[_in++] << bits;
          bits += 8;
          hold += input[_in++] << bits;
          bits += 8;
        }
        here = lcode[hold & lmask];
        dolen:
          for (; ; ) {
            op = here >>> 24;
            hold >>>= op;
            bits -= op;
            op = here >>> 16 & 255;
            if (op === 0) {
              output[_out++] = here & 65535;
            } else if (op & 16) {
              len = here & 65535;
              op &= 15;
              if (op) {
                if (bits < op) {
                  hold += input[_in++] << bits;
                  bits += 8;
                }
                len += hold & (1 << op) - 1;
                hold >>>= op;
                bits -= op;
              }
              if (bits < 15) {
                hold += input[_in++] << bits;
                bits += 8;
                hold += input[_in++] << bits;
                bits += 8;
              }
              here = dcode[hold & dmask];
              dodist:
                for (; ; ) {
                  op = here >>> 24;
                  hold >>>= op;
                  bits -= op;
                  op = here >>> 16 & 255;
                  if (op & 16) {
                    dist = here & 65535;
                    op &= 15;
                    if (bits < op) {
                      hold += input[_in++] << bits;
                      bits += 8;
                      if (bits < op) {
                        hold += input[_in++] << bits;
                        bits += 8;
                      }
                    }
                    dist += hold & (1 << op) - 1;
                    if (dist > dmax) {
                      strm.msg = "invalid distance too far back";
                      state.mode = BAD$1;
                      break top;
                    }
                    hold >>>= op;
                    bits -= op;
                    op = _out - beg;
                    if (dist > op) {
                      op = dist - op;
                      if (op > whave) {
                        if (state.sane) {
                          strm.msg = "invalid distance too far back";
                          state.mode = BAD$1;
                          break top;
                        }
                      }
                      from = 0;
                      from_source = s_window;
                      if (wnext === 0) {
                        from += wsize - op;
                        if (op < len) {
                          len -= op;
                          do {
                            output[_out++] = s_window[from++];
                          } while (--op);
                          from = _out - dist;
                          from_source = output;
                        }
                      } else if (wnext < op) {
                        from += wsize + wnext - op;
                        op -= wnext;
                        if (op < len) {
                          len -= op;
                          do {
                            output[_out++] = s_window[from++];
                          } while (--op);
                          from = 0;
                          if (wnext < len) {
                            op = wnext;
                            len -= op;
                            do {
                              output[_out++] = s_window[from++];
                            } while (--op);
                            from = _out - dist;
                            from_source = output;
                          }
                        }
                      } else {
                        from += wnext - op;
                        if (op < len) {
                          len -= op;
                          do {
                            output[_out++] = s_window[from++];
                          } while (--op);
                          from = _out - dist;
                          from_source = output;
                        }
                      }
                      while (len > 2) {
                        output[_out++] = from_source[from++];
                        output[_out++] = from_source[from++];
                        output[_out++] = from_source[from++];
                        len -= 3;
                      }
                      if (len) {
                        output[_out++] = from_source[from++];
                        if (len > 1) {
                          output[_out++] = from_source[from++];
                        }
                      }
                    } else {
                      from = _out - dist;
                      do {
                        output[_out++] = output[from++];
                        output[_out++] = output[from++];
                        output[_out++] = output[from++];
                        len -= 3;
                      } while (len > 2);
                      if (len) {
                        output[_out++] = output[from++];
                        if (len > 1) {
                          output[_out++] = output[from++];
                        }
                      }
                    }
                  } else if ((op & 64) === 0) {
                    here = dcode[(here & 65535) + (hold & (1 << op) - 1)];
                    continue dodist;
                  } else {
                    strm.msg = "invalid distance code";
                    state.mode = BAD$1;
                    break top;
                  }
                  break;
                }
            } else if ((op & 64) === 0) {
              here = lcode[(here & 65535) + (hold & (1 << op) - 1)];
              continue dolen;
            } else if (op & 32) {
              state.mode = TYPE$1;
              break top;
            } else {
              strm.msg = "invalid literal/length code";
              state.mode = BAD$1;
              break top;
            }
            break;
          }
      } while (_in < last && _out < end);
    len = bits >> 3;
    _in -= len;
    bits -= len << 3;
    hold &= (1 << bits) - 1;
    strm.next_in = _in;
    strm.next_out = _out;
    strm.avail_in = _in < last ? 5 + (last - _in) : 5 - (_in - last);
    strm.avail_out = _out < end ? 257 + (end - _out) : 257 - (_out - end);
    state.hold = hold;
    state.bits = bits;
    return;
  };
  var MAXBITS = 15;
  var ENOUGH_LENS$1 = 852;
  var ENOUGH_DISTS$1 = 592;
  var CODES$1 = 0;
  var LENS$1 = 1;
  var DISTS$1 = 2;
  var lbase = new Uint16Array([
    /* Length codes 257..285 base */
    3,
    4,
    5,
    6,
    7,
    8,
    9,
    10,
    11,
    13,
    15,
    17,
    19,
    23,
    27,
    31,
    35,
    43,
    51,
    59,
    67,
    83,
    99,
    115,
    131,
    163,
    195,
    227,
    258,
    0,
    0
  ]);
  var lext = new Uint8Array([
    /* Length codes 257..285 extra */
    16,
    16,
    16,
    16,
    16,
    16,
    16,
    16,
    17,
    17,
    17,
    17,
    18,
    18,
    18,
    18,
    19,
    19,
    19,
    19,
    20,
    20,
    20,
    20,
    21,
    21,
    21,
    21,
    16,
    72,
    78
  ]);
  var dbase = new Uint16Array([
    /* Distance codes 0..29 base */
    1,
    2,
    3,
    4,
    5,
    7,
    9,
    13,
    17,
    25,
    33,
    49,
    65,
    97,
    129,
    193,
    257,
    385,
    513,
    769,
    1025,
    1537,
    2049,
    3073,
    4097,
    6145,
    8193,
    12289,
    16385,
    24577,
    0,
    0
  ]);
  var dext = new Uint8Array([
    /* Distance codes 0..29 extra */
    16,
    16,
    16,
    16,
    17,
    17,
    18,
    18,
    19,
    19,
    20,
    20,
    21,
    21,
    22,
    22,
    23,
    23,
    24,
    24,
    25,
    25,
    26,
    26,
    27,
    27,
    28,
    28,
    29,
    29,
    64,
    64
  ]);
  var inflate_table = (type2, lens, lens_index, codes, table, table_index, work, opts) => {
    const bits = opts.bits;
    let len = 0;
    let sym = 0;
    let min = 0, max = 0;
    let root = 0;
    let curr = 0;
    let drop = 0;
    let left = 0;
    let used = 0;
    let huff = 0;
    let incr;
    let fill;
    let low;
    let mask2;
    let next;
    let base = null;
    let match;
    const count = new Uint16Array(MAXBITS + 1);
    const offs = new Uint16Array(MAXBITS + 1);
    let extra = null;
    let here_bits, here_op, here_val;
    for (len = 0; len <= MAXBITS; len++) {
      count[len] = 0;
    }
    for (sym = 0; sym < codes; sym++) {
      count[lens[lens_index + sym]]++;
    }
    root = bits;
    for (max = MAXBITS; max >= 1; max--) {
      if (count[max] !== 0) {
        break;
      }
    }
    if (root > max) {
      root = max;
    }
    if (max === 0) {
      table[table_index++] = 1 << 24 | 64 << 16 | 0;
      table[table_index++] = 1 << 24 | 64 << 16 | 0;
      opts.bits = 1;
      return 0;
    }
    for (min = 1; min < max; min++) {
      if (count[min] !== 0) {
        break;
      }
    }
    if (root < min) {
      root = min;
    }
    left = 1;
    for (len = 1; len <= MAXBITS; len++) {
      left <<= 1;
      left -= count[len];
      if (left < 0) {
        return -1;
      }
    }
    if (left > 0 && (type2 === CODES$1 || max !== 1)) {
      return -1;
    }
    offs[1] = 0;
    for (len = 1; len < MAXBITS; len++) {
      offs[len + 1] = offs[len] + count[len];
    }
    for (sym = 0; sym < codes; sym++) {
      if (lens[lens_index + sym] !== 0) {
        work[offs[lens[lens_index + sym]]++] = sym;
      }
    }
    if (type2 === CODES$1) {
      base = extra = work;
      match = 20;
    } else if (type2 === LENS$1) {
      base = lbase;
      extra = lext;
      match = 257;
    } else {
      base = dbase;
      extra = dext;
      match = 0;
    }
    huff = 0;
    sym = 0;
    len = min;
    next = table_index;
    curr = root;
    drop = 0;
    low = -1;
    used = 1 << root;
    mask2 = used - 1;
    if (type2 === LENS$1 && used > ENOUGH_LENS$1 || type2 === DISTS$1 && used > ENOUGH_DISTS$1) {
      return 1;
    }
    for (; ; ) {
      here_bits = len - drop;
      if (work[sym] + 1 < match) {
        here_op = 0;
        here_val = work[sym];
      } else if (work[sym] >= match) {
        here_op = extra[work[sym] - match];
        here_val = base[work[sym] - match];
      } else {
        here_op = 32 + 64;
        here_val = 0;
      }
      incr = 1 << len - drop;
      fill = 1 << curr;
      min = fill;
      do {
        fill -= incr;
        table[next + (huff >> drop) + fill] = here_bits << 24 | here_op << 16 | here_val | 0;
      } while (fill !== 0);
      incr = 1 << len - 1;
      while (huff & incr) {
        incr >>= 1;
      }
      if (incr !== 0) {
        huff &= incr - 1;
        huff += incr;
      } else {
        huff = 0;
      }
      sym++;
      if (--count[len] === 0) {
        if (len === max) {
          break;
        }
        len = lens[lens_index + work[sym]];
      }
      if (len > root && (huff & mask2) !== low) {
        if (drop === 0) {
          drop = root;
        }
        next += min;
        curr = len - drop;
        left = 1 << curr;
        while (curr + drop < max) {
          left -= count[curr + drop];
          if (left <= 0) {
            break;
          }
          curr++;
          left <<= 1;
        }
        used += 1 << curr;
        if (type2 === LENS$1 && used > ENOUGH_LENS$1 || type2 === DISTS$1 && used > ENOUGH_DISTS$1) {
          return 1;
        }
        low = huff & mask2;
        table[low] = root << 24 | curr << 16 | next - table_index | 0;
      }
    }
    if (huff !== 0) {
      table[next + huff] = len - drop << 24 | 64 << 16 | 0;
    }
    opts.bits = root;
    return 0;
  };
  var inftrees = inflate_table;
  var CODES = 0;
  var LENS = 1;
  var DISTS = 2;
  var {
    Z_FINISH: Z_FINISH$1,
    Z_BLOCK,
    Z_TREES,
    Z_OK: Z_OK$1,
    Z_STREAM_END: Z_STREAM_END$1,
    Z_NEED_DICT: Z_NEED_DICT$1,
    Z_STREAM_ERROR: Z_STREAM_ERROR$1,
    Z_DATA_ERROR: Z_DATA_ERROR$1,
    Z_MEM_ERROR: Z_MEM_ERROR$1,
    Z_BUF_ERROR,
    Z_DEFLATED
  } = constants$2;
  var HEAD = 16180;
  var FLAGS = 16181;
  var TIME = 16182;
  var OS = 16183;
  var EXLEN = 16184;
  var EXTRA = 16185;
  var NAME = 16186;
  var COMMENT = 16187;
  var HCRC = 16188;
  var DICTID = 16189;
  var DICT = 16190;
  var TYPE = 16191;
  var TYPEDO = 16192;
  var STORED = 16193;
  var COPY_ = 16194;
  var COPY = 16195;
  var TABLE = 16196;
  var LENLENS = 16197;
  var CODELENS = 16198;
  var LEN_ = 16199;
  var LEN = 16200;
  var LENEXT = 16201;
  var DIST = 16202;
  var DISTEXT = 16203;
  var MATCH = 16204;
  var LIT = 16205;
  var CHECK = 16206;
  var LENGTH = 16207;
  var DONE = 16208;
  var BAD = 16209;
  var MEM = 16210;
  var SYNC = 16211;
  var ENOUGH_LENS = 852;
  var ENOUGH_DISTS = 592;
  var MAX_WBITS = 15;
  var DEF_WBITS = MAX_WBITS;
  var zswap32 = (q) => {
    return (q >>> 24 & 255) + (q >>> 8 & 65280) + ((q & 65280) << 8) + ((q & 255) << 24);
  };
  function InflateState() {
    this.strm = null;
    this.mode = 0;
    this.last = false;
    this.wrap = 0;
    this.havedict = false;
    this.flags = 0;
    this.dmax = 0;
    this.check = 0;
    this.total = 0;
    this.head = null;
    this.wbits = 0;
    this.wsize = 0;
    this.whave = 0;
    this.wnext = 0;
    this.window = null;
    this.hold = 0;
    this.bits = 0;
    this.length = 0;
    this.offset = 0;
    this.extra = 0;
    this.lencode = null;
    this.distcode = null;
    this.lenbits = 0;
    this.distbits = 0;
    this.ncode = 0;
    this.nlen = 0;
    this.ndist = 0;
    this.have = 0;
    this.next = null;
    this.lens = new Uint16Array(320);
    this.work = new Uint16Array(288);
    this.lendyn = null;
    this.distdyn = null;
    this.sane = 0;
    this.back = 0;
    this.was = 0;
  }
  var inflateStateCheck = (strm) => {
    if (!strm) {
      return 1;
    }
    const state = strm.state;
    if (!state || state.strm !== strm || state.mode < HEAD || state.mode > SYNC) {
      return 1;
    }
    return 0;
  };
  var inflateResetKeep = (strm) => {
    if (inflateStateCheck(strm)) {
      return Z_STREAM_ERROR$1;
    }
    const state = strm.state;
    strm.total_in = strm.total_out = state.total = 0;
    strm.msg = "";
    if (state.wrap) {
      strm.adler = state.wrap & 1;
    }
    state.mode = HEAD;
    state.last = 0;
    state.havedict = 0;
    state.flags = -1;
    state.dmax = 32768;
    state.head = null;
    state.hold = 0;
    state.bits = 0;
    state.lencode = state.lendyn = new Int32Array(ENOUGH_LENS);
    state.distcode = state.distdyn = new Int32Array(ENOUGH_DISTS);
    state.sane = 1;
    state.back = -1;
    return Z_OK$1;
  };
  var inflateReset = (strm) => {
    if (inflateStateCheck(strm)) {
      return Z_STREAM_ERROR$1;
    }
    const state = strm.state;
    state.wsize = 0;
    state.whave = 0;
    state.wnext = 0;
    return inflateResetKeep(strm);
  };
  var inflateReset2 = (strm, windowBits) => {
    let wrap;
    if (inflateStateCheck(strm)) {
      return Z_STREAM_ERROR$1;
    }
    const state = strm.state;
    if (windowBits < 0) {
      wrap = 0;
      windowBits = -windowBits;
    } else {
      wrap = (windowBits >> 4) + 5;
      if (windowBits < 48) {
        windowBits &= 15;
      }
    }
    if (windowBits && (windowBits < 8 || windowBits > 15)) {
      return Z_STREAM_ERROR$1;
    }
    if (state.window !== null && state.wbits !== windowBits) {
      state.window = null;
    }
    state.wrap = wrap;
    state.wbits = windowBits;
    return inflateReset(strm);
  };
  var inflateInit2 = (strm, windowBits) => {
    if (!strm) {
      return Z_STREAM_ERROR$1;
    }
    const state = new InflateState();
    strm.state = state;
    state.strm = strm;
    state.window = null;
    state.mode = HEAD;
    const ret = inflateReset2(strm, windowBits);
    if (ret !== Z_OK$1) {
      strm.state = null;
    }
    return ret;
  };
  var inflateInit = (strm) => {
    return inflateInit2(strm, DEF_WBITS);
  };
  var virgin = true;
  var lenfix;
  var distfix;
  var fixedtables = (state) => {
    if (virgin) {
      lenfix = new Int32Array(512);
      distfix = new Int32Array(32);
      let sym = 0;
      while (sym < 144) {
        state.lens[sym++] = 8;
      }
      while (sym < 256) {
        state.lens[sym++] = 9;
      }
      while (sym < 280) {
        state.lens[sym++] = 7;
      }
      while (sym < 288) {
        state.lens[sym++] = 8;
      }
      inftrees(LENS, state.lens, 0, 288, lenfix, 0, state.work, { bits: 9 });
      sym = 0;
      while (sym < 32) {
        state.lens[sym++] = 5;
      }
      inftrees(DISTS, state.lens, 0, 32, distfix, 0, state.work, { bits: 5 });
      virgin = false;
    }
    state.lencode = lenfix;
    state.lenbits = 9;
    state.distcode = distfix;
    state.distbits = 5;
  };
  var updatewindow = (strm, src, end, copy) => {
    let dist;
    const state = strm.state;
    if (state.window === null) {
      state.wsize = 1 << state.wbits;
      state.wnext = 0;
      state.whave = 0;
      state.window = new Uint8Array(state.wsize);
    }
    if (copy >= state.wsize) {
      state.window.set(src.subarray(end - state.wsize, end), 0);
      state.wnext = 0;
      state.whave = state.wsize;
    } else {
      dist = state.wsize - state.wnext;
      if (dist > copy) {
        dist = copy;
      }
      state.window.set(src.subarray(end - copy, end - copy + dist), state.wnext);
      copy -= dist;
      if (copy) {
        state.window.set(src.subarray(end - copy, end), 0);
        state.wnext = copy;
        state.whave = state.wsize;
      } else {
        state.wnext += dist;
        if (state.wnext === state.wsize) {
          state.wnext = 0;
        }
        if (state.whave < state.wsize) {
          state.whave += dist;
        }
      }
    }
    return 0;
  };
  var inflate$2 = (strm, flush) => {
    let state;
    let input, output;
    let next;
    let put;
    let have, left;
    let hold;
    let bits;
    let _in, _out;
    let copy;
    let from;
    let from_source;
    let here = 0;
    let here_bits, here_op, here_val;
    let last_bits, last_op, last_val;
    let len;
    let ret;
    const hbuf = new Uint8Array(4);
    let opts;
    let n;
    const order = (
      /* permutation of code lengths */
      new Uint8Array([16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15])
    );
    if (inflateStateCheck(strm) || !strm.output || !strm.input && strm.avail_in !== 0) {
      return Z_STREAM_ERROR$1;
    }
    state = strm.state;
    if (state.mode === TYPE) {
      state.mode = TYPEDO;
    }
    put = strm.next_out;
    output = strm.output;
    left = strm.avail_out;
    next = strm.next_in;
    input = strm.input;
    have = strm.avail_in;
    hold = state.hold;
    bits = state.bits;
    _in = have;
    _out = left;
    ret = Z_OK$1;
    inf_leave:
      for (; ; ) {
        switch (state.mode) {
          case HEAD:
            if (state.wrap === 0) {
              state.mode = TYPEDO;
              break;
            }
            while (bits < 16) {
              if (have === 0) {
                break inf_leave;
              }
              have--;
              hold += input[next++] << bits;
              bits += 8;
            }
            if (state.wrap & 2 && hold === 35615) {
              if (state.wbits === 0) {
                state.wbits = 15;
              }
              state.check = 0;
              hbuf[0] = hold & 255;
              hbuf[1] = hold >>> 8 & 255;
              state.check = crc32_1(state.check, hbuf, 2, 0);
              hold = 0;
              bits = 0;
              state.mode = FLAGS;
              break;
            }
            if (state.head) {
              state.head.done = false;
            }
            if (!(state.wrap & 1) || /* check if zlib header allowed */
            (((hold & 255) << 8) + (hold >> 8)) % 31) {
              strm.msg = "incorrect header check";
              state.mode = BAD;
              break;
            }
            if ((hold & 15) !== Z_DEFLATED) {
              strm.msg = "unknown compression method";
              state.mode = BAD;
              break;
            }
            hold >>>= 4;
            bits -= 4;
            len = (hold & 15) + 8;
            if (state.wbits === 0) {
              state.wbits = len;
            }
            if (len > 15 || len > state.wbits) {
              strm.msg = "invalid window size";
              state.mode = BAD;
              break;
            }
            state.dmax = 1 << state.wbits;
            state.flags = 0;
            strm.adler = state.check = 1;
            state.mode = hold & 512 ? DICTID : TYPE;
            hold = 0;
            bits = 0;
            break;
          case FLAGS:
            while (bits < 16) {
              if (have === 0) {
                break inf_leave;
              }
              have--;
              hold += input[next++] << bits;
              bits += 8;
            }
            state.flags = hold;
            if ((state.flags & 255) !== Z_DEFLATED) {
              strm.msg = "unknown compression method";
              state.mode = BAD;
              break;
            }
            if (state.flags & 57344) {
              strm.msg = "unknown header flags set";
              state.mode = BAD;
              break;
            }
            if (state.head) {
              state.head.text = hold >> 8 & 1;
            }
            if (state.flags & 512 && state.wrap & 4) {
              hbuf[0] = hold & 255;
              hbuf[1] = hold >>> 8 & 255;
              state.check = crc32_1(state.check, hbuf, 2, 0);
            }
            hold = 0;
            bits = 0;
            state.mode = TIME;
          /* falls through */
          case TIME:
            while (bits < 32) {
              if (have === 0) {
                break inf_leave;
              }
              have--;
              hold += input[next++] << bits;
              bits += 8;
            }
            if (state.head) {
              state.head.time = hold;
            }
            if (state.flags & 512 && state.wrap & 4) {
              hbuf[0] = hold & 255;
              hbuf[1] = hold >>> 8 & 255;
              hbuf[2] = hold >>> 16 & 255;
              hbuf[3] = hold >>> 24 & 255;
              state.check = crc32_1(state.check, hbuf, 4, 0);
            }
            hold = 0;
            bits = 0;
            state.mode = OS;
          /* falls through */
          case OS:
            while (bits < 16) {
              if (have === 0) {
                break inf_leave;
              }
              have--;
              hold += input[next++] << bits;
              bits += 8;
            }
            if (state.head) {
              state.head.xflags = hold & 255;
              state.head.os = hold >> 8;
            }
            if (state.flags & 512 && state.wrap & 4) {
              hbuf[0] = hold & 255;
              hbuf[1] = hold >>> 8 & 255;
              state.check = crc32_1(state.check, hbuf, 2, 0);
            }
            hold = 0;
            bits = 0;
            state.mode = EXLEN;
          /* falls through */
          case EXLEN:
            if (state.flags & 1024) {
              while (bits < 16) {
                if (have === 0) {
                  break inf_leave;
                }
                have--;
                hold += input[next++] << bits;
                bits += 8;
              }
              state.length = hold;
              if (state.head) {
                state.head.extra_len = hold;
              }
              if (state.flags & 512 && state.wrap & 4) {
                hbuf[0] = hold & 255;
                hbuf[1] = hold >>> 8 & 255;
                state.check = crc32_1(state.check, hbuf, 2, 0);
              }
              hold = 0;
              bits = 0;
            } else if (state.head) {
              state.head.extra = null;
            }
            state.mode = EXTRA;
          /* falls through */
          case EXTRA:
            if (state.flags & 1024) {
              copy = state.length;
              if (copy > have) {
                copy = have;
              }
              if (copy) {
                if (state.head) {
                  len = state.head.extra_len - state.length;
                  if (!state.head.extra) {
                    state.head.extra = new Uint8Array(state.head.extra_len);
                  }
                  state.head.extra.set(
                    input.subarray(
                      next,
                      // extra field is limited to 65536 bytes
                      // - no need for additional size check
                      next + copy
                    ),
                    /*len + copy > state.head.extra_max - len ? state.head.extra_max : copy,*/
                    len
                  );
                }
                if (state.flags & 512 && state.wrap & 4) {
                  state.check = crc32_1(state.check, input, copy, next);
                }
                have -= copy;
                next += copy;
                state.length -= copy;
              }
              if (state.length) {
                break inf_leave;
              }
            }
            state.length = 0;
            state.mode = NAME;
          /* falls through */
          case NAME:
            if (state.flags & 2048) {
              if (have === 0) {
                break inf_leave;
              }
              copy = 0;
              do {
                len = input[next + copy++];
                if (state.head && len && state.length < 65536) {
                  state.head.name += String.fromCharCode(len);
                }
              } while (len && copy < have);
              if (state.flags & 512 && state.wrap & 4) {
                state.check = crc32_1(state.check, input, copy, next);
              }
              have -= copy;
              next += copy;
              if (len) {
                break inf_leave;
              }
            } else if (state.head) {
              state.head.name = null;
            }
            state.length = 0;
            state.mode = COMMENT;
          /* falls through */
          case COMMENT:
            if (state.flags & 4096) {
              if (have === 0) {
                break inf_leave;
              }
              copy = 0;
              do {
                len = input[next + copy++];
                if (state.head && len && state.length < 65536) {
                  state.head.comment += String.fromCharCode(len);
                }
              } while (len && copy < have);
              if (state.flags & 512 && state.wrap & 4) {
                state.check = crc32_1(state.check, input, copy, next);
              }
              have -= copy;
              next += copy;
              if (len) {
                break inf_leave;
              }
            } else if (state.head) {
              state.head.comment = null;
            }
            state.mode = HCRC;
          /* falls through */
          case HCRC:
            if (state.flags & 512) {
              while (bits < 16) {
                if (have === 0) {
                  break inf_leave;
                }
                have--;
                hold += input[next++] << bits;
                bits += 8;
              }
              if (state.wrap & 4 && hold !== (state.check & 65535)) {
                strm.msg = "header crc mismatch";
                state.mode = BAD;
                break;
              }
              hold = 0;
              bits = 0;
            }
            if (state.head) {
              state.head.hcrc = state.flags >> 9 & 1;
              state.head.done = true;
            }
            strm.adler = state.check = 0;
            state.mode = TYPE;
            break;
          case DICTID:
            while (bits < 32) {
              if (have === 0) {
                break inf_leave;
              }
              have--;
              hold += input[next++] << bits;
              bits += 8;
            }
            strm.adler = state.check = zswap32(hold);
            hold = 0;
            bits = 0;
            state.mode = DICT;
          /* falls through */
          case DICT:
            if (state.havedict === 0) {
              strm.next_out = put;
              strm.avail_out = left;
              strm.next_in = next;
              strm.avail_in = have;
              state.hold = hold;
              state.bits = bits;
              return Z_NEED_DICT$1;
            }
            strm.adler = state.check = 1;
            state.mode = TYPE;
          /* falls through */
          case TYPE:
            if (flush === Z_BLOCK || flush === Z_TREES) {
              break inf_leave;
            }
          /* falls through */
          case TYPEDO:
            if (state.last) {
              hold >>>= bits & 7;
              bits -= bits & 7;
              state.mode = CHECK;
              break;
            }
            while (bits < 3) {
              if (have === 0) {
                break inf_leave;
              }
              have--;
              hold += input[next++] << bits;
              bits += 8;
            }
            state.last = hold & 1;
            hold >>>= 1;
            bits -= 1;
            switch (hold & 3) {
              case 0:
                state.mode = STORED;
                break;
              case 1:
                fixedtables(state);
                state.mode = LEN_;
                if (flush === Z_TREES) {
                  hold >>>= 2;
                  bits -= 2;
                  break inf_leave;
                }
                break;
              case 2:
                state.mode = TABLE;
                break;
              case 3:
                strm.msg = "invalid block type";
                state.mode = BAD;
            }
            hold >>>= 2;
            bits -= 2;
            break;
          case STORED:
            hold >>>= bits & 7;
            bits -= bits & 7;
            while (bits < 32) {
              if (have === 0) {
                break inf_leave;
              }
              have--;
              hold += input[next++] << bits;
              bits += 8;
            }
            if ((hold & 65535) !== (hold >>> 16 ^ 65535)) {
              strm.msg = "invalid stored block lengths";
              state.mode = BAD;
              break;
            }
            state.length = hold & 65535;
            hold = 0;
            bits = 0;
            state.mode = COPY_;
            if (flush === Z_TREES) {
              break inf_leave;
            }
          /* falls through */
          case COPY_:
            state.mode = COPY;
          /* falls through */
          case COPY:
            copy = state.length;
            if (copy) {
              if (copy > have) {
                copy = have;
              }
              if (copy > left) {
                copy = left;
              }
              if (copy === 0) {
                break inf_leave;
              }
              output.set(input.subarray(next, next + copy), put);
              have -= copy;
              next += copy;
              left -= copy;
              put += copy;
              state.length -= copy;
              break;
            }
            state.mode = TYPE;
            break;
          case TABLE:
            while (bits < 14) {
              if (have === 0) {
                break inf_leave;
              }
              have--;
              hold += input[next++] << bits;
              bits += 8;
            }
            state.nlen = (hold & 31) + 257;
            hold >>>= 5;
            bits -= 5;
            state.ndist = (hold & 31) + 1;
            hold >>>= 5;
            bits -= 5;
            state.ncode = (hold & 15) + 4;
            hold >>>= 4;
            bits -= 4;
            if (state.nlen > 286 || state.ndist > 30) {
              strm.msg = "too many length or distance symbols";
              state.mode = BAD;
              break;
            }
            state.have = 0;
            state.mode = LENLENS;
          /* falls through */
          case LENLENS:
            while (state.have < state.ncode) {
              while (bits < 3) {
                if (have === 0) {
                  break inf_leave;
                }
                have--;
                hold += input[next++] << bits;
                bits += 8;
              }
              state.lens[order[state.have++]] = hold & 7;
              hold >>>= 3;
              bits -= 3;
            }
            while (state.have < 19) {
              state.lens[order[state.have++]] = 0;
            }
            state.lencode = state.lendyn;
            state.lenbits = 7;
            opts = { bits: state.lenbits };
            ret = inftrees(CODES, state.lens, 0, 19, state.lencode, 0, state.work, opts);
            state.lenbits = opts.bits;
            if (ret) {
              strm.msg = "invalid code lengths set";
              state.mode = BAD;
              break;
            }
            state.have = 0;
            state.mode = CODELENS;
          /* falls through */
          case CODELENS:
            while (state.have < state.nlen + state.ndist) {
              for (; ; ) {
                here = state.lencode[hold & (1 << state.lenbits) - 1];
                here_bits = here >>> 24;
                here_op = here >>> 16 & 255;
                here_val = here & 65535;
                if (here_bits <= bits) {
                  break;
                }
                if (have === 0) {
                  break inf_leave;
                }
                have--;
                hold += input[next++] << bits;
                bits += 8;
              }
              if (here_val < 16) {
                hold >>>= here_bits;
                bits -= here_bits;
                state.lens[state.have++] = here_val;
              } else {
                if (here_val === 16) {
                  n = here_bits + 2;
                  while (bits < n) {
                    if (have === 0) {
                      break inf_leave;
                    }
                    have--;
                    hold += input[next++] << bits;
                    bits += 8;
                  }
                  hold >>>= here_bits;
                  bits -= here_bits;
                  if (state.have === 0) {
                    strm.msg = "invalid bit length repeat";
                    state.mode = BAD;
                    break;
                  }
                  len = state.lens[state.have - 1];
                  copy = 3 + (hold & 3);
                  hold >>>= 2;
                  bits -= 2;
                } else if (here_val === 17) {
                  n = here_bits + 3;
                  while (bits < n) {
                    if (have === 0) {
                      break inf_leave;
                    }
                    have--;
                    hold += input[next++] << bits;
                    bits += 8;
                  }
                  hold >>>= here_bits;
                  bits -= here_bits;
                  len = 0;
                  copy = 3 + (hold & 7);
                  hold >>>= 3;
                  bits -= 3;
                } else {
                  n = here_bits + 7;
                  while (bits < n) {
                    if (have === 0) {
                      break inf_leave;
                    }
                    have--;
                    hold += input[next++] << bits;
                    bits += 8;
                  }
                  hold >>>= here_bits;
                  bits -= here_bits;
                  len = 0;
                  copy = 11 + (hold & 127);
                  hold >>>= 7;
                  bits -= 7;
                }
                if (state.have + copy > state.nlen + state.ndist) {
                  strm.msg = "invalid bit length repeat";
                  state.mode = BAD;
                  break;
                }
                while (copy--) {
                  state.lens[state.have++] = len;
                }
              }
            }
            if (state.mode === BAD) {
              break;
            }
            if (state.lens[256] === 0) {
              strm.msg = "invalid code -- missing end-of-block";
              state.mode = BAD;
              break;
            }
            state.lenbits = 9;
            opts = { bits: state.lenbits };
            ret = inftrees(LENS, state.lens, 0, state.nlen, state.lencode, 0, state.work, opts);
            state.lenbits = opts.bits;
            if (ret) {
              strm.msg = "invalid literal/lengths set";
              state.mode = BAD;
              break;
            }
            state.distbits = 6;
            state.distcode = state.distdyn;
            opts = { bits: state.distbits };
            ret = inftrees(DISTS, state.lens, state.nlen, state.ndist, state.distcode, 0, state.work, opts);
            state.distbits = opts.bits;
            if (ret) {
              strm.msg = "invalid distances set";
              state.mode = BAD;
              break;
            }
            state.mode = LEN_;
            if (flush === Z_TREES) {
              break inf_leave;
            }
          /* falls through */
          case LEN_:
            state.mode = LEN;
          /* falls through */
          case LEN:
            if (have >= 6 && left >= 258) {
              strm.next_out = put;
              strm.avail_out = left;
              strm.next_in = next;
              strm.avail_in = have;
              state.hold = hold;
              state.bits = bits;
              inffast(strm, _out);
              put = strm.next_out;
              output = strm.output;
              left = strm.avail_out;
              next = strm.next_in;
              input = strm.input;
              have = strm.avail_in;
              hold = state.hold;
              bits = state.bits;
              if (state.mode === TYPE) {
                state.back = -1;
              }
              break;
            }
            state.back = 0;
            for (; ; ) {
              here = state.lencode[hold & (1 << state.lenbits) - 1];
              here_bits = here >>> 24;
              here_op = here >>> 16 & 255;
              here_val = here & 65535;
              if (here_bits <= bits) {
                break;
              }
              if (have === 0) {
                break inf_leave;
              }
              have--;
              hold += input[next++] << bits;
              bits += 8;
            }
            if (here_op && (here_op & 240) === 0) {
              last_bits = here_bits;
              last_op = here_op;
              last_val = here_val;
              for (; ; ) {
                here = state.lencode[last_val + ((hold & (1 << last_bits + last_op) - 1) >> last_bits)];
                here_bits = here >>> 24;
                here_op = here >>> 16 & 255;
                here_val = here & 65535;
                if (last_bits + here_bits <= bits) {
                  break;
                }
                if (have === 0) {
                  break inf_leave;
                }
                have--;
                hold += input[next++] << bits;
                bits += 8;
              }
              hold >>>= last_bits;
              bits -= last_bits;
              state.back += last_bits;
            }
            hold >>>= here_bits;
            bits -= here_bits;
            state.back += here_bits;
            state.length = here_val;
            if (here_op === 0) {
              state.mode = LIT;
              break;
            }
            if (here_op & 32) {
              state.back = -1;
              state.mode = TYPE;
              break;
            }
            if (here_op & 64) {
              strm.msg = "invalid literal/length code";
              state.mode = BAD;
              break;
            }
            state.extra = here_op & 15;
            state.mode = LENEXT;
          /* falls through */
          case LENEXT:
            if (state.extra) {
              n = state.extra;
              while (bits < n) {
                if (have === 0) {
                  break inf_leave;
                }
                have--;
                hold += input[next++] << bits;
                bits += 8;
              }
              state.length += hold & (1 << state.extra) - 1;
              hold >>>= state.extra;
              bits -= state.extra;
              state.back += state.extra;
            }
            state.was = state.length;
            state.mode = DIST;
          /* falls through */
          case DIST:
            for (; ; ) {
              here = state.distcode[hold & (1 << state.distbits) - 1];
              here_bits = here >>> 24;
              here_op = here >>> 16 & 255;
              here_val = here & 65535;
              if (here_bits <= bits) {
                break;
              }
              if (have === 0) {
                break inf_leave;
              }
              have--;
              hold += input[next++] << bits;
              bits += 8;
            }
            if ((here_op & 240) === 0) {
              last_bits = here_bits;
              last_op = here_op;
              last_val = here_val;
              for (; ; ) {
                here = state.distcode[last_val + ((hold & (1 << last_bits + last_op) - 1) >> last_bits)];
                here_bits = here >>> 24;
                here_op = here >>> 16 & 255;
                here_val = here & 65535;
                if (last_bits + here_bits <= bits) {
                  break;
                }
                if (have === 0) {
                  break inf_leave;
                }
                have--;
                hold += input[next++] << bits;
                bits += 8;
              }
              hold >>>= last_bits;
              bits -= last_bits;
              state.back += last_bits;
            }
            hold >>>= here_bits;
            bits -= here_bits;
            state.back += here_bits;
            if (here_op & 64) {
              strm.msg = "invalid distance code";
              state.mode = BAD;
              break;
            }
            state.offset = here_val;
            state.extra = here_op & 15;
            state.mode = DISTEXT;
          /* falls through */
          case DISTEXT:
            if (state.extra) {
              n = state.extra;
              while (bits < n) {
                if (have === 0) {
                  break inf_leave;
                }
                have--;
                hold += input[next++] << bits;
                bits += 8;
              }
              state.offset += hold & (1 << state.extra) - 1;
              hold >>>= state.extra;
              bits -= state.extra;
              state.back += state.extra;
            }
            if (state.offset > state.dmax) {
              strm.msg = "invalid distance too far back";
              state.mode = BAD;
              break;
            }
            state.mode = MATCH;
          /* falls through */
          case MATCH:
            if (left === 0) {
              break inf_leave;
            }
            copy = _out - left;
            if (state.offset > copy) {
              copy = state.offset - copy;
              if (copy > state.whave) {
                if (state.sane) {
                  strm.msg = "invalid distance too far back";
                  state.mode = BAD;
                  break;
                }
              }
              if (copy > state.wnext) {
                copy -= state.wnext;
                from = state.wsize - copy;
              } else {
                from = state.wnext - copy;
              }
              if (copy > state.length) {
                copy = state.length;
              }
              from_source = state.window;
            } else {
              from_source = output;
              from = put - state.offset;
              copy = state.length;
            }
            if (copy > left) {
              copy = left;
            }
            left -= copy;
            state.length -= copy;
            do {
              output[put++] = from_source[from++];
            } while (--copy);
            if (state.length === 0) {
              state.mode = LEN;
            }
            break;
          case LIT:
            if (left === 0) {
              break inf_leave;
            }
            output[put++] = state.length;
            left--;
            state.mode = LEN;
            break;
          case CHECK:
            if (state.wrap) {
              while (bits < 32) {
                if (have === 0) {
                  break inf_leave;
                }
                have--;
                hold |= input[next++] << bits;
                bits += 8;
              }
              _out -= left;
              strm.total_out += _out;
              state.total += _out;
              if (state.wrap & 4 && _out) {
                strm.adler = state.check = /*UPDATE_CHECK(state.check, put - _out, _out);*/
                state.flags ? crc32_1(state.check, output, _out, put - _out) : adler32_1(state.check, output, _out, put - _out);
              }
              _out = left;
              if (state.wrap & 4 && (state.flags ? hold : zswap32(hold)) !== state.check) {
                strm.msg = "incorrect data check";
                state.mode = BAD;
                break;
              }
              hold = 0;
              bits = 0;
            }
            state.mode = LENGTH;
          /* falls through */
          case LENGTH:
            if (state.wrap && state.flags) {
              while (bits < 32) {
                if (have === 0) {
                  break inf_leave;
                }
                have--;
                hold += input[next++] << bits;
                bits += 8;
              }
              if (state.wrap & 4 && hold !== (state.total & 4294967295)) {
                strm.msg = "incorrect length check";
                state.mode = BAD;
                break;
              }
              hold = 0;
              bits = 0;
            }
            state.mode = DONE;
          /* falls through */
          case DONE:
            ret = Z_STREAM_END$1;
            break inf_leave;
          case BAD:
            ret = Z_DATA_ERROR$1;
            break inf_leave;
          case MEM:
            return Z_MEM_ERROR$1;
          case SYNC:
          /* falls through */
          default:
            return Z_STREAM_ERROR$1;
        }
      }
    strm.next_out = put;
    strm.avail_out = left;
    strm.next_in = next;
    strm.avail_in = have;
    state.hold = hold;
    state.bits = bits;
    if (state.wsize || _out !== strm.avail_out && state.mode < BAD && (state.mode < CHECK || flush !== Z_FINISH$1)) {
      if (updatewindow(strm, strm.output, strm.next_out, _out - strm.avail_out)) ;
    }
    _in -= strm.avail_in;
    _out -= strm.avail_out;
    strm.total_in += _in;
    strm.total_out += _out;
    state.total += _out;
    if (state.wrap & 4 && _out) {
      strm.adler = state.check = /*UPDATE_CHECK(state.check, strm.next_out - _out, _out);*/
      state.flags ? crc32_1(state.check, output, _out, strm.next_out - _out) : adler32_1(state.check, output, _out, strm.next_out - _out);
    }
    strm.data_type = state.bits + (state.last ? 64 : 0) + (state.mode === TYPE ? 128 : 0) + (state.mode === LEN_ || state.mode === COPY_ ? 256 : 0);
    if ((_in === 0 && _out === 0 || flush === Z_FINISH$1) && ret === Z_OK$1) {
      ret = Z_BUF_ERROR;
    }
    return ret;
  };
  var inflateEnd = (strm) => {
    if (inflateStateCheck(strm)) {
      return Z_STREAM_ERROR$1;
    }
    let state = strm.state;
    if (state.window) {
      state.window = null;
    }
    strm.state = null;
    return Z_OK$1;
  };
  var inflateGetHeader = (strm, head) => {
    if (inflateStateCheck(strm)) {
      return Z_STREAM_ERROR$1;
    }
    const state = strm.state;
    if ((state.wrap & 2) === 0) {
      return Z_STREAM_ERROR$1;
    }
    state.head = head;
    head.done = false;
    return Z_OK$1;
  };
  var inflateSetDictionary = (strm, dictionary) => {
    const dictLength = dictionary.length;
    let state;
    let dictid;
    let ret;
    if (inflateStateCheck(strm)) {
      return Z_STREAM_ERROR$1;
    }
    state = strm.state;
    if (state.wrap !== 0 && state.mode !== DICT) {
      return Z_STREAM_ERROR$1;
    }
    if (state.mode === DICT) {
      dictid = 1;
      dictid = adler32_1(dictid, dictionary, dictLength, 0);
      if (dictid !== state.check) {
        return Z_DATA_ERROR$1;
      }
    }
    ret = updatewindow(strm, dictionary, dictLength, dictLength);
    if (ret) {
      state.mode = MEM;
      return Z_MEM_ERROR$1;
    }
    state.havedict = 1;
    return Z_OK$1;
  };
  var inflateReset_1 = inflateReset;
  var inflateReset2_1 = inflateReset2;
  var inflateResetKeep_1 = inflateResetKeep;
  var inflateInit_1 = inflateInit;
  var inflateInit2_1 = inflateInit2;
  var inflate_2$1 = inflate$2;
  var inflateEnd_1 = inflateEnd;
  var inflateGetHeader_1 = inflateGetHeader;
  var inflateSetDictionary_1 = inflateSetDictionary;
  var inflateInfo = "pako inflate (from Nodeca project)";
  var inflate_1$2 = {
    inflateReset: inflateReset_1,
    inflateReset2: inflateReset2_1,
    inflateResetKeep: inflateResetKeep_1,
    inflateInit: inflateInit_1,
    inflateInit2: inflateInit2_1,
    inflate: inflate_2$1,
    inflateEnd: inflateEnd_1,
    inflateGetHeader: inflateGetHeader_1,
    inflateSetDictionary: inflateSetDictionary_1,
    inflateInfo
  };
  function GZheader() {
    this.text = 0;
    this.time = 0;
    this.xflags = 0;
    this.os = 0;
    this.extra = null;
    this.extra_len = 0;
    this.name = "";
    this.comment = "";
    this.hcrc = 0;
    this.done = false;
  }
  var gzheader = GZheader;
  var toString = Object.prototype.toString;
  var {
    Z_NO_FLUSH,
    Z_FINISH,
    Z_OK,
    Z_STREAM_END,
    Z_NEED_DICT,
    Z_STREAM_ERROR,
    Z_DATA_ERROR,
    Z_MEM_ERROR
  } = constants$2;
  function Inflate$1(options) {
    this.options = common.assign({
      chunkSize: 1024 * 64,
      windowBits: 15,
      to: ""
    }, options || {});
    const opt = this.options;
    if (opt.raw && opt.windowBits >= 0 && opt.windowBits < 16) {
      opt.windowBits = -opt.windowBits;
      if (opt.windowBits === 0) {
        opt.windowBits = -15;
      }
    }
    if (opt.windowBits >= 0 && opt.windowBits < 16 && !(options && options.windowBits)) {
      opt.windowBits += 32;
    }
    if (opt.windowBits > 15 && opt.windowBits < 48) {
      if ((opt.windowBits & 15) === 0) {
        opt.windowBits |= 15;
      }
    }
    this.err = 0;
    this.msg = "";
    this.ended = false;
    this.chunks = [];
    this.strm = new zstream();
    this.strm.avail_out = 0;
    let status = inflate_1$2.inflateInit2(
      this.strm,
      opt.windowBits
    );
    if (status !== Z_OK) {
      throw new Error(messages[status]);
    }
    this.header = new gzheader();
    inflate_1$2.inflateGetHeader(this.strm, this.header);
    if (opt.dictionary) {
      if (typeof opt.dictionary === "string") {
        opt.dictionary = strings.string2buf(opt.dictionary);
      } else if (toString.call(opt.dictionary) === "[object ArrayBuffer]") {
        opt.dictionary = new Uint8Array(opt.dictionary);
      }
      if (opt.raw) {
        status = inflate_1$2.inflateSetDictionary(this.strm, opt.dictionary);
        if (status !== Z_OK) {
          throw new Error(messages[status]);
        }
      }
    }
  }
  Inflate$1.prototype.push = function(data, flush_mode) {
    const strm = this.strm;
    const chunkSize = this.options.chunkSize;
    const dictionary = this.options.dictionary;
    let status, _flush_mode, last_avail_out;
    if (this.ended) return false;
    if (flush_mode === ~~flush_mode) _flush_mode = flush_mode;
    else _flush_mode = flush_mode === true ? Z_FINISH : Z_NO_FLUSH;
    if (toString.call(data) === "[object ArrayBuffer]") {
      strm.input = new Uint8Array(data);
    } else {
      strm.input = data;
    }
    strm.next_in = 0;
    strm.avail_in = strm.input.length;
    for (; ; ) {
      if (strm.avail_out === 0) {
        strm.output = new Uint8Array(chunkSize);
        strm.next_out = 0;
        strm.avail_out = chunkSize;
      }
      status = inflate_1$2.inflate(strm, _flush_mode);
      if (status === Z_NEED_DICT && dictionary) {
        status = inflate_1$2.inflateSetDictionary(strm, dictionary);
        if (status === Z_OK) {
          status = inflate_1$2.inflate(strm, _flush_mode);
        } else if (status === Z_DATA_ERROR) {
          status = Z_NEED_DICT;
        }
      }
      while (strm.avail_in > 0 && status === Z_STREAM_END && strm.state.wrap > 0 && data[strm.next_in] !== 0) {
        inflate_1$2.inflateReset(strm);
        status = inflate_1$2.inflate(strm, _flush_mode);
      }
      switch (status) {
        case Z_STREAM_ERROR:
        case Z_DATA_ERROR:
        case Z_NEED_DICT:
        case Z_MEM_ERROR:
          this.onEnd(status);
          this.ended = true;
          return false;
      }
      last_avail_out = strm.avail_out;
      if (strm.next_out) {
        if (strm.avail_out === 0 || status === Z_STREAM_END) {
          if (this.options.to === "string") {
            let next_out_utf8 = strings.utf8border(strm.output, strm.next_out);
            let tail = strm.next_out - next_out_utf8;
            let utf8str = strings.buf2string(strm.output, next_out_utf8);
            strm.next_out = tail;
            strm.avail_out = chunkSize - tail;
            if (tail) strm.output.set(strm.output.subarray(next_out_utf8, next_out_utf8 + tail), 0);
            this.onData(utf8str);
          } else {
            this.onData(strm.output.length === strm.next_out ? strm.output : strm.output.subarray(0, strm.next_out));
          }
        }
      }
      if (status === Z_OK && last_avail_out === 0) continue;
      if (status === Z_STREAM_END) {
        status = inflate_1$2.inflateEnd(this.strm);
        this.onEnd(status);
        this.ended = true;
        return true;
      }
      if (strm.avail_in === 0) break;
    }
    return true;
  };
  Inflate$1.prototype.onData = function(chunk) {
    this.chunks.push(chunk);
  };
  Inflate$1.prototype.onEnd = function(status) {
    if (status === Z_OK) {
      if (this.options.to === "string") {
        this.result = this.chunks.join("");
      } else {
        this.result = common.flattenChunks(this.chunks);
      }
    }
    this.chunks = [];
    this.err = status;
    this.msg = this.strm.msg;
  };
  function inflate$1(input, options) {
    const inflator = new Inflate$1(options);
    inflator.push(input);
    if (inflator.err) throw inflator.msg || messages[inflator.err];
    return inflator.result;
  }
  function inflateRaw$1(input, options) {
    options = options || {};
    options.raw = true;
    return inflate$1(input, options);
  }
  var Inflate_1$1 = Inflate$1;
  var inflate_2 = inflate$1;
  var inflateRaw_1$1 = inflateRaw$1;
  var ungzip$1 = inflate$1;
  var constants = constants$2;
  var inflate_1$1 = {
    Inflate: Inflate_1$1,
    inflate: inflate_2,
    inflateRaw: inflateRaw_1$1,
    ungzip: ungzip$1,
    constants
  };
  var { Deflate, deflate, deflateRaw, gzip } = deflate_1$1;
  var { Inflate, inflate, inflateRaw, ungzip } = inflate_1$1;
  var inflate_1 = inflate;

  // node_modules/@coral-xyz/anchor/dist/browser/index.js
  var import_eventemitter3 = __toESM(require_eventemitter32());
  function chunks(array3, size) {
    return Array.apply(0, new Array(Math.ceil(array3.length / size))).map((_, index2) => array3.slice(index2 * size, (index2 + 1) * size));
  }
  var isVersionedTransaction = (tx) => {
    return "version" in tx;
  };
  function encode$3(data) {
    return data.reduce((str2, byte) => str2 + byte.toString(16).padStart(2, "0"), "0x");
  }
  function decode$3(data) {
    if (data.indexOf("0x") === 0) {
      data = data.substr(2);
    }
    if (data.length % 2 === 1) {
      data = "0" + data;
    }
    let key = data.match(/.{2}/g);
    if (key === null) {
      return import_buffer.Buffer.from([]);
    }
    return import_buffer.Buffer.from(key.map((byte) => parseInt(byte, 16)));
  }
  var hex = /* @__PURE__ */ Object.freeze({
    __proto__: null,
    encode: encode$3,
    decode: decode$3
  });
  function decode$2(array3) {
    const decoder = new TextDecoder("utf-8");
    return decoder.decode(array3);
  }
  function encode$2(input) {
    const encoder = new TextEncoder();
    return encoder.encode(input);
  }
  var utf8 = /* @__PURE__ */ Object.freeze({
    __proto__: null,
    decode: decode$2,
    encode: encode$2
  });
  function encode$1(data) {
    return import_bs58.default.encode(data);
  }
  function decode$1(data) {
    return import_bs58.default.decode(data);
  }
  var bs58 = /* @__PURE__ */ Object.freeze({
    __proto__: null,
    encode: encode$1,
    decode: decode$1
  });
  function encode(data) {
    return data.toString("base64");
  }
  function decode(data) {
    return import_buffer.Buffer.from(data, "base64");
  }
  var base64 = /* @__PURE__ */ Object.freeze({
    __proto__: null,
    encode,
    decode
  });
  var index$1 = /* @__PURE__ */ Object.freeze({
    __proto__: null,
    hex,
    utf8,
    bs58,
    base64
  });
  function parseIdlErrors(idl) {
    const errors = /* @__PURE__ */ new Map();
    if (idl.errors) {
      idl.errors.forEach((e) => {
        var _a;
        let msg = (_a = e.msg) !== null && _a !== void 0 ? _a : e.name;
        errors.set(e.code, msg);
      });
    }
    return errors;
  }
  function toInstruction(idlIx, ...args) {
    if (idlIx.args.length != args.length) {
      throw new Error("Invalid argument length");
    }
    const ix = {};
    let idx = 0;
    idlIx.args.forEach((ixArg) => {
      ix[ixArg.name] = args[idx];
      idx += 1;
    });
    return ix;
  }
  function validateAccounts(ixAccounts, accounts = {}) {
    ixAccounts.forEach((acc) => {
      if ("accounts" in acc) {
        validateAccounts(acc.accounts, accounts[acc.name]);
      } else {
        if (accounts[acc.name] === void 0) {
          throw new Error(`Invalid arguments: ${acc.name} not provided.`);
        }
      }
    });
  }
  function translateAddress(address) {
    return address instanceof import_web3.PublicKey ? address : new import_web3.PublicKey(address);
  }
  var StructError = class extends TypeError {
    constructor(failure, failures) {
      let cached;
      const {
        message,
        ...rest
      } = failure;
      const {
        path
      } = failure;
      const msg = path.length === 0 ? message : "At path: " + path.join(".") + " -- " + message;
      super(msg);
      this.value = void 0;
      this.key = void 0;
      this.type = void 0;
      this.refinement = void 0;
      this.path = void 0;
      this.branch = void 0;
      this.failures = void 0;
      Object.assign(this, rest);
      this.name = this.constructor.name;
      this.failures = () => {
        var _cached;
        return (_cached = cached) != null ? _cached : cached = [failure, ...failures()];
      };
    }
  };
  function isIterable(x) {
    return isObject(x) && typeof x[Symbol.iterator] === "function";
  }
  function isObject(x) {
    return typeof x === "object" && x != null;
  }
  function print(value) {
    return typeof value === "string" ? JSON.stringify(value) : "" + value;
  }
  function shiftIterator(input) {
    const {
      done,
      value
    } = input.next();
    return done ? void 0 : value;
  }
  function toFailure(result, context, struct3, value) {
    if (result === true) {
      return;
    } else if (result === false) {
      result = {};
    } else if (typeof result === "string") {
      result = {
        message: result
      };
    }
    const {
      path,
      branch
    } = context;
    const {
      type: type2
    } = struct3;
    const {
      refinement,
      message = "Expected a value of type `" + type2 + "`" + (refinement ? " with refinement `" + refinement + "`" : "") + ", but received: `" + print(value) + "`"
    } = result;
    return {
      value,
      type: type2,
      refinement,
      key: path[path.length - 1],
      path,
      branch,
      ...result,
      message
    };
  }
  function* toFailures(result, context, struct3, value) {
    if (!isIterable(result)) {
      result = [result];
    }
    for (const r of result) {
      const failure = toFailure(r, context, struct3, value);
      if (failure) {
        yield failure;
      }
    }
  }
  function* run(value, struct3, options) {
    if (options === void 0) {
      options = {};
    }
    const {
      path = [],
      branch = [value],
      coerce: coerce2 = false,
      mask: mask2 = false
    } = options;
    const ctx = {
      path,
      branch
    };
    if (coerce2) {
      value = struct3.coercer(value, ctx);
      if (mask2 && struct3.type !== "type" && isObject(struct3.schema) && isObject(value) && !Array.isArray(value)) {
        for (const key in value) {
          if (struct3.schema[key] === void 0) {
            delete value[key];
          }
        }
      }
    }
    let valid = true;
    for (const failure of struct3.validator(value, ctx)) {
      valid = false;
      yield [failure, void 0];
    }
    for (let [k, v, s] of struct3.entries(value, ctx)) {
      const ts = run(v, s, {
        path: k === void 0 ? path : [...path, k],
        branch: k === void 0 ? branch : [...branch, v],
        coerce: coerce2,
        mask: mask2
      });
      for (const t of ts) {
        if (t[0]) {
          valid = false;
          yield [t[0], void 0];
        } else if (coerce2) {
          v = t[1];
          if (k === void 0) {
            value = v;
          } else if (value instanceof Map) {
            value.set(k, v);
          } else if (value instanceof Set) {
            value.add(v);
          } else if (isObject(value)) {
            value[k] = v;
          }
        }
      }
    }
    if (valid) {
      for (const failure of struct3.refiner(value, ctx)) {
        valid = false;
        yield [failure, void 0];
      }
    }
    if (valid) {
      yield [void 0, value];
    }
  }
  var Struct = class {
    constructor(props) {
      this.TYPE = void 0;
      this.type = void 0;
      this.schema = void 0;
      this.coercer = void 0;
      this.validator = void 0;
      this.refiner = void 0;
      this.entries = void 0;
      const {
        type: type2,
        schema,
        validator,
        refiner,
        coercer = (value) => value,
        entries = function* () {
        }
      } = props;
      this.type = type2;
      this.schema = schema;
      this.entries = entries;
      this.coercer = coercer;
      if (validator) {
        this.validator = (value, context) => {
          const result = validator(value, context);
          return toFailures(result, context, this, value);
        };
      } else {
        this.validator = () => [];
      }
      if (refiner) {
        this.refiner = (value, context) => {
          const result = refiner(value, context);
          return toFailures(result, context, this, value);
        };
      } else {
        this.refiner = () => [];
      }
    }
    /**
     * Assert that a value passes the struct's validation, throwing if it doesn't.
     */
    assert(value) {
      return assert(value, this);
    }
    /**
     * Create a value with the struct's coercion logic, then validate it.
     */
    create(value) {
      return create(value, this);
    }
    /**
     * Check if a value passes the struct's validation.
     */
    is(value) {
      return is(value, this);
    }
    /**
     * Mask a value, coercing and validating it, but returning only the subset of
     * properties defined by the struct's schema.
     */
    mask(value) {
      return mask(value, this);
    }
    /**
     * Validate a value with the struct's validation logic, returning a tuple
     * representing the result.
     *
     * You may optionally pass `true` for the `withCoercion` argument to coerce
     * the value before attempting to validate it. If you do, the result will
     * contain the coerced result when successful.
     */
    validate(value, options) {
      if (options === void 0) {
        options = {};
      }
      return validate2(value, this, options);
    }
  };
  function assert(value, struct3) {
    const result = validate2(value, struct3);
    if (result[0]) {
      throw result[0];
    }
  }
  function create(value, struct3) {
    const result = validate2(value, struct3, {
      coerce: true
    });
    if (result[0]) {
      throw result[0];
    } else {
      return result[1];
    }
  }
  function mask(value, struct3) {
    const result = validate2(value, struct3, {
      coerce: true,
      mask: true
    });
    if (result[0]) {
      throw result[0];
    } else {
      return result[1];
    }
  }
  function is(value, struct3) {
    const result = validate2(value, struct3);
    return !result[0];
  }
  function validate2(value, struct3, options) {
    if (options === void 0) {
      options = {};
    }
    const tuples = run(value, struct3, options);
    const tuple = shiftIterator(tuples);
    if (tuple[0]) {
      const error = new StructError(tuple[0], function* () {
        for (const t of tuples) {
          if (t[0]) {
            yield t[0];
          }
        }
      });
      return [error, void 0];
    } else {
      const v = tuple[1];
      return [void 0, v];
    }
  }
  function define2(name, validator) {
    return new Struct({
      type: name,
      schema: null,
      validator
    });
  }
  function any() {
    return define2("any", () => true);
  }
  function array2(Element) {
    return new Struct({
      type: "array",
      schema: Element,
      *entries(value) {
        if (Element && Array.isArray(value)) {
          for (const [i, v] of value.entries()) {
            yield [i, v, Element];
          }
        }
      },
      coercer(value) {
        return Array.isArray(value) ? value.slice() : value;
      },
      validator(value) {
        return Array.isArray(value) || "Expected an array value, but received: " + print(value);
      }
    });
  }
  function boolean() {
    return define2("boolean", (value) => {
      return typeof value === "boolean";
    });
  }
  function literal(constant) {
    const description = print(constant);
    const t = typeof constant;
    return new Struct({
      type: "literal",
      schema: t === "string" || t === "number" || t === "boolean" ? constant : null,
      validator(value) {
        return value === constant || "Expected the literal `" + description + "`, but received: " + print(value);
      }
    });
  }
  function nullable(struct3) {
    return new Struct({
      ...struct3,
      validator: (value, ctx) => value === null || struct3.validator(value, ctx),
      refiner: (value, ctx) => value === null || struct3.refiner(value, ctx)
    });
  }
  function number() {
    return define2("number", (value) => {
      return typeof value === "number" && !isNaN(value) || "Expected a number, but received: " + print(value);
    });
  }
  function optional(struct3) {
    return new Struct({
      ...struct3,
      validator: (value, ctx) => value === void 0 || struct3.validator(value, ctx),
      refiner: (value, ctx) => value === void 0 || struct3.refiner(value, ctx)
    });
  }
  function string() {
    return define2("string", (value) => {
      return typeof value === "string" || "Expected a string, but received: " + print(value);
    });
  }
  function type(schema) {
    const keys = Object.keys(schema);
    return new Struct({
      type: "type",
      schema,
      *entries(value) {
        if (isObject(value)) {
          for (const k of keys) {
            yield [k, value[k], schema[k]];
          }
        }
      },
      validator(value) {
        return isObject(value) || "Expected an object, but received: " + print(value);
      }
    });
  }
  function union$1(Structs) {
    const description = Structs.map((s) => s.type).join(" | ");
    return new Struct({
      type: "union",
      schema: null,
      coercer(value, ctx) {
        const firstMatch = Structs.find((s) => {
          const [e] = s.validate(value, {
            coerce: true
          });
          return !e;
        }) || unknown();
        return firstMatch.coercer(value, ctx);
      },
      validator(value, ctx) {
        const failures = [];
        for (const S of Structs) {
          const [...tuples] = run(value, S, ctx);
          const [first] = tuples;
          if (!first[0]) {
            return [];
          } else {
            for (const [failure] of tuples) {
              if (failure) {
                failures.push(failure);
              }
            }
          }
        }
        return ["Expected the value to satisfy a union of `" + description + "`, but received: " + print(value), ...failures];
      }
    });
  }
  function unknown() {
    return define2("unknown", () => true);
  }
  function coerce(struct3, condition, coercer) {
    return new Struct({
      ...struct3,
      coercer: (value, ctx) => {
        return is(value, condition) ? struct3.coercer(coercer(value, ctx), ctx) : struct3.coercer(value, ctx);
      }
    });
  }
  async function invoke(programId, accounts, data, provider) {
    programId = translateAddress(programId);
    if (!provider) {
      provider = getProvider();
    }
    const tx = new import_web3.Transaction();
    tx.add(new import_web3.TransactionInstruction({
      programId,
      keys: accounts !== null && accounts !== void 0 ? accounts : [],
      data
    }));
    if (provider.sendAndConfirm === void 0) {
      throw new Error("This function requires 'Provider.sendAndConfirm' to be implemented.");
    }
    return await provider.sendAndConfirm(tx, []);
  }
  var GET_MULTIPLE_ACCOUNTS_LIMIT = 99;
  async function getMultipleAccounts(connection, publicKeys, commitment) {
    const results = await getMultipleAccountsAndContext(connection, publicKeys, commitment);
    return results.map((result) => {
      return result ? { publicKey: result.publicKey, account: result.account } : null;
    });
  }
  async function getMultipleAccountsAndContext(connection, publicKeys, commitment) {
    if (publicKeys.length <= GET_MULTIPLE_ACCOUNTS_LIMIT) {
      return await getMultipleAccountsAndContextCore(connection, publicKeys, commitment);
    } else {
      const batches = chunks(publicKeys, GET_MULTIPLE_ACCOUNTS_LIMIT);
      const results = await Promise.all(batches.map((batch) => getMultipleAccountsAndContextCore(connection, batch, commitment)));
      return results.flat();
    }
  }
  async function getMultipleAccountsAndContextCore(connection, publicKeys, commitmentOverride) {
    const commitment = commitmentOverride !== null && commitmentOverride !== void 0 ? commitmentOverride : connection.commitment;
    const { value: accountInfos, context } = await connection.getMultipleAccountsInfoAndContext(publicKeys, commitment);
    const accounts = accountInfos.map((account, idx) => {
      if (account === null) {
        return null;
      }
      return {
        publicKey: publicKeys[idx],
        account,
        context
      };
    });
    return accounts;
  }
  async function simulateTransaction(connection, transaction, signers, commitment, includeAccounts) {
    var _a;
    if (signers && signers.length > 0) {
      transaction.sign(...signers);
    }
    const message = transaction._compile();
    const signData = message.serialize();
    const wireTransaction = transaction._serialize(signData);
    const encodedTransaction = wireTransaction.toString("base64");
    const config = {
      encoding: "base64",
      commitment: commitment !== null && commitment !== void 0 ? commitment : connection.commitment
    };
    if (includeAccounts) {
      const addresses = (Array.isArray(includeAccounts) ? includeAccounts : message.nonProgramIds()).map((key) => key.toBase58());
      config["accounts"] = {
        encoding: "base64",
        addresses
      };
    }
    if (signers) {
      config.sigVerify = true;
    }
    const args = [encodedTransaction, config];
    const unsafeRes = await connection._rpcRequest("simulateTransaction", args);
    const res = create(unsafeRes, SimulatedTransactionResponseStruct);
    if ("error" in res) {
      let logs;
      if ("data" in res.error) {
        logs = (_a = res.error.data) === null || _a === void 0 ? void 0 : _a.logs;
        if (logs && Array.isArray(logs)) {
          const traceIndent = "\n    ";
          const logTrace = traceIndent + logs.join(traceIndent);
          console.error(res.error.message, logTrace);
        }
      }
      throw new import_web3.SendTransactionError("failed to simulate transaction: " + res.error.message, logs);
    }
    return res.result;
  }
  function jsonRpcResult(schema) {
    return coerce(createRpcResult(schema), UnknownRpcResult, (value) => {
      if ("error" in value) {
        return value;
      } else {
        return {
          ...value,
          result: create(value.result, schema)
        };
      }
    });
  }
  var UnknownRpcResult = createRpcResult(unknown());
  function createRpcResult(result) {
    return union$1([
      type({
        jsonrpc: literal("2.0"),
        id: string(),
        result
      }),
      type({
        jsonrpc: literal("2.0"),
        id: string(),
        error: type({
          code: unknown(),
          message: string(),
          data: optional(any())
        })
      })
    ]);
  }
  function jsonRpcResultAndContext(value) {
    return jsonRpcResult(type({
      context: type({
        slot: number()
      }),
      value
    }));
  }
  var SimulatedTransactionResponseStruct = jsonRpcResultAndContext(type({
    err: nullable(union$1([type({}), string()])),
    logs: nullable(array2(string())),
    accounts: optional(nullable(array2(nullable(type({
      executable: boolean(),
      owner: string(),
      lamports: number(),
      data: array2(string()),
      rentEpoch: optional(number())
    }))))),
    unitsConsumed: optional(number())
  }));
  var rpc = /* @__PURE__ */ Object.freeze({
    __proto__: null,
    invoke,
    getMultipleAccounts,
    getMultipleAccountsAndContext,
    simulateTransaction
  });
  var AnchorProvider = class {
    /**
     * @param connection The cluster connection where the program is deployed.
     * @param wallet     The wallet used to pay for and sign all transactions.
     * @param opts       Transaction confirmation options to use by default.
     */
    constructor(connection, wallet, opts) {
      this.connection = connection;
      this.wallet = wallet;
      this.opts = opts;
      this.publicKey = wallet === null || wallet === void 0 ? void 0 : wallet.publicKey;
    }
    static defaultOptions() {
      return {
        preflightCommitment: "processed",
        commitment: "processed"
      };
    }
    /**
     * Returns a `Provider` with a wallet read from the local filesystem.
     *
     * @param url  The network cluster url.
     * @param opts The default transaction confirmation options.
     *
     * (This api is for Node only.)
     */
    static local(url, opts) {
      {
        throw new Error(`Provider local is not available on browser.`);
      }
    }
    /**
     * Returns a `Provider` read from the `ANCHOR_PROVIDER_URL` environment
     * variable
     *
     * (This api is for Node only.)
     */
    static env() {
      {
        throw new Error(`Provider env is not available on browser.`);
      }
    }
    /**
     * Sends the given transaction, paid for and signed by the provider's wallet.
     *
     * @param tx      The transaction to send.
     * @param signers The signers of the transaction.
     * @param opts    Transaction confirmation options.
     */
    async sendAndConfirm(tx, signers, opts) {
      var _a, _b, _c, _d;
      if (opts === void 0) {
        opts = this.opts;
      }
      if (isVersionedTransaction(tx)) {
        if (signers) {
          tx.sign(signers);
        }
      } else {
        tx.feePayer = (_a = tx.feePayer) !== null && _a !== void 0 ? _a : this.wallet.publicKey;
        tx.recentBlockhash = (await this.connection.getLatestBlockhash(opts.preflightCommitment)).blockhash;
        if (signers) {
          for (const signer of signers) {
            tx.partialSign(signer);
          }
        }
      }
      tx = await this.wallet.signTransaction(tx);
      const rawTx = tx.serialize();
      try {
        return await sendAndConfirmRawTransaction(this.connection, rawTx, opts);
      } catch (err2) {
        if (err2 instanceof ConfirmError) {
          const txSig = encode$1(isVersionedTransaction(tx) ? ((_b = tx.signatures) === null || _b === void 0 ? void 0 : _b[0]) || new Uint8Array() : (_c = tx.signature) !== null && _c !== void 0 ? _c : new Uint8Array());
          const failedTx = await this.connection.getTransaction(txSig, {
            commitment: "confirmed"
          });
          if (!failedTx) {
            throw err2;
          } else {
            const logs = (_d = failedTx.meta) === null || _d === void 0 ? void 0 : _d.logMessages;
            throw !logs ? err2 : new import_web3.SendTransactionError(err2.message, logs);
          }
        } else {
          throw err2;
        }
      }
    }
    /**
     * Similar to `send`, but for an array of transactions and signers.
     * All transactions need to be of the same type, it doesn't support a mix of `VersionedTransaction`s and `Transaction`s.
     *
     * @param txWithSigners Array of transactions and signers.
     * @param opts          Transaction confirmation options.
     */
    async sendAll(txWithSigners, opts) {
      var _a, _b, _c;
      if (opts === void 0) {
        opts = this.opts;
      }
      const recentBlockhash = (await this.connection.getLatestBlockhash(opts.preflightCommitment)).blockhash;
      let txs = txWithSigners.map((r) => {
        var _a2, _b2;
        if (isVersionedTransaction(r.tx)) {
          let tx = r.tx;
          if (r.signers) {
            tx.sign(r.signers);
          }
          return tx;
        } else {
          let tx = r.tx;
          let signers = (_a2 = r.signers) !== null && _a2 !== void 0 ? _a2 : [];
          tx.feePayer = (_b2 = tx.feePayer) !== null && _b2 !== void 0 ? _b2 : this.wallet.publicKey;
          tx.recentBlockhash = recentBlockhash;
          signers.forEach((kp) => {
            tx.partialSign(kp);
          });
          return tx;
        }
      });
      const signedTxs = await this.wallet.signAllTransactions(txs);
      const sigs = [];
      for (let k = 0; k < txs.length; k += 1) {
        const tx = signedTxs[k];
        const rawTx = tx.serialize();
        try {
          sigs.push(await sendAndConfirmRawTransaction(this.connection, rawTx, opts));
        } catch (err2) {
          if (err2 instanceof ConfirmError) {
            const txSig = encode$1(isVersionedTransaction(tx) ? ((_a = tx.signatures) === null || _a === void 0 ? void 0 : _a[0]) || new Uint8Array() : (_b = tx.signature) !== null && _b !== void 0 ? _b : new Uint8Array());
            const failedTx = await this.connection.getTransaction(txSig, {
              commitment: "confirmed"
            });
            if (!failedTx) {
              throw err2;
            } else {
              const logs = (_c = failedTx.meta) === null || _c === void 0 ? void 0 : _c.logMessages;
              throw !logs ? err2 : new import_web3.SendTransactionError(err2.message, logs);
            }
          } else {
            throw err2;
          }
        }
      }
      return sigs;
    }
    /**
     * Simulates the given transaction, returning emitted logs from execution.
     *
     * @param tx      The transaction to send.
     * @param signers The signers of the transaction. If unset, the transaction
     *                will be simulated with the "sigVerify: false" option. This
     *                allows for simulation of transactions without asking the
     *                wallet for a signature.
     * @param opts    Transaction confirmation options.
     */
    async simulate(tx, signers, commitment, includeAccounts) {
      let recentBlockhash = (await this.connection.getLatestBlockhash(commitment !== null && commitment !== void 0 ? commitment : this.connection.commitment)).blockhash;
      let result;
      if (isVersionedTransaction(tx)) {
        if (signers) {
          tx.sign(signers);
          tx = await this.wallet.signTransaction(tx);
        }
        result = await this.connection.simulateTransaction(tx, { commitment });
      } else {
        tx.feePayer = tx.feePayer || this.wallet.publicKey;
        tx.recentBlockhash = recentBlockhash;
        if (signers) {
          tx = await this.wallet.signTransaction(tx);
        }
        result = await simulateTransaction(this.connection, tx, signers, commitment, includeAccounts);
      }
      if (result.value.err) {
        throw new SimulateError(result.value);
      }
      return result.value;
    }
  };
  var SimulateError = class extends Error {
    constructor(simulationResponse, message) {
      super(message);
      this.simulationResponse = simulationResponse;
    }
  };
  async function sendAndConfirmRawTransaction(connection, rawTransaction, options) {
    const sendOptions = options && {
      skipPreflight: options.skipPreflight,
      preflightCommitment: options.preflightCommitment || options.commitment
    };
    const signature = await connection.sendRawTransaction(rawTransaction, sendOptions);
    const status = (await connection.confirmTransaction(signature, options && options.commitment)).value;
    if (status.err) {
      throw new ConfirmError(`Raw transaction ${signature} failed (${JSON.stringify(status)})`);
    }
    return signature;
  }
  var ConfirmError = class extends Error {
    constructor(message) {
      super(message);
    }
  };
  function setProvider(provider) {
    _provider = provider;
  }
  function getProvider() {
    if (_provider === null) {
      return AnchorProvider.local();
    }
    return _provider;
  }
  var _provider = null;
  var _AVAILABLE_FEATURES = /* @__PURE__ */ new Set(["anchor-deprecated-state", "debug-logs"]);
  var _FEATURES = /* @__PURE__ */ new Map();
  function set(key) {
    if (!_AVAILABLE_FEATURES.has(key)) {
      throw new Error("Invalid feature");
    }
    _FEATURES.set(key, true);
  }
  function isSet(key) {
    return _FEATURES.get(key) !== void 0;
  }
  var features = /* @__PURE__ */ Object.freeze({
    __proto__: null,
    set,
    isSet
  });
  var IdlError = class extends Error {
    constructor(message) {
      super(message);
      this.name = "IdlError";
    }
  };
  var ProgramErrorStack = class _ProgramErrorStack {
    constructor(stack) {
      this.stack = stack;
    }
    static parse(logs) {
      var _a;
      const programKeyRegex = /^Program (\w*) invoke/;
      const successRegex = /^Program \w* success/;
      const programStack = [];
      for (let i = 0; i < logs.length; i++) {
        if (successRegex.exec(logs[i])) {
          programStack.pop();
          continue;
        }
        const programKey = (_a = programKeyRegex.exec(logs[i])) === null || _a === void 0 ? void 0 : _a[1];
        if (!programKey) {
          continue;
        }
        programStack.push(new import_web3.PublicKey(programKey));
      }
      return new _ProgramErrorStack(programStack);
    }
  };
  var AnchorError = class _AnchorError extends Error {
    constructor(errorCode, errorMessage, errorLogs, logs, origin, comparedValues) {
      super(errorLogs.join("\n").replace("Program log: ", ""));
      this.errorLogs = errorLogs;
      this.logs = logs;
      this.error = { errorCode, errorMessage, comparedValues, origin };
      this._programErrorStack = ProgramErrorStack.parse(logs);
    }
    static parse(logs) {
      if (!logs) {
        return null;
      }
      const anchorErrorLogIndex = logs.findIndex((log) => log.startsWith("Program log: AnchorError"));
      if (anchorErrorLogIndex === -1) {
        return null;
      }
      const anchorErrorLog = logs[anchorErrorLogIndex];
      const errorLogs = [anchorErrorLog];
      let comparedValues;
      if (anchorErrorLogIndex + 1 < logs.length) {
        if (logs[anchorErrorLogIndex + 1] === "Program log: Left:") {
          const pubkeyRegex = /^Program log: (.*)$/;
          const leftPubkey = pubkeyRegex.exec(logs[anchorErrorLogIndex + 2])[1];
          const rightPubkey = pubkeyRegex.exec(logs[anchorErrorLogIndex + 4])[1];
          comparedValues = [
            new import_web3.PublicKey(leftPubkey),
            new import_web3.PublicKey(rightPubkey)
          ];
          errorLogs.push(...logs.slice(anchorErrorLogIndex + 1, anchorErrorLogIndex + 5));
        } else if (logs[anchorErrorLogIndex + 1].startsWith("Program log: Left:")) {
          const valueRegex = /^Program log: (Left|Right): (.*)$/;
          const leftValue = valueRegex.exec(logs[anchorErrorLogIndex + 1])[2];
          const rightValue = valueRegex.exec(logs[anchorErrorLogIndex + 2])[2];
          errorLogs.push(...logs.slice(anchorErrorLogIndex + 1, anchorErrorLogIndex + 3));
          comparedValues = [leftValue, rightValue];
        }
      }
      const regexNoInfo = /^Program log: AnchorError occurred\. Error Code: (.*)\. Error Number: (\d*)\. Error Message: (.*)\./;
      const noInfoAnchorErrorLog = regexNoInfo.exec(anchorErrorLog);
      const regexFileLine = /^Program log: AnchorError thrown in (.*):(\d*)\. Error Code: (.*)\. Error Number: (\d*)\. Error Message: (.*)\./;
      const fileLineAnchorErrorLog = regexFileLine.exec(anchorErrorLog);
      const regexAccountName = /^Program log: AnchorError caused by account: (.*)\. Error Code: (.*)\. Error Number: (\d*)\. Error Message: (.*)\./;
      const accountNameAnchorErrorLog = regexAccountName.exec(anchorErrorLog);
      if (noInfoAnchorErrorLog) {
        const [errorCodeString, errorNumber, errorMessage] = noInfoAnchorErrorLog.slice(1, 4);
        const errorCode = {
          code: errorCodeString,
          number: parseInt(errorNumber)
        };
        return new _AnchorError(errorCode, errorMessage, errorLogs, logs, void 0, comparedValues);
      } else if (fileLineAnchorErrorLog) {
        const [file, line, errorCodeString, errorNumber, errorMessage] = fileLineAnchorErrorLog.slice(1, 6);
        const errorCode = {
          code: errorCodeString,
          number: parseInt(errorNumber)
        };
        const fileLine = { file, line: parseInt(line) };
        return new _AnchorError(errorCode, errorMessage, errorLogs, logs, fileLine, comparedValues);
      } else if (accountNameAnchorErrorLog) {
        const [accountName, errorCodeString, errorNumber, errorMessage] = accountNameAnchorErrorLog.slice(1, 5);
        const origin = accountName;
        const errorCode = {
          code: errorCodeString,
          number: parseInt(errorNumber)
        };
        return new _AnchorError(errorCode, errorMessage, errorLogs, logs, origin, comparedValues);
      } else {
        return null;
      }
    }
    get program() {
      return this._programErrorStack.stack[this._programErrorStack.stack.length - 1];
    }
    get programErrorStack() {
      return this._programErrorStack.stack;
    }
    toString() {
      return this.message;
    }
  };
  var ProgramError = class _ProgramError extends Error {
    constructor(code, msg, logs) {
      super();
      this.code = code;
      this.msg = msg;
      this.logs = logs;
      if (logs) {
        this._programErrorStack = ProgramErrorStack.parse(logs);
      }
    }
    static parse(err2, idlErrors) {
      const errString = err2.toString();
      let unparsedErrorCode;
      if (errString.includes("custom program error:")) {
        let components = errString.split("custom program error: ");
        if (components.length !== 2) {
          return null;
        } else {
          unparsedErrorCode = components[1];
        }
      } else {
        const matches = errString.match(/"Custom":([0-9]+)}/g);
        if (!matches || matches.length > 1) {
          return null;
        }
        unparsedErrorCode = matches[0].match(/([0-9]+)/g)[0];
      }
      let errorCode;
      try {
        errorCode = parseInt(unparsedErrorCode);
      } catch (parseErr) {
        return null;
      }
      let errorMsg = idlErrors.get(errorCode);
      if (errorMsg !== void 0) {
        return new _ProgramError(errorCode, errorMsg, err2.logs);
      }
      errorMsg = LangErrorMessage.get(errorCode);
      if (errorMsg !== void 0) {
        return new _ProgramError(errorCode, errorMsg, err2.logs);
      }
      return null;
    }
    get program() {
      var _a;
      return (_a = this._programErrorStack) === null || _a === void 0 ? void 0 : _a.stack[this._programErrorStack.stack.length - 1];
    }
    get programErrorStack() {
      var _a;
      return (_a = this._programErrorStack) === null || _a === void 0 ? void 0 : _a.stack;
    }
    toString() {
      return this.msg;
    }
  };
  function translateError(err2, idlErrors) {
    if (isSet("debug-logs")) {
      console.log("Translating error:", err2);
    }
    const anchorError = AnchorError.parse(err2.logs);
    if (anchorError) {
      return anchorError;
    }
    const programError = ProgramError.parse(err2, idlErrors);
    if (programError) {
      return programError;
    }
    if (err2.logs) {
      const handler = {
        get: function(target, prop) {
          if (prop === "programErrorStack") {
            return target.programErrorStack.stack;
          } else if (prop === "program") {
            return target.programErrorStack.stack[err2.programErrorStack.stack.length - 1];
          } else {
            return Reflect.get(...arguments);
          }
        }
      };
      err2.programErrorStack = ProgramErrorStack.parse(err2.logs);
      return new Proxy(err2, handler);
    }
    return err2;
  }
  var LangErrorCode = {
    // Instructions.
    InstructionMissing: 100,
    InstructionFallbackNotFound: 101,
    InstructionDidNotDeserialize: 102,
    InstructionDidNotSerialize: 103,
    // IDL instructions.
    IdlInstructionStub: 1e3,
    IdlInstructionInvalidProgram: 1001,
    // Constraints.
    ConstraintMut: 2e3,
    ConstraintHasOne: 2001,
    ConstraintSigner: 2002,
    ConstraintRaw: 2003,
    ConstraintOwner: 2004,
    ConstraintRentExempt: 2005,
    ConstraintSeeds: 2006,
    ConstraintExecutable: 2007,
    ConstraintState: 2008,
    ConstraintAssociated: 2009,
    ConstraintAssociatedInit: 2010,
    ConstraintClose: 2011,
    ConstraintAddress: 2012,
    ConstraintZero: 2013,
    ConstraintTokenMint: 2014,
    ConstraintTokenOwner: 2015,
    ConstraintMintMintAuthority: 2016,
    ConstraintMintFreezeAuthority: 2017,
    ConstraintMintDecimals: 2018,
    ConstraintSpace: 2019,
    ConstraintAccountIsNone: 2020,
    // Require.
    RequireViolated: 2500,
    RequireEqViolated: 2501,
    RequireKeysEqViolated: 2502,
    RequireNeqViolated: 2503,
    RequireKeysNeqViolated: 2504,
    RequireGtViolated: 2505,
    RequireGteViolated: 2506,
    // Accounts.
    AccountDiscriminatorAlreadySet: 3e3,
    AccountDiscriminatorNotFound: 3001,
    AccountDiscriminatorMismatch: 3002,
    AccountDidNotDeserialize: 3003,
    AccountDidNotSerialize: 3004,
    AccountNotEnoughKeys: 3005,
    AccountNotMutable: 3006,
    AccountOwnedByWrongProgram: 3007,
    InvalidProgramId: 3008,
    InvalidProgramExecutable: 3009,
    AccountNotSigner: 3010,
    AccountNotSystemOwned: 3011,
    AccountNotInitialized: 3012,
    AccountNotProgramData: 3013,
    AccountNotAssociatedTokenAccount: 3014,
    AccountSysvarMismatch: 3015,
    AccountReallocExceedsLimit: 3016,
    AccountDuplicateReallocs: 3017,
    // Miscellaneous
    DeclaredProgramIdMismatch: 4100,
    // Used for APIs that shouldn't be used anymore.
    Deprecated: 5e3
  };
  var LangErrorMessage = /* @__PURE__ */ new Map([
    // Instructions.
    [
      LangErrorCode.InstructionMissing,
      "8 byte instruction identifier not provided"
    ],
    [
      LangErrorCode.InstructionFallbackNotFound,
      "Fallback functions are not supported"
    ],
    [
      LangErrorCode.InstructionDidNotDeserialize,
      "The program could not deserialize the given instruction"
    ],
    [
      LangErrorCode.InstructionDidNotSerialize,
      "The program could not serialize the given instruction"
    ],
    // Idl instructions.
    [
      LangErrorCode.IdlInstructionStub,
      "The program was compiled without idl instructions"
    ],
    [
      LangErrorCode.IdlInstructionInvalidProgram,
      "The transaction was given an invalid program for the IDL instruction"
    ],
    // Constraints.
    [LangErrorCode.ConstraintMut, "A mut constraint was violated"],
    [LangErrorCode.ConstraintHasOne, "A has one constraint was violated"],
    [LangErrorCode.ConstraintSigner, "A signer constraint was violated"],
    [LangErrorCode.ConstraintRaw, "A raw constraint was violated"],
    [LangErrorCode.ConstraintOwner, "An owner constraint was violated"],
    [
      LangErrorCode.ConstraintRentExempt,
      "A rent exemption constraint was violated"
    ],
    [LangErrorCode.ConstraintSeeds, "A seeds constraint was violated"],
    [LangErrorCode.ConstraintExecutable, "An executable constraint was violated"],
    [
      LangErrorCode.ConstraintState,
      "Deprecated Error, feel free to replace with something else"
    ],
    [LangErrorCode.ConstraintAssociated, "An associated constraint was violated"],
    [
      LangErrorCode.ConstraintAssociatedInit,
      "An associated init constraint was violated"
    ],
    [LangErrorCode.ConstraintClose, "A close constraint was violated"],
    [LangErrorCode.ConstraintAddress, "An address constraint was violated"],
    [LangErrorCode.ConstraintZero, "Expected zero account discriminant"],
    [LangErrorCode.ConstraintTokenMint, "A token mint constraint was violated"],
    [LangErrorCode.ConstraintTokenOwner, "A token owner constraint was violated"],
    [
      LangErrorCode.ConstraintMintMintAuthority,
      "A mint mint authority constraint was violated"
    ],
    [
      LangErrorCode.ConstraintMintFreezeAuthority,
      "A mint freeze authority constraint was violated"
    ],
    [
      LangErrorCode.ConstraintMintDecimals,
      "A mint decimals constraint was violated"
    ],
    [LangErrorCode.ConstraintSpace, "A space constraint was violated"],
    [
      LangErrorCode.ConstraintAccountIsNone,
      "A required account for the constraint is None"
    ],
    // Require.
    [LangErrorCode.RequireViolated, "A require expression was violated"],
    [LangErrorCode.RequireEqViolated, "A require_eq expression was violated"],
    [
      LangErrorCode.RequireKeysEqViolated,
      "A require_keys_eq expression was violated"
    ],
    [LangErrorCode.RequireNeqViolated, "A require_neq expression was violated"],
    [
      LangErrorCode.RequireKeysNeqViolated,
      "A require_keys_neq expression was violated"
    ],
    [LangErrorCode.RequireGtViolated, "A require_gt expression was violated"],
    [LangErrorCode.RequireGteViolated, "A require_gte expression was violated"],
    // Accounts.
    [
      LangErrorCode.AccountDiscriminatorAlreadySet,
      "The account discriminator was already set on this account"
    ],
    [
      LangErrorCode.AccountDiscriminatorNotFound,
      "No 8 byte discriminator was found on the account"
    ],
    [
      LangErrorCode.AccountDiscriminatorMismatch,
      "8 byte discriminator did not match what was expected"
    ],
    [LangErrorCode.AccountDidNotDeserialize, "Failed to deserialize the account"],
    [LangErrorCode.AccountDidNotSerialize, "Failed to serialize the account"],
    [
      LangErrorCode.AccountNotEnoughKeys,
      "Not enough account keys given to the instruction"
    ],
    [LangErrorCode.AccountNotMutable, "The given account is not mutable"],
    [
      LangErrorCode.AccountOwnedByWrongProgram,
      "The given account is owned by a different program than expected"
    ],
    [LangErrorCode.InvalidProgramId, "Program ID was not as expected"],
    [LangErrorCode.InvalidProgramExecutable, "Program account is not executable"],
    [LangErrorCode.AccountNotSigner, "The given account did not sign"],
    [
      LangErrorCode.AccountNotSystemOwned,
      "The given account is not owned by the system program"
    ],
    [
      LangErrorCode.AccountNotInitialized,
      "The program expected this account to be already initialized"
    ],
    [
      LangErrorCode.AccountNotProgramData,
      "The given account is not a program data account"
    ],
    [
      LangErrorCode.AccountNotAssociatedTokenAccount,
      "The given account is not the associated token account"
    ],
    [
      LangErrorCode.AccountSysvarMismatch,
      "The given public key does not match the required sysvar"
    ],
    [
      LangErrorCode.AccountReallocExceedsLimit,
      "The account reallocation exceeds the MAX_PERMITTED_DATA_INCREASE limit"
    ],
    [
      LangErrorCode.AccountDuplicateReallocs,
      "The account was duplicated for more than one reallocation"
    ],
    // Miscellaneous
    [
      LangErrorCode.DeclaredProgramIdMismatch,
      "The declared program id does not match the actual program id"
    ],
    // Deprecated
    [
      LangErrorCode.Deprecated,
      "The API being used is deprecated and should no longer be used"
    ]
  ]);
  var __assign$1 = function() {
    __assign$1 = Object.assign || function __assign2(t) {
      for (var s, i = 1, n = arguments.length; i < n; i++) {
        s = arguments[i];
        for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];
      }
      return t;
    };
    return __assign$1.apply(this, arguments);
  };
  var __assign = function() {
    __assign = Object.assign || function __assign2(t) {
      for (var s, i = 1, n = arguments.length; i < n; i++) {
        s = arguments[i];
        for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];
      }
      return t;
    };
    return __assign.apply(this, arguments);
  };
  function lowerCase(str2) {
    return str2.toLowerCase();
  }
  var DEFAULT_SPLIT_REGEXP = [/([a-z0-9])([A-Z])/g, /([A-Z])([A-Z][a-z])/g];
  var DEFAULT_STRIP_REGEXP = /[^A-Z0-9]+/gi;
  function noCase(input, options) {
    if (options === void 0) {
      options = {};
    }
    var _a = options.splitRegexp, splitRegexp = _a === void 0 ? DEFAULT_SPLIT_REGEXP : _a, _b = options.stripRegexp, stripRegexp = _b === void 0 ? DEFAULT_STRIP_REGEXP : _b, _c = options.transform, transform = _c === void 0 ? lowerCase : _c, _d = options.delimiter, delimiter = _d === void 0 ? " " : _d;
    var result = replace(replace(input, splitRegexp, "$1\0$2"), stripRegexp, "\0");
    var start = 0;
    var end = result.length;
    while (result.charAt(start) === "\0")
      start++;
    while (result.charAt(end - 1) === "\0")
      end--;
    return result.slice(start, end).split("\0").map(transform).join(delimiter);
  }
  function replace(input, re, value) {
    if (re instanceof RegExp)
      return input.replace(re, value);
    return re.reduce(function(input2, re2) {
      return input2.replace(re2, value);
    }, input);
  }
  function dotCase(input, options) {
    if (options === void 0) {
      options = {};
    }
    return noCase(input, __assign({ delimiter: "." }, options));
  }
  function snakeCase(input, options) {
    if (options === void 0) {
      options = {};
    }
    return dotCase(input, __assign$1({ delimiter: "_" }, options));
  }
  var IdlCoder = class _IdlCoder {
    static fieldLayout(field, types) {
      const fieldName = field.name !== void 0 ? (0, import_camelcase.default)(field.name) : void 0;
      switch (field.type) {
        case "bool": {
          return borsh.bool(fieldName);
        }
        case "u8": {
          return borsh.u8(fieldName);
        }
        case "i8": {
          return borsh.i8(fieldName);
        }
        case "u16": {
          return borsh.u16(fieldName);
        }
        case "i16": {
          return borsh.i16(fieldName);
        }
        case "u32": {
          return borsh.u32(fieldName);
        }
        case "i32": {
          return borsh.i32(fieldName);
        }
        case "f32": {
          return borsh.f32(fieldName);
        }
        case "u64": {
          return borsh.u64(fieldName);
        }
        case "i64": {
          return borsh.i64(fieldName);
        }
        case "f64": {
          return borsh.f64(fieldName);
        }
        case "u128": {
          return borsh.u128(fieldName);
        }
        case "i128": {
          return borsh.i128(fieldName);
        }
        case "u256": {
          return borsh.u256(fieldName);
        }
        case "i256": {
          return borsh.i256(fieldName);
        }
        case "bytes": {
          return borsh.vecU8(fieldName);
        }
        case "string": {
          return borsh.str(fieldName);
        }
        case "publicKey": {
          return borsh.publicKey(fieldName);
        }
        default: {
          if ("vec" in field.type) {
            return borsh.vec(_IdlCoder.fieldLayout({
              name: void 0,
              type: field.type.vec
            }, types), fieldName);
          } else if ("option" in field.type) {
            return borsh.option(_IdlCoder.fieldLayout({
              name: void 0,
              type: field.type.option
            }, types), fieldName);
          } else if ("defined" in field.type) {
            if (!types) {
              throw new IdlError("User defined types not provided");
            }
            const defined = field.type.defined;
            const filtered = types.filter((t) => t.name === defined);
            if (filtered.length !== 1) {
              throw new IdlError(`Type not found: ${JSON.stringify(field)}`);
            }
            return _IdlCoder.typeDefLayout(filtered[0], types, fieldName);
          } else if ("array" in field.type) {
            let arrayTy = field.type.array[0];
            let arrayLen = field.type.array[1];
            let innerLayout = _IdlCoder.fieldLayout({
              name: void 0,
              type: arrayTy
            }, types);
            return borsh.array(innerLayout, arrayLen, fieldName);
          } else {
            throw new Error(`Not yet implemented: ${field}`);
          }
        }
      }
    }
    static typeDefLayout(typeDef, types = [], name) {
      switch (typeDef.type.kind) {
        case "struct": {
          const fieldLayouts = typeDef.type.fields.map((field) => {
            return _IdlCoder.fieldLayout(field, types);
          });
          return borsh.struct(fieldLayouts, name);
        }
        case "enum": {
          let variants = typeDef.type.variants.map((variant) => {
            const name2 = (0, import_camelcase.default)(variant.name);
            if (!variant.fields) {
              return borsh.struct([], name2);
            }
            const fieldLayouts = variant.fields.map((f2, i) => {
              if (f2 === null || f2 === void 0 ? void 0 : f2.name) {
                return _IdlCoder.fieldLayout(f2, types);
              }
              return _IdlCoder.fieldLayout({ type: f2, name: i.toString() }, types);
            });
            return borsh.struct(fieldLayouts, name2);
          });
          if (name !== void 0) {
            return borsh.rustEnum(variants).replicate(name);
          }
          return borsh.rustEnum(variants, name);
        }
        case "alias": {
          return _IdlCoder.fieldLayout({ type: typeDef.type.value, name: typeDef.name }, types);
        }
      }
    }
  };
  var SIGHASH_GLOBAL_NAMESPACE = "global";
  var BorshInstructionCoder = class _BorshInstructionCoder {
    constructor(idl) {
      this.idl = idl;
      this.ixLayout = _BorshInstructionCoder.parseIxLayout(idl);
      const sighashLayouts = /* @__PURE__ */ new Map();
      idl.instructions.forEach((ix) => {
        const sh = sighash(SIGHASH_GLOBAL_NAMESPACE, ix.name);
        sighashLayouts.set(import_bs58.default.encode(sh), {
          layout: this.ixLayout.get(ix.name),
          name: ix.name
        });
      });
      this.sighashLayouts = sighashLayouts;
    }
    /**
     * Encodes a program instruction.
     */
    encode(ixName, ix) {
      return this._encode(SIGHASH_GLOBAL_NAMESPACE, ixName, ix);
    }
    _encode(nameSpace, ixName, ix) {
      const buffer = import_buffer.Buffer.alloc(1e3);
      const methodName = (0, import_camelcase.default)(ixName);
      const layout = this.ixLayout.get(methodName);
      if (!layout) {
        throw new Error(`Unknown method: ${methodName}`);
      }
      const len = layout.encode(ix, buffer);
      const data = buffer.slice(0, len);
      return import_buffer.Buffer.concat([sighash(nameSpace, ixName), data]);
    }
    static parseIxLayout(idl) {
      const ixLayouts = idl.instructions.map((ix) => {
        let fieldLayouts = ix.args.map((arg) => {
          var _a, _b;
          return IdlCoder.fieldLayout(arg, Array.from([...(_a = idl.accounts) !== null && _a !== void 0 ? _a : [], ...(_b = idl.types) !== null && _b !== void 0 ? _b : []]));
        });
        const name = (0, import_camelcase.default)(ix.name);
        return [name, borsh.struct(fieldLayouts, name)];
      });
      return new Map(ixLayouts);
    }
    /**
     * Decodes a program instruction.
     */
    decode(ix, encoding = "hex") {
      if (typeof ix === "string") {
        ix = encoding === "hex" ? import_buffer.Buffer.from(ix, "hex") : import_bs58.default.decode(ix);
      }
      let sighash2 = import_bs58.default.encode(ix.slice(0, 8));
      let data = ix.slice(8);
      const decoder = this.sighashLayouts.get(sighash2);
      if (!decoder) {
        return null;
      }
      return {
        data: decoder.layout.decode(data),
        name: decoder.name
      };
    }
    /**
     * Returns a formatted table of all the fields in the given instruction data.
     */
    format(ix, accountMetas) {
      return InstructionFormatter.format(ix, accountMetas, this.idl);
    }
  };
  var InstructionFormatter = class _InstructionFormatter {
    static format(ix, accountMetas, idl) {
      const idlIx = idl.instructions.filter((i) => ix.name === i.name)[0];
      if (idlIx === void 0) {
        console.error("Invalid instruction given");
        return null;
      }
      const args = idlIx.args.map((idlField) => {
        return {
          name: idlField.name,
          type: _InstructionFormatter.formatIdlType(idlField.type),
          data: _InstructionFormatter.formatIdlData(idlField, ix.data[idlField.name], idl.types)
        };
      });
      const flatIdlAccounts = _InstructionFormatter.flattenIdlAccounts(idlIx.accounts);
      const accounts = accountMetas.map((meta, idx) => {
        if (idx < flatIdlAccounts.length) {
          return {
            name: flatIdlAccounts[idx].name,
            ...meta
          };
        } else {
          return {
            name: void 0,
            ...meta
          };
        }
      });
      return {
        args,
        accounts
      };
    }
    static formatIdlType(idlType) {
      if (typeof idlType === "string") {
        return idlType;
      }
      if ("vec" in idlType) {
        return `Vec<${this.formatIdlType(idlType.vec)}>`;
      }
      if ("option" in idlType) {
        return `Option<${this.formatIdlType(idlType.option)}>`;
      }
      if ("defined" in idlType) {
        return idlType.defined;
      }
      if ("array" in idlType) {
        return `Array<${idlType.array[0]}; ${idlType.array[1]}>`;
      }
      throw new Error(`Unknown IDL type: ${idlType}`);
    }
    static formatIdlData(idlField, data, types) {
      if (typeof idlField.type === "string") {
        return data.toString();
      }
      if (idlField.type.hasOwnProperty("vec")) {
        return "[" + data.map((d) => this.formatIdlData({ name: "", type: idlField.type.vec }, d)).join(", ") + "]";
      }
      if (idlField.type.hasOwnProperty("option")) {
        return data === null ? "null" : this.formatIdlData({ name: "", type: idlField.type.option }, data, types);
      }
      if (idlField.type.hasOwnProperty("defined")) {
        if (types === void 0) {
          throw new Error("User defined types not provided");
        }
        const filtered = types.filter((t) => t.name === idlField.type.defined);
        if (filtered.length !== 1) {
          throw new Error(`Type not found: ${idlField.type.defined}`);
        }
        return _InstructionFormatter.formatIdlDataDefined(filtered[0], data, types);
      }
      return "unknown";
    }
    static formatIdlDataDefined(typeDef, data, types) {
      switch (typeDef.type.kind) {
        case "struct": {
          const struct3 = typeDef.type;
          const fields = Object.keys(data).map((k) => {
            const field = struct3.fields.find((f2) => f2.name === k);
            if (!field) {
              throw new Error("Unable to find type");
            }
            return k + ": " + _InstructionFormatter.formatIdlData(field, data[k], types);
          }).join(", ");
          return "{ " + fields + " }";
        }
        case "enum": {
          if (typeDef.type.variants.length === 0) {
            return "{}";
          }
          if (typeDef.type.variants[0].name) {
            const variants = typeDef.type.variants;
            const variant = Object.keys(data)[0];
            const enumType = data[variant];
            const namedFields = Object.keys(enumType).map((f2) => {
              var _a;
              const fieldData = enumType[f2];
              const idlField = (_a = variants[variant]) === null || _a === void 0 ? void 0 : _a.find((v) => v.name === f2);
              if (!idlField) {
                throw new Error("Unable to find variant");
              }
              return f2 + ": " + _InstructionFormatter.formatIdlData(idlField, fieldData, types);
            }).join(", ");
            const variantName = (0, import_camelcase.default)(variant, { pascalCase: true });
            if (namedFields.length === 0) {
              return variantName;
            }
            return `${variantName} { ${namedFields} }`;
          } else {
            return "Tuple formatting not yet implemented";
          }
        }
        case "alias": {
          return _InstructionFormatter.formatIdlType(typeDef.type.value);
        }
      }
    }
    static flattenIdlAccounts(accounts, prefix) {
      return accounts.map((account) => {
        const accName = sentenceCase(account.name);
        if (account.hasOwnProperty("accounts")) {
          const newPrefix = prefix ? `${prefix} > ${accName}` : accName;
          return _InstructionFormatter.flattenIdlAccounts(account.accounts, newPrefix);
        } else {
          return {
            ...account,
            name: prefix ? `${prefix} > ${accName}` : accName
          };
        }
      }).flat();
    }
  };
  function sentenceCase(field) {
    const result = field.replace(/([A-Z])/g, " $1");
    return result.charAt(0).toUpperCase() + result.slice(1);
  }
  function sighash(nameSpace, ixName) {
    let name = snakeCase(ixName);
    let preimage = `${nameSpace}:${name}`;
    return import_buffer.Buffer.from(sha2562(preimage).slice(0, 8));
  }
  function accountSize(idl, idlAccount) {
    switch (idlAccount.type.kind) {
      case "struct": {
        return idlAccount.type.fields.map((f2) => typeSize(idl, f2.type)).reduce((acc, size) => acc + size, 0);
      }
      case "enum": {
        const variantSizes = idlAccount.type.variants.map((variant) => {
          if (!variant.fields) {
            return 0;
          }
          return variant.fields.map((f2) => {
            if (!(typeof f2 === "object" && "name" in f2)) {
              return typeSize(idl, f2);
            }
            return typeSize(idl, f2.type);
          }).reduce((acc, size) => acc + size, 0);
        });
        return Math.max(...variantSizes) + 1;
      }
      case "alias": {
        return typeSize(idl, idlAccount.type.value);
      }
    }
  }
  function typeSize(idl, ty) {
    var _a, _b;
    switch (ty) {
      case "bool":
        return 1;
      case "u8":
        return 1;
      case "i8":
        return 1;
      case "i16":
        return 2;
      case "u16":
        return 2;
      case "u32":
        return 4;
      case "i32":
        return 4;
      case "f32":
        return 4;
      case "u64":
        return 8;
      case "i64":
        return 8;
      case "f64":
        return 8;
      case "u128":
        return 16;
      case "i128":
        return 16;
      case "u256":
        return 32;
      case "i256":
        return 32;
      case "bytes":
        return 1;
      case "string":
        return 1;
      case "publicKey":
        return 32;
      default:
        if ("vec" in ty) {
          return 1;
        }
        if ("option" in ty) {
          return 1 + typeSize(idl, ty.option);
        }
        if ("coption" in ty) {
          return 4 + typeSize(idl, ty.coption);
        }
        if ("defined" in ty) {
          const filtered = (_b = (_a = idl.types) === null || _a === void 0 ? void 0 : _a.filter((t) => t.name === ty.defined)) !== null && _b !== void 0 ? _b : [];
          if (filtered.length !== 1) {
            throw new IdlError(`Type not found: ${JSON.stringify(ty)}`);
          }
          let typeDef = filtered[0];
          return accountSize(idl, typeDef);
        }
        if ("array" in ty) {
          let arrayTy = ty.array[0];
          let arraySize = ty.array[1];
          return typeSize(idl, arrayTy) * arraySize;
        }
        throw new Error(`Invalid type ${JSON.stringify(ty)}`);
    }
  }
  var DISCRIMINATOR_SIZE = 8;
  function discriminator(preimage) {
    return Buffer.from(sha2562(preimage).slice(0, DISCRIMINATOR_SIZE));
  }
  var BorshAccountsCoder = class _BorshAccountsCoder {
    constructor(idl) {
      if (idl.accounts === void 0) {
        this.accountLayouts = /* @__PURE__ */ new Map();
        return;
      }
      const layouts = idl.accounts.map((acc) => {
        return [acc.name, IdlCoder.typeDefLayout(acc, idl.types)];
      });
      this.accountLayouts = new Map(layouts);
      this.idl = idl;
    }
    async encode(accountName, account) {
      const buffer = import_buffer.Buffer.alloc(1e3);
      const layout = this.accountLayouts.get(accountName);
      if (!layout) {
        throw new Error(`Unknown account: ${accountName}`);
      }
      const len = layout.encode(account, buffer);
      let accountData = buffer.slice(0, len);
      let discriminator2 = _BorshAccountsCoder.accountDiscriminator(accountName);
      return import_buffer.Buffer.concat([discriminator2, accountData]);
    }
    decode(accountName, data) {
      const discriminator2 = _BorshAccountsCoder.accountDiscriminator(accountName);
      if (discriminator2.compare(data.slice(0, 8))) {
        throw new Error("Invalid account discriminator");
      }
      return this.decodeUnchecked(accountName, data);
    }
    decodeAny(data) {
      const accountDescriminator = data.slice(0, 8);
      const accountName = Array.from(this.accountLayouts.keys()).find((key) => _BorshAccountsCoder.accountDiscriminator(key).equals(accountDescriminator));
      if (!accountName) {
        throw new Error("Account descriminator not found");
      }
      return this.decodeUnchecked(accountName, data);
    }
    decodeUnchecked(accountName, ix) {
      const data = ix.subarray(DISCRIMINATOR_SIZE);
      const layout = this.accountLayouts.get(accountName);
      if (!layout) {
        throw new Error(`Unknown account: ${accountName}`);
      }
      return layout.decode(data);
    }
    memcmp(accountName, appendData) {
      const discriminator2 = _BorshAccountsCoder.accountDiscriminator(accountName);
      return {
        offset: 0,
        bytes: import_bs58.default.encode(appendData ? import_buffer.Buffer.concat([discriminator2, appendData]) : discriminator2)
      };
    }
    size(idlAccount) {
      var _a;
      return DISCRIMINATOR_SIZE + ((_a = accountSize(this.idl, idlAccount)) !== null && _a !== void 0 ? _a : 0);
    }
    /**
     * Calculates and returns a unique 8 byte discriminator prepended to all anchor accounts.
     *
     * @param name The name of the account to calculate the discriminator.
     */
    static accountDiscriminator(name) {
      const discriminatorPreimage = `account:${(0, import_camelcase.default)(name, {
        pascalCase: true,
        preserveConsecutiveUppercase: true
      })}`;
      return discriminator(discriminatorPreimage);
    }
  };
  var BorshEventCoder = class {
    constructor(idl) {
      if (idl.events === void 0) {
        this.layouts = /* @__PURE__ */ new Map();
        return;
      }
      const layouts = idl.events.map((event) => {
        let eventTypeDef = {
          name: event.name,
          type: {
            kind: "struct",
            fields: event.fields.map((f2) => {
              return { name: f2.name, type: f2.type };
            })
          }
        };
        return [event.name, IdlCoder.typeDefLayout(eventTypeDef, idl.types)];
      });
      this.layouts = new Map(layouts);
      this.discriminators = new Map(idl.events === void 0 ? [] : idl.events.map((e) => [
        encode(eventDiscriminator(e.name)),
        e.name
      ]));
    }
    decode(log) {
      let logArr;
      try {
        logArr = decode(log);
      } catch (e) {
        return null;
      }
      const disc = encode(logArr.slice(0, 8));
      const eventName = this.discriminators.get(disc);
      if (eventName === void 0) {
        return null;
      }
      const layout = this.layouts.get(eventName);
      if (!layout) {
        throw new Error(`Unknown event: ${eventName}`);
      }
      const data = layout.decode(logArr.slice(8));
      return { data, name: eventName };
    }
  };
  function eventDiscriminator(name) {
    return discriminator(`event:${name}`);
  }
  var BorshTypesCoder = class {
    constructor(idl) {
      if (idl.types === void 0) {
        this.typeLayouts = /* @__PURE__ */ new Map();
        return;
      }
      const layouts = idl.types.map((acc) => {
        return [acc.name, IdlCoder.typeDefLayout(acc, idl.types)];
      });
      this.typeLayouts = new Map(layouts);
      this.idl = idl;
    }
    encode(typeName, type2) {
      const buffer = import_buffer.Buffer.alloc(1e3);
      const layout = this.typeLayouts.get(typeName);
      if (!layout) {
        throw new Error(`Unknown type: ${typeName}`);
      }
      const len = layout.encode(type2, buffer);
      return buffer.slice(0, len);
    }
    decode(typeName, typeData) {
      const layout = this.typeLayouts.get(typeName);
      if (!layout) {
        throw new Error(`Unknown type: ${typeName}`);
      }
      return layout.decode(typeData);
    }
  };
  var BorshCoder = class {
    constructor(idl) {
      this.instruction = new BorshInstructionCoder(idl);
      this.accounts = new BorshAccountsCoder(idl);
      this.events = new BorshEventCoder(idl);
      this.types = new BorshTypesCoder(idl);
    }
  };
  var commonjsGlobal = typeof globalThis !== "undefined" ? globalThis : typeof window !== "undefined" ? window : typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : {};
  function getDefaultExportFromCjs(x) {
    return x && x.__esModule && Object.prototype.hasOwnProperty.call(x, "default") ? x["default"] : x;
  }
  var Layout = class {
    constructor(span, property) {
      if (!Number.isInteger(span)) {
        throw new TypeError("span must be an integer");
      }
      this.span = span;
      this.property = property;
    }
    /** Function to create an Object into which decoded properties will
     * be written.
     *
     * Used only for layouts that {@link Layout#decode|decode} to Object
     * instances, which means:
     * * {@link Structure}
     * * {@link Union}
     * * {@link VariantLayout}
     * * {@link BitStructure}
     *
     * If left undefined the JavaScript representation of these layouts
     * will be Object instances.
     *
     * See {@link bindConstructorLayout}.
     */
    makeDestinationObject() {
      return {};
    }
    /**
     * Decode from a Buffer into an JavaScript value.
     *
     * @param {Buffer} b - the buffer from which encoded data is read.
     *
     * @param {Number} [offset] - the offset at which the encoded data
     * starts.  If absent a zero offset is inferred.
     *
     * @returns {(Number|Array|Object)} - the value of the decoded data.
     *
     * @abstract
     */
    decode(b, offset2) {
      throw new Error("Layout is abstract");
    }
    /**
     * Encode a JavaScript value into a Buffer.
     *
     * @param {(Number|Array|Object)} src - the value to be encoded into
     * the buffer.  The type accepted depends on the (sub-)type of {@link
     * Layout}.
     *
     * @param {Buffer} b - the buffer into which encoded data will be
     * written.
     *
     * @param {Number} [offset] - the offset at which the encoded data
     * starts.  If absent a zero offset is inferred.
     *
     * @returns {Number} - the number of bytes encoded, including the
     * space skipped for internal padding, but excluding data such as
     * {@link Sequence#count|lengths} when stored {@link
     * ExternalLayout|externally}.  This is the adjustment to `offset`
     * producing the offset where data for the next layout would be
     * written.
     *
     * @abstract
     */
    encode(src, b, offset2) {
      throw new Error("Layout is abstract");
    }
    /**
     * Calculate the span of a specific instance of a layout.
     *
     * @param {Buffer} b - the buffer that contains an encoded instance.
     *
     * @param {Number} [offset] - the offset at which the encoded instance
     * starts.  If absent a zero offset is inferred.
     *
     * @return {Number} - the number of bytes covered by the layout
     * instance.  If this method is not overridden in a subclass the
     * definition-time constant {@link Layout#span|span} will be
     * returned.
     *
     * @throws {RangeError} - if the length of the value cannot be
     * determined.
     */
    getSpan(b, offset2) {
      if (0 > this.span) {
        throw new RangeError("indeterminate span");
      }
      return this.span;
    }
    /**
     * Replicate the layout using a new property.
     *
     * This function must be used to get a structurally-equivalent layout
     * with a different name since all {@link Layout} instances are
     * immutable.
     *
     * **NOTE** This is a shallow copy.  All fields except {@link
     * Layout#property|property} are strictly equal to the origin layout.
     *
     * @param {String} property - the value for {@link
     * Layout#property|property} in the replica.
     *
     * @returns {Layout} - the copy with {@link Layout#property|property}
     * set to `property`.
     */
    replicate(property) {
      const rv = Object.create(this.constructor.prototype);
      Object.assign(rv, this);
      rv.property = property;
      return rv;
    }
    /**
     * Create an object from layout properties and an array of values.
     *
     * **NOTE** This function returns `undefined` if invoked on a layout
     * that does not return its value as an Object.  Objects are
     * returned for things that are a {@link Structure}, which includes
     * {@link VariantLayout|variant layouts} if they are structures, and
     * excludes {@link Union}s.  If you want this feature for a union
     * you must use {@link Union.getVariant|getVariant} to select the
     * desired layout.
     *
     * @param {Array} values - an array of values that correspond to the
     * default order for properties.  As with {@link Layout#decode|decode}
     * layout elements that have no property name are skipped when
     * iterating over the array values.  Only the top-level properties are
     * assigned; arguments are not assigned to properties of contained
     * layouts.  Any unused values are ignored.
     *
     * @return {(Object|undefined)}
     */
    fromArray(values) {
      return void 0;
    }
  };
  var Layout_2 = Layout;
  function nameWithProperty(name, lo) {
    if (lo.property) {
      return name + "[" + lo.property + "]";
    }
    return name;
  }
  var ExternalLayout = class extends Layout {
    /**
     * Return `true` iff the external layout decodes to an unsigned
     * integer layout.
     *
     * In that case it can be used as the source of {@link
     * Sequence#count|Sequence counts}, {@link Blob#length|Blob lengths},
     * or as {@link UnionLayoutDiscriminator#layout|external union
     * discriminators}.
     *
     * @abstract
     */
    isCount() {
      throw new Error("ExternalLayout is abstract");
    }
  };
  var OffsetLayout = class extends ExternalLayout {
    constructor(layout, offset2, property) {
      if (!(layout instanceof Layout)) {
        throw new TypeError("layout must be a Layout");
      }
      if (void 0 === offset2) {
        offset2 = 0;
      } else if (!Number.isInteger(offset2)) {
        throw new TypeError("offset must be integer or undefined");
      }
      super(layout.span, property || layout.property);
      this.layout = layout;
      this.offset = offset2;
    }
    /** @override */
    isCount() {
      return this.layout instanceof UInt || this.layout instanceof UIntBE;
    }
    /** @override */
    decode(b, offset2) {
      if (void 0 === offset2) {
        offset2 = 0;
      }
      return this.layout.decode(b, offset2 + this.offset);
    }
    /** @override */
    encode(src, b, offset2) {
      if (void 0 === offset2) {
        offset2 = 0;
      }
      return this.layout.encode(src, b, offset2 + this.offset);
    }
  };
  var UInt = class extends Layout {
    constructor(span, property) {
      super(span, property);
      if (6 < this.span) {
        throw new RangeError("span must not exceed 6 bytes");
      }
    }
    /** @override */
    decode(b, offset2) {
      if (void 0 === offset2) {
        offset2 = 0;
      }
      return b.readUIntLE(offset2, this.span);
    }
    /** @override */
    encode(src, b, offset2) {
      if (void 0 === offset2) {
        offset2 = 0;
      }
      b.writeUIntLE(src, offset2, this.span);
      return this.span;
    }
  };
  var UIntBE = class extends Layout {
    constructor(span, property) {
      super(span, property);
      if (6 < this.span) {
        throw new RangeError("span must not exceed 6 bytes");
      }
    }
    /** @override */
    decode(b, offset2) {
      if (void 0 === offset2) {
        offset2 = 0;
      }
      return b.readUIntBE(offset2, this.span);
    }
    /** @override */
    encode(src, b, offset2) {
      if (void 0 === offset2) {
        offset2 = 0;
      }
      b.writeUIntBE(src, offset2, this.span);
      return this.span;
    }
  };
  var V2E32 = Math.pow(2, 32);
  function divmodInt64(src) {
    const hi32 = Math.floor(src / V2E32);
    const lo32 = src - hi32 * V2E32;
    return { hi32, lo32 };
  }
  function roundedInt64(hi32, lo32) {
    return hi32 * V2E32 + lo32;
  }
  var NearUInt64 = class extends Layout {
    constructor(property) {
      super(8, property);
    }
    /** @override */
    decode(b, offset2) {
      if (void 0 === offset2) {
        offset2 = 0;
      }
      const lo32 = b.readUInt32LE(offset2);
      const hi32 = b.readUInt32LE(offset2 + 4);
      return roundedInt64(hi32, lo32);
    }
    /** @override */
    encode(src, b, offset2) {
      if (void 0 === offset2) {
        offset2 = 0;
      }
      const split = divmodInt64(src);
      b.writeUInt32LE(split.lo32, offset2);
      b.writeUInt32LE(split.hi32, offset2 + 4);
      return 8;
    }
  };
  var NearInt64 = class extends Layout {
    constructor(property) {
      super(8, property);
    }
    /** @override */
    decode(b, offset2) {
      if (void 0 === offset2) {
        offset2 = 0;
      }
      const lo32 = b.readUInt32LE(offset2);
      const hi32 = b.readInt32LE(offset2 + 4);
      return roundedInt64(hi32, lo32);
    }
    /** @override */
    encode(src, b, offset2) {
      if (void 0 === offset2) {
        offset2 = 0;
      }
      const split = divmodInt64(src);
      b.writeUInt32LE(split.lo32, offset2);
      b.writeInt32LE(split.hi32, offset2 + 4);
      return 8;
    }
  };
  var Structure = class extends Layout {
    constructor(fields, property, decodePrefixes) {
      if (!(Array.isArray(fields) && fields.reduce((acc, v) => acc && v instanceof Layout, true))) {
        throw new TypeError("fields must be array of Layout instances");
      }
      if ("boolean" === typeof property && void 0 === decodePrefixes) {
        decodePrefixes = property;
        property = void 0;
      }
      for (const fd of fields) {
        if (0 > fd.span && void 0 === fd.property) {
          throw new Error("fields cannot contain unnamed variable-length layout");
        }
      }
      let span = -1;
      try {
        span = fields.reduce((span2, fd) => span2 + fd.getSpan(), 0);
      } catch (e) {
      }
      super(span, property);
      this.fields = fields;
      this.decodePrefixes = !!decodePrefixes;
    }
    /** @override */
    getSpan(b, offset2) {
      if (0 <= this.span) {
        return this.span;
      }
      if (void 0 === offset2) {
        offset2 = 0;
      }
      let span = 0;
      try {
        span = this.fields.reduce((span2, fd) => {
          const fsp = fd.getSpan(b, offset2);
          offset2 += fsp;
          return span2 + fsp;
        }, 0);
      } catch (e) {
        throw new RangeError("indeterminate span");
      }
      return span;
    }
    /** @override */
    decode(b, offset2) {
      if (void 0 === offset2) {
        offset2 = 0;
      }
      const dest = this.makeDestinationObject();
      for (const fd of this.fields) {
        if (void 0 !== fd.property) {
          dest[fd.property] = fd.decode(b, offset2);
        }
        offset2 += fd.getSpan(b, offset2);
        if (this.decodePrefixes && b.length === offset2) {
          break;
        }
      }
      return dest;
    }
    /** Implement {@link Layout#encode|encode} for {@link Structure}.
     *
     * If `src` is missing a property for a member with a defined {@link
     * Layout#property|property} the corresponding region of the buffer is
     * left unmodified. */
    encode(src, b, offset2) {
      if (void 0 === offset2) {
        offset2 = 0;
      }
      const firstOffset = offset2;
      let lastOffset = 0;
      let lastWrote = 0;
      for (const fd of this.fields) {
        let span = fd.span;
        lastWrote = 0 < span ? span : 0;
        if (void 0 !== fd.property) {
          const fv = src[fd.property];
          if (void 0 !== fv) {
            lastWrote = fd.encode(fv, b, offset2);
            if (0 > span) {
              span = fd.getSpan(b, offset2);
            }
          }
        }
        lastOffset = offset2;
        offset2 += span;
      }
      return lastOffset + lastWrote - firstOffset;
    }
    /** @override */
    fromArray(values) {
      const dest = this.makeDestinationObject();
      for (const fd of this.fields) {
        if (void 0 !== fd.property && 0 < values.length) {
          dest[fd.property] = values.shift();
        }
      }
      return dest;
    }
    /**
     * Get access to the layout of a given property.
     *
     * @param {String} property - the structure member of interest.
     *
     * @return {Layout} - the layout associated with `property`, or
     * undefined if there is no such property.
     */
    layoutFor(property) {
      if ("string" !== typeof property) {
        throw new TypeError("property must be string");
      }
      for (const fd of this.fields) {
        if (fd.property === property) {
          return fd;
        }
      }
    }
    /**
     * Get the offset of a structure member.
     *
     * @param {String} property - the structure member of interest.
     *
     * @return {Number} - the offset in bytes to the start of `property`
     * within the structure, or undefined if `property` is not a field
     * within the structure.  If the property is a member but follows a
     * variable-length structure member a negative number will be
     * returned.
     */
    offsetOf(property) {
      if ("string" !== typeof property) {
        throw new TypeError("property must be string");
      }
      let offset2 = 0;
      for (const fd of this.fields) {
        if (fd.property === property) {
          return offset2;
        }
        if (0 > fd.span) {
          offset2 = -1;
        } else if (0 <= offset2) {
          offset2 += fd.span;
        }
      }
    }
  };
  var UnionDiscriminator = class {
    constructor(property) {
      this.property = property;
    }
    /** Analog to {@link Layout#decode|Layout decode} for union discriminators.
     *
     * The implementation of this method need not reference the buffer if
     * variant information is available through other means. */
    decode() {
      throw new Error("UnionDiscriminator is abstract");
    }
    /** Analog to {@link Layout#decode|Layout encode} for union discriminators.
     *
     * The implementation of this method need not store the value if
     * variant information is maintained through other means. */
    encode() {
      throw new Error("UnionDiscriminator is abstract");
    }
  };
  var UnionLayoutDiscriminator = class extends UnionDiscriminator {
    constructor(layout, property) {
      if (!(layout instanceof ExternalLayout && layout.isCount())) {
        throw new TypeError("layout must be an unsigned integer ExternalLayout");
      }
      super(property || layout.property || "variant");
      this.layout = layout;
    }
    /** Delegate decoding to {@link UnionLayoutDiscriminator#layout|layout}. */
    decode(b, offset2) {
      return this.layout.decode(b, offset2);
    }
    /** Delegate encoding to {@link UnionLayoutDiscriminator#layout|layout}. */
    encode(src, b, offset2) {
      return this.layout.encode(src, b, offset2);
    }
  };
  var Union = class extends Layout {
    constructor(discr, defaultLayout, property) {
      const upv = discr instanceof UInt || discr instanceof UIntBE;
      if (upv) {
        discr = new UnionLayoutDiscriminator(new OffsetLayout(discr));
      } else if (discr instanceof ExternalLayout && discr.isCount()) {
        discr = new UnionLayoutDiscriminator(discr);
      } else if (!(discr instanceof UnionDiscriminator)) {
        throw new TypeError("discr must be a UnionDiscriminator or an unsigned integer layout");
      }
      if (void 0 === defaultLayout) {
        defaultLayout = null;
      }
      if (!(null === defaultLayout || defaultLayout instanceof Layout)) {
        throw new TypeError("defaultLayout must be null or a Layout");
      }
      if (null !== defaultLayout) {
        if (0 > defaultLayout.span) {
          throw new Error("defaultLayout must have constant span");
        }
        if (void 0 === defaultLayout.property) {
          defaultLayout = defaultLayout.replicate("content");
        }
      }
      let span = -1;
      if (defaultLayout) {
        span = defaultLayout.span;
        if (0 <= span && upv) {
          span += discr.layout.span;
        }
      }
      super(span, property);
      this.discriminator = discr;
      this.usesPrefixDiscriminator = upv;
      this.defaultLayout = defaultLayout;
      this.registry = {};
      let boundGetSourceVariant = this.defaultGetSourceVariant.bind(this);
      this.getSourceVariant = function(src) {
        return boundGetSourceVariant(src);
      };
      this.configGetSourceVariant = function(gsv) {
        boundGetSourceVariant = gsv.bind(this);
      };
    }
    /** @override */
    getSpan(b, offset2) {
      if (0 <= this.span) {
        return this.span;
      }
      if (void 0 === offset2) {
        offset2 = 0;
      }
      const vlo = this.getVariant(b, offset2);
      if (!vlo) {
        throw new Error("unable to determine span for unrecognized variant");
      }
      return vlo.getSpan(b, offset2);
    }
    /**
     * Method to infer a registered Union variant compatible with `src`.
     *
     * The first satisified rule in the following sequence defines the
     * return value:
     * * If `src` has properties matching the Union discriminator and
     *   the default layout, `undefined` is returned regardless of the
     *   value of the discriminator property (this ensures the default
     *   layout will be used);
     * * If `src` has a property matching the Union discriminator, the
     *   value of the discriminator identifies a registered variant, and
     *   either (a) the variant has no layout, or (b) `src` has the
     *   variant's property, then the variant is returned (because the
     *   source satisfies the constraints of the variant it identifies);
     * * If `src` does not have a property matching the Union
     *   discriminator, but does have a property matching a registered
     *   variant, then the variant is returned (because the source
     *   matches a variant without an explicit conflict);
     * * An error is thrown (because we either can't identify a variant,
     *   or we were explicitly told the variant but can't satisfy it).
     *
     * @param {Object} src - an object presumed to be compatible with
     * the content of the Union.
     *
     * @return {(undefined|VariantLayout)} - as described above.
     *
     * @throws {Error} - if `src` cannot be associated with a default or
     * registered variant.
     */
    defaultGetSourceVariant(src) {
      if (src.hasOwnProperty(this.discriminator.property)) {
        if (this.defaultLayout && src.hasOwnProperty(this.defaultLayout.property)) {
          return void 0;
        }
        const vlo = this.registry[src[this.discriminator.property]];
        if (vlo && (!vlo.layout || src.hasOwnProperty(vlo.property))) {
          return vlo;
        }
      } else {
        for (const tag in this.registry) {
          const vlo = this.registry[tag];
          if (src.hasOwnProperty(vlo.property)) {
            return vlo;
          }
        }
      }
      throw new Error("unable to infer src variant");
    }
    /** Implement {@link Layout#decode|decode} for {@link Union}.
     *
     * If the variant is {@link Union#addVariant|registered} the return
     * value is an instance of that variant, with no explicit
     * discriminator.  Otherwise the {@link Union#defaultLayout|default
     * layout} is used to decode the content. */
    decode(b, offset2) {
      if (void 0 === offset2) {
        offset2 = 0;
      }
      let dest;
      const dlo = this.discriminator;
      const discr = dlo.decode(b, offset2);
      let clo = this.registry[discr];
      if (void 0 === clo) {
        let contentOffset = 0;
        clo = this.defaultLayout;
        if (this.usesPrefixDiscriminator) {
          contentOffset = dlo.layout.span;
        }
        dest = this.makeDestinationObject();
        dest[dlo.property] = discr;
        dest[clo.property] = this.defaultLayout.decode(b, offset2 + contentOffset);
      } else {
        dest = clo.decode(b, offset2);
      }
      return dest;
    }
    /** Implement {@link Layout#encode|encode} for {@link Union}.
     *
     * This API assumes the `src` object is consistent with the union's
     * {@link Union#defaultLayout|default layout}.  To encode variants
     * use the appropriate variant-specific {@link VariantLayout#encode}
     * method. */
    encode(src, b, offset2) {
      if (void 0 === offset2) {
        offset2 = 0;
      }
      const vlo = this.getSourceVariant(src);
      if (void 0 === vlo) {
        const dlo = this.discriminator;
        const clo = this.defaultLayout;
        let contentOffset = 0;
        if (this.usesPrefixDiscriminator) {
          contentOffset = dlo.layout.span;
        }
        dlo.encode(src[dlo.property], b, offset2);
        return contentOffset + clo.encode(
          src[clo.property],
          b,
          offset2 + contentOffset
        );
      }
      return vlo.encode(src, b, offset2);
    }
    /** Register a new variant structure within a union.  The newly
     * created variant is returned.
     *
     * @param {Number} variant - initializer for {@link
     * VariantLayout#variant|variant}.
     *
     * @param {Layout} layout - initializer for {@link
     * VariantLayout#layout|layout}.
     *
     * @param {String} property - initializer for {@link
     * Layout#property|property}.
     *
     * @return {VariantLayout} */
    addVariant(variant, layout, property) {
      const rv = new VariantLayout(this, variant, layout, property);
      this.registry[variant] = rv;
      return rv;
    }
    /**
     * Get the layout associated with a registered variant.
     *
     * If `vb` does not produce a registered variant the function returns
     * `undefined`.
     *
     * @param {(Number|Buffer)} vb - either the variant number, or a
     * buffer from which the discriminator is to be read.
     *
     * @param {Number} offset - offset into `vb` for the start of the
     * union.  Used only when `vb` is an instance of {Buffer}.
     *
     * @return {({VariantLayout}|undefined)}
     */
    getVariant(vb, offset2) {
      let variant = vb;
      if (Buffer.isBuffer(vb)) {
        if (void 0 === offset2) {
          offset2 = 0;
        }
        variant = this.discriminator.decode(vb, offset2);
      }
      return this.registry[variant];
    }
  };
  var VariantLayout = class extends Layout {
    constructor(union2, variant, layout, property) {
      if (!(union2 instanceof Union)) {
        throw new TypeError("union must be a Union");
      }
      if (!Number.isInteger(variant) || 0 > variant) {
        throw new TypeError("variant must be a (non-negative) integer");
      }
      if ("string" === typeof layout && void 0 === property) {
        property = layout;
        layout = null;
      }
      if (layout) {
        if (!(layout instanceof Layout)) {
          throw new TypeError("layout must be a Layout");
        }
        if (null !== union2.defaultLayout && 0 <= layout.span && layout.span > union2.defaultLayout.span) {
          throw new Error("variant span exceeds span of containing union");
        }
        if ("string" !== typeof property) {
          throw new TypeError("variant must have a String property");
        }
      }
      let span = union2.span;
      if (0 > union2.span) {
        span = layout ? layout.span : 0;
        if (0 <= span && union2.usesPrefixDiscriminator) {
          span += union2.discriminator.layout.span;
        }
      }
      super(span, property);
      this.union = union2;
      this.variant = variant;
      this.layout = layout || null;
    }
    /** @override */
    getSpan(b, offset2) {
      if (0 <= this.span) {
        return this.span;
      }
      if (void 0 === offset2) {
        offset2 = 0;
      }
      let contentOffset = 0;
      if (this.union.usesPrefixDiscriminator) {
        contentOffset = this.union.discriminator.layout.span;
      }
      return contentOffset + this.layout.getSpan(b, offset2 + contentOffset);
    }
    /** @override */
    decode(b, offset2) {
      const dest = this.makeDestinationObject();
      if (void 0 === offset2) {
        offset2 = 0;
      }
      if (this !== this.union.getVariant(b, offset2)) {
        throw new Error("variant mismatch");
      }
      let contentOffset = 0;
      if (this.union.usesPrefixDiscriminator) {
        contentOffset = this.union.discriminator.layout.span;
      }
      if (this.layout) {
        dest[this.property] = this.layout.decode(b, offset2 + contentOffset);
      } else if (this.property) {
        dest[this.property] = true;
      } else if (this.union.usesPrefixDiscriminator) {
        dest[this.union.discriminator.property] = this.variant;
      }
      return dest;
    }
    /** @override */
    encode(src, b, offset2) {
      if (void 0 === offset2) {
        offset2 = 0;
      }
      let contentOffset = 0;
      if (this.union.usesPrefixDiscriminator) {
        contentOffset = this.union.discriminator.layout.span;
      }
      if (this.layout && !src.hasOwnProperty(this.property)) {
        throw new TypeError("variant lacks property " + this.property);
      }
      this.union.discriminator.encode(this.variant, b, offset2);
      let span = contentOffset;
      if (this.layout) {
        this.layout.encode(src[this.property], b, offset2 + contentOffset);
        span += this.layout.getSpan(b, offset2 + contentOffset);
        if (0 <= this.union.span && span > this.union.span) {
          throw new Error("encoded variant overruns containing union");
        }
      }
      return span;
    }
    /** Delegate {@link Layout#fromArray|fromArray} to {@link
     * VariantLayout#layout|layout}. */
    fromArray(values) {
      if (this.layout) {
        return this.layout.fromArray(values);
      }
    }
  };
  var Blob$1 = class extends Layout {
    constructor(length, property) {
      if (!(length instanceof ExternalLayout && length.isCount() || Number.isInteger(length) && 0 <= length)) {
        throw new TypeError("length must be positive integer or an unsigned integer ExternalLayout");
      }
      let span = -1;
      if (!(length instanceof ExternalLayout)) {
        span = length;
      }
      super(span, property);
      this.length = length;
    }
    /** @override */
    getSpan(b, offset2) {
      let span = this.span;
      if (0 > span) {
        span = this.length.decode(b, offset2);
      }
      return span;
    }
    /** @override */
    decode(b, offset2) {
      if (void 0 === offset2) {
        offset2 = 0;
      }
      let span = this.span;
      if (0 > span) {
        span = this.length.decode(b, offset2);
      }
      return b.slice(offset2, offset2 + span);
    }
    /** Implement {@link Layout#encode|encode} for {@link Blob}.
     *
     * **NOTE** If {@link Layout#count|count} is an instance of {@link
     * ExternalLayout} then the length of `src` will be encoded as the
     * count after `src` is encoded. */
    encode(src, b, offset2) {
      let span = this.length;
      if (this.length instanceof ExternalLayout) {
        span = src.length;
      }
      if (!(Buffer.isBuffer(src) && span === src.length)) {
        throw new TypeError(nameWithProperty("Blob.encode", this) + " requires (length " + span + ") Buffer as src");
      }
      if (offset2 + span > b.length) {
        throw new RangeError("encoding overruns Buffer");
      }
      b.write(src.toString("hex"), offset2, span, "hex");
      if (this.length instanceof ExternalLayout) {
        this.length.encode(span, b, offset2);
      }
      return span;
    }
  };
  var offset = ((layout, offset2, property) => new OffsetLayout(layout, offset2, property));
  var u82 = ((property) => new UInt(1, property));
  var u322 = ((property) => new UInt(4, property));
  var nu64 = ((property) => new NearUInt64(property));
  var ns64 = ((property) => new NearInt64(property));
  var struct2 = ((fields, property, decodePrefixes) => new Structure(fields, property, decodePrefixes));
  var union = ((discr, defaultLayout, property) => new Union(discr, defaultLayout, property));
  var blob = ((length, property) => new Blob$1(length, property));
  var SystemInstructionCoder = class {
    // eslint-disable-next-line @typescript-eslint/no-empty-function
    constructor(_) {
    }
    encode(ixName, ix) {
      switch ((0, import_camelcase.default)(ixName)) {
        case "createAccount": {
          return encodeCreateAccount(ix);
        }
        case "assign": {
          return encodeAssign(ix);
        }
        case "transfer": {
          return encodeTransfer(ix);
        }
        case "createAccountWithSeed": {
          return encodeCreateAccountWithSeed(ix);
        }
        case "advanceNonceAccount": {
          return encodeAdvanceNonceAccount(ix);
        }
        case "withdrawNonceAccount": {
          return encodeWithdrawNonceAccount(ix);
        }
        case "initializeNonceAccount": {
          return encodeInitializeNonceAccount(ix);
        }
        case "authorizeNonceAccount": {
          return encodeAuthorizeNonceAccount(ix);
        }
        case "allocate": {
          return encodeAllocate(ix);
        }
        case "allocateWithSeed": {
          return encodeAllocateWithSeed(ix);
        }
        case "assignWithSeed": {
          return encodeAssignWithSeed(ix);
        }
        case "transferWithSeed": {
          return encodeTransferWithSeed(ix);
        }
        default: {
          throw new Error(`Invalid instruction: ${ixName}`);
        }
      }
    }
    encodeState(_ixName, _ix) {
      throw new Error("System does not have state");
    }
  };
  var RustStringLayout = class extends Layout_2 {
    constructor(property) {
      super(-1, property);
      this.property = property;
      this.layout = struct2([
        u322("length"),
        u322("lengthPadding"),
        blob(offset(u322(), -8), "chars")
      ], this.property);
    }
    encode(src, b, offset2 = 0) {
      if (src === null || src === void 0) {
        return this.layout.span;
      }
      const data = {
        chars: Buffer.from(src, "utf8")
      };
      return this.layout.encode(data, b, offset2);
    }
    decode(b, offset2 = 0) {
      const data = this.layout.decode(b, offset2);
      return data["chars"].toString();
    }
    getSpan(b, offset2 = 0) {
      return u322().span + u322().span + new import_bn.default(new Uint8Array(b).slice(offset2, offset2 + 4), 10, "le").toNumber();
    }
  };
  function rustStringLayout(property) {
    return new RustStringLayout(property);
  }
  function publicKey$2(property) {
    return blob(32, property);
  }
  function encodeCreateAccount({ lamports, space, owner }) {
    return encodeData({
      createAccount: { lamports, space, owner: owner.toBuffer() }
    });
  }
  function encodeAssign({ owner }) {
    return encodeData({
      assign: { owner: owner.toBuffer() }
    });
  }
  function encodeTransfer({ lamports }) {
    return encodeData({
      transfer: { lamports }
    });
  }
  function encodeCreateAccountWithSeed({ base, seed: seed2, lamports, space, owner }) {
    return encodeData({
      createAccountWithSeed: {
        base: base.toBuffer(),
        seed: seed2,
        lamports,
        space,
        owner: owner.toBuffer()
      }
    }, LAYOUT.getVariant(3).span + seed2.length);
  }
  function encodeInitializeNonceAccount({ authorized }) {
    return encodeData({
      initializeNonceAccount: { authorized: authorized.toBuffer() }
    });
  }
  function encodeAdvanceNonceAccount({ authorized }) {
    return encodeData({
      advanceNonceAccount: { authorized: authorized.toBuffer() }
    });
  }
  function encodeWithdrawNonceAccount({ lamports }) {
    return encodeData({
      withdrawNonceAccount: { lamports }
    });
  }
  function encodeAuthorizeNonceAccount({ authorized }) {
    return encodeData({
      authorizeNonceAccount: { authorized: authorized.toBuffer() }
    });
  }
  function encodeAllocate({ space }) {
    return encodeData({
      allocate: { space }
    });
  }
  function encodeAllocateWithSeed({ base, seed: seed2, space, owner }) {
    return encodeData({
      allocateWithSeed: {
        base: base.toBuffer(),
        seed: seed2,
        space,
        owner: owner.toBuffer()
      }
    }, LAYOUT.getVariant(9).span + seed2.length);
  }
  function encodeAssignWithSeed({ base, seed: seed2, owner }) {
    return encodeData({
      assignWithSeed: {
        base: base.toBuffer(),
        seed: seed2,
        owner: owner.toBuffer()
      }
    }, LAYOUT.getVariant(10).span + seed2.length);
  }
  function encodeTransferWithSeed({ lamports, seed: seed2, owner }) {
    return encodeData({
      transferWithSeed: {
        lamports,
        seed: seed2,
        owner: owner.toBuffer()
      }
    }, LAYOUT.getVariant(11).span + seed2.length);
  }
  var LAYOUT = union(u322("instruction"));
  LAYOUT.addVariant(0, struct2([
    ns64("lamports"),
    ns64("space"),
    publicKey$2("owner")
  ]), "createAccount");
  LAYOUT.addVariant(1, struct2([publicKey$2("owner")]), "assign");
  LAYOUT.addVariant(2, struct2([ns64("lamports")]), "transfer");
  LAYOUT.addVariant(3, struct2([
    publicKey$2("base"),
    rustStringLayout("seed"),
    ns64("lamports"),
    ns64("space"),
    publicKey$2("owner")
  ]), "createAccountWithSeed");
  LAYOUT.addVariant(4, struct2([publicKey$2("authorized")]), "advanceNonceAccount");
  LAYOUT.addVariant(5, struct2([ns64("lamports")]), "withdrawNonceAccount");
  LAYOUT.addVariant(6, struct2([publicKey$2("authorized")]), "initializeNonceAccount");
  LAYOUT.addVariant(7, struct2([publicKey$2("authorized")]), "authorizeNonceAccount");
  LAYOUT.addVariant(8, struct2([ns64("space")]), "allocate");
  LAYOUT.addVariant(9, struct2([
    publicKey$2("base"),
    rustStringLayout("seed"),
    ns64("space"),
    publicKey$2("owner")
  ]), "allocateWithSeed");
  LAYOUT.addVariant(10, struct2([
    publicKey$2("base"),
    rustStringLayout("seed"),
    publicKey$2("owner")
  ]), "assignWithSeed");
  LAYOUT.addVariant(11, struct2([
    ns64("lamports"),
    rustStringLayout("seed"),
    publicKey$2("owner")
  ]), "transferWithSeed");
  function encodeData(instruction, maxSpan) {
    const b = Buffer.alloc(maxSpan !== null && maxSpan !== void 0 ? maxSpan : instructionMaxSpan);
    const span = LAYOUT.encode(instruction, b);
    if (maxSpan === void 0) {
      return b.slice(0, span);
    }
    return b;
  }
  var instructionMaxSpan = Math.max(...Object.values(LAYOUT.registry).map((r) => r.span));
  var SystemAccountsCoder = class {
    constructor(idl) {
      this.idl = idl;
    }
    async encode(accountName, account) {
      switch (accountName) {
        case "nonce": {
          const buffer = Buffer.alloc(import_web3.NONCE_ACCOUNT_LENGTH);
          const len = NONCE_ACCOUNT_LAYOUT.encode(account, buffer);
          return buffer.slice(0, len);
        }
        default: {
          throw new Error(`Invalid account name: ${accountName}`);
        }
      }
    }
    decode(accountName, ix) {
      return this.decodeUnchecked(accountName, ix);
    }
    decodeUnchecked(accountName, ix) {
      switch (accountName) {
        case "nonce": {
          return decodeNonceAccount(ix);
        }
        default: {
          throw new Error(`Invalid account name: ${accountName}`);
        }
      }
    }
    // TODO: this won't use the appendData.
    memcmp(accountName, _appendData) {
      switch (accountName) {
        case "nonce": {
          return {
            dataSize: import_web3.NONCE_ACCOUNT_LENGTH
          };
        }
        default: {
          throw new Error(`Invalid account name: ${accountName}`);
        }
      }
    }
    size(idlAccount) {
      var _a;
      return (_a = accountSize(this.idl, idlAccount)) !== null && _a !== void 0 ? _a : 0;
    }
  };
  function decodeNonceAccount(ix) {
    return NONCE_ACCOUNT_LAYOUT.decode(ix);
  }
  var WrappedLayout$1 = class extends Layout_2 {
    constructor(layout, decoder, encoder, property) {
      super(layout.span, property);
      this.layout = layout;
      this.decoder = decoder;
      this.encoder = encoder;
    }
    decode(b, offset2) {
      return this.decoder(this.layout.decode(b, offset2));
    }
    encode(src, b, offset2) {
      return this.layout.encode(this.encoder(src), b, offset2);
    }
    getSpan(b, offset2) {
      return this.layout.getSpan(b, offset2);
    }
  };
  function publicKey$1(property) {
    return new WrappedLayout$1(blob(32), (b) => new import_web3.PublicKey(b), (key) => key.toBuffer(), property);
  }
  var NONCE_ACCOUNT_LAYOUT = struct2([
    u322("version"),
    u322("state"),
    publicKey$1("authorizedPubkey"),
    publicKey$1("nonce"),
    struct2([nu64("lamportsPerSignature")], "feeCalculator")
  ]);
  var SystemEventsCoder = class {
    constructor(_idl) {
    }
    decode(_log) {
      throw new Error("System program does not have events");
    }
  };
  var SystemTypesCoder = class {
    constructor(_idl) {
    }
    encode(_name, _type) {
      throw new Error("System does not have user-defined types");
    }
    decode(_name, _typeData) {
      throw new Error("System does not have user-defined types");
    }
  };
  var SystemCoder = class {
    constructor(idl) {
      this.instruction = new SystemInstructionCoder(idl);
      this.accounts = new SystemAccountsCoder(idl);
      this.events = new SystemEventsCoder(idl);
      this.types = new SystemTypesCoder(idl);
    }
  };
  function hash(data) {
    return new TextDecoder().decode(sha2562(data));
  }
  var sha2563 = /* @__PURE__ */ Object.freeze({
    __proto__: null,
    hash
  });
  function createWithSeedSync(fromPublicKey, seed2, programId) {
    const buffer = import_buffer.Buffer.concat([
      fromPublicKey.toBuffer(),
      import_buffer.Buffer.from(seed2),
      programId.toBuffer()
    ]);
    return new import_web3.PublicKey(sha2562(buffer));
  }
  function associated(programId, ...args) {
    let seeds = [import_buffer.Buffer.from([97, 110, 99, 104, 111, 114])];
    args.forEach((arg) => {
      seeds.push(arg instanceof import_buffer.Buffer ? arg : translateAddress(arg).toBuffer());
    });
    const [assoc] = import_web3.PublicKey.findProgramAddressSync(seeds, translateAddress(programId));
    return assoc;
  }
  var pubkey = /* @__PURE__ */ Object.freeze({
    __proto__: null,
    createWithSeedSync,
    associated
  });
  var TOKEN_PROGRAM_ID = new import_web3.PublicKey("TokenkegQfeZyiNwAJbNbGKPFXCWuBvf9Ss623VQ5DA");
  var ASSOCIATED_PROGRAM_ID = new import_web3.PublicKey("ATokenGPvbdGVxr1b2hvZbsiqW5xWH25efTNsLJA8knL");
  function associatedAddress({ mint, owner }) {
    return import_web3.PublicKey.findProgramAddressSync([owner.toBuffer(), TOKEN_PROGRAM_ID.toBuffer(), mint.toBuffer()], ASSOCIATED_PROGRAM_ID)[0];
  }
  var token = /* @__PURE__ */ Object.freeze({
    __proto__: null,
    TOKEN_PROGRAM_ID,
    ASSOCIATED_PROGRAM_ID,
    associatedAddress
  });
  var browserPonyfill = { exports: {} };
  (function(module, exports) {
    var global2 = typeof self !== "undefined" ? self : commonjsGlobal;
    var __self__ = (function() {
      function F() {
        this.fetch = false;
        this.DOMException = global2.DOMException;
      }
      F.prototype = global2;
      return new F();
    })();
    (function(self2) {
      (function(exports2) {
        var support = {
          searchParams: "URLSearchParams" in self2,
          iterable: "Symbol" in self2 && "iterator" in Symbol,
          blob: "FileReader" in self2 && "Blob" in self2 && (function() {
            try {
              new Blob();
              return true;
            } catch (e) {
              return false;
            }
          })(),
          formData: "FormData" in self2,
          arrayBuffer: "ArrayBuffer" in self2
        };
        function isDataView(obj) {
          return obj && DataView.prototype.isPrototypeOf(obj);
        }
        if (support.arrayBuffer) {
          var viewClasses = [
            "[object Int8Array]",
            "[object Uint8Array]",
            "[object Uint8ClampedArray]",
            "[object Int16Array]",
            "[object Uint16Array]",
            "[object Int32Array]",
            "[object Uint32Array]",
            "[object Float32Array]",
            "[object Float64Array]"
          ];
          var isArrayBufferView = ArrayBuffer.isView || function(obj) {
            return obj && viewClasses.indexOf(Object.prototype.toString.call(obj)) > -1;
          };
        }
        function normalizeName(name) {
          if (typeof name !== "string") {
            name = String(name);
          }
          if (/[^a-z0-9\-#$%&'*+.^_`|~]/i.test(name)) {
            throw new TypeError("Invalid character in header field name");
          }
          return name.toLowerCase();
        }
        function normalizeValue(value) {
          if (typeof value !== "string") {
            value = String(value);
          }
          return value;
        }
        function iteratorFor(items) {
          var iterator = {
            next: function() {
              var value = items.shift();
              return { done: value === void 0, value };
            }
          };
          if (support.iterable) {
            iterator[Symbol.iterator] = function() {
              return iterator;
            };
          }
          return iterator;
        }
        function Headers(headers) {
          this.map = {};
          if (headers instanceof Headers) {
            headers.forEach(function(value, name) {
              this.append(name, value);
            }, this);
          } else if (Array.isArray(headers)) {
            headers.forEach(function(header) {
              this.append(header[0], header[1]);
            }, this);
          } else if (headers) {
            Object.getOwnPropertyNames(headers).forEach(function(name) {
              this.append(name, headers[name]);
            }, this);
          }
        }
        Headers.prototype.append = function(name, value) {
          name = normalizeName(name);
          value = normalizeValue(value);
          var oldValue = this.map[name];
          this.map[name] = oldValue ? oldValue + ", " + value : value;
        };
        Headers.prototype["delete"] = function(name) {
          delete this.map[normalizeName(name)];
        };
        Headers.prototype.get = function(name) {
          name = normalizeName(name);
          return this.has(name) ? this.map[name] : null;
        };
        Headers.prototype.has = function(name) {
          return this.map.hasOwnProperty(normalizeName(name));
        };
        Headers.prototype.set = function(name, value) {
          this.map[normalizeName(name)] = normalizeValue(value);
        };
        Headers.prototype.forEach = function(callback, thisArg) {
          for (var name in this.map) {
            if (this.map.hasOwnProperty(name)) {
              callback.call(thisArg, this.map[name], name, this);
            }
          }
        };
        Headers.prototype.keys = function() {
          var items = [];
          this.forEach(function(value, name) {
            items.push(name);
          });
          return iteratorFor(items);
        };
        Headers.prototype.values = function() {
          var items = [];
          this.forEach(function(value) {
            items.push(value);
          });
          return iteratorFor(items);
        };
        Headers.prototype.entries = function() {
          var items = [];
          this.forEach(function(value, name) {
            items.push([name, value]);
          });
          return iteratorFor(items);
        };
        if (support.iterable) {
          Headers.prototype[Symbol.iterator] = Headers.prototype.entries;
        }
        function consumed(body) {
          if (body.bodyUsed) {
            return Promise.reject(new TypeError("Already read"));
          }
          body.bodyUsed = true;
        }
        function fileReaderReady(reader) {
          return new Promise(function(resolve, reject) {
            reader.onload = function() {
              resolve(reader.result);
            };
            reader.onerror = function() {
              reject(reader.error);
            };
          });
        }
        function readBlobAsArrayBuffer(blob2) {
          var reader = new FileReader();
          var promise = fileReaderReady(reader);
          reader.readAsArrayBuffer(blob2);
          return promise;
        }
        function readBlobAsText(blob2) {
          var reader = new FileReader();
          var promise = fileReaderReady(reader);
          reader.readAsText(blob2);
          return promise;
        }
        function readArrayBufferAsText(buf) {
          var view = new Uint8Array(buf);
          var chars = new Array(view.length);
          for (var i = 0; i < view.length; i++) {
            chars[i] = String.fromCharCode(view[i]);
          }
          return chars.join("");
        }
        function bufferClone(buf) {
          if (buf.slice) {
            return buf.slice(0);
          } else {
            var view = new Uint8Array(buf.byteLength);
            view.set(new Uint8Array(buf));
            return view.buffer;
          }
        }
        function Body() {
          this.bodyUsed = false;
          this._initBody = function(body) {
            this._bodyInit = body;
            if (!body) {
              this._bodyText = "";
            } else if (typeof body === "string") {
              this._bodyText = body;
            } else if (support.blob && Blob.prototype.isPrototypeOf(body)) {
              this._bodyBlob = body;
            } else if (support.formData && FormData.prototype.isPrototypeOf(body)) {
              this._bodyFormData = body;
            } else if (support.searchParams && URLSearchParams.prototype.isPrototypeOf(body)) {
              this._bodyText = body.toString();
            } else if (support.arrayBuffer && support.blob && isDataView(body)) {
              this._bodyArrayBuffer = bufferClone(body.buffer);
              this._bodyInit = new Blob([this._bodyArrayBuffer]);
            } else if (support.arrayBuffer && (ArrayBuffer.prototype.isPrototypeOf(body) || isArrayBufferView(body))) {
              this._bodyArrayBuffer = bufferClone(body);
            } else {
              this._bodyText = body = Object.prototype.toString.call(body);
            }
            if (!this.headers.get("content-type")) {
              if (typeof body === "string") {
                this.headers.set("content-type", "text/plain;charset=UTF-8");
              } else if (this._bodyBlob && this._bodyBlob.type) {
                this.headers.set("content-type", this._bodyBlob.type);
              } else if (support.searchParams && URLSearchParams.prototype.isPrototypeOf(body)) {
                this.headers.set("content-type", "application/x-www-form-urlencoded;charset=UTF-8");
              }
            }
          };
          if (support.blob) {
            this.blob = function() {
              var rejected = consumed(this);
              if (rejected) {
                return rejected;
              }
              if (this._bodyBlob) {
                return Promise.resolve(this._bodyBlob);
              } else if (this._bodyArrayBuffer) {
                return Promise.resolve(new Blob([this._bodyArrayBuffer]));
              } else if (this._bodyFormData) {
                throw new Error("could not read FormData body as blob");
              } else {
                return Promise.resolve(new Blob([this._bodyText]));
              }
            };
            this.arrayBuffer = function() {
              if (this._bodyArrayBuffer) {
                return consumed(this) || Promise.resolve(this._bodyArrayBuffer);
              } else {
                return this.blob().then(readBlobAsArrayBuffer);
              }
            };
          }
          this.text = function() {
            var rejected = consumed(this);
            if (rejected) {
              return rejected;
            }
            if (this._bodyBlob) {
              return readBlobAsText(this._bodyBlob);
            } else if (this._bodyArrayBuffer) {
              return Promise.resolve(readArrayBufferAsText(this._bodyArrayBuffer));
            } else if (this._bodyFormData) {
              throw new Error("could not read FormData body as text");
            } else {
              return Promise.resolve(this._bodyText);
            }
          };
          if (support.formData) {
            this.formData = function() {
              return this.text().then(decode2);
            };
          }
          this.json = function() {
            return this.text().then(JSON.parse);
          };
          return this;
        }
        var methods = ["DELETE", "GET", "HEAD", "OPTIONS", "POST", "PUT"];
        function normalizeMethod(method) {
          var upcased = method.toUpperCase();
          return methods.indexOf(upcased) > -1 ? upcased : method;
        }
        function Request(input, options) {
          options = options || {};
          var body = options.body;
          if (input instanceof Request) {
            if (input.bodyUsed) {
              throw new TypeError("Already read");
            }
            this.url = input.url;
            this.credentials = input.credentials;
            if (!options.headers) {
              this.headers = new Headers(input.headers);
            }
            this.method = input.method;
            this.mode = input.mode;
            this.signal = input.signal;
            if (!body && input._bodyInit != null) {
              body = input._bodyInit;
              input.bodyUsed = true;
            }
          } else {
            this.url = String(input);
          }
          this.credentials = options.credentials || this.credentials || "same-origin";
          if (options.headers || !this.headers) {
            this.headers = new Headers(options.headers);
          }
          this.method = normalizeMethod(options.method || this.method || "GET");
          this.mode = options.mode || this.mode || null;
          this.signal = options.signal || this.signal;
          this.referrer = null;
          if ((this.method === "GET" || this.method === "HEAD") && body) {
            throw new TypeError("Body not allowed for GET or HEAD requests");
          }
          this._initBody(body);
        }
        Request.prototype.clone = function() {
          return new Request(this, { body: this._bodyInit });
        };
        function decode2(body) {
          var form = new FormData();
          body.trim().split("&").forEach(function(bytes) {
            if (bytes) {
              var split = bytes.split("=");
              var name = split.shift().replace(/\+/g, " ");
              var value = split.join("=").replace(/\+/g, " ");
              form.append(decodeURIComponent(name), decodeURIComponent(value));
            }
          });
          return form;
        }
        function parseHeaders(rawHeaders) {
          var headers = new Headers();
          var preProcessedHeaders = rawHeaders.replace(/\r?\n[\t ]+/g, " ");
          preProcessedHeaders.split(/\r?\n/).forEach(function(line) {
            var parts = line.split(":");
            var key = parts.shift().trim();
            if (key) {
              var value = parts.join(":").trim();
              headers.append(key, value);
            }
          });
          return headers;
        }
        Body.call(Request.prototype);
        function Response(bodyInit, options) {
          if (!options) {
            options = {};
          }
          this.type = "default";
          this.status = options.status === void 0 ? 200 : options.status;
          this.ok = this.status >= 200 && this.status < 300;
          this.statusText = "statusText" in options ? options.statusText : "OK";
          this.headers = new Headers(options.headers);
          this.url = options.url || "";
          this._initBody(bodyInit);
        }
        Body.call(Response.prototype);
        Response.prototype.clone = function() {
          return new Response(this._bodyInit, {
            status: this.status,
            statusText: this.statusText,
            headers: new Headers(this.headers),
            url: this.url
          });
        };
        Response.error = function() {
          var response = new Response(null, { status: 0, statusText: "" });
          response.type = "error";
          return response;
        };
        var redirectStatuses = [301, 302, 303, 307, 308];
        Response.redirect = function(url, status) {
          if (redirectStatuses.indexOf(status) === -1) {
            throw new RangeError("Invalid status code");
          }
          return new Response(null, { status, headers: { location: url } });
        };
        exports2.DOMException = self2.DOMException;
        try {
          new exports2.DOMException();
        } catch (err2) {
          exports2.DOMException = function(message, name) {
            this.message = message;
            this.name = name;
            var error = Error(message);
            this.stack = error.stack;
          };
          exports2.DOMException.prototype = Object.create(Error.prototype);
          exports2.DOMException.prototype.constructor = exports2.DOMException;
        }
        function fetch2(input, init) {
          return new Promise(function(resolve, reject) {
            var request = new Request(input, init);
            if (request.signal && request.signal.aborted) {
              return reject(new exports2.DOMException("Aborted", "AbortError"));
            }
            var xhr = new XMLHttpRequest();
            function abortXhr() {
              xhr.abort();
            }
            xhr.onload = function() {
              var options = {
                status: xhr.status,
                statusText: xhr.statusText,
                headers: parseHeaders(xhr.getAllResponseHeaders() || "")
              };
              options.url = "responseURL" in xhr ? xhr.responseURL : options.headers.get("X-Request-URL");
              var body = "response" in xhr ? xhr.response : xhr.responseText;
              resolve(new Response(body, options));
            };
            xhr.onerror = function() {
              reject(new TypeError("Network request failed"));
            };
            xhr.ontimeout = function() {
              reject(new TypeError("Network request failed"));
            };
            xhr.onabort = function() {
              reject(new exports2.DOMException("Aborted", "AbortError"));
            };
            xhr.open(request.method, request.url, true);
            if (request.credentials === "include") {
              xhr.withCredentials = true;
            } else if (request.credentials === "omit") {
              xhr.withCredentials = false;
            }
            if ("responseType" in xhr && support.blob) {
              xhr.responseType = "blob";
            }
            request.headers.forEach(function(value, name) {
              xhr.setRequestHeader(name, value);
            });
            if (request.signal) {
              request.signal.addEventListener("abort", abortXhr);
              xhr.onreadystatechange = function() {
                if (xhr.readyState === 4) {
                  request.signal.removeEventListener("abort", abortXhr);
                }
              };
            }
            xhr.send(typeof request._bodyInit === "undefined" ? null : request._bodyInit);
          });
        }
        fetch2.polyfill = true;
        if (!self2.fetch) {
          self2.fetch = fetch2;
          self2.Headers = Headers;
          self2.Request = Request;
          self2.Response = Response;
        }
        exports2.Headers = Headers;
        exports2.Request = Request;
        exports2.Response = Response;
        exports2.fetch = fetch2;
        Object.defineProperty(exports2, "__esModule", { value: true });
        return exports2;
      })({});
    })(__self__);
    __self__.fetch.ponyfill = true;
    delete __self__.fetch.polyfill;
    var ctx = __self__;
    exports = ctx.fetch;
    exports.default = ctx.fetch;
    exports.fetch = ctx.fetch;
    exports.Headers = ctx.Headers;
    exports.Request = ctx.Request;
    exports.Response = ctx.Response;
    module.exports = exports;
  })(browserPonyfill, browserPonyfill.exports);
  var fetch = /* @__PURE__ */ getDefaultExportFromCjs(browserPonyfill.exports);
  async function verifiedBuild(connection, programId, limit = 5) {
    const url = `https://api.apr.dev/api/v0/program/${programId.toString()}/latest?limit=${limit}`;
    const [programData, latestBuildsResp] = await Promise.all([
      fetchData(connection, programId),
      fetch(url)
    ]);
    const latestBuilds = (await latestBuildsResp.json()).filter((b) => !b.aborted && b.state === "Built" && b.verified === "Verified");
    if (latestBuilds.length === 0) {
      return null;
    }
    const build = latestBuilds[0];
    if (programData.slot.toNumber() !== build.verified_slot) {
      return null;
    }
    return build;
  }
  async function fetchData(connection, programId) {
    const accountInfo = await connection.getAccountInfo(programId);
    if (accountInfo === null) {
      throw new Error("program account not found");
    }
    const { program: program2 } = decodeUpgradeableLoaderState(accountInfo.data);
    const programdataAccountInfo = await connection.getAccountInfo(program2.programdataAddress);
    if (programdataAccountInfo === null) {
      throw new Error("program data account not found");
    }
    const { programData } = decodeUpgradeableLoaderState(programdataAccountInfo.data);
    return programData;
  }
  var UPGRADEABLE_LOADER_STATE_LAYOUT = borsh.rustEnum([
    borsh.struct([], "uninitialized"),
    borsh.struct([borsh.option(borsh.publicKey(), "authorityAddress")], "buffer"),
    borsh.struct([borsh.publicKey("programdataAddress")], "program"),
    borsh.struct([
      borsh.u64("slot"),
      borsh.option(borsh.publicKey(), "upgradeAuthorityAddress")
    ], "programData")
  ], void 0, borsh.u32());
  function decodeUpgradeableLoaderState(data) {
    return UPGRADEABLE_LOADER_STATE_LAYOUT.decode(data);
  }
  var registry = /* @__PURE__ */ Object.freeze({
    __proto__: null,
    verifiedBuild,
    fetchData,
    decodeUpgradeableLoaderState
  });
  var index = /* @__PURE__ */ Object.freeze({
    __proto__: null,
    sha256: sha2563,
    rpc,
    publicKey: pubkey,
    bytes: index$1,
    token,
    features,
    registry
  });
  function isIdlAccounts(accountItem) {
    return "accounts" in accountItem;
  }
  async function idlAddress(programId) {
    const base = (await import_web3.PublicKey.findProgramAddress([], programId))[0];
    return await import_web3.PublicKey.createWithSeed(base, seed(), programId);
  }
  function seed() {
    return "anchor:idl";
  }
  var IDL_ACCOUNT_LAYOUT = borsh.struct([
    borsh.publicKey("authority"),
    borsh.vecU8("data")
  ]);
  function decodeIdlAccount(data) {
    return IDL_ACCOUNT_LAYOUT.decode(data);
  }
  function splitArgsAndCtx(idlIx, args) {
    var _a, _b;
    let options = {};
    const inputLen = idlIx.args ? idlIx.args.length : 0;
    if (args.length > inputLen) {
      if (args.length !== inputLen + 1) {
        throw new Error(`provided too many arguments ${args} to instruction ${idlIx === null || idlIx === void 0 ? void 0 : idlIx.name} expecting: ${(_b = (_a = idlIx.args) === null || _a === void 0 ? void 0 : _a.map((a) => a.name)) !== null && _b !== void 0 ? _b : []}`);
      }
      options = args.pop();
    }
    return [args, options];
  }
  var InstructionNamespaceFactory = class _InstructionNamespaceFactory {
    static build(idlIx, encodeFn, programId) {
      if (idlIx.name === "_inner") {
        throw new IdlError("the _inner name is reserved");
      }
      const ix = (...args) => {
        const [ixArgs, ctx] = splitArgsAndCtx(idlIx, [...args]);
        validateAccounts(idlIx.accounts, ctx.accounts);
        validateInstruction(idlIx, ...args);
        const keys = ix.accounts(ctx.accounts);
        if (ctx.remainingAccounts !== void 0) {
          keys.push(...ctx.remainingAccounts);
        }
        if (isSet("debug-logs")) {
          console.log("Outgoing account metas:", keys);
        }
        return new import_web3.TransactionInstruction({
          keys,
          programId,
          data: encodeFn(idlIx.name, toInstruction(idlIx, ...ixArgs))
        });
      };
      ix["accounts"] = (accs) => {
        return _InstructionNamespaceFactory.accountsArray(accs, idlIx.accounts, programId, idlIx.name);
      };
      return ix;
    }
    static accountsArray(ctx, accounts, programId, ixName) {
      if (!ctx) {
        return [];
      }
      return accounts.map((acc) => {
        const nestedAccounts = "accounts" in acc ? acc.accounts : void 0;
        if (nestedAccounts !== void 0) {
          const rpcAccs = ctx[acc.name];
          return _InstructionNamespaceFactory.accountsArray(rpcAccs, acc.accounts, programId, ixName).flat();
        } else {
          const account = acc;
          let pubkey2;
          try {
            pubkey2 = translateAddress(ctx[acc.name]);
          } catch (err2) {
            throw new Error(`Wrong input type for account "${acc.name}" in the instruction accounts object${ixName !== void 0 ? ' for instruction "' + ixName + '"' : ""}. Expected PublicKey or string.`);
          }
          const optional2 = account.isOptional && pubkey2.equals(programId);
          const isWritable = account.isMut && !optional2;
          const isSigner = account.isSigner && !optional2;
          return {
            pubkey: pubkey2,
            isWritable,
            isSigner
          };
        }
      }).flat();
    }
  };
  function validateInstruction(ix, ...args) {
  }
  var TransactionFactory = class {
    static build(idlIx, ixFn) {
      const txFn = (...args) => {
        var _a, _b, _c;
        const [, ctx] = splitArgsAndCtx(idlIx, [...args]);
        const tx = new import_web3.Transaction();
        if (ctx.preInstructions && ctx.instructions) {
          throw new Error("instructions is deprecated, use preInstructions");
        }
        (_a = ctx.preInstructions) === null || _a === void 0 ? void 0 : _a.forEach((ix) => tx.add(ix));
        (_b = ctx.instructions) === null || _b === void 0 ? void 0 : _b.forEach((ix) => tx.add(ix));
        tx.add(ixFn(...args));
        (_c = ctx.postInstructions) === null || _c === void 0 ? void 0 : _c.forEach((ix) => tx.add(ix));
        return tx;
      };
      return txFn;
    }
  };
  var RpcFactory = class {
    static build(idlIx, txFn, idlErrors, provider) {
      const rpc2 = async (...args) => {
        var _a;
        const tx = txFn(...args);
        const [, ctx] = splitArgsAndCtx(idlIx, [...args]);
        if (provider.sendAndConfirm === void 0) {
          throw new Error("This function requires 'Provider.sendAndConfirm' to be implemented.");
        }
        try {
          return await provider.sendAndConfirm(tx, (_a = ctx.signers) !== null && _a !== void 0 ? _a : [], ctx.options);
        } catch (err2) {
          throw translateError(err2, idlErrors);
        }
      };
      return rpc2;
    }
  };
  var AccountFactory = class {
    static build(idl, coder2, programId, provider) {
      var _a;
      const accountFns = {};
      (_a = idl.accounts) === null || _a === void 0 ? void 0 : _a.forEach((idlAccount) => {
        const name = (0, import_camelcase.default)(idlAccount.name);
        accountFns[name] = new AccountClient(idl, idlAccount, programId, provider, coder2);
      });
      return accountFns;
    }
  };
  var AccountClient = class {
    /**
     * Returns the number of bytes in this account.
     */
    get size() {
      return this._size;
    }
    /**
     * Returns the program ID owning all accounts.
     */
    get programId() {
      return this._programId;
    }
    /**
     * Returns the client's wallet and network provider.
     */
    get provider() {
      return this._provider;
    }
    /**
     * Returns the coder.
     */
    get coder() {
      return this._coder;
    }
    /**
     * Returns the idl account.
     */
    get idlAccount() {
      return this._idlAccount;
    }
    constructor(idl, idlAccount, programId, provider, coder2) {
      this._idlAccount = idlAccount;
      this._programId = programId;
      this._provider = provider !== null && provider !== void 0 ? provider : getProvider();
      this._coder = coder2 !== null && coder2 !== void 0 ? coder2 : new BorshCoder(idl);
      this._size = this._coder.accounts.size(idlAccount);
    }
    /**
     * Returns a deserialized account, returning null if it doesn't exist.
     *
     * @param address The address of the account to fetch.
     */
    async fetchNullable(address, commitment) {
      const { data } = await this.fetchNullableAndContext(address, commitment);
      return data;
    }
    /**
     * Returns a deserialized account along with the associated rpc response context, returning null if it doesn't exist.
     *
     * @param address The address of the account to fetch.
     */
    async fetchNullableAndContext(address, commitment) {
      const accountInfo = await this.getAccountInfoAndContext(address, commitment);
      const { value, context } = accountInfo;
      return {
        data: value && value.data.length !== 0 ? this._coder.accounts.decode(this._idlAccount.name, value.data) : null,
        context
      };
    }
    /**
     * Returns a deserialized account.
     *
     * @param address The address of the account to fetch.
     */
    async fetch(address, commitment) {
      const { data } = await this.fetchNullableAndContext(address, commitment);
      if (data === null) {
        throw new Error(`Account does not exist or has no data ${address.toString()}`);
      }
      return data;
    }
    /**
     * Returns a deserialized account along with the associated rpc response context.
     *
     * @param address The address of the account to fetch.
     */
    async fetchAndContext(address, commitment) {
      const { data, context } = await this.fetchNullableAndContext(address, commitment);
      if (data === null) {
        throw new Error(`Account does not exist ${address.toString()}`);
      }
      return { data, context };
    }
    /**
     * Returns multiple deserialized accounts.
     * Accounts not found or with wrong discriminator are returned as null.
     *
     * @param addresses The addresses of the accounts to fetch.
     */
    async fetchMultiple(addresses, commitment) {
      const accounts = await this.fetchMultipleAndContext(addresses, commitment);
      return accounts.map((account) => account ? account.data : null);
    }
    /**
     * Returns multiple deserialized accounts.
     * Accounts not found or with wrong discriminator are returned as null.
     *
     * @param addresses The addresses of the accounts to fetch.
     */
    async fetchMultipleAndContext(addresses, commitment) {
      const accounts = await getMultipleAccountsAndContext(this._provider.connection, addresses.map((address) => translateAddress(address)), commitment);
      return accounts.map((result) => {
        if (result == null) {
          return null;
        }
        const { account, context } = result;
        return {
          data: this._coder.accounts.decode(this._idlAccount.name, account.data),
          context
        };
      });
    }
    /**
     * Returns all instances of this account type for the program.
     *
     * @param filters User-provided filters to narrow the results from `connection.getProgramAccounts`.
     *
     *                When filters are not defined this method returns all
     *                the account instances.
     *
     *                When filters are of type `Buffer`, the filters are appended
     *                after the discriminator.
     *
     *                When filters are of type `GetProgramAccountsFilter[]`,
     *                filters are appended after the discriminator filter.
     */
    async all(filters) {
      const filter = this.coder.accounts.memcmp(this._idlAccount.name, filters instanceof Buffer ? filters : void 0);
      const coderFilters = [];
      if ((filter === null || filter === void 0 ? void 0 : filter.offset) != void 0 && (filter === null || filter === void 0 ? void 0 : filter.bytes) != void 0) {
        coderFilters.push({
          memcmp: { offset: filter.offset, bytes: filter.bytes }
        });
      }
      if ((filter === null || filter === void 0 ? void 0 : filter.dataSize) != void 0) {
        coderFilters.push({ dataSize: filter.dataSize });
      }
      let resp = await this._provider.connection.getProgramAccounts(this._programId, {
        commitment: this._provider.connection.commitment,
        filters: [...coderFilters, ...Array.isArray(filters) ? filters : []]
      });
      return resp.map(({ pubkey: pubkey2, account }) => {
        return {
          publicKey: pubkey2,
          account: this._coder.accounts.decode(this._idlAccount.name, account.data)
        };
      });
    }
    /**
     * Returns an `EventEmitter` emitting a "change" event whenever the account
     * changes.
     */
    subscribe(address, commitment) {
      const sub = subscriptions.get(address.toString());
      if (sub) {
        return sub.ee;
      }
      const ee = new import_eventemitter3.default();
      address = translateAddress(address);
      const listener = this._provider.connection.onAccountChange(address, (acc) => {
        const account = this._coder.accounts.decode(this._idlAccount.name, acc.data);
        ee.emit("change", account);
      }, commitment);
      subscriptions.set(address.toString(), {
        ee,
        listener
      });
      return ee;
    }
    /**
     * Unsubscribes from the account at the given address.
     */
    async unsubscribe(address) {
      let sub = subscriptions.get(address.toString());
      if (!sub) {
        console.warn("Address is not subscribed");
        return;
      }
      if (subscriptions) {
        await this._provider.connection.removeAccountChangeListener(sub.listener).then(() => {
          subscriptions.delete(address.toString());
        }).catch(console.error);
      }
    }
    /**
     * Returns an instruction for creating this account.
     */
    async createInstruction(signer, sizeOverride) {
      const size = this.size;
      if (this._provider.publicKey === void 0) {
        throw new Error("This function requires the Provider interface implementor to have a 'publicKey' field.");
      }
      return import_web3.SystemProgram.createAccount({
        fromPubkey: this._provider.publicKey,
        newAccountPubkey: signer.publicKey,
        space: sizeOverride !== null && sizeOverride !== void 0 ? sizeOverride : size,
        lamports: await this._provider.connection.getMinimumBalanceForRentExemption(sizeOverride !== null && sizeOverride !== void 0 ? sizeOverride : size),
        programId: this._programId
      });
    }
    /**
     * @deprecated since version 14.0.
     *
     * Function returning the associated account. Args are keys to associate.
     * Order matters.
     */
    async associated(...args) {
      const addr = await this.associatedAddress(...args);
      return await this.fetch(addr);
    }
    /**
     * @deprecated since version 14.0.
     *
     * Function returning the associated address. Args are keys to associate.
     * Order matters.
     */
    async associatedAddress(...args) {
      return await associated(this._programId, ...args);
    }
    async getAccountInfo(address, commitment) {
      return await this._provider.connection.getAccountInfo(translateAddress(address), commitment);
    }
    async getAccountInfoAndContext(address, commitment) {
      return await this._provider.connection.getAccountInfoAndContext(translateAddress(address), commitment);
    }
  };
  var subscriptions = /* @__PURE__ */ new Map();
  var PROGRAM_LOG = "Program log: ";
  var PROGRAM_DATA = "Program data: ";
  var PROGRAM_LOG_START_INDEX = PROGRAM_LOG.length;
  var PROGRAM_DATA_START_INDEX = PROGRAM_DATA.length;
  var EventManager = class {
    constructor(programId, provider, coder2) {
      this._programId = programId;
      this._provider = provider;
      this._eventParser = new EventParser(programId, coder2);
      this._eventCallbacks = /* @__PURE__ */ new Map();
      this._eventListeners = /* @__PURE__ */ new Map();
      this._listenerIdCount = 0;
    }
    addEventListener(eventName, callback) {
      var _a;
      let listener = this._listenerIdCount;
      this._listenerIdCount += 1;
      if (!this._eventListeners.has(eventName)) {
        this._eventListeners.set(eventName, []);
      }
      this._eventListeners.set(eventName, ((_a = this._eventListeners.get(eventName)) !== null && _a !== void 0 ? _a : []).concat(listener));
      this._eventCallbacks.set(listener, [eventName, callback]);
      if (this._onLogsSubscriptionId !== void 0) {
        return listener;
      }
      this._onLogsSubscriptionId = this._provider.connection.onLogs(this._programId, (logs, ctx) => {
        if (logs.err) {
          return;
        }
        for (const event of this._eventParser.parseLogs(logs.logs)) {
          const allListeners = this._eventListeners.get(event.name);
          if (allListeners) {
            allListeners.forEach((listener2) => {
              const listenerCb = this._eventCallbacks.get(listener2);
              if (listenerCb) {
                const [, callback2] = listenerCb;
                callback2(event.data, ctx.slot, logs.signature);
              }
            });
          }
        }
      });
      return listener;
    }
    async removeEventListener(listener) {
      const callback = this._eventCallbacks.get(listener);
      if (!callback) {
        throw new Error(`Event listener ${listener} doesn't exist!`);
      }
      const [eventName] = callback;
      let listeners = this._eventListeners.get(eventName);
      if (!listeners) {
        throw new Error(`Event listeners don't exist for ${eventName}!`);
      }
      this._eventCallbacks.delete(listener);
      listeners = listeners.filter((l) => l !== listener);
      this._eventListeners.set(eventName, listeners);
      if (listeners.length === 0) {
        this._eventListeners.delete(eventName);
      }
      if (this._eventCallbacks.size === 0) {
        if (this._eventListeners.size !== 0) {
          throw new Error(`Expected event listeners size to be 0 but got ${this._eventListeners.size}`);
        }
        if (this._onLogsSubscriptionId !== void 0) {
          await this._provider.connection.removeOnLogsListener(this._onLogsSubscriptionId);
          this._onLogsSubscriptionId = void 0;
        }
      }
    }
  };
  var EventParser = class {
    constructor(programId, coder2) {
      this.coder = coder2;
      this.programId = programId;
    }
    // Each log given, represents an array of messages emitted by
    // a single transaction, which can execute many different programs across
    // CPI boundaries. However, the subscription is only interested in the
    // events emitted by *this* program. In achieving this, we keep track of the
    // program execution context by parsing each log and looking for a CPI
    // `invoke` call. If one exists, we know a new program is executing. So we
    // push the programId onto a stack and switch the program context. This
    // allows us to track, for a given log, which program was executing during
    // its emission, thereby allowing us to know if a given log event was
    // emitted by *this* program. If it was, then we parse the raw string and
    // emit the event if the string matches the event being subscribed to.
    *parseLogs(logs, errorOnDecodeFailure = false) {
      const logScanner = new LogScanner(logs);
      const execution = new ExecutionContext();
      let log = logScanner.next();
      while (log !== null) {
        let [event, newProgram, didPop] = this.handleLog(execution, log, errorOnDecodeFailure);
        if (event) {
          yield event;
        }
        if (newProgram) {
          execution.push(newProgram);
        }
        if (didPop) {
          execution.pop();
        }
        log = logScanner.next();
      }
    }
    // Main log handler. Returns a three element array of the event, the
    // next program that was invoked for CPI, and a boolean indicating if
    // a program has completed execution (and thus should be popped off the
    // execution stack).
    handleLog(execution, log, errorOnDecodeFailure) {
      if (execution.stack.length > 0 && execution.program() === this.programId.toString()) {
        return this.handleProgramLog(log, errorOnDecodeFailure);
      } else {
        return [null, ...this.handleSystemLog(log)];
      }
    }
    // Handles logs from *this* program.
    handleProgramLog(log, errorOnDecodeFailure) {
      if (log.startsWith(PROGRAM_LOG) || log.startsWith(PROGRAM_DATA)) {
        const logStr = log.startsWith(PROGRAM_LOG) ? log.slice(PROGRAM_LOG_START_INDEX) : log.slice(PROGRAM_DATA_START_INDEX);
        const event = this.coder.events.decode(logStr);
        if (errorOnDecodeFailure && event === null) {
          throw new Error(`Unable to decode event ${logStr}`);
        }
        return [event, null, false];
      } else {
        return [null, ...this.handleSystemLog(log)];
      }
    }
    // Handles logs when the current program being executing is *not* this.
    handleSystemLog(log) {
      const logStart = log.split(":")[0];
      if (logStart.match(/^Program (.*) success/g) !== null) {
        return [null, true];
      } else if (logStart.startsWith(`Program ${this.programId.toString()} invoke`)) {
        return [this.programId.toString(), false];
      } else if (logStart.includes("invoke")) {
        return ["cpi", false];
      } else {
        return [null, false];
      }
    }
  };
  var ExecutionContext = class {
    constructor() {
      this.stack = [];
    }
    program() {
      if (!this.stack.length) {
        throw new Error("Expected the stack to have elements");
      }
      return this.stack[this.stack.length - 1];
    }
    push(newProgram) {
      this.stack.push(newProgram);
    }
    pop() {
      if (!this.stack.length) {
        throw new Error("Expected the stack to have elements");
      }
      this.stack.pop();
    }
  };
  var LogScanner = class {
    constructor(logs) {
      this.logs = logs;
    }
    next() {
      if (this.logs.length === 0) {
        return null;
      }
      let l = this.logs[0];
      this.logs = this.logs.slice(1);
      return l;
    }
  };
  var SimulateFactory = class {
    static build(idlIx, txFn, idlErrors, provider, coder2, programId, idl) {
      const simulate = async (...args) => {
        var _a;
        const tx = txFn(...args);
        const [, ctx] = splitArgsAndCtx(idlIx, [...args]);
        let resp = void 0;
        if (provider.simulate === void 0) {
          throw new Error("This function requires 'Provider.simulate' to be implemented.");
        }
        try {
          resp = await provider.simulate(tx, ctx.signers, (_a = ctx.options) === null || _a === void 0 ? void 0 : _a.commitment);
        } catch (err2) {
          throw translateError(err2, idlErrors);
        }
        if (resp === void 0) {
          throw new Error("Unable to simulate transaction");
        }
        const logs = resp.logs;
        if (!logs) {
          throw new Error("Simulated logs not found");
        }
        const events = [];
        if (idl.events) {
          let parser = new EventParser(programId, coder2);
          for (const event of parser.parseLogs(logs)) {
            events.push(event);
          }
        }
        return { events, raw: logs };
      };
      return simulate;
    }
  };
  function uint64(property) {
    return new WrappedLayout(blob(8), (b) => u642.fromBuffer(b), (n) => n.toBuffer(), property);
  }
  function publicKey2(property) {
    return new WrappedLayout(blob(32), (b) => new import_web3.PublicKey(b), (key) => key.toBuffer(), property);
  }
  function coption(layout, property) {
    return new COptionLayout(layout, property);
  }
  var WrappedLayout = class extends Layout_2 {
    constructor(layout, decoder, encoder, property) {
      super(layout.span, property);
      this.layout = layout;
      this.decoder = decoder;
      this.encoder = encoder;
    }
    decode(b, offset2) {
      return this.decoder(this.layout.decode(b, offset2));
    }
    encode(src, b, offset2) {
      return this.layout.encode(this.encoder(src), b, offset2);
    }
    getSpan(b, offset2) {
      return this.layout.getSpan(b, offset2);
    }
  };
  var COptionLayout = class extends Layout_2 {
    constructor(layout, property) {
      super(-1, property);
      this.layout = layout;
      this.discriminator = u322();
    }
    encode(src, b, offset2 = 0) {
      if (src === null || src === void 0) {
        return this.layout.span + this.discriminator.encode(0, b, offset2);
      }
      this.discriminator.encode(1, b, offset2);
      return this.layout.encode(src, b, offset2 + 4) + 4;
    }
    decode(b, offset2 = 0) {
      const discriminator2 = this.discriminator.decode(b, offset2);
      if (discriminator2 === 0) {
        return null;
      } else if (discriminator2 === 1) {
        return this.layout.decode(b, offset2 + 4);
      }
      throw new Error("Invalid coption " + this.layout.property);
    }
    getSpan(b, offset2 = 0) {
      return this.layout.getSpan(b, offset2 + 4) + 4;
    }
  };
  var u642 = class _u64 extends import_bn.default {
    /**
     * Convert to Buffer representation
     */
    toBuffer() {
      const a = super.toArray().reverse();
      const b = Buffer.from(a);
      if (b.length === 8) {
        return b;
      }
      if (b.length >= 8) {
        throw new Error("u64 too large");
      }
      const zeroPad = Buffer.alloc(8);
      b.copy(zeroPad);
      return zeroPad;
    }
    /**
     * Construct a u64 from Buffer representation
     */
    static fromBuffer(buffer) {
      if (buffer.length !== 8) {
        throw new Error(`Invalid buffer length: ${buffer.length}`);
      }
      return new _u64([...buffer].reverse().map((i) => `00${i.toString(16)}`.slice(-2)).join(""), 16);
    }
  };
  var TOKEN_ACCOUNT_LAYOUT = struct2([
    publicKey2("mint"),
    publicKey2("owner"),
    uint64("amount"),
    coption(publicKey2(), "delegate"),
    ((p) => {
      const U = union(u82("discriminator"), null, p);
      U.addVariant(0, struct2([]), "uninitialized");
      U.addVariant(1, struct2([]), "initialized");
      U.addVariant(2, struct2([]), "frozen");
      return U;
    })("state"),
    coption(uint64(), "isNative"),
    uint64("delegatedAmount"),
    coption(publicKey2(), "closeAuthority")
  ]);
  function decodeTokenAccount(b) {
    return TOKEN_ACCOUNT_LAYOUT.decode(b);
  }
  var AccountsResolver = class _AccountsResolver {
    constructor(_args, _accounts, _provider2, _programId, _idlIx, _accountNamespace, _idlTypes, _customResolver) {
      this._accounts = _accounts;
      this._provider = _provider2;
      this._programId = _programId;
      this._idlIx = _idlIx;
      this._idlTypes = _idlTypes;
      this._customResolver = _customResolver;
      this._args = _args;
      this._accountStore = new AccountStore(_provider2, _accountNamespace, this._programId);
    }
    args(_args) {
      this._args = _args;
    }
    // Note: We serially resolve PDAs one by one rather than doing them
    //       in parallel because there can be dependencies between
    //       addresses. That is, one PDA can be used as a seed in another.
    async resolve() {
      await this.resolveConst(this._idlIx.accounts);
      this._resolveEventCpi(this._idlIx.accounts);
      while (await this.resolvePdas(this._idlIx.accounts) + await this.resolveRelations(this._idlIx.accounts) + await this.resolveCustom() > 0) {
      }
    }
    async resolveCustom() {
      if (this._customResolver) {
        const { accounts, resolved } = await this._customResolver({
          args: this._args,
          accounts: this._accounts,
          provider: this._provider,
          programId: this._programId,
          idlIx: this._idlIx
        });
        this._accounts = accounts;
        return resolved;
      }
      return 0;
    }
    resolveOptionalsHelper(partialAccounts, accountItems) {
      const nestedAccountsGeneric = {};
      for (const accountItem of accountItems) {
        const accountName = accountItem.name;
        const partialAccount = partialAccounts[accountName];
        if (partialAccount === void 0)
          continue;
        if (isPartialAccounts(partialAccount)) {
          if (isIdlAccounts(accountItem)) {
            nestedAccountsGeneric[accountName] = this.resolveOptionalsHelper(partialAccount, accountItem["accounts"]);
          } else {
            nestedAccountsGeneric[accountName] = flattenPartialAccounts(partialAccount, true);
          }
        } else {
          if (partialAccount !== null) {
            nestedAccountsGeneric[accountName] = translateAddress(partialAccount);
          } else if (accountItem["isOptional"]) {
            nestedAccountsGeneric[accountName] = this._programId;
          }
        }
      }
      return nestedAccountsGeneric;
    }
    resolveOptionals(accounts) {
      Object.assign(this._accounts, this.resolveOptionalsHelper(accounts, this._idlIx.accounts));
    }
    get(path) {
      const ret = path.reduce((acc, subPath) => acc && acc[subPath], this._accounts);
      if (ret && ret.toBase58) {
        return ret;
      }
    }
    set(path, value) {
      let curr = this._accounts;
      path.forEach((p, idx) => {
        const isLast = idx == path.length - 1;
        if (isLast) {
          curr[p] = value;
        }
        curr[p] = curr[p] || {};
        curr = curr[p];
      });
    }
    async resolveConst(accounts, path = []) {
      for (let k = 0; k < accounts.length; k += 1) {
        const accountDescOrAccounts = accounts[k];
        const subAccounts = accountDescOrAccounts.accounts;
        if (subAccounts) {
          await this.resolveConst(subAccounts, [
            ...path,
            (0, import_camelcase.default)(accountDescOrAccounts.name)
          ]);
        }
        const accountDesc = accountDescOrAccounts;
        const accountDescName = (0, import_camelcase.default)(accountDescOrAccounts.name);
        if (accountDesc.isSigner && !this.get([...path, accountDescName])) {
          if (this._provider.wallet === void 0) {
            throw new Error("This function requires the Provider interface implementor to have a 'wallet' field.");
          }
          this.set([...path, accountDescName], this._provider.wallet.publicKey);
        }
        if (Reflect.has(_AccountsResolver.CONST_ACCOUNTS, accountDescName) && !this.get([...path, accountDescName])) {
          this.set([...path, accountDescName], _AccountsResolver.CONST_ACCOUNTS[accountDescName]);
        }
      }
    }
    /**
     * Resolve event CPI accounts `eventAuthority` and `program`.
     *
     * Accounts will only be resolved if they are declared next to each other to
     * reduce the chance of name collision.
     */
    _resolveEventCpi(accounts, path = []) {
      for (const i in accounts) {
        const accountDescOrAccounts = accounts[i];
        const subAccounts = accountDescOrAccounts.accounts;
        if (subAccounts) {
          this._resolveEventCpi(subAccounts, [
            ...path,
            (0, import_camelcase.default)(accountDescOrAccounts.name)
          ]);
        }
        const nextIndex = +i + 1;
        if (nextIndex === accounts.length)
          return;
        const currentName = (0, import_camelcase.default)(accounts[i].name);
        const nextName = (0, import_camelcase.default)(accounts[nextIndex].name);
        if (currentName === "eventAuthority" && nextName === "program") {
          const currentPath = [...path, currentName];
          const nextPath = [...path, nextName];
          if (!this.get(currentPath)) {
            this.set(currentPath, import_web3.PublicKey.findProgramAddressSync([Buffer.from("__event_authority")], this._programId)[0]);
          }
          if (!this.get(nextPath)) {
            this.set(nextPath, this._programId);
          }
          return;
        }
      }
    }
    async resolvePdas(accounts, path = []) {
      let found = 0;
      for (let k = 0; k < accounts.length; k += 1) {
        const accountDesc = accounts[k];
        const subAccounts = accountDesc.accounts;
        if (subAccounts) {
          found += await this.resolvePdas(subAccounts, [
            ...path,
            (0, import_camelcase.default)(accountDesc.name)
          ]);
        }
        const accountDescCasted = accountDesc;
        const accountDescName = (0, import_camelcase.default)(accountDesc.name);
        if (accountDescCasted.pda && accountDescCasted.pda.seeds.length > 0 && !this.get([...path, accountDescName])) {
          if (Boolean(await this.autoPopulatePda(accountDescCasted, path))) {
            found += 1;
          }
        }
      }
      return found;
    }
    async resolveRelations(accounts, path = []) {
      let found = 0;
      for (let k = 0; k < accounts.length; k += 1) {
        const accountDesc = accounts[k];
        const subAccounts = accountDesc.accounts;
        if (subAccounts) {
          found += await this.resolveRelations(subAccounts, [
            ...path,
            (0, import_camelcase.default)(accountDesc.name)
          ]);
        }
        const relations = accountDesc.relations || [];
        const accountDescName = (0, import_camelcase.default)(accountDesc.name);
        const newPath = [...path, accountDescName];
        const accountKey = this.get(newPath);
        if (accountKey) {
          const matching = relations.filter((rel) => !this.get([...path, (0, import_camelcase.default)(rel)]));
          found += matching.length;
          if (matching.length > 0) {
            const account = await this._accountStore.fetchAccount({
              publicKey: accountKey
            });
            await Promise.all(matching.map(async (rel) => {
              const relName = (0, import_camelcase.default)(rel);
              this.set([...path, relName], account[relName]);
              return account[relName];
            }));
          }
        }
      }
      return found;
    }
    async autoPopulatePda(accountDesc, path = []) {
      if (!accountDesc.pda || !accountDesc.pda.seeds)
        throw new Error("Must have seeds");
      const seeds = await Promise.all(accountDesc.pda.seeds.map((seedDesc) => this.toBuffer(seedDesc, path)));
      if (seeds.some((seed2) => typeof seed2 == "undefined")) {
        return;
      }
      const programId = await this.parseProgramId(accountDesc, path);
      if (!programId) {
        return;
      }
      const [pubkey2] = await import_web3.PublicKey.findProgramAddress(seeds, programId);
      this.set([...path, (0, import_camelcase.default)(accountDesc.name)], pubkey2);
    }
    async parseProgramId(accountDesc, path = []) {
      var _a;
      if (!((_a = accountDesc.pda) === null || _a === void 0 ? void 0 : _a.programId)) {
        return this._programId;
      }
      switch (accountDesc.pda.programId.kind) {
        case "const":
          return new import_web3.PublicKey(this.toBufferConst(accountDesc.pda.programId.value));
        case "arg":
          return this.argValue(accountDesc.pda.programId);
        case "account":
          return await this.accountValue(accountDesc.pda.programId, path);
        default:
          throw new Error(`Unexpected program seed kind: ${accountDesc.pda.programId.kind}`);
      }
    }
    async toBuffer(seedDesc, path = []) {
      switch (seedDesc.kind) {
        case "const":
          return this.toBufferConst(seedDesc);
        case "arg":
          return await this.toBufferArg(seedDesc);
        case "account":
          return await this.toBufferAccount(seedDesc, path);
        default:
          throw new Error(`Unexpected seed kind: ${seedDesc.kind}`);
      }
    }
    /**
     * Recursively get the type at some path of either a primitive or a user defined struct.
     */
    getType(type2, path = []) {
      if (path.length > 0 && type2.defined) {
        const subType = this._idlTypes.find((t) => t.name === type2.defined);
        if (!subType) {
          throw new Error(`Cannot find type ${type2.defined}`);
        }
        const structType = subType.type;
        const field = structType.fields.find((field2) => field2.name === path[0]);
        return this.getType(field.type, path.slice(1));
      }
      return type2;
    }
    toBufferConst(seedDesc) {
      return this.toBufferValue(this.getType(seedDesc.type, (seedDesc.path || "").split(".").slice(1)), seedDesc.value);
    }
    async toBufferArg(seedDesc) {
      const argValue = this.argValue(seedDesc);
      if (typeof argValue === "undefined") {
        return;
      }
      return this.toBufferValue(this.getType(seedDesc.type, (seedDesc.path || "").split(".").slice(1)), argValue);
    }
    argValue(seedDesc) {
      const split = seedDesc.path.split(".");
      const seedArgName = (0, import_camelcase.default)(split[0]);
      const idlArgPosition = this._idlIx.args.findIndex((argDesc) => argDesc.name === seedArgName);
      if (idlArgPosition === -1) {
        throw new Error(`Unable to find argument for seed: ${seedArgName}`);
      }
      return split.slice(1).reduce((curr, path) => (curr || {})[path], this._args[idlArgPosition]);
    }
    async toBufferAccount(seedDesc, path = []) {
      const accountValue = await this.accountValue(seedDesc, path);
      if (!accountValue) {
        return;
      }
      return this.toBufferValue(seedDesc.type, accountValue);
    }
    async accountValue(seedDesc, path = []) {
      const pathComponents = seedDesc.path.split(".");
      const fieldName = pathComponents[0];
      const fieldPubkey = this.get([...path, (0, import_camelcase.default)(fieldName)]);
      if (fieldPubkey === null) {
        throw new Error(`fieldPubkey is null`);
      }
      if (pathComponents.length === 1) {
        return fieldPubkey;
      }
      const account = await this._accountStore.fetchAccount({
        publicKey: fieldPubkey,
        name: seedDesc.account
      });
      const fieldValue = this.parseAccountValue(account, pathComponents.slice(1));
      return fieldValue;
    }
    parseAccountValue(account, path) {
      let accountField;
      while (path.length > 0) {
        accountField = account[(0, import_camelcase.default)(path[0])];
        path = path.slice(1);
      }
      return accountField;
    }
    // Converts the given idl valaue into a Buffer. The values here must be
    // primitives. E.g. no structs.
    //
    // TODO: add more types here as needed.
    toBufferValue(type2, value) {
      switch (type2) {
        case "u8":
          return Buffer.from([value]);
        case "u16":
          let b = Buffer.alloc(2);
          b.writeUInt16LE(value);
          return b;
        case "u32":
          let buf = Buffer.alloc(4);
          buf.writeUInt32LE(value);
          return buf;
        case "u64":
          let bU64 = Buffer.alloc(8);
          bU64.writeBigUInt64LE(BigInt(value));
          return bU64;
        case "string":
          return Buffer.from(encode$2(value));
        case "publicKey":
          return value.toBuffer();
        default:
          if (type2.array) {
            return Buffer.from(value);
          }
          throw new Error(`Unexpected seed type: ${type2}`);
      }
    }
  };
  AccountsResolver.CONST_ACCOUNTS = {
    associatedTokenProgram: ASSOCIATED_PROGRAM_ID,
    rent: import_web3.SYSVAR_RENT_PUBKEY,
    systemProgram: import_web3.SystemProgram.programId,
    tokenProgram: TOKEN_PROGRAM_ID,
    clock: import_web3.SYSVAR_CLOCK_PUBKEY
  };
  var AccountStore = class {
    // todo: don't use the progrma use the account namespace.
    constructor(_provider2, _accounts, _programId) {
      this._provider = _provider2;
      this._programId = _programId;
      this._cache = /* @__PURE__ */ new Map();
      this._idls = {};
      this._idls[_programId.toBase58()] = _accounts;
    }
    async ensureIdl(programId) {
      if (!this._idls[programId.toBase58()]) {
        const idl = await Program.fetchIdl(programId, this._provider);
        if (idl) {
          const program2 = new Program(idl, programId, this._provider);
          this._idls[programId.toBase58()] = program2.account;
        }
      }
      return this._idls[programId.toBase58()];
    }
    async fetchAccount({ publicKey: publicKey3, name, programId = this._programId }) {
      const address = publicKey3.toString();
      if (!this._cache.has(address)) {
        if (name === "TokenAccount") {
          const accountInfo = await this._provider.connection.getAccountInfo(publicKey3);
          if (accountInfo === null) {
            throw new Error(`invalid account info for ${address}`);
          }
          const data = decodeTokenAccount(accountInfo.data);
          this._cache.set(address, data);
        } else if (name) {
          const accounts = await this.ensureIdl(programId);
          if (accounts) {
            const accountFetcher = accounts[(0, import_camelcase.default)(name)];
            if (accountFetcher) {
              const account = await accountFetcher.fetch(publicKey3);
              this._cache.set(address, account);
            }
          }
        } else {
          const account = await this._provider.connection.getAccountInfo(publicKey3);
          if (account === null) {
            throw new Error(`invalid account info for ${address}`);
          }
          const data = account.data;
          const accounts = await this.ensureIdl(account.owner);
          if (accounts) {
            const firstAccountLayout = Object.values(accounts)[0];
            if (!firstAccountLayout) {
              throw new Error("No accounts for this program");
            }
            const result = firstAccountLayout.coder.accounts.decodeAny(data);
            this._cache.set(address, result);
          }
        }
      }
      return this._cache.get(address);
    }
  };
  var MethodsBuilderFactory = class {
    static build(provider, programId, idlIx, ixFn, txFn, rpcFn, simulateFn, viewFn, accountNamespace, idlTypes, customResolver) {
      return (...args) => new MethodsBuilder(args, ixFn, txFn, rpcFn, simulateFn, viewFn, provider, programId, idlIx, accountNamespace, idlTypes, customResolver);
    }
  };
  function isPartialAccounts(partialAccount) {
    return typeof partialAccount === "object" && partialAccount !== null && !("_bn" in partialAccount);
  }
  function flattenPartialAccounts(partialAccounts, throwOnNull) {
    const toReturn = {};
    for (const accountName in partialAccounts) {
      const account = partialAccounts[accountName];
      if (account === null) {
        if (throwOnNull)
          throw new Error("Failed to resolve optionals due to IDL type mismatch with input accounts!");
        continue;
      }
      toReturn[accountName] = isPartialAccounts(account) ? flattenPartialAccounts(account, true) : translateAddress(account);
    }
    return toReturn;
  }
  var MethodsBuilder = class {
    constructor(_args, _ixFn, _txFn, _rpcFn, _simulateFn, _viewFn, _provider2, _programId, _idlIx, _accountNamespace, _idlTypes, _customResolver) {
      this._ixFn = _ixFn;
      this._txFn = _txFn;
      this._rpcFn = _rpcFn;
      this._simulateFn = _simulateFn;
      this._viewFn = _viewFn;
      this._programId = _programId;
      this._accounts = {};
      this._remainingAccounts = [];
      this._signers = [];
      this._preInstructions = [];
      this._postInstructions = [];
      this._autoResolveAccounts = true;
      this._args = _args;
      this._accountsResolver = new AccountsResolver(_args, this._accounts, _provider2, _programId, _idlIx, _accountNamespace, _idlTypes, _customResolver);
    }
    args(_args) {
      this._args = _args;
      this._accountsResolver.args(_args);
    }
    async pubkeys() {
      if (this._autoResolveAccounts) {
        await this._accountsResolver.resolve();
      }
      return this._accounts;
    }
    accounts(accounts) {
      this._autoResolveAccounts = true;
      this._accountsResolver.resolveOptionals(accounts);
      return this;
    }
    accountsStrict(accounts) {
      this._autoResolveAccounts = false;
      this._accountsResolver.resolveOptionals(accounts);
      return this;
    }
    signers(signers) {
      this._signers = this._signers.concat(signers);
      return this;
    }
    remainingAccounts(accounts) {
      this._remainingAccounts = this._remainingAccounts.concat(accounts);
      return this;
    }
    preInstructions(ixs) {
      this._preInstructions = this._preInstructions.concat(ixs);
      return this;
    }
    postInstructions(ixs) {
      this._postInstructions = this._postInstructions.concat(ixs);
      return this;
    }
    async rpc(options) {
      if (this._autoResolveAccounts) {
        await this._accountsResolver.resolve();
      }
      return this._rpcFn(...this._args, {
        accounts: this._accounts,
        signers: this._signers,
        remainingAccounts: this._remainingAccounts,
        preInstructions: this._preInstructions,
        postInstructions: this._postInstructions,
        options
      });
    }
    async rpcAndKeys(options) {
      const pubkeys = await this.pubkeys();
      return {
        pubkeys,
        signature: await this.rpc(options)
      };
    }
    async view(options) {
      if (this._autoResolveAccounts) {
        await this._accountsResolver.resolve();
      }
      if (!this._viewFn) {
        throw new Error("Method does not support views");
      }
      return this._viewFn(...this._args, {
        accounts: this._accounts,
        signers: this._signers,
        remainingAccounts: this._remainingAccounts,
        preInstructions: this._preInstructions,
        postInstructions: this._postInstructions,
        options
      });
    }
    async simulate(options) {
      if (this._autoResolveAccounts) {
        await this._accountsResolver.resolve();
      }
      return this._simulateFn(...this._args, {
        accounts: this._accounts,
        signers: this._signers,
        remainingAccounts: this._remainingAccounts,
        preInstructions: this._preInstructions,
        postInstructions: this._postInstructions,
        options
      });
    }
    async instruction() {
      if (this._autoResolveAccounts) {
        await this._accountsResolver.resolve();
      }
      return this._ixFn(...this._args, {
        accounts: this._accounts,
        signers: this._signers,
        remainingAccounts: this._remainingAccounts,
        preInstructions: this._preInstructions,
        postInstructions: this._postInstructions
      });
    }
    /**
     * Convenient shortcut to get instructions and pubkeys via
     * const { pubkeys, instructions } = await prepare();
     */
    async prepare() {
      return {
        instruction: await this.instruction(),
        pubkeys: await this.pubkeys(),
        signers: await this._signers
      };
    }
    async transaction() {
      if (this._autoResolveAccounts) {
        await this._accountsResolver.resolve();
      }
      return this._txFn(...this._args, {
        accounts: this._accounts,
        signers: this._signers,
        remainingAccounts: this._remainingAccounts,
        preInstructions: this._preInstructions,
        postInstructions: this._postInstructions
      });
    }
  };
  var ViewFactory = class {
    static build(programId, idlIx, simulateFn, idl) {
      const isMut = idlIx.accounts.find((a) => a.isMut);
      const hasReturn = !!idlIx.returns;
      if (isMut || !hasReturn)
        return;
      const view = async (...args) => {
        var _a, _b;
        let simulationResult = await simulateFn(...args);
        const returnPrefix = `Program return: ${programId} `;
        let returnLog = simulationResult.raw.find((l) => l.startsWith(returnPrefix));
        if (!returnLog) {
          throw new Error("View expected return log");
        }
        let returnData = decode(returnLog.slice(returnPrefix.length));
        let returnType = idlIx.returns;
        if (!returnType) {
          throw new Error("View expected return type");
        }
        const coder2 = IdlCoder.fieldLayout({ type: returnType }, Array.from([...(_a = idl.accounts) !== null && _a !== void 0 ? _a : [], ...(_b = idl.types) !== null && _b !== void 0 ? _b : []]));
        return coder2.decode(returnData);
      };
      return view;
    }
  };
  var NamespaceFactory = class {
    /**
     * Generates all namespaces for a given program.
     */
    static build(idl, coder2, programId, provider, getCustomResolver) {
      const rpc2 = {};
      const instruction = {};
      const transaction = {};
      const simulate = {};
      const methods = {};
      const view = {};
      const idlErrors = parseIdlErrors(idl);
      const account = idl.accounts ? AccountFactory.build(idl, coder2, programId, provider) : {};
      idl.instructions.forEach((idlIx) => {
        const ixItem = InstructionNamespaceFactory.build(idlIx, (ixName, ix) => coder2.instruction.encode(ixName, ix), programId);
        const txItem = TransactionFactory.build(idlIx, ixItem);
        const rpcItem = RpcFactory.build(idlIx, txItem, idlErrors, provider);
        const simulateItem = SimulateFactory.build(idlIx, txItem, idlErrors, provider, coder2, programId, idl);
        const viewItem = ViewFactory.build(programId, idlIx, simulateItem, idl);
        const methodItem = MethodsBuilderFactory.build(provider, programId, idlIx, ixItem, txItem, rpcItem, simulateItem, viewItem, account, idl.types || [], getCustomResolver && getCustomResolver(idlIx));
        const name = (0, import_camelcase.default)(idlIx.name);
        instruction[name] = ixItem;
        transaction[name] = txItem;
        rpc2[name] = rpcItem;
        simulate[name] = simulateItem;
        methods[name] = methodItem;
        if (viewItem) {
          view[name] = viewItem;
        }
      });
      return [
        rpc2,
        instruction,
        transaction,
        account,
        simulate,
        methods,
        view
      ];
    }
  };
  var Program = class _Program {
    /**
     * Address of the program.
     */
    get programId() {
      return this._programId;
    }
    /**
     * IDL defining the program's interface.
     */
    get idl() {
      return this._idl;
    }
    /**
     * Coder for serializing requests.
     */
    get coder() {
      return this._coder;
    }
    /**
     * Wallet and network provider.
     */
    get provider() {
      return this._provider;
    }
    /**
     * @param idl       The interface definition.
     * @param programId The on-chain address of the program.
     * @param provider  The network and wallet context to use. If not provided
     *                  then uses [[getProvider]].
     * @param getCustomResolver A function that returns a custom account resolver
     *                          for the given instruction. This is useful for resolving
     *                          public keys of missing accounts when building instructions
     */
    constructor(idl, programId, provider, coder2, getCustomResolver) {
      programId = translateAddress(programId);
      if (!provider) {
        provider = getProvider();
      }
      this._idl = idl;
      this._provider = provider;
      this._programId = programId;
      this._coder = coder2 !== null && coder2 !== void 0 ? coder2 : new BorshCoder(idl);
      this._events = new EventManager(this._programId, provider, this._coder);
      const [rpc2, instruction, transaction, account, simulate, methods, views] = NamespaceFactory.build(idl, this._coder, programId, provider, getCustomResolver !== null && getCustomResolver !== void 0 ? getCustomResolver : (() => void 0));
      this.rpc = rpc2;
      this.instruction = instruction;
      this.transaction = transaction;
      this.account = account;
      this.simulate = simulate;
      this.methods = methods;
      this.views = views;
    }
    /**
     * Generates a Program client by fetching the IDL from the network.
     *
     * In order to use this method, an IDL must have been previously initialized
     * via the anchor CLI's `anchor idl init` command.
     *
     * @param programId The on-chain address of the program.
     * @param provider  The network and wallet context.
     */
    static async at(address, provider) {
      const programId = translateAddress(address);
      const idl = await _Program.fetchIdl(programId, provider);
      if (!idl) {
        throw new Error(`IDL not found for program: ${address.toString()}`);
      }
      return new _Program(idl, programId, provider);
    }
    /**
     * Fetches an idl from the blockchain.
     *
     * In order to use this method, an IDL must have been previously initialized
     * via the anchor CLI's `anchor idl init` command.
     *
     * @param programId The on-chain address of the program.
     * @param provider  The network and wallet context.
     */
    static async fetchIdl(address, provider) {
      provider = provider !== null && provider !== void 0 ? provider : getProvider();
      const programId = translateAddress(address);
      const idlAddr = await idlAddress(programId);
      const accountInfo = await provider.connection.getAccountInfo(idlAddr);
      if (!accountInfo) {
        return null;
      }
      let idlAccount = decodeIdlAccount(accountInfo.data.slice(8));
      const inflatedIdl = inflate_1(idlAccount.data);
      return JSON.parse(decode$2(inflatedIdl));
    }
    /**
     * Invokes the given callback every time the given event is emitted.
     *
     * @param eventName The PascalCase name of the event, provided by the IDL.
     * @param callback  The function to invoke whenever the event is emitted from
     *                  program logs.
     */
    addEventListener(eventName, callback) {
      return this._events.addEventListener(eventName, callback);
    }
    /**
     * Unsubscribes from the given eventName.
     */
    async removeEventListener(listener) {
      return await this._events.removeEventListener(listener);
    }
  };
  var SYSTEM_PROGRAM_ID = new import_web3.PublicKey("11111111111111111111111111111111");
  function program(provider) {
    return new Program(IDL, SYSTEM_PROGRAM_ID, provider, coder());
  }
  function coder() {
    return new SystemCoder(IDL);
  }
  var IDL = {
    version: "0.1.0",
    name: "system_program",
    instructions: [
      {
        name: "createAccount",
        accounts: [
          {
            name: "from",
            isMut: true,
            isSigner: true
          },
          {
            name: "to",
            isMut: true,
            isSigner: true
          }
        ],
        args: [
          {
            name: "lamports",
            type: "u64"
          },
          {
            name: "space",
            type: "u64"
          },
          {
            name: "owner",
            type: "publicKey"
          }
        ]
      },
      {
        name: "assign",
        accounts: [
          {
            name: "pubkey",
            isMut: true,
            isSigner: true
          }
        ],
        args: [
          {
            name: "owner",
            type: "publicKey"
          }
        ]
      },
      {
        name: "transfer",
        accounts: [
          {
            name: "from",
            isMut: true,
            isSigner: true
          },
          {
            name: "to",
            isMut: true,
            isSigner: false
          }
        ],
        args: [
          {
            name: "lamports",
            type: "u64"
          }
        ]
      },
      {
        name: "createAccountWithSeed",
        accounts: [
          {
            name: "from",
            isMut: true,
            isSigner: true
          },
          {
            name: "to",
            isMut: true,
            isSigner: false
          },
          {
            name: "base",
            isMut: false,
            isSigner: true
          }
        ],
        args: [
          {
            name: "base",
            type: "publicKey"
          },
          {
            name: "seed",
            type: "string"
          },
          {
            name: "lamports",
            type: "u64"
          },
          {
            name: "space",
            type: "u64"
          },
          {
            name: "owner",
            type: "publicKey"
          }
        ]
      },
      {
        name: "advanceNonceAccount",
        accounts: [
          {
            name: "nonce",
            isMut: true,
            isSigner: false
          },
          {
            name: "recentBlockhashes",
            isMut: false,
            isSigner: false
          },
          {
            name: "authorized",
            isMut: false,
            isSigner: true
          }
        ],
        args: [
          {
            name: "authorized",
            type: "publicKey"
          }
        ]
      },
      {
        name: "withdrawNonceAccount",
        accounts: [
          {
            name: "nonce",
            isMut: true,
            isSigner: false
          },
          {
            name: "to",
            isMut: true,
            isSigner: false
          },
          {
            name: "recentBlockhashes",
            isMut: false,
            isSigner: false
          },
          {
            name: "rent",
            isMut: false,
            isSigner: false
          },
          {
            name: "authorized",
            isMut: false,
            isSigner: true
          }
        ],
        args: [
          {
            name: "lamports",
            type: "u64"
          }
        ]
      },
      {
        name: "initializeNonceAccount",
        accounts: [
          {
            name: "nonce",
            isMut: true,
            isSigner: true
          },
          {
            name: "recentBlockhashes",
            isMut: false,
            isSigner: false
          },
          {
            name: "rent",
            isMut: false,
            isSigner: false
          }
        ],
        args: [
          {
            name: "authorized",
            type: "publicKey"
          }
        ]
      },
      {
        name: "authorizeNonceAccount",
        accounts: [
          {
            name: "nonce",
            isMut: true,
            isSigner: false
          },
          {
            name: "authorized",
            isMut: false,
            isSigner: true
          }
        ],
        args: [
          {
            name: "authorized",
            type: "publicKey"
          }
        ]
      },
      {
        name: "allocate",
        accounts: [
          {
            name: "pubkey",
            isMut: true,
            isSigner: true
          }
        ],
        args: [
          {
            name: "space",
            type: "u64"
          }
        ]
      },
      {
        name: "allocateWithSeed",
        accounts: [
          {
            name: "account",
            isMut: true,
            isSigner: false
          },
          {
            name: "base",
            isMut: false,
            isSigner: true
          }
        ],
        args: [
          {
            name: "base",
            type: "publicKey"
          },
          {
            name: "seed",
            type: "string"
          },
          {
            name: "space",
            type: "u64"
          },
          {
            name: "owner",
            type: "publicKey"
          }
        ]
      },
      {
        name: "assignWithSeed",
        accounts: [
          {
            name: "account",
            isMut: true,
            isSigner: false
          },
          {
            name: "base",
            isMut: false,
            isSigner: true
          }
        ],
        args: [
          {
            name: "base",
            type: "publicKey"
          },
          {
            name: "seed",
            type: "string"
          },
          {
            name: "owner",
            type: "publicKey"
          }
        ]
      },
      {
        name: "transferWithSeed",
        accounts: [
          {
            name: "from",
            isMut: true,
            isSigner: false
          },
          {
            name: "base",
            isMut: false,
            isSigner: true
          },
          {
            name: "to",
            isMut: true,
            isSigner: false
          }
        ],
        args: [
          {
            name: "lamports",
            type: "u64"
          },
          {
            name: "seed",
            type: "string"
          },
          {
            name: "owner",
            type: "publicKey"
          }
        ]
      }
    ],
    accounts: [
      {
        name: "nonce",
        type: {
          kind: "struct",
          fields: [
            {
              name: "version",
              type: "u32"
            },
            {
              name: "state",
              type: "u32"
            },
            {
              name: "authorizedPubkey",
              type: "publicKey"
            },
            {
              name: "nonce",
              type: "publicKey"
            },
            {
              name: "feeCalculator",
              type: {
                defined: "FeeCalculator"
              }
            }
          ]
        }
      }
    ],
    types: [
      {
        name: "FeeCalculator",
        type: {
          kind: "struct",
          fields: [
            {
              name: "lamportsPerSignature",
              type: "u64"
            }
          ]
        }
      }
    ]
  };
  var Native = class {
    static system(provider) {
      return program(provider);
    }
  };

  // temp-entry.js
  window.Buffer = import_buffer2.Buffer;
  window.solanaWeb3 = solanaWeb3;
  window.anchor = browser_exports;
  console.log("\u2705 Solana web3.js loaded successfully!");
  console.log("\u2705 Anchor SDK loaded successfully!");
})();
/*! Bundled license information:

ieee754/index.js:
  (*! ieee754. BSD-3-Clause License. Feross Aboukhadijeh <https://feross.org/opensource> *)

buffer/index.js:
  (*!
   * The buffer module from node.js, for the browser.
   *
   * @author   Feross Aboukhadijeh <https://feross.org>
   * @license  MIT
   *)

@noble/hashes/utils.js:
@noble/hashes/esm/utils.js:
  (*! noble-hashes - MIT License (c) 2022 Paul Miller (paulmillr.com) *)

@noble/curves/utils.js:
@noble/curves/abstract/modular.js:
@noble/curves/abstract/curve.js:
@noble/curves/abstract/edwards.js:
@noble/curves/abstract/montgomery.js:
@noble/curves/ed25519.js:
@noble/curves/abstract/weierstrass.js:
@noble/curves/_shortw_utils.js:
@noble/curves/secp256k1.js:
  (*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) *)

safe-buffer/index.js:
  (*! safe-buffer. MIT License. Feross Aboukhadijeh <https://feross.org/opensource> *)

@solana/buffer-layout/lib/Layout.js:
  (**
   * Support for translating between Uint8Array instances and JavaScript
   * native types.
   *
   * {@link module:Layout~Layout|Layout} is the basis of a class
   * hierarchy that associates property names with sequences of encoded
   * bytes.
   *
   * Layouts are supported for these scalar (numeric) types:
   * * {@link module:Layout~UInt|Unsigned integers in little-endian
   *   format} with {@link module:Layout.u8|8-bit}, {@link
   *   module:Layout.u16|16-bit}, {@link module:Layout.u24|24-bit},
   *   {@link module:Layout.u32|32-bit}, {@link
   *   module:Layout.u40|40-bit}, and {@link module:Layout.u48|48-bit}
   *   representation ranges;
   * * {@link module:Layout~UIntBE|Unsigned integers in big-endian
   *   format} with {@link module:Layout.u16be|16-bit}, {@link
   *   module:Layout.u24be|24-bit}, {@link module:Layout.u32be|32-bit},
   *   {@link module:Layout.u40be|40-bit}, and {@link
   *   module:Layout.u48be|48-bit} representation ranges;
   * * {@link module:Layout~Int|Signed integers in little-endian
   *   format} with {@link module:Layout.s8|8-bit}, {@link
   *   module:Layout.s16|16-bit}, {@link module:Layout.s24|24-bit},
   *   {@link module:Layout.s32|32-bit}, {@link
   *   module:Layout.s40|40-bit}, and {@link module:Layout.s48|48-bit}
   *   representation ranges;
   * * {@link module:Layout~IntBE|Signed integers in big-endian format}
   *   with {@link module:Layout.s16be|16-bit}, {@link
   *   module:Layout.s24be|24-bit}, {@link module:Layout.s32be|32-bit},
   *   {@link module:Layout.s40be|40-bit}, and {@link
   *   module:Layout.s48be|48-bit} representation ranges;
   * * 64-bit integral values that decode to an exact (if magnitude is
   *   less than 2^53) or nearby integral Number in {@link
   *   module:Layout.nu64|unsigned little-endian}, {@link
   *   module:Layout.nu64be|unsigned big-endian}, {@link
   *   module:Layout.ns64|signed little-endian}, and {@link
   *   module:Layout.ns64be|unsigned big-endian} encodings;
   * * 32-bit floating point values with {@link
   *   module:Layout.f32|little-endian} and {@link
   *   module:Layout.f32be|big-endian} representations;
   * * 64-bit floating point values with {@link
   *   module:Layout.f64|little-endian} and {@link
   *   module:Layout.f64be|big-endian} representations;
   * * {@link module:Layout.const|Constants} that take no space in the
   *   encoded expression.
   *
   * and for these aggregate types:
   * * {@link module:Layout.seq|Sequence}s of instances of a {@link
   *   module:Layout~Layout|Layout}, with JavaScript representation as
   *   an Array and constant or data-dependent {@link
   *   module:Layout~Sequence#count|length};
   * * {@link module:Layout.struct|Structure}s that aggregate a
   *   heterogeneous sequence of {@link module:Layout~Layout|Layout}
   *   instances, with JavaScript representation as an Object;
   * * {@link module:Layout.union|Union}s that support multiple {@link
   *   module:Layout~VariantLayout|variant layouts} over a fixed
   *   (padded) or variable (not padded) span of bytes, using an
   *   unsigned integer at the start of the data or a separate {@link
   *   module:Layout.unionLayoutDiscriminator|layout element} to
   *   determine which layout to use when interpreting the buffer
   *   contents;
   * * {@link module:Layout.bits|BitStructure}s that contain a sequence
   *   of individual {@link
   *   module:Layout~BitStructure#addField|BitField}s packed into an 8,
   *   16, 24, or 32-bit unsigned integer starting at the least- or
   *   most-significant bit;
   * * {@link module:Layout.cstr|C strings} of varying length;
   * * {@link module:Layout.blob|Blobs} of fixed- or variable-{@link
   *   module:Layout~Blob#length|length} raw data.
   *
   * All {@link module:Layout~Layout|Layout} instances are immutable
   * after construction, to prevent internal state from becoming
   * inconsistent.
   *
   * @local Layout
   * @local ExternalLayout
   * @local GreedyCount
   * @local OffsetLayout
   * @local UInt
   * @local UIntBE
   * @local Int
   * @local IntBE
   * @local NearUInt64
   * @local NearUInt64BE
   * @local NearInt64
   * @local NearInt64BE
   * @local Float
   * @local FloatBE
   * @local Double
   * @local DoubleBE
   * @local Sequence
   * @local Structure
   * @local UnionDiscriminator
   * @local UnionLayoutDiscriminator
   * @local Union
   * @local VariantLayout
   * @local BitStructure
   * @local BitField
   * @local Boolean
   * @local Blob
   * @local CString
   * @local Constant
   * @local bindConstructorLayout
   * @module Layout
   * @license MIT
   * @author Peter A. Bigot
   * @see {@link https://github.com/pabigot/buffer-layout|buffer-layout on GitHub}
   *)

buffer-layout/lib/Layout.js:
  (**
   * Support for translating between Buffer instances and JavaScript
   * native types.
   *
   * {@link module:Layout~Layout|Layout} is the basis of a class
   * hierarchy that associates property names with sequences of encoded
   * bytes.
   *
   * Layouts are supported for these scalar (numeric) types:
   * * {@link module:Layout~UInt|Unsigned integers in little-endian
   *   format} with {@link module:Layout.u8|8-bit}, {@link
   *   module:Layout.u16|16-bit}, {@link module:Layout.u24|24-bit},
   *   {@link module:Layout.u32|32-bit}, {@link
   *   module:Layout.u40|40-bit}, and {@link module:Layout.u48|48-bit}
   *   representation ranges;
   * * {@link module:Layout~UIntBE|Unsigned integers in big-endian
   *   format} with {@link module:Layout.u16be|16-bit}, {@link
   *   module:Layout.u24be|24-bit}, {@link module:Layout.u32be|32-bit},
   *   {@link module:Layout.u40be|40-bit}, and {@link
   *   module:Layout.u48be|48-bit} representation ranges;
   * * {@link module:Layout~Int|Signed integers in little-endian
   *   format} with {@link module:Layout.s8|8-bit}, {@link
   *   module:Layout.s16|16-bit}, {@link module:Layout.s24|24-bit},
   *   {@link module:Layout.s32|32-bit}, {@link
   *   module:Layout.s40|40-bit}, and {@link module:Layout.s48|48-bit}
   *   representation ranges;
   * * {@link module:Layout~IntBE|Signed integers in big-endian format}
   *   with {@link module:Layout.s16be|16-bit}, {@link
   *   module:Layout.s24be|24-bit}, {@link module:Layout.s32be|32-bit},
   *   {@link module:Layout.s40be|40-bit}, and {@link
   *   module:Layout.s48be|48-bit} representation ranges;
   * * 64-bit integral values that decode to an exact (if magnitude is
   *   less than 2^53) or nearby integral Number in {@link
   *   module:Layout.nu64|unsigned little-endian}, {@link
   *   module:Layout.nu64be|unsigned big-endian}, {@link
   *   module:Layout.ns64|signed little-endian}, and {@link
   *   module:Layout.ns64be|unsigned big-endian} encodings;
   * * 32-bit floating point values with {@link
   *   module:Layout.f32|little-endian} and {@link
   *   module:Layout.f32be|big-endian} representations;
   * * 64-bit floating point values with {@link
   *   module:Layout.f64|little-endian} and {@link
   *   module:Layout.f64be|big-endian} representations;
   * * {@link module:Layout.const|Constants} that take no space in the
   *   encoded expression.
   *
   * and for these aggregate types:
   * * {@link module:Layout.seq|Sequence}s of instances of a {@link
   *   module:Layout~Layout|Layout}, with JavaScript representation as
   *   an Array and constant or data-dependent {@link
   *   module:Layout~Sequence#count|length};
   * * {@link module:Layout.struct|Structure}s that aggregate a
   *   heterogeneous sequence of {@link module:Layout~Layout|Layout}
   *   instances, with JavaScript representation as an Object;
   * * {@link module:Layout.union|Union}s that support multiple {@link
   *   module:Layout~VariantLayout|variant layouts} over a fixed
   *   (padded) or variable (not padded) span of bytes, using an
   *   unsigned integer at the start of the data or a separate {@link
   *   module:Layout.unionLayoutDiscriminator|layout element} to
   *   determine which layout to use when interpreting the buffer
   *   contents;
   * * {@link module:Layout.bits|BitStructure}s that contain a sequence
   *   of individual {@link
   *   module:Layout~BitStructure#addField|BitField}s packed into an 8,
   *   16, 24, or 32-bit unsigned integer starting at the least- or
   *   most-significant bit;
   * * {@link module:Layout.cstr|C strings} of varying length;
   * * {@link module:Layout.blob|Blobs} of fixed- or variable-{@link
   *   module:Layout~Blob#length|length} raw data.
   *
   * All {@link module:Layout~Layout|Layout} instances are immutable
   * after construction, to prevent internal state from becoming
   * inconsistent.
   *
   * @local Layout
   * @local ExternalLayout
   * @local GreedyCount
   * @local OffsetLayout
   * @local UInt
   * @local UIntBE
   * @local Int
   * @local IntBE
   * @local NearUInt64
   * @local NearUInt64BE
   * @local NearInt64
   * @local NearInt64BE
   * @local Float
   * @local FloatBE
   * @local Double
   * @local DoubleBE
   * @local Sequence
   * @local Structure
   * @local UnionDiscriminator
   * @local UnionLayoutDiscriminator
   * @local Union
   * @local VariantLayout
   * @local BitStructure
   * @local BitField
   * @local Boolean
   * @local Blob
   * @local CString
   * @local Constant
   * @local bindConstructorLayout
   * @module Layout
   * @license MIT
   * @author Peter A. Bigot
   * @see {@link https://github.com/pabigot/buffer-layout|buffer-layout on GitHub}
   *)

pako/dist/pako.esm.mjs:
  (*! pako 2.1.0 https://github.com/nodeca/pako @license (MIT AND Zlib) *)
*/
